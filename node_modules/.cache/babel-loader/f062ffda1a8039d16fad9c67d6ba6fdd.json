{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Carousel = void 0;\n\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\n\nconst react_1 = __importStar(require(\"react\"));\n\nconst slide_1 = __importDefault(require(\"./slide\"));\n\nconst announce_slide_1 = __importDefault(require(\"./announce-slide\"));\n\nconst slider_list_1 = require(\"./slider-list\");\n\nconst controls_1 = __importDefault(require(\"./controls\"));\n\nconst default_carousel_props_1 = __importDefault(require(\"./default-carousel-props\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst use_frame_height_1 = require(\"./hooks/use-frame-height\");\n\nconst default_controls_1 = require(\"./default-controls\");\n\nconst Carousel = rawProps => {\n  /**\n   * We need this cast because we want the component's properties to seem\n   * optional to external users, but always-present for the internal\n   * implementation.\n   *\n   * This cast is safe due to the `Carousel.defaultProps = defaultProps;`\n   * statement below. That guarantees all the properties are present, since\n   * `defaultProps` has type `InternalCarouselProps`.\n   */\n  const props = rawProps;\n  const {\n    adaptiveHeight,\n    adaptiveHeightAnimation,\n    afterSlide,\n    animation,\n    autoplay,\n    autoplayInterval,\n    autoplayReverse,\n    beforeSlide,\n    cellAlign,\n    cellSpacing,\n    children,\n    className,\n    disableAnimation,\n    dragging: desktopDraggingEnabled,\n    dragThreshold: propsDragThreshold,\n    enableKeyboardControls,\n    frameAriaLabel,\n    innerRef,\n    keyCodeConfig,\n    onDrag,\n    onDragEnd,\n    onDragStart,\n    onUserNavigation,\n    pauseOnHover,\n    renderAnnounceSlideMessage,\n    scrollMode,\n    slideIndex,\n    slidesToScroll: propsSlidesToScroll,\n    slidesToShow,\n    speed,\n    style,\n    swiping: mobileDraggingEnabled,\n    wrapAround,\n    zoomScale\n  } = props;\n  const filteredSlides = react_1.default.Children.toArray(children).filter(Boolean);\n  const slideCount = filteredSlides.length;\n  const slidesToScroll = animation === 'fade' ? slidesToShow : propsSlidesToScroll;\n  const [currentSlide, setCurrentSlide] = (0, react_1.useState)(() => (0, utils_1.getDefaultSlideIndex)(slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode));\n  const [pause, setPause] = (0, react_1.useState)(false);\n  const [isDragging, setIsDragging] = (0, react_1.useState)(false);\n  const [dragDistance, setDragDistance] = (0, react_1.useState)(0);\n  const [animationDistance, setAnimationDistance] = (0, react_1.useState)(0);\n  const prevXPosition = (0, react_1.useRef)(null);\n  const preDragOffset = (0, react_1.useRef)(0);\n  const sliderListRef = (0, react_1.useRef)(null);\n  const defaultCarouselRef = (0, react_1.useRef)(null);\n  const autoplayTimeout = (0, react_1.useRef)();\n  const autoplayLastTriggeredRef = (0, react_1.useRef)(null);\n  const isMounted = (0, react_1.useRef)(true);\n  const setSliderListRef = (0, react_1.useCallback)(node => {\n    if (node) {\n      // disable img draggable attribute by default, this will improve the dragging\n      // applying the querySelectorAll on just the descendants of the sliderList prevents\n      // impacting DOM elements outside our scope\n      node.querySelectorAll('.slider-list img').forEach(el => el.setAttribute('draggable', 'false'));\n    }\n\n    sliderListRef.current = node;\n  }, []);\n  (0, react_1.useEffect)(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  const carouselRef = innerRef || defaultCarouselRef;\n  const goToSlide = (0, react_1.useCallback)(targetSlideUnbounded => {\n    if (!sliderListRef.current || !carouselRef.current) return;\n    const targetSlideBounded = (0, utils_1.getBoundedIndex)(targetSlideUnbounded, slideCount);\n    const slideChanged = targetSlideUnbounded !== currentSlide;\n    slideChanged && beforeSlide(currentSlide, targetSlideBounded); // Calculate the distance the slide transition animation needs to cover.\n\n    const currentOffset = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n    const sliderWidth = sliderListRef.current.offsetWidth;\n    let targetOffset = (0, slider_list_1.getPercentOffsetForSlide)(targetSlideBounded, slideCount, slidesToShow, cellAlign, wrapAround) / 100 * sliderWidth;\n\n    if (wrapAround) {\n      // We have to do a bit of a recovery effort to figure out the closest\n      // offset based on the direction we're going in the slides. The reason\n      // it's complicated is because, when wrapped, both the current offset\n      // and the calculated target offset are based on bounded slide indices -\n      // that is, when wrapping, we often skip back to the first or last slide\n      // seamlessly to make the carousel appear to infinitely repeat\n      // The DOM width of `slideCount` slides\n      const slideSetWidth = sliderWidth / 3;\n\n      if (targetSlideUnbounded < 0) {\n        targetOffset += slideSetWidth;\n      }\n\n      if (targetSlideUnbounded >= slideCount) {\n        targetOffset -= slideSetWidth;\n      }\n    }\n\n    setAnimationDistance(targetOffset - currentOffset);\n\n    if (slideChanged) {\n      setCurrentSlide(targetSlideBounded); // if animation is disabled decrease the speed to 40\n\n      const msToEndOfAnimation = !disableAnimation ? speed || 500 : 40;\n      setTimeout(() => {\n        if (!isMounted.current) return;\n        afterSlide(targetSlideBounded);\n      }, msToEndOfAnimation);\n    }\n  }, [afterSlide, beforeSlide, carouselRef, cellAlign, currentSlide, disableAnimation, speed, slideCount, slidesToShow, wrapAround]);\n  const nextSlide = (0, react_1.useCallback)(() => {\n    const nextSlideIndex = (0, utils_1.getNextMoveIndex)(scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign);\n\n    if (currentSlide !== nextSlideIndex) {\n      goToSlide(nextSlideIndex);\n    }\n  }, [cellAlign, currentSlide, goToSlide, slidesToScroll, scrollMode, slideCount, slidesToShow, wrapAround]);\n  const prevSlide = (0, react_1.useCallback)(() => {\n    const prevSlideIndex = (0, utils_1.getPrevMoveIndex)(scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign);\n\n    if (currentSlide !== prevSlideIndex) {\n      goToSlide(prevSlideIndex);\n    }\n  }, [cellAlign, currentSlide, goToSlide, slidesToScroll, scrollMode, slidesToShow, wrapAround]); // When user changed the slideIndex property from outside.\n\n  const prevMovedToSlideIndex = (0, react_1.useRef)(slideIndex);\n  (0, react_1.useEffect)(() => {\n    if (slideIndex !== undefined && slideIndex !== prevMovedToSlideIndex.current && !autoplayReverse) {\n      goToSlide(slideIndex);\n      prevMovedToSlideIndex.current = slideIndex;\n    }\n  }, [slideIndex, autoplayReverse, goToSlide]);\n  (0, react_1.useEffect)(() => {\n    let pauseStarted = null; // Keep track of when autoplay was paused so we can resume it with the same\n    // remaining time to the next slide transition\n\n    if (pause) {\n      pauseStarted = Date.now();\n    }\n\n    return () => {\n      if (pauseStarted !== null && autoplayLastTriggeredRef.current !== null) {\n        autoplayLastTriggeredRef.current += Date.now() - pauseStarted;\n      }\n    };\n  }, [pause]);\n  (0, react_1.useEffect)(() => {\n    if (autoplay && !pause) {\n      // Adjust the timeout duration to account for changes that triggered the\n      // re-creation of this timeout, such as the currentSlide being changed\n      // periodically to make wrapAround loop forever\n      const adjustedTimeoutMs = autoplayLastTriggeredRef.current !== null ? autoplayInterval - (Date.now() - autoplayLastTriggeredRef.current) : autoplayInterval;\n      autoplayTimeout.current = setTimeout(() => {\n        autoplayLastTriggeredRef.current = Date.now();\n\n        if (autoplayReverse) {\n          prevSlide();\n        } else {\n          nextSlide();\n        }\n      }, adjustedTimeoutMs);\n    } // Clear the timeout if user hover on carousel\n\n\n    if (autoplay && pause) {\n      clearTimeout(autoplayTimeout.current);\n    }\n\n    return () => {\n      clearTimeout(autoplayTimeout.current);\n    };\n  }, [pause, autoplay, autoplayInterval, autoplayReverse, prevSlide, nextSlide]);\n\n  const onKeyDown = event => {\n    let keyCommand = null;\n    Object.keys(keyCodeConfig).forEach(command => {\n      var _a;\n\n      if ((_a = keyCodeConfig[command]) === null || _a === void 0 ? void 0 : _a.includes(event.keyCode)) {\n        keyCommand = command;\n      }\n    });\n    if (keyCommand === null) return; // At this point we know some action is going to be triggered, so we\n    // preventDefault to avoid the browser interpreting the key event and\n    // stopPropagation to avoid any higher-up handlers from interpreting it.\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    switch (keyCommand) {\n      case 'nextSlide':\n        onUserNavigation(event);\n        nextSlide();\n        break;\n\n      case 'previousSlide':\n        onUserNavigation(event);\n        prevSlide();\n        break;\n\n      case 'firstSlide':\n      case 'lastSlide':\n        {\n          onUserNavigation(event);\n          const dotIndices = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n\n          if (keyCommand === 'firstSlide') {\n            goToSlide(dotIndices[0]);\n          } else {\n            goToSlide(dotIndices[dotIndices.length - 1]);\n          }\n\n          break;\n        }\n\n      case 'pause':\n        setPause(p => !p);\n        break;\n    }\n  };\n\n  const dragPositions = (0, react_1.useRef)([]);\n\n  const handleDragEnd = e => {\n    if (!isDragging || !carouselRef.current) return;\n    setIsDragging(false); // Inertia calculation is used to allow quick flicks to scroll the carousel\n    // where they might not based on the start and end points of the gesture\n    // alone. In certain conditions, the inertia may also scroll the carousel\n    // several times.\n\n    let distanceFromInertia = 0;\n\n    if (dragPositions.current.length > 1) {\n      const startMove = dragPositions.current[0];\n      const endMove = dragPositions.current[dragPositions.current.length - 1];\n      const timeOffset = endMove.time - startMove.time;\n      const goodInertiaFeelConstant = 9;\n      const goodFrictionFeelConstant = 0.92;\n      const initialVelocity = goodInertiaFeelConstant * Math.abs((endMove.pos - startMove.pos) / timeOffset);\n      let velocity = initialVelocity;\n\n      while (Math.abs(velocity) > 1) {\n        distanceFromInertia += velocity;\n        velocity *= goodFrictionFeelConstant;\n      }\n    }\n\n    dragPositions.current = [];\n    const adjustedDragDistance = Math.abs(dragDistance) + Math.abs(distanceFromInertia);\n    onDragEnd(e);\n    prevXPosition.current = null;\n    setDragDistance(0);\n    const oneScrollWidth = carouselRef.current.offsetWidth * Math.min(1, slidesToScroll / slidesToShow);\n    const dragThreshold = oneScrollWidth * propsDragThreshold;\n\n    if (adjustedDragDistance < dragThreshold) {\n      goToSlide(currentSlide);\n      return;\n    } // If skipping over multiple slides at a time is still roughly trackable by\n    // your eyes, we allow for skipping multiple slides with a single gesture.\n    // This formula is just based off an observation that it is confusing to\n    // skip from slides 1 to 3 when only one slide is shown at a time, but\n    // skipping from 1 to 4 or so with two slides shown at a time is pulled-back\n    // enough that you can still roughly keep track of your place in the\n    // carousel.\n\n\n    const canMaintainVisualContinuity = slidesToShow >= 2 * slidesToScroll;\n    const timesToMove = canMaintainVisualContinuity ? 1 + Math.floor((adjustedDragDistance - dragThreshold) / oneScrollWidth) : 1;\n    let nextSlideIndex = currentSlide;\n\n    for (let index = 0; index < timesToMove; index += 1) {\n      if (dragDistance > 0) {\n        nextSlideIndex = (0, utils_1.getNextMoveIndex)(scrollMode, wrapAround, nextSlideIndex, slideCount, slidesToScroll, slidesToShow, cellAlign);\n      } else {\n        nextSlideIndex = (0, utils_1.getPrevMoveIndex)(scrollMode, wrapAround, nextSlideIndex, slidesToScroll, slidesToShow, cellAlign);\n      }\n    }\n\n    if (nextSlideIndex !== currentSlide) {\n      onUserNavigation(e);\n    }\n\n    goToSlide(nextSlideIndex);\n  };\n\n  const onTouchStart = (0, react_1.useCallback)(e => {\n    if (!mobileDraggingEnabled || !sliderListRef.current || !carouselRef.current) {\n      return;\n    }\n\n    setIsDragging(true);\n    preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n    onDragStart(e);\n  }, [carouselRef, onDragStart, mobileDraggingEnabled]);\n  const handlePointerMove = (0, react_1.useCallback)(xPosition => {\n    if (!isDragging) return;\n    const isFirstMove = prevXPosition.current === null;\n    const delta = prevXPosition.current !== null ? xPosition - prevXPosition.current : 0;\n    const nextDragDistance = dragDistance + delta;\n    const now = Date.now(); // Maintain a buffer of drag positions from the last 100ms\n\n    while (dragPositions.current.length > 0) {\n      if (now - dragPositions.current[0].time <= 100) {\n        break;\n      }\n\n      dragPositions.current.shift();\n    }\n\n    dragPositions.current.push({\n      pos: nextDragDistance,\n      time: now\n    });\n\n    if (!isFirstMove) {\n      // nextDragDistance will always be `0` on the first move event, so we\n      // skip it because the value is already set to 0 at this point\n      setDragDistance(nextDragDistance);\n    }\n\n    prevXPosition.current = xPosition;\n  }, [isDragging, dragDistance]);\n  const onTouchMove = (0, react_1.useCallback)(e => {\n    if (!isDragging || !carouselRef.current) return;\n    onDragStart(e);\n    const moveValue = carouselRef.current.offsetWidth - e.touches[0].pageX;\n    handlePointerMove(moveValue);\n  }, [isDragging, carouselRef, handlePointerMove, onDragStart]);\n  const onMouseDown = (0, react_1.useCallback)(e => {\n    if (!desktopDraggingEnabled || !sliderListRef.current || !carouselRef.current) return;\n    setIsDragging(true);\n    preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n    onDragStart(e);\n  }, [carouselRef, desktopDraggingEnabled, onDragStart]);\n  const onMouseMove = (0, react_1.useCallback)(e => {\n    if (!isDragging || !carouselRef.current) return;\n    onDrag(e);\n    const offsetX = e.clientX - carouselRef.current.getBoundingClientRect().left;\n    const moveValue = carouselRef.current.offsetWidth - offsetX;\n    handlePointerMove(moveValue);\n  }, [carouselRef, isDragging, handlePointerMove, onDrag]);\n\n  const onMouseUp = e => {\n    e.preventDefault();\n    handleDragEnd(e);\n  };\n\n  const onMouseEnter = (0, react_1.useCallback)(() => {\n    if (pauseOnHover) {\n      setPause(true);\n    }\n  }, [pauseOnHover]);\n  const onMouseLeave = (0, react_1.useCallback)(() => {\n    if (pauseOnHover) {\n      setPause(false);\n    }\n  }, [pauseOnHover]);\n  const {\n    frameHeight,\n    handleVisibleSlideHeightChange,\n    initializedAdaptiveHeight\n  } = (0, use_frame_height_1.useFrameHeight)(adaptiveHeight, slidesToShow, slideCount);\n\n  const renderSlides = typeOfSlide => {\n    const slides = filteredSlides.map((child, index) => {\n      return (0, jsx_runtime_1.jsx)(slide_1.default, Object.assign({\n        count: slideCount,\n        currentSlide: currentSlide,\n        index: index,\n        isCurrentSlide: currentSlide === index,\n        typeOfSlide: typeOfSlide,\n        wrapAround: wrapAround,\n        cellSpacing: cellSpacing,\n        animation: animation,\n        slidesToShow: slidesToShow,\n        speed: speed,\n        zoomScale: zoomScale,\n        cellAlign: cellAlign,\n        onVisibleSlideHeightChange: handleVisibleSlideHeightChange,\n        adaptiveHeight: adaptiveHeight,\n        initializedAdaptiveHeight: initializedAdaptiveHeight\n      }, {\n        children: child\n      }), `${typeOfSlide}-${index}`);\n    });\n    return slides;\n  };\n\n  return (0, jsx_runtime_1.jsxs)(\"div\", Object.assign({\n    className: 'slider-container',\n    style: {\n      position: 'relative'\n    },\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave\n  }, {\n    children: [(0, jsx_runtime_1.jsx)(announce_slide_1.default, {\n      ariaLive: autoplay && !pause ? 'off' : 'polite',\n      message: renderAnnounceSlideMessage({\n        currentSlide,\n        count: slideCount\n      })\n    }), (0, controls_1.default)(props, slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll), (0, jsx_runtime_1.jsx)(\"div\", Object.assign({\n      className: ['slider-frame', className || ''].join(' ').trim(),\n      style: Object.assign({\n        overflow: 'hidden',\n        width: '100%',\n        position: 'relative',\n        outline: 'none',\n        height: frameHeight,\n        transition: adaptiveHeightAnimation ? 'height 300ms ease-in-out' : undefined,\n        willChange: 'height',\n        userSelect: 'none'\n      }, style),\n      \"aria-label\": frameAriaLabel,\n      role: \"region\",\n      tabIndex: enableKeyboardControls ? 0 : -1,\n      onKeyDown: enableKeyboardControls ? onKeyDown : undefined,\n      ref: carouselRef,\n      onMouseUp: onMouseUp,\n      onMouseDown: onMouseDown,\n      onMouseMove: onMouseMove,\n      onMouseLeave: onMouseUp,\n      onTouchStart: onTouchStart,\n      onTouchEnd: handleDragEnd,\n      onTouchMove: onTouchMove\n    }, {\n      children: (0, jsx_runtime_1.jsxs)(slider_list_1.SliderList, Object.assign({\n        animationDistance: animationDistance,\n        cellAlign: cellAlign,\n        currentSlide: currentSlide,\n        disableEdgeSwiping: props.disableEdgeSwiping,\n        draggedOffset: preDragOffset.current - dragDistance,\n        disableAnimation: disableAnimation,\n        easing: props.easing,\n        edgeEasing: props.edgeEasing,\n        isDragging: isDragging,\n        ref: setSliderListRef,\n        scrollMode: scrollMode,\n        animation: animation,\n        slideCount: slideCount,\n        slidesToScroll: slidesToScroll,\n        slidesToShow: slidesToShow,\n        speed: speed,\n        wrapAround: wrapAround\n      }, {\n        children: [wrapAround ? renderSlides('prev-cloned') : null, renderSlides(), wrapAround ? renderSlides('next-cloned') : null]\n      }))\n    }))]\n  }));\n};\n\nexports.Carousel = Carousel;\nexports.Carousel.defaultProps = default_carousel_props_1.default;\nexports.default = exports.Carousel;","map":{"version":3,"sources":["../src/carousel.tsx"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Carousel = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst react_1 = __importStar(require(\"react\"));\nconst slide_1 = __importDefault(require(\"./slide\"));\nconst announce_slide_1 = __importDefault(require(\"./announce-slide\"));\nconst slider_list_1 = require(\"./slider-list\");\nconst controls_1 = __importDefault(require(\"./controls\"));\nconst default_carousel_props_1 = __importDefault(require(\"./default-carousel-props\"));\nconst utils_1 = require(\"./utils\");\nconst use_frame_height_1 = require(\"./hooks/use-frame-height\");\nconst default_controls_1 = require(\"./default-controls\");\nconst Carousel = (rawProps) => {\n    /**\n     * We need this cast because we want the component's properties to seem\n     * optional to external users, but always-present for the internal\n     * implementation.\n     *\n     * This cast is safe due to the `Carousel.defaultProps = defaultProps;`\n     * statement below. That guarantees all the properties are present, since\n     * `defaultProps` has type `InternalCarouselProps`.\n     */\n    const props = rawProps;\n    const { adaptiveHeight, adaptiveHeightAnimation, afterSlide, animation, autoplay, autoplayInterval, autoplayReverse, beforeSlide, cellAlign, cellSpacing, children, className, disableAnimation, dragging: desktopDraggingEnabled, dragThreshold: propsDragThreshold, enableKeyboardControls, frameAriaLabel, innerRef, keyCodeConfig, onDrag, onDragEnd, onDragStart, onUserNavigation, pauseOnHover, renderAnnounceSlideMessage, scrollMode, slideIndex, slidesToScroll: propsSlidesToScroll, slidesToShow, speed, style, swiping: mobileDraggingEnabled, wrapAround, zoomScale, } = props;\n    const filteredSlides = react_1.default.Children.toArray(children).filter(Boolean);\n    const slideCount = filteredSlides.length;\n    const slidesToScroll = animation === 'fade' ? slidesToShow : propsSlidesToScroll;\n    const [currentSlide, setCurrentSlide] = (0, react_1.useState)(() => (0, utils_1.getDefaultSlideIndex)(slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode));\n    const [pause, setPause] = (0, react_1.useState)(false);\n    const [isDragging, setIsDragging] = (0, react_1.useState)(false);\n    const [dragDistance, setDragDistance] = (0, react_1.useState)(0);\n    const [animationDistance, setAnimationDistance] = (0, react_1.useState)(0);\n    const prevXPosition = (0, react_1.useRef)(null);\n    const preDragOffset = (0, react_1.useRef)(0);\n    const sliderListRef = (0, react_1.useRef)(null);\n    const defaultCarouselRef = (0, react_1.useRef)(null);\n    const autoplayTimeout = (0, react_1.useRef)();\n    const autoplayLastTriggeredRef = (0, react_1.useRef)(null);\n    const isMounted = (0, react_1.useRef)(true);\n    const setSliderListRef = (0, react_1.useCallback)((node) => {\n        if (node) {\n            // disable img draggable attribute by default, this will improve the dragging\n            // applying the querySelectorAll on just the descendants of the sliderList prevents\n            // impacting DOM elements outside our scope\n            node\n                .querySelectorAll('.slider-list img')\n                .forEach((el) => el.setAttribute('draggable', 'false'));\n        }\n        sliderListRef.current = node;\n    }, []);\n    (0, react_1.useEffect)(() => {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    const carouselRef = innerRef || defaultCarouselRef;\n    const goToSlide = (0, react_1.useCallback)((targetSlideUnbounded) => {\n        if (!sliderListRef.current || !carouselRef.current)\n            return;\n        const targetSlideBounded = (0, utils_1.getBoundedIndex)(targetSlideUnbounded, slideCount);\n        const slideChanged = targetSlideUnbounded !== currentSlide;\n        slideChanged && beforeSlide(currentSlide, targetSlideBounded);\n        // Calculate the distance the slide transition animation needs to cover.\n        const currentOffset = sliderListRef.current.getBoundingClientRect().left -\n            carouselRef.current.getBoundingClientRect().left;\n        const sliderWidth = sliderListRef.current.offsetWidth;\n        let targetOffset = ((0, slider_list_1.getPercentOffsetForSlide)(targetSlideBounded, slideCount, slidesToShow, cellAlign, wrapAround) /\n            100) *\n            sliderWidth;\n        if (wrapAround) {\n            // We have to do a bit of a recovery effort to figure out the closest\n            // offset based on the direction we're going in the slides. The reason\n            // it's complicated is because, when wrapped, both the current offset\n            // and the calculated target offset are based on bounded slide indices -\n            // that is, when wrapping, we often skip back to the first or last slide\n            // seamlessly to make the carousel appear to infinitely repeat\n            // The DOM width of `slideCount` slides\n            const slideSetWidth = sliderWidth / 3;\n            if (targetSlideUnbounded < 0) {\n                targetOffset += slideSetWidth;\n            }\n            if (targetSlideUnbounded >= slideCount) {\n                targetOffset -= slideSetWidth;\n            }\n        }\n        setAnimationDistance(targetOffset - currentOffset);\n        if (slideChanged) {\n            setCurrentSlide(targetSlideBounded);\n            // if animation is disabled decrease the speed to 40\n            const msToEndOfAnimation = !disableAnimation ? speed || 500 : 40;\n            setTimeout(() => {\n                if (!isMounted.current)\n                    return;\n                afterSlide(targetSlideBounded);\n            }, msToEndOfAnimation);\n        }\n    }, [\n        afterSlide,\n        beforeSlide,\n        carouselRef,\n        cellAlign,\n        currentSlide,\n        disableAnimation,\n        speed,\n        slideCount,\n        slidesToShow,\n        wrapAround,\n    ]);\n    const nextSlide = (0, react_1.useCallback)(() => {\n        const nextSlideIndex = (0, utils_1.getNextMoveIndex)(scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign);\n        if (currentSlide !== nextSlideIndex) {\n            goToSlide(nextSlideIndex);\n        }\n    }, [\n        cellAlign,\n        currentSlide,\n        goToSlide,\n        slidesToScroll,\n        scrollMode,\n        slideCount,\n        slidesToShow,\n        wrapAround,\n    ]);\n    const prevSlide = (0, react_1.useCallback)(() => {\n        const prevSlideIndex = (0, utils_1.getPrevMoveIndex)(scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign);\n        if (currentSlide !== prevSlideIndex) {\n            goToSlide(prevSlideIndex);\n        }\n    }, [\n        cellAlign,\n        currentSlide,\n        goToSlide,\n        slidesToScroll,\n        scrollMode,\n        slidesToShow,\n        wrapAround,\n    ]);\n    // When user changed the slideIndex property from outside.\n    const prevMovedToSlideIndex = (0, react_1.useRef)(slideIndex);\n    (0, react_1.useEffect)(() => {\n        if (slideIndex !== undefined &&\n            slideIndex !== prevMovedToSlideIndex.current &&\n            !autoplayReverse) {\n            goToSlide(slideIndex);\n            prevMovedToSlideIndex.current = slideIndex;\n        }\n    }, [slideIndex, autoplayReverse, goToSlide]);\n    (0, react_1.useEffect)(() => {\n        let pauseStarted = null;\n        // Keep track of when autoplay was paused so we can resume it with the same\n        // remaining time to the next slide transition\n        if (pause) {\n            pauseStarted = Date.now();\n        }\n        return () => {\n            if (pauseStarted !== null && autoplayLastTriggeredRef.current !== null) {\n                autoplayLastTriggeredRef.current += Date.now() - pauseStarted;\n            }\n        };\n    }, [pause]);\n    (0, react_1.useEffect)(() => {\n        if (autoplay && !pause) {\n            // Adjust the timeout duration to account for changes that triggered the\n            // re-creation of this timeout, such as the currentSlide being changed\n            // periodically to make wrapAround loop forever\n            const adjustedTimeoutMs = autoplayLastTriggeredRef.current !== null\n                ? autoplayInterval - (Date.now() - autoplayLastTriggeredRef.current)\n                : autoplayInterval;\n            autoplayTimeout.current = setTimeout(() => {\n                autoplayLastTriggeredRef.current = Date.now();\n                if (autoplayReverse) {\n                    prevSlide();\n                }\n                else {\n                    nextSlide();\n                }\n            }, adjustedTimeoutMs);\n        }\n        // Clear the timeout if user hover on carousel\n        if (autoplay && pause) {\n            clearTimeout(autoplayTimeout.current);\n        }\n        return () => {\n            clearTimeout(autoplayTimeout.current);\n        };\n    }, [\n        pause,\n        autoplay,\n        autoplayInterval,\n        autoplayReverse,\n        prevSlide,\n        nextSlide,\n    ]);\n    const onKeyDown = (event) => {\n        let keyCommand = null;\n        Object.keys(keyCodeConfig).forEach((command) => {\n            var _a;\n            if ((_a = keyCodeConfig[command]) === null || _a === void 0 ? void 0 : _a.includes(event.keyCode)) {\n                keyCommand = command;\n            }\n        });\n        if (keyCommand === null)\n            return;\n        // At this point we know some action is going to be triggered, so we\n        // preventDefault to avoid the browser interpreting the key event and\n        // stopPropagation to avoid any higher-up handlers from interpreting it.\n        event.preventDefault();\n        event.stopPropagation();\n        switch (keyCommand) {\n            case 'nextSlide':\n                onUserNavigation(event);\n                nextSlide();\n                break;\n            case 'previousSlide':\n                onUserNavigation(event);\n                prevSlide();\n                break;\n            case 'firstSlide':\n            case 'lastSlide': {\n                onUserNavigation(event);\n                const dotIndices = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n                if (keyCommand === 'firstSlide') {\n                    goToSlide(dotIndices[0]);\n                }\n                else {\n                    goToSlide(dotIndices[dotIndices.length - 1]);\n                }\n                break;\n            }\n            case 'pause':\n                setPause((p) => !p);\n                break;\n        }\n    };\n    const dragPositions = (0, react_1.useRef)([]);\n    const handleDragEnd = (e) => {\n        if (!isDragging || !carouselRef.current)\n            return;\n        setIsDragging(false);\n        // Inertia calculation is used to allow quick flicks to scroll the carousel\n        // where they might not based on the start and end points of the gesture\n        // alone. In certain conditions, the inertia may also scroll the carousel\n        // several times.\n        let distanceFromInertia = 0;\n        if (dragPositions.current.length > 1) {\n            const startMove = dragPositions.current[0];\n            const endMove = dragPositions.current[dragPositions.current.length - 1];\n            const timeOffset = endMove.time - startMove.time;\n            const goodInertiaFeelConstant = 9;\n            const goodFrictionFeelConstant = 0.92;\n            const initialVelocity = goodInertiaFeelConstant *\n                Math.abs((endMove.pos - startMove.pos) / timeOffset);\n            let velocity = initialVelocity;\n            while (Math.abs(velocity) > 1) {\n                distanceFromInertia += velocity;\n                velocity *= goodFrictionFeelConstant;\n            }\n        }\n        dragPositions.current = [];\n        const adjustedDragDistance = Math.abs(dragDistance) + Math.abs(distanceFromInertia);\n        onDragEnd(e);\n        prevXPosition.current = null;\n        setDragDistance(0);\n        const oneScrollWidth = carouselRef.current.offsetWidth *\n            Math.min(1, slidesToScroll / slidesToShow);\n        const dragThreshold = oneScrollWidth * propsDragThreshold;\n        if (adjustedDragDistance < dragThreshold) {\n            goToSlide(currentSlide);\n            return;\n        }\n        // If skipping over multiple slides at a time is still roughly trackable by\n        // your eyes, we allow for skipping multiple slides with a single gesture.\n        // This formula is just based off an observation that it is confusing to\n        // skip from slides 1 to 3 when only one slide is shown at a time, but\n        // skipping from 1 to 4 or so with two slides shown at a time is pulled-back\n        // enough that you can still roughly keep track of your place in the\n        // carousel.\n        const canMaintainVisualContinuity = slidesToShow >= 2 * slidesToScroll;\n        const timesToMove = canMaintainVisualContinuity\n            ? 1 + Math.floor((adjustedDragDistance - dragThreshold) / oneScrollWidth)\n            : 1;\n        let nextSlideIndex = currentSlide;\n        for (let index = 0; index < timesToMove; index += 1) {\n            if (dragDistance > 0) {\n                nextSlideIndex = (0, utils_1.getNextMoveIndex)(scrollMode, wrapAround, nextSlideIndex, slideCount, slidesToScroll, slidesToShow, cellAlign);\n            }\n            else {\n                nextSlideIndex = (0, utils_1.getPrevMoveIndex)(scrollMode, wrapAround, nextSlideIndex, slidesToScroll, slidesToShow, cellAlign);\n            }\n        }\n        if (nextSlideIndex !== currentSlide) {\n            onUserNavigation(e);\n        }\n        goToSlide(nextSlideIndex);\n    };\n    const onTouchStart = (0, react_1.useCallback)((e) => {\n        if (!mobileDraggingEnabled ||\n            !sliderListRef.current ||\n            !carouselRef.current) {\n            return;\n        }\n        setIsDragging(true);\n        preDragOffset.current =\n            sliderListRef.current.getBoundingClientRect().left -\n                carouselRef.current.getBoundingClientRect().left;\n        onDragStart(e);\n    }, [carouselRef, onDragStart, mobileDraggingEnabled]);\n    const handlePointerMove = (0, react_1.useCallback)((xPosition) => {\n        if (!isDragging)\n            return;\n        const isFirstMove = prevXPosition.current === null;\n        const delta = prevXPosition.current !== null ? xPosition - prevXPosition.current : 0;\n        const nextDragDistance = dragDistance + delta;\n        const now = Date.now();\n        // Maintain a buffer of drag positions from the last 100ms\n        while (dragPositions.current.length > 0) {\n            if (now - dragPositions.current[0].time <= 100) {\n                break;\n            }\n            dragPositions.current.shift();\n        }\n        dragPositions.current.push({ pos: nextDragDistance, time: now });\n        if (!isFirstMove) {\n            // nextDragDistance will always be `0` on the first move event, so we\n            // skip it because the value is already set to 0 at this point\n            setDragDistance(nextDragDistance);\n        }\n        prevXPosition.current = xPosition;\n    }, [isDragging, dragDistance]);\n    const onTouchMove = (0, react_1.useCallback)((e) => {\n        if (!isDragging || !carouselRef.current)\n            return;\n        onDragStart(e);\n        const moveValue = carouselRef.current.offsetWidth - e.touches[0].pageX;\n        handlePointerMove(moveValue);\n    }, [isDragging, carouselRef, handlePointerMove, onDragStart]);\n    const onMouseDown = (0, react_1.useCallback)((e) => {\n        if (!desktopDraggingEnabled ||\n            !sliderListRef.current ||\n            !carouselRef.current)\n            return;\n        setIsDragging(true);\n        preDragOffset.current =\n            sliderListRef.current.getBoundingClientRect().left -\n                carouselRef.current.getBoundingClientRect().left;\n        onDragStart(e);\n    }, [carouselRef, desktopDraggingEnabled, onDragStart]);\n    const onMouseMove = (0, react_1.useCallback)((e) => {\n        if (!isDragging || !carouselRef.current)\n            return;\n        onDrag(e);\n        const offsetX = e.clientX - carouselRef.current.getBoundingClientRect().left;\n        const moveValue = carouselRef.current.offsetWidth - offsetX;\n        handlePointerMove(moveValue);\n    }, [carouselRef, isDragging, handlePointerMove, onDrag]);\n    const onMouseUp = (e) => {\n        e.preventDefault();\n        handleDragEnd(e);\n    };\n    const onMouseEnter = (0, react_1.useCallback)(() => {\n        if (pauseOnHover) {\n            setPause(true);\n        }\n    }, [pauseOnHover]);\n    const onMouseLeave = (0, react_1.useCallback)(() => {\n        if (pauseOnHover) {\n            setPause(false);\n        }\n    }, [pauseOnHover]);\n    const { frameHeight, handleVisibleSlideHeightChange, initializedAdaptiveHeight, } = (0, use_frame_height_1.useFrameHeight)(adaptiveHeight, slidesToShow, slideCount);\n    const renderSlides = (typeOfSlide) => {\n        const slides = filteredSlides.map((child, index) => {\n            return ((0, jsx_runtime_1.jsx)(slide_1.default, Object.assign({ count: slideCount, currentSlide: currentSlide, index: index, isCurrentSlide: currentSlide === index, typeOfSlide: typeOfSlide, wrapAround: wrapAround, cellSpacing: cellSpacing, animation: animation, slidesToShow: slidesToShow, speed: speed, zoomScale: zoomScale, cellAlign: cellAlign, onVisibleSlideHeightChange: handleVisibleSlideHeightChange, adaptiveHeight: adaptiveHeight, initializedAdaptiveHeight: initializedAdaptiveHeight }, { children: child }), `${typeOfSlide}-${index}`));\n        });\n        return slides;\n    };\n    return ((0, jsx_runtime_1.jsxs)(\"div\", Object.assign({ className: 'slider-container', style: {\n            position: 'relative',\n        }, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave }, { children: [(0, jsx_runtime_1.jsx)(announce_slide_1.default, { ariaLive: autoplay && !pause ? 'off' : 'polite', message: renderAnnounceSlideMessage({\n                    currentSlide,\n                    count: slideCount,\n                }) }), (0, controls_1.default)(props, slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll), (0, jsx_runtime_1.jsx)(\"div\", Object.assign({ className: ['slider-frame', className || ''].join(' ').trim(), style: Object.assign({ overflow: 'hidden', width: '100%', position: 'relative', outline: 'none', height: frameHeight, transition: adaptiveHeightAnimation\n                        ? 'height 300ms ease-in-out'\n                        : undefined, willChange: 'height', userSelect: 'none' }, style), \"aria-label\": frameAriaLabel, role: \"region\", tabIndex: enableKeyboardControls ? 0 : -1, onKeyDown: enableKeyboardControls ? onKeyDown : undefined, ref: carouselRef, onMouseUp: onMouseUp, onMouseDown: onMouseDown, onMouseMove: onMouseMove, onMouseLeave: onMouseUp, onTouchStart: onTouchStart, onTouchEnd: handleDragEnd, onTouchMove: onTouchMove }, { children: (0, jsx_runtime_1.jsxs)(slider_list_1.SliderList, Object.assign({ animationDistance: animationDistance, cellAlign: cellAlign, currentSlide: currentSlide, disableEdgeSwiping: props.disableEdgeSwiping, draggedOffset: preDragOffset.current - dragDistance, disableAnimation: disableAnimation, easing: props.easing, edgeEasing: props.edgeEasing, isDragging: isDragging, ref: setSliderListRef, scrollMode: scrollMode, animation: animation, slideCount: slideCount, slidesToScroll: slidesToScroll, slidesToShow: slidesToShow, speed: speed, wrapAround: wrapAround }, { children: [wrapAround ? renderSlides('prev-cloned') : null, renderSlides(), wrapAround ? renderSlides('next-cloned') : null] })) }))] })));\n};\nexports.Carousel = Carousel;\nexports.Carousel.defaultProps = default_carousel_props_1.default;\nexports.default = exports.Carousel;\n"]},"metadata":{},"sourceType":"script"}