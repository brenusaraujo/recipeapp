{"ast":null,"code":"/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); // Operators that always result in a boolean value\n\n\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n  \"==\": \"!=\",\n  \"!=\": \"==\",\n  \"===\": \"!==\",\n  \"!==\": \"===\" // Operators like < and >= are not true inverses, since both will return false with NaN.\n\n};\nconst OR_PRECEDENCE = astUtils.getPrecedence({\n  type: \"LogicalExpression\",\n  operator: \"||\"\n}); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow ternary operators when simpler alternatives exist\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        defaultAssignment: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessaryConditionalExpression: \"Unnecessary use of boolean literals in conditional expression.\",\n      unnecessaryConditionalAssignment: \"Unnecessary use of conditional expression for default assignment.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const defaultAssignment = options.defaultAssignment !== false;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Test if the node is a boolean literal\n     * @param {ASTNode} node The node to report.\n     * @returns {boolean} True if the its a boolean literal\n     * @private\n     */\n\n    function isBooleanLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"boolean\";\n    }\n    /**\n     * Creates an expression that represents the boolean inverse of the expression represented by the original node\n     * @param {ASTNode} node A node representing an expression\n     * @returns {string} A string representing an inverted expression\n     */\n\n\n    function invertExpression(node) {\n      if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n        const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        const text = sourceCode.getText();\n        return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n      }\n\n      if (astUtils.getPrecedence(node) < astUtils.getPrecedence({\n        type: \"UnaryExpression\"\n      })) {\n        return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n      }\n\n      return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n    }\n    /**\n     * Tests if a given node always evaluates to a boolean value\n     * @param {ASTNode} node An expression node\n     * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n     */\n\n\n    function isBooleanExpression(node) {\n      return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) || node.type === \"UnaryExpression\" && node.operator === \"!\";\n    }\n    /**\n     * Test if the node matches the pattern id ? id : expression\n     * @param {ASTNode} node The ConditionalExpression to check.\n     * @returns {boolean} True if the pattern is matched, and false otherwise\n     * @private\n     */\n\n\n    function matchesDefaultAssignment(node) {\n      return node.test.type === \"Identifier\" && node.consequent.type === \"Identifier\" && node.test.name === node.consequent.name;\n    }\n\n    return {\n      ConditionalExpression(node) {\n        if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n          context.report({\n            node,\n            messageId: \"unnecessaryConditionalExpression\",\n\n            fix(fixer) {\n              if (node.consequent.value === node.alternate.value) {\n                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n              }\n\n              if (node.alternate.value) {\n                // Replace `foo() ? false : true` with `!(foo())`\n                return fixer.replaceText(node, invertExpression(node.test));\n              } // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n\n              return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n            }\n\n          });\n        } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n          context.report({\n            node,\n            messageId: \"unnecessaryConditionalAssignment\",\n            fix: fixer => {\n              const shouldParenthesizeAlternate = (astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE || astUtils.isCoalesceExpression(node.alternate)) && !astUtils.isParenthesised(sourceCode, node.alternate);\n              const alternateText = shouldParenthesizeAlternate ? `(${sourceCode.getText(node.alternate)})` : astUtils.getParenthesisedText(sourceCode, node.alternate);\n              const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n              return fixer.replaceText(node, `${testText} || ${alternateText}`);\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","BOOLEAN_OPERATORS","Set","OPERATOR_INVERSES","OR_PRECEDENCE","getPrecedence","type","operator","module","exports","meta","docs","description","category","recommended","url","schema","properties","defaultAssignment","default","additionalProperties","fixable","messages","unnecessaryConditionalExpression","unnecessaryConditionalAssignment","create","context","options","sourceCode","getSourceCode","isBooleanLiteral","node","value","invertExpression","Object","prototype","hasOwnProperty","call","operatorToken","getFirstTokenBetween","left","right","token","text","getText","slice","range","getParenthesisedText","isBooleanExpression","has","matchesDefaultAssignment","test","consequent","name","ConditionalExpression","alternate","report","messageId","fix","fixer","replaceText","toString","shouldParenthesizeAlternate","isCoalesceExpression","isParenthesised","alternateText","testText"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-unneeded-ternary.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Operators that always result in a boolean value\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n    \"==\": \"!=\",\n    \"!=\": \"==\",\n    \"===\": \"!==\",\n    \"!==\": \"===\"\n\n    // Operators like < and >= are not true inverses, since both will return false with NaN.\n};\nconst OR_PRECEDENCE = astUtils.getPrecedence({ type: \"LogicalExpression\", operator: \"||\" });\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow ternary operators when simpler alternatives exist\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    defaultAssignment: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            unnecessaryConditionalExpression: \"Unnecessary use of boolean literals in conditional expression.\",\n            unnecessaryConditionalAssignment: \"Unnecessary use of conditional expression for default assignment.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const defaultAssignment = options.defaultAssignment !== false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Test if the node is a boolean literal\n         * @param {ASTNode} node The node to report.\n         * @returns {boolean} True if the its a boolean literal\n         * @private\n         */\n        function isBooleanLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\n        }\n\n        /**\n         * Creates an expression that represents the boolean inverse of the expression represented by the original node\n         * @param {ASTNode} node A node representing an expression\n         * @returns {string} A string representing an inverted expression\n         */\n        function invertExpression(node) {\n            if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n                const operatorToken = sourceCode.getFirstTokenBetween(\n                    node.left,\n                    node.right,\n                    token => token.value === node.operator\n                );\n                const text = sourceCode.getText();\n\n                return text.slice(node.range[0],\n                    operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n            }\n\n            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\" })) {\n                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n            }\n            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n        }\n\n        /**\n         * Tests if a given node always evaluates to a boolean value\n         * @param {ASTNode} node An expression node\n         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n         */\n        function isBooleanExpression(node) {\n            return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) ||\n                node.type === \"UnaryExpression\" && node.operator === \"!\";\n        }\n\n        /**\n         * Test if the node matches the pattern id ? id : expression\n         * @param {ASTNode} node The ConditionalExpression to check.\n         * @returns {boolean} True if the pattern is matched, and false otherwise\n         * @private\n         */\n        function matchesDefaultAssignment(node) {\n            return node.test.type === \"Identifier\" &&\n                   node.consequent.type === \"Identifier\" &&\n                   node.test.name === node.consequent.name;\n        }\n\n        return {\n\n            ConditionalExpression(node) {\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryConditionalExpression\",\n                        fix(fixer) {\n                            if (node.consequent.value === node.alternate.value) {\n\n                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n                            }\n                            if (node.alternate.value) {\n\n                                // Replace `foo() ? false : true` with `!(foo())`\n                                return fixer.replaceText(node, invertExpression(node.test));\n                            }\n\n                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n                        }\n                    });\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryConditionalAssignment\",\n                        fix: fixer => {\n                            const shouldParenthesizeAlternate =\n                                (\n                                    astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE ||\n                                    astUtils.isCoalesceExpression(node.alternate)\n                                ) &&\n                                !astUtils.isParenthesised(sourceCode, node.alternate);\n                            const alternateText = shouldParenthesizeAlternate\n                                ? `(${sourceCode.getText(node.alternate)})`\n                                : astUtils.getParenthesisedText(sourceCode, node.alternate);\n                            const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n\n                            return fixer.replaceText(node, `${testText} || ${alternateText}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}