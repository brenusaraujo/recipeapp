{"ast":null,"code":"/**\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst SPACES = /\\s+/gu;\n/**\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\n * @param {ASTNode|null} left A left node to traverse. This is a Pattern or\n *      a Property.\n * @param {ASTNode|null} right A right node to traverse. This is a Pattern or\n *      a Property.\n * @param {boolean} props The flag to check member expressions as well.\n * @param {Function} report A callback function to report.\n * @returns {void}\n */\n\nfunction eachSelfAssignment(left, right, props, report) {\n  if (!left || !right) {// do nothing\n  } else if (left.type === \"Identifier\" && right.type === \"Identifier\" && left.name === right.name) {\n    report(right);\n  } else if (left.type === \"ArrayPattern\" && right.type === \"ArrayExpression\") {\n    const end = Math.min(left.elements.length, right.elements.length);\n\n    for (let i = 0; i < end; ++i) {\n      const leftElement = left.elements[i];\n      const rightElement = right.elements[i]; // Avoid cases such as [...a] = [...a, 1]\n\n      if (leftElement && leftElement.type === \"RestElement\" && i < right.elements.length - 1) {\n        break;\n      }\n\n      eachSelfAssignment(leftElement, rightElement, props, report); // After a spread element, those indices are unknown.\n\n      if (rightElement && rightElement.type === \"SpreadElement\") {\n        break;\n      }\n    }\n  } else if (left.type === \"RestElement\" && right.type === \"SpreadElement\") {\n    eachSelfAssignment(left.argument, right.argument, props, report);\n  } else if (left.type === \"ObjectPattern\" && right.type === \"ObjectExpression\" && right.properties.length >= 1) {\n    /*\n     * Gets the index of the last spread property.\n     * It's possible to overwrite properties followed by it.\n     */\n    let startJ = 0;\n\n    for (let i = right.properties.length - 1; i >= 0; --i) {\n      const propType = right.properties[i].type;\n\n      if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\n        startJ = i + 1;\n        break;\n      }\n    }\n\n    for (let i = 0; i < left.properties.length; ++i) {\n      for (let j = startJ; j < right.properties.length; ++j) {\n        eachSelfAssignment(left.properties[i], right.properties[j], props, report);\n      }\n    }\n  } else if (left.type === \"Property\" && right.type === \"Property\" && right.kind === \"init\" && !right.method) {\n    const leftName = astUtils.getStaticPropertyName(left);\n\n    if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {\n      eachSelfAssignment(left.value, right.value, props, report);\n    }\n  } else if (props && astUtils.skipChainExpression(left).type === \"MemberExpression\" && astUtils.skipChainExpression(right).type === \"MemberExpression\" && astUtils.isSameReference(left, right)) {\n    report(right);\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignments where both sides are exactly the same\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-self-assign\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        props: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      selfAssignment: \"'{{name}}' is assigned to itself.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const [{\n      props = true\n    } = {}] = context.options;\n    /**\n     * Reports a given node as self assignments.\n     * @param {ASTNode} node A node to report. This is an Identifier node.\n     * @returns {void}\n     */\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"selfAssignment\",\n        data: {\n          name: sourceCode.getText(node).replace(SPACES, \"\")\n        }\n      });\n    }\n\n    return {\n      AssignmentExpression(node) {\n        if (node.operator === \"=\") {\n          eachSelfAssignment(node.left, node.right, props, report);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","SPACES","eachSelfAssignment","left","right","props","report","type","name","end","Math","min","elements","length","i","leftElement","rightElement","argument","properties","startJ","propType","j","kind","method","leftName","getStaticPropertyName","value","skipChainExpression","isSameReference","module","exports","meta","docs","description","category","recommended","url","schema","default","additionalProperties","messages","selfAssignment","create","context","sourceCode","getSourceCode","options","node","messageId","data","getText","replace","AssignmentExpression","operator"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-self-assign.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SPACES = /\\s+/gu;\n\n/**\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\n * @param {ASTNode|null} left A left node to traverse. This is a Pattern or\n *      a Property.\n * @param {ASTNode|null} right A right node to traverse. This is a Pattern or\n *      a Property.\n * @param {boolean} props The flag to check member expressions as well.\n * @param {Function} report A callback function to report.\n * @returns {void}\n */\nfunction eachSelfAssignment(left, right, props, report) {\n    if (!left || !right) {\n\n        // do nothing\n    } else if (\n        left.type === \"Identifier\" &&\n        right.type === \"Identifier\" &&\n        left.name === right.name\n    ) {\n        report(right);\n    } else if (\n        left.type === \"ArrayPattern\" &&\n        right.type === \"ArrayExpression\"\n    ) {\n        const end = Math.min(left.elements.length, right.elements.length);\n\n        for (let i = 0; i < end; ++i) {\n            const leftElement = left.elements[i];\n            const rightElement = right.elements[i];\n\n            // Avoid cases such as [...a] = [...a, 1]\n            if (\n                leftElement &&\n                leftElement.type === \"RestElement\" &&\n                i < right.elements.length - 1\n            ) {\n                break;\n            }\n\n            eachSelfAssignment(leftElement, rightElement, props, report);\n\n            // After a spread element, those indices are unknown.\n            if (rightElement && rightElement.type === \"SpreadElement\") {\n                break;\n            }\n        }\n    } else if (\n        left.type === \"RestElement\" &&\n        right.type === \"SpreadElement\"\n    ) {\n        eachSelfAssignment(left.argument, right.argument, props, report);\n    } else if (\n        left.type === \"ObjectPattern\" &&\n        right.type === \"ObjectExpression\" &&\n        right.properties.length >= 1\n    ) {\n\n        /*\n         * Gets the index of the last spread property.\n         * It's possible to overwrite properties followed by it.\n         */\n        let startJ = 0;\n\n        for (let i = right.properties.length - 1; i >= 0; --i) {\n            const propType = right.properties[i].type;\n\n            if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\n                startJ = i + 1;\n                break;\n            }\n        }\n\n        for (let i = 0; i < left.properties.length; ++i) {\n            for (let j = startJ; j < right.properties.length; ++j) {\n                eachSelfAssignment(\n                    left.properties[i],\n                    right.properties[j],\n                    props,\n                    report\n                );\n            }\n        }\n    } else if (\n        left.type === \"Property\" &&\n        right.type === \"Property\" &&\n        right.kind === \"init\" &&\n        !right.method\n    ) {\n        const leftName = astUtils.getStaticPropertyName(left);\n\n        if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {\n            eachSelfAssignment(left.value, right.value, props, report);\n        }\n    } else if (\n        props &&\n        astUtils.skipChainExpression(left).type === \"MemberExpression\" &&\n        astUtils.skipChainExpression(right).type === \"MemberExpression\" &&\n        astUtils.isSameReference(left, right)\n    ) {\n        report(right);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignments where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-self-assign\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    props: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            selfAssignment: \"'{{name}}' is assigned to itself.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const [{ props = true } = {}] = context.options;\n\n        /**\n         * Reports a given node as self assignments.\n         * @param {ASTNode} node A node to report. This is an Identifier node.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"selfAssignment\",\n                data: {\n                    name: sourceCode.getText(node).replace(SPACES, \"\")\n                }\n            });\n        }\n\n        return {\n            AssignmentExpression(node) {\n                if (node.operator === \"=\") {\n                    eachSelfAssignment(node.left, node.right, props, report);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}