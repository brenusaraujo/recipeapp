{"ast":null,"code":"/**\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\n * @author Jacob Moore\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow literal numbers that lose precision\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-loss-of-precision\"\n    },\n    schema: [],\n    messages: {\n      noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n    }\n  },\n\n  create(context) {\n    /**\n     * Returns whether the node is number literal\n     * @param {Node} node the node literal being evaluated\n     * @returns {boolean} true if the node is a number literal\n     */\n    function isNumber(node) {\n      return typeof node.value === \"number\";\n    }\n    /**\n     * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\n     * @param {Node} node the number `Literal` node\n     * @returns {string} raw source code of the literal, without numeric separators\n     */\n\n\n    function getRaw(node) {\n      return node.raw.replace(/_/gu, \"\");\n    }\n    /**\n     * Checks whether the number is  base ten\n     * @param {ASTNode} node the node being evaluated\n     * @returns {boolean} true if the node is in base ten\n     */\n\n\n    function isBaseTen(node) {\n      const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\n      return prefixes.every(prefix => !node.raw.startsWith(prefix)) && !/^0[0-7]+$/u.test(node.raw);\n    }\n    /**\n     * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\n     * @param {Node} node the node being evaluated\n     * @returns {boolean} true if they do not match\n     */\n\n\n    function notBaseTenLosesPrecision(node) {\n      const rawString = getRaw(node).toUpperCase();\n      let base = 0;\n\n      if (rawString.startsWith(\"0B\")) {\n        base = 2;\n      } else if (rawString.startsWith(\"0X\")) {\n        base = 16;\n      } else {\n        base = 8;\n      }\n\n      return !rawString.endsWith(node.value.toString(base).toUpperCase());\n    }\n    /**\n     * Adds a decimal point to the numeric string at index 1\n     * @param {string} stringNumber the numeric string without any decimal point\n     * @returns {string} the numeric string with a decimal point in the proper place\n     */\n\n\n    function addDecimalPointToNumber(stringNumber) {\n      return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;\n    }\n    /**\n     * Returns the number stripped of leading zeros\n     * @param {string} numberAsString the string representation of the number\n     * @returns {string} the stripped string\n     */\n\n\n    function removeLeadingZeros(numberAsString) {\n      return numberAsString.replace(/^0*/u, \"\");\n    }\n    /**\n     * Returns the number stripped of trailing zeros\n     * @param {string} numberAsString the string representation of the number\n     * @returns {string} the stripped string\n     */\n\n\n    function removeTrailingZeros(numberAsString) {\n      return numberAsString.replace(/0*$/u, \"\");\n    }\n    /**\n     * Converts an integer to to an object containing the integer's coefficient and order of magnitude\n     * @param {string} stringInteger the string representation of the integer being converted\n     * @returns {Object} the object containing the integer's coefficient and order of magnitude\n     */\n\n\n    function normalizeInteger(stringInteger) {\n      const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n      return {\n        magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n        coefficient: addDecimalPointToNumber(significantDigits)\n      };\n    }\n    /**\n     *\n     * Converts a float to to an object containing the floats's coefficient and order of magnitude\n     * @param {string} stringFloat the string representation of the float being converted\n     * @returns {Object} the object containing the integer's coefficient and order of magnitude\n     */\n\n\n    function normalizeFloat(stringFloat) {\n      const trimmedFloat = removeLeadingZeros(stringFloat);\n\n      if (trimmedFloat.startsWith(\".\")) {\n        const decimalDigits = trimmedFloat.split(\".\").pop();\n        const significantDigits = removeLeadingZeros(decimalDigits);\n        return {\n          magnitude: significantDigits.length - decimalDigits.length - 1,\n          coefficient: addDecimalPointToNumber(significantDigits)\n        };\n      }\n\n      return {\n        magnitude: trimmedFloat.indexOf(\".\") - 1,\n        coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n      };\n    }\n    /**\n     * Converts a base ten number to proper scientific notation\n     * @param {string} stringNumber the string representation of the base ten number to be converted\n     * @returns {string} the number converted to scientific notation\n     */\n\n\n    function convertNumberToScientificNotation(stringNumber) {\n      const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n      const originalCoefficient = splitNumber[0];\n      const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient) : normalizeInteger(originalCoefficient);\n      const normalizedCoefficient = normalizedNumber.coefficient;\n      const magnitude = splitNumber.length > 1 ? parseInt(splitNumber[1], 10) + normalizedNumber.magnitude : normalizedNumber.magnitude;\n      return `${normalizedCoefficient}e${magnitude}`;\n    }\n    /**\n     * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\n     * @param {Node} node the node being evaluated\n     * @returns {boolean} true if they do not match\n     */\n\n\n    function baseTenLosesPrecision(node) {\n      const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n      const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n\n      if (requestedPrecision > 100) {\n        return true;\n      }\n\n      const storedNumber = node.value.toPrecision(requestedPrecision);\n      const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n      return normalizedRawNumber !== normalizedStoredNumber;\n    }\n    /**\n     * Checks that the user-intended number equals the actual number after is has been converted to the Number type\n     * @param {Node} node the node being evaluated\n     * @returns {boolean} true if they do not match\n     */\n\n\n    function losesPrecision(node) {\n      return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n    }\n\n    return {\n      Literal(node) {\n        if (node.value && isNumber(node) && losesPrecision(node)) {\n          context.report({\n            messageId: \"noLossOfPrecision\",\n            node\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","messages","noLossOfPrecision","create","context","isNumber","node","value","getRaw","raw","replace","isBaseTen","prefixes","every","prefix","startsWith","test","notBaseTenLosesPrecision","rawString","toUpperCase","base","endsWith","toString","addDecimalPointToNumber","stringNumber","slice","removeLeadingZeros","numberAsString","removeTrailingZeros","normalizeInteger","stringInteger","significantDigits","magnitude","length","coefficient","normalizeFloat","stringFloat","trimmedFloat","decimalDigits","split","pop","indexOf","convertNumberToScientificNotation","splitNumber","originalCoefficient","normalizedNumber","includes","normalizedCoefficient","parseInt","baseTenLosesPrecision","normalizedRawNumber","requestedPrecision","storedNumber","toPrecision","normalizedStoredNumber","losesPrecision","Literal","report","messageId"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-loss-of-precision.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\n * @author Jacob Moore\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow literal numbers that lose precision\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-loss-of-precision\"\n        },\n        schema: [],\n        messages: {\n            noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Returns whether the node is number literal\n         * @param {Node} node the node literal being evaluated\n         * @returns {boolean} true if the node is a number literal\n         */\n        function isNumber(node) {\n            return typeof node.value === \"number\";\n        }\n\n        /**\n         * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\n         * @param {Node} node the number `Literal` node\n         * @returns {string} raw source code of the literal, without numeric separators\n         */\n        function getRaw(node) {\n            return node.raw.replace(/_/gu, \"\");\n        }\n\n        /**\n         * Checks whether the number is  base ten\n         * @param {ASTNode} node the node being evaluated\n         * @returns {boolean} true if the node is in base ten\n         */\n        function isBaseTen(node) {\n            const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\n\n            return prefixes.every(prefix => !node.raw.startsWith(prefix)) &&\n            !/^0[0-7]+$/u.test(node.raw);\n        }\n\n        /**\n         * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function notBaseTenLosesPrecision(node) {\n            const rawString = getRaw(node).toUpperCase();\n            let base = 0;\n\n            if (rawString.startsWith(\"0B\")) {\n                base = 2;\n            } else if (rawString.startsWith(\"0X\")) {\n                base = 16;\n            } else {\n                base = 8;\n            }\n\n            return !rawString.endsWith(node.value.toString(base).toUpperCase());\n        }\n\n        /**\n         * Adds a decimal point to the numeric string at index 1\n         * @param {string} stringNumber the numeric string without any decimal point\n         * @returns {string} the numeric string with a decimal point in the proper place\n         */\n        function addDecimalPointToNumber(stringNumber) {\n            return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;\n        }\n\n        /**\n         * Returns the number stripped of leading zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeLeadingZeros(numberAsString) {\n            return numberAsString.replace(/^0*/u, \"\");\n        }\n\n        /**\n         * Returns the number stripped of trailing zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeTrailingZeros(numberAsString) {\n            return numberAsString.replace(/0*$/u, \"\");\n        }\n\n        /**\n         * Converts an integer to to an object containing the integer's coefficient and order of magnitude\n         * @param {string} stringInteger the string representation of the integer being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeInteger(stringInteger) {\n            const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n\n            return {\n                magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n                coefficient: addDecimalPointToNumber(significantDigits)\n            };\n        }\n\n        /**\n         *\n         * Converts a float to to an object containing the floats's coefficient and order of magnitude\n         * @param {string} stringFloat the string representation of the float being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeFloat(stringFloat) {\n            const trimmedFloat = removeLeadingZeros(stringFloat);\n\n            if (trimmedFloat.startsWith(\".\")) {\n                const decimalDigits = trimmedFloat.split(\".\").pop();\n                const significantDigits = removeLeadingZeros(decimalDigits);\n\n                return {\n                    magnitude: significantDigits.length - decimalDigits.length - 1,\n                    coefficient: addDecimalPointToNumber(significantDigits)\n                };\n\n            }\n            return {\n                magnitude: trimmedFloat.indexOf(\".\") - 1,\n                coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n\n            };\n        }\n\n\n        /**\n         * Converts a base ten number to proper scientific notation\n         * @param {string} stringNumber the string representation of the base ten number to be converted\n         * @returns {string} the number converted to scientific notation\n         */\n        function convertNumberToScientificNotation(stringNumber) {\n            const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n            const originalCoefficient = splitNumber[0];\n            const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient)\n                : normalizeInteger(originalCoefficient);\n            const normalizedCoefficient = normalizedNumber.coefficient;\n            const magnitude = splitNumber.length > 1 ? (parseInt(splitNumber[1], 10) + normalizedNumber.magnitude)\n                : normalizedNumber.magnitude;\n\n            return `${normalizedCoefficient}e${magnitude}`;\n\n        }\n\n        /**\n         * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function baseTenLosesPrecision(node) {\n            const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n            const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n\n            if (requestedPrecision > 100) {\n                return true;\n            }\n            const storedNumber = node.value.toPrecision(requestedPrecision);\n            const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n\n            return normalizedRawNumber !== normalizedStoredNumber;\n        }\n\n\n        /**\n         * Checks that the user-intended number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function losesPrecision(node) {\n            return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n        }\n\n\n        return {\n            Literal(node) {\n                if (node.value && isNumber(node) && losesPrecision(node)) {\n                    context.report({\n                        messageId: \"noLossOfPrecision\",\n                        node\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}