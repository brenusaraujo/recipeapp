{"ast":null,"code":"/**\n * @fileoverview enforce a particular style for multiline comments\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a particular style for multiline comments\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/multiline-comment-style\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"starred-block\", \"separate-lines\", \"bare-block\"]\n    }],\n    messages: {\n      expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n      expectedBareBlock: \"Expected a block comment without padding stars.\",\n      startNewline: \"Expected a linebreak after '/*'.\",\n      endNewline: \"Expected a linebreak before '*/'.\",\n      missingStar: \"Expected a '*' at the start of this line.\",\n      alignment: \"Expected this line to be aligned with the start of the comment.\",\n      expectedLines: \"Expected multiple line comments instead of a block comment.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"starred-block\"; //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Checks if a comment line is starred.\n     * @param {string} line A string representing a comment line.\n     * @returns {boolean} Whether or not the comment line is starred.\n     */\n\n    function isStarredCommentLine(line) {\n      return /^\\s*\\*/u.test(line);\n    }\n    /**\n     * Checks if a comment group is in starred-block form.\n     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n     * @returns {boolean} Whether or not the comment group is in starred block form.\n     */\n\n\n    function isStarredBlockComment(_ref) {\n      let [firstComment] = _ref;\n\n      if (firstComment.type !== \"Block\") {\n        return false;\n      }\n\n      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER); // The first and last lines can only contain whitespace.\n\n      return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\\s*$/u : /^\\s*\\*/u).test(line));\n    }\n    /**\n     * Checks if a comment group is in JSDoc form.\n     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n     * @returns {boolean} Whether or not the comment group is in JSDoc form.\n     */\n\n\n    function isJSDocComment(_ref2) {\n      let [firstComment] = _ref2;\n\n      if (firstComment.type !== \"Block\") {\n        return false;\n      }\n\n      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n      return /^\\*\\s*$/u.test(lines[0]) && lines.slice(1, -1).every(line => /^\\s* /u.test(line)) && /^\\s*$/u.test(lines[lines.length - 1]);\n    }\n    /**\n     * Processes a comment group that is currently in separate-line form, calculating the offset for each line.\n     * @param {Token[]} commentGroup A group of comments containing multiple line comments.\n     * @returns {string[]} An array of the processed lines.\n     */\n\n\n    function processSeparateLineComments(commentGroup) {\n      const allLinesHaveLeadingSpace = commentGroup.map(_ref3 => {\n        let {\n          value\n        } = _ref3;\n        return value;\n      }).filter(line => line.trim().length).every(line => line.startsWith(\" \"));\n      return commentGroup.map(_ref4 => {\n        let {\n          value\n        } = _ref4;\n        return allLinesHaveLeadingSpace ? value.replace(/^ /u, \"\") : value;\n      });\n    }\n    /**\n     * Processes a comment group that is currently in starred-block form, calculating the offset for each line.\n     * @param {Token} comment A single block comment token in starred-block form.\n     * @returns {string[]} An array of the processed lines.\n     */\n\n\n    function processStarredBlockComment(comment) {\n      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1)).map(line => line.replace(/^\\s*$/u, \"\"));\n      const allLinesHaveLeadingSpace = lines.map(line => line.replace(/\\s*\\*/u, \"\")).filter(line => line.trim().length).every(line => line.startsWith(\" \"));\n      return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\\s*\\* ?/u : /\\s*\\*/u, \"\"));\n    }\n    /**\n     * Processes a comment group that is currently in bare-block form, calculating the offset for each line.\n     * @param {Token} comment A single block comment token in bare-block form.\n     * @returns {string[]} An array of the processed lines.\n     */\n\n\n    function processBareBlockComment(comment) {\n      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\\s*$/u, \"\"));\n      const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;\n      let offset = \"\";\n      /*\n       * Calculate the offset of the least indented line and use that as the basis for offsetting all the lines.\n       * The first line should not be checked because it is inline with the opening block comment delimiter.\n       */\n\n      for (const [i, line] of lines.entries()) {\n        if (!line.trim().length || i === 0) {\n          continue;\n        }\n\n        const [, lineOffset] = line.match(/^(\\s*\\*?\\s*)/u);\n\n        if (lineOffset.length < leadingWhitespace.length) {\n          const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);\n\n          if (newOffset.length > offset.length) {\n            offset = newOffset;\n          }\n        }\n      }\n\n      return lines.map(line => {\n        const match = line.match(/^(\\s*\\*?\\s*)(.*)/u);\n        const [, lineOffset, lineContents] = match;\n\n        if (lineOffset.length > leadingWhitespace.length) {\n          return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;\n        }\n\n        if (lineOffset.length < leadingWhitespace.length) {\n          return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;\n        }\n\n        return lineContents;\n      });\n    }\n    /**\n     * Gets a list of comment lines in a group, formatting leading whitespace as necessary.\n     * @param {Token[]} commentGroup A group of comments containing either multiple line comments or a single block comment.\n     * @returns {string[]} A list of comment lines.\n     */\n\n\n    function getCommentLines(commentGroup) {\n      const [firstComment] = commentGroup;\n\n      if (firstComment.type === \"Line\") {\n        return processSeparateLineComments(commentGroup);\n      }\n\n      if (isStarredBlockComment(commentGroup)) {\n        return processStarredBlockComment(firstComment);\n      }\n\n      return processBareBlockComment(firstComment);\n    }\n    /**\n     * Gets the initial offset (whitespace) from the beginning of a line to a given comment token.\n     * @param {Token} comment The token to check.\n     * @returns {string} The offset from the beginning of a line to the token.\n     */\n\n\n    function getInitialOffset(comment) {\n      return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);\n    }\n    /**\n     * Converts a comment into starred-block form\n     * @param {Token} firstComment The first comment of the group being converted\n     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n     * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers\n     */\n\n\n    function convertToStarredBlock(firstComment, commentLinesList) {\n      const initialOffset = getInitialOffset(firstComment);\n      return `/*\\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join(\"\\n\")}\\n${initialOffset} */`;\n    }\n    /**\n     * Converts a comment into separate-line form\n     * @param {Token} firstComment The first comment of the group being converted\n     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n     * @returns {string} A representation of the comment value in separate-line form\n     */\n\n\n    function convertToSeparateLines(firstComment, commentLinesList) {\n      return commentLinesList.map(line => `// ${line}`).join(`\\n${getInitialOffset(firstComment)}`);\n    }\n    /**\n     * Converts a comment into bare-block form\n     * @param {Token} firstComment The first comment of the group being converted\n     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n     * @returns {string} A representation of the comment value in bare-block form\n     */\n\n\n    function convertToBlock(firstComment, commentLinesList) {\n      return `/* ${commentLinesList.join(`\\n${getInitialOffset(firstComment)}   `)} */`;\n    }\n    /**\n     * Each method checks a group of comments to see if it's valid according to the given option.\n     * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single\n     * block comment or multiple line comments.\n     * @returns {void}\n     */\n\n\n    const commentGroupCheckers = {\n      \"starred-block\"(commentGroup) {\n        const [firstComment] = commentGroup;\n        const commentLines = getCommentLines(commentGroup);\n\n        if (commentLines.some(value => value.includes(\"*/\"))) {\n          return;\n        }\n\n        if (commentGroup.length > 1) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: commentGroup[commentGroup.length - 1].loc.end\n            },\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];\n              return commentLines.some(value => value.startsWith(\"/\")) ? null : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));\n            }\n\n          });\n        } else {\n          const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n          const expectedLeadingWhitespace = getInitialOffset(firstComment);\n          const expectedLinePrefix = `${expectedLeadingWhitespace} *`;\n\n          if (!/^\\*?\\s*$/u.test(lines[0])) {\n            const start = firstComment.value.startsWith(\"*\") ? firstComment.range[0] + 1 : firstComment.range[0];\n            context.report({\n              loc: {\n                start: firstComment.loc.start,\n                end: {\n                  line: firstComment.loc.start.line,\n                  column: firstComment.loc.start.column + 2\n                }\n              },\n              messageId: \"startNewline\",\n              fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n            });\n          }\n\n          if (!/^\\s*$/u.test(lines[lines.length - 1])) {\n            context.report({\n              loc: {\n                start: {\n                  line: firstComment.loc.end.line,\n                  column: firstComment.loc.end.column - 2\n                },\n                end: firstComment.loc.end\n              },\n              messageId: \"endNewline\",\n              fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\\n${expectedLinePrefix}/`)\n            });\n          }\n\n          for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {\n            const lineText = sourceCode.lines[lineNumber - 1];\n            const errorType = isStarredCommentLine(lineText) ? \"alignment\" : \"missingStar\";\n\n            if (!lineText.startsWith(expectedLinePrefix)) {\n              context.report({\n                loc: {\n                  start: {\n                    line: lineNumber,\n                    column: 0\n                  },\n                  end: {\n                    line: lineNumber,\n                    column: lineText.length\n                  }\n                },\n                messageId: errorType,\n\n                fix(fixer) {\n                  const lineStartIndex = sourceCode.getIndexFromLoc({\n                    line: lineNumber,\n                    column: 0\n                  });\n\n                  if (errorType === \"alignment\") {\n                    const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*\\*)/u) || [];\n                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);\n                  }\n\n                  const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*)/u) || [];\n                  const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                  let offset;\n\n                  for (const [idx, line] of lines.entries()) {\n                    if (!/\\S+/u.test(line)) {\n                      continue;\n                    }\n\n                    const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];\n                    const [, prefix = \"\", initialOffset = \"\"] = lineTextToAlignWith.match(/^(\\s*(?:\\/?\\*)?(\\s*))/u) || [];\n                    offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;\n\n                    if (/^\\s*\\//u.test(lineText) && offset.length === 0) {\n                      offset += \" \";\n                    }\n\n                    break;\n                  }\n\n                  return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);\n                }\n\n              });\n            }\n          }\n        }\n      },\n\n      \"separate-lines\"(commentGroup) {\n        const [firstComment] = commentGroup;\n\n        if (firstComment.type !== \"Block\" || isJSDocComment(commentGroup)) {\n          return;\n        }\n\n        const commentLines = getCommentLines(commentGroup);\n        const tokenAfter = sourceCode.getTokenAfter(firstComment, {\n          includeComments: true\n        });\n\n        if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {\n          return;\n        }\n\n        context.report({\n          loc: {\n            start: firstComment.loc.start,\n            end: {\n              line: firstComment.loc.start.line,\n              column: firstComment.loc.start.column + 2\n            }\n          },\n          messageId: \"expectedLines\",\n\n          fix(fixer) {\n            return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));\n          }\n\n        });\n      },\n\n      \"bare-block\"(commentGroup) {\n        if (isJSDocComment(commentGroup)) {\n          return;\n        }\n\n        const [firstComment] = commentGroup;\n        const commentLines = getCommentLines(commentGroup); // Disallows consecutive line comments in favor of using a block comment.\n\n        if (firstComment.type === \"Line\" && commentLines.length > 1 && !commentLines.some(value => value.includes(\"*/\"))) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: commentGroup[commentGroup.length - 1].loc.end\n            },\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              return fixer.replaceTextRange([firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]], convertToBlock(firstComment, commentLines));\n            }\n\n          });\n        } // Prohibits block comments from having a * at the beginning of each line.\n\n\n        if (isStarredBlockComment(commentGroup)) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: {\n                line: firstComment.loc.start.line,\n                column: firstComment.loc.start.column + 2\n              }\n            },\n            messageId: \"expectedBareBlock\",\n\n            fix(fixer) {\n              return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));\n            }\n\n          });\n        }\n      }\n\n    }; //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      Program() {\n        return sourceCode.getAllComments().filter(comment => comment.type !== \"Shebang\").filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value)).filter(comment => {\n          const tokenBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n          return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n        }).reduce((commentGroups, comment, index, commentList) => {\n          const tokenBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n\n          if (comment.type === \"Line\" && index && commentList[index - 1].type === \"Line\" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {\n            commentGroups[commentGroups.length - 1].push(comment);\n          } else {\n            commentGroups.push([comment]);\n          }\n\n          return commentGroups;\n        }, []).filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line)).forEach(commentGroupCheckers[option]);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","expectedBlock","expectedBareBlock","startNewline","endNewline","missingStar","alignment","expectedLines","create","context","sourceCode","getSourceCode","option","options","isStarredCommentLine","line","test","isStarredBlockComment","firstComment","lines","value","split","LINEBREAK_MATCHER","length","every","i","isJSDocComment","slice","processSeparateLineComments","commentGroup","allLinesHaveLeadingSpace","map","filter","trim","startsWith","replace","processStarredBlockComment","comment","linesArr","processBareBlockComment","leadingWhitespace","text","range","loc","start","column","offset","entries","lineOffset","match","newOffset","lineContents","getCommentLines","getInitialOffset","convertToStarredBlock","commentLinesList","initialOffset","join","convertToSeparateLines","convertToBlock","commentGroupCheckers","commentLines","some","includes","report","end","messageId","fix","fixer","replaceTextRange","expectedLeadingWhitespace","expectedLinePrefix","insertTextAfterRange","lineNumber","lineText","errorType","lineStartIndex","getIndexFromLoc","commentTextPrefix","commentTextStartIndex","idx","lineTextToAlignWith","prefix","tokenAfter","getTokenAfter","includeComments","replaceText","Program","getAllComments","COMMENTS_IGNORE_PATTERN","tokenBefore","getTokenBefore","reduce","commentGroups","index","commentList","push","forEach"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/multiline-comment-style.js"],"sourcesContent":["/**\n * @fileoverview enforce a particular style for multiline comments\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a particular style for multiline comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/multiline-comment-style\"\n        },\n\n        fixable: \"whitespace\",\n        schema: [{ enum: [\"starred-block\", \"separate-lines\", \"bare-block\"] }],\n        messages: {\n            expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n            expectedBareBlock: \"Expected a block comment without padding stars.\",\n            startNewline: \"Expected a linebreak after '/*'.\",\n            endNewline: \"Expected a linebreak before '*/'.\",\n            missingStar: \"Expected a '*' at the start of this line.\",\n            alignment: \"Expected this line to be aligned with the start of the comment.\",\n            expectedLines: \"Expected multiple line comments instead of a block comment.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"starred-block\";\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks if a comment line is starred.\n         * @param {string} line A string representing a comment line.\n         * @returns {boolean} Whether or not the comment line is starred.\n         */\n        function isStarredCommentLine(line) {\n            return /^\\s*\\*/u.test(line);\n        }\n\n        /**\n         * Checks if a comment group is in starred-block form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in starred block form.\n         */\n        function isStarredBlockComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            // The first and last lines can only contain whitespace.\n            return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\\s*$/u : /^\\s*\\*/u).test(line));\n        }\n\n        /**\n         * Checks if a comment group is in JSDoc form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in JSDoc form.\n         */\n        function isJSDocComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            return /^\\*\\s*$/u.test(lines[0]) &&\n                lines.slice(1, -1).every(line => /^\\s* /u.test(line)) &&\n                /^\\s*$/u.test(lines[lines.length - 1]);\n        }\n\n        /**\n         * Processes a comment group that is currently in separate-line form, calculating the offset for each line.\n         * @param {Token[]} commentGroup A group of comments containing multiple line comments.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processSeparateLineComments(commentGroup) {\n            const allLinesHaveLeadingSpace = commentGroup\n                .map(({ value }) => value)\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return commentGroup.map(({ value }) => (allLinesHaveLeadingSpace ? value.replace(/^ /u, \"\") : value));\n        }\n\n        /**\n         * Processes a comment group that is currently in starred-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in starred-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processStarredBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER)\n                .filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1))\n                .map(line => line.replace(/^\\s*$/u, \"\"));\n            const allLinesHaveLeadingSpace = lines\n                .map(line => line.replace(/\\s*\\*/u, \"\"))\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\\s*\\* ?/u : /\\s*\\*/u, \"\"));\n        }\n\n        /**\n         * Processes a comment group that is currently in bare-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in bare-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processBareBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\\s*$/u, \"\"));\n            const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;\n            let offset = \"\";\n\n            /*\n             * Calculate the offset of the least indented line and use that as the basis for offsetting all the lines.\n             * The first line should not be checked because it is inline with the opening block comment delimiter.\n             */\n            for (const [i, line] of lines.entries()) {\n                if (!line.trim().length || i === 0) {\n                    continue;\n                }\n\n                const [, lineOffset] = line.match(/^(\\s*\\*?\\s*)/u);\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);\n\n                    if (newOffset.length > offset.length) {\n                        offset = newOffset;\n                    }\n                }\n            }\n\n            return lines.map(line => {\n                const match = line.match(/^(\\s*\\*?\\s*)(.*)/u);\n                const [, lineOffset, lineContents] = match;\n\n                if (lineOffset.length > leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;\n                }\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;\n                }\n\n                return lineContents;\n            });\n        }\n\n        /**\n         * Gets a list of comment lines in a group, formatting leading whitespace as necessary.\n         * @param {Token[]} commentGroup A group of comments containing either multiple line comments or a single block comment.\n         * @returns {string[]} A list of comment lines.\n         */\n        function getCommentLines(commentGroup) {\n            const [firstComment] = commentGroup;\n\n            if (firstComment.type === \"Line\") {\n                return processSeparateLineComments(commentGroup);\n            }\n\n            if (isStarredBlockComment(commentGroup)) {\n                return processStarredBlockComment(firstComment);\n            }\n\n            return processBareBlockComment(firstComment);\n        }\n\n        /**\n         * Gets the initial offset (whitespace) from the beginning of a line to a given comment token.\n         * @param {Token} comment The token to check.\n         * @returns {string} The offset from the beginning of a line to the token.\n         */\n        function getInitialOffset(comment) {\n            return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);\n        }\n\n        /**\n         * Converts a comment into starred-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers\n         */\n        function convertToStarredBlock(firstComment, commentLinesList) {\n            const initialOffset = getInitialOffset(firstComment);\n\n            return `/*\\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join(\"\\n\")}\\n${initialOffset} */`;\n        }\n\n        /**\n         * Converts a comment into separate-line form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in separate-line form\n         */\n        function convertToSeparateLines(firstComment, commentLinesList) {\n            return commentLinesList.map(line => `// ${line}`).join(`\\n${getInitialOffset(firstComment)}`);\n        }\n\n        /**\n         * Converts a comment into bare-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in bare-block form\n         */\n        function convertToBlock(firstComment, commentLinesList) {\n            return `/* ${commentLinesList.join(`\\n${getInitialOffset(firstComment)}   `)} */`;\n        }\n\n        /**\n         * Each method checks a group of comments to see if it's valid according to the given option.\n         * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single\n         * block comment or multiple line comments.\n         * @returns {void}\n         */\n        const commentGroupCheckers = {\n            \"starred-block\"(commentGroup) {\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                if (commentLines.some(value => value.includes(\"*/\"))) {\n                    return;\n                }\n\n                if (commentGroup.length > 1) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup[commentGroup.length - 1].loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];\n\n                            return commentLines.some(value => value.startsWith(\"/\"))\n                                ? null\n                                : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));\n                        }\n                    });\n                } else {\n                    const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n                    const expectedLeadingWhitespace = getInitialOffset(firstComment);\n                    const expectedLinePrefix = `${expectedLeadingWhitespace} *`;\n\n                    if (!/^\\*?\\s*$/u.test(lines[0])) {\n                        const start = firstComment.value.startsWith(\"*\") ? firstComment.range[0] + 1 : firstComment.range[0];\n\n                        context.report({\n                            loc: {\n                                start: firstComment.loc.start,\n                                end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                            },\n                            messageId: \"startNewline\",\n                            fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n                        });\n                    }\n\n                    if (!/^\\s*$/u.test(lines[lines.length - 1])) {\n                        context.report({\n                            loc: {\n                                start: { line: firstComment.loc.end.line, column: firstComment.loc.end.column - 2 },\n                                end: firstComment.loc.end\n                            },\n                            messageId: \"endNewline\",\n                            fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\\n${expectedLinePrefix}/`)\n                        });\n                    }\n\n                    for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {\n                        const lineText = sourceCode.lines[lineNumber - 1];\n                        const errorType = isStarredCommentLine(lineText)\n                            ? \"alignment\"\n                            : \"missingStar\";\n\n                        if (!lineText.startsWith(expectedLinePrefix)) {\n                            context.report({\n                                loc: {\n                                    start: { line: lineNumber, column: 0 },\n                                    end: { line: lineNumber, column: lineText.length }\n                                },\n                                messageId: errorType,\n                                fix(fixer) {\n                                    const lineStartIndex = sourceCode.getIndexFromLoc({ line: lineNumber, column: 0 });\n\n                                    if (errorType === \"alignment\") {\n                                        const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*\\*)/u) || [];\n                                        const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n\n                                        return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);\n                                    }\n\n                                    const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*)/u) || [];\n                                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                                    let offset;\n\n                                    for (const [idx, line] of lines.entries()) {\n                                        if (!/\\S+/u.test(line)) {\n                                            continue;\n                                        }\n\n                                        const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];\n                                        const [, prefix = \"\", initialOffset = \"\"] = lineTextToAlignWith.match(/^(\\s*(?:\\/?\\*)?(\\s*))/u) || [];\n\n                                        offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;\n\n                                        if (/^\\s*\\//u.test(lineText) && offset.length === 0) {\n                                            offset += \" \";\n                                        }\n                                        break;\n                                    }\n\n                                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);\n                                }\n                            });\n                        }\n                    }\n                }\n            },\n            \"separate-lines\"(commentGroup) {\n                const [firstComment] = commentGroup;\n\n                if (firstComment.type !== \"Block\" || isJSDocComment(commentGroup)) {\n                    return;\n                }\n\n                const commentLines = getCommentLines(commentGroup);\n                const tokenAfter = sourceCode.getTokenAfter(firstComment, { includeComments: true });\n\n                if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {\n                    return;\n                }\n\n                context.report({\n                    loc: {\n                        start: firstComment.loc.start,\n                        end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                    },\n                    messageId: \"expectedLines\",\n                    fix(fixer) {\n                        return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));\n                    }\n                });\n            },\n            \"bare-block\"(commentGroup) {\n                if (isJSDocComment(commentGroup)) {\n                    return;\n                }\n\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                // Disallows consecutive line comments in favor of using a block comment.\n                if (firstComment.type === \"Line\" && commentLines.length > 1 &&\n                    !commentLines.some(value => value.includes(\"*/\"))) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup[commentGroup.length - 1].loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]],\n                                convertToBlock(firstComment, commentLines)\n                            );\n                        }\n                    });\n                }\n\n                // Prohibits block comments from having a * at the beginning of each line.\n                if (isStarredBlockComment(commentGroup)) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                        },\n                        messageId: \"expectedBareBlock\",\n                        fix(fixer) {\n                            return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));\n                        }\n                    });\n                }\n            }\n        };\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                return sourceCode.getAllComments()\n                    .filter(comment => comment.type !== \"Shebang\")\n                    .filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value))\n                    .filter(comment => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n                    })\n                    .reduce((commentGroups, comment, index, commentList) => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        if (\n                            comment.type === \"Line\" &&\n                            index && commentList[index - 1].type === \"Line\" &&\n                            tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 &&\n                            tokenBefore === commentList[index - 1]\n                        ) {\n                            commentGroups[commentGroups.length - 1].push(comment);\n                        } else {\n                            commentGroups.push([comment]);\n                        }\n\n                        return commentGroups;\n                    }, [])\n                    .filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line))\n                    .forEach(commentGroupCheckers[option]);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}