{"ast":null,"code":"/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStringsOrObjects = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        importNames: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjectPatterns = {\n  anyOf: [{\n    type: \"array\",\n    items: {\n      type: \"string\"\n    },\n    uniqueItems: true\n  }, {\n    type: \"array\",\n    items: {\n      type: \"object\",\n      properties: {\n        group: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        }\n      },\n      additionalProperties: false,\n      required: [\"group\"]\n    },\n    uniqueItems: true\n  }]\n};\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified modules when loaded by `import`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n    },\n    messages: {\n      path: \"'{{importSource}}' import is restricted from being used.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n      patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n      everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n      importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects, {\n        type: \"array\",\n        items: [{\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects,\n            patterns: arrayOfStringsOrObjectPatterns\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }]\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n      if (typeof importSource === \"string\") {\n        memo[importSource] = {\n          message: null\n        };\n      } else {\n        memo[importSource.name] = {\n          message: importSource.message,\n          importNames: importSource.importNames\n        };\n      }\n\n      return memo;\n    }, {}); // Handle patterns too, either as strings or groups\n\n    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n    const restrictedPatternGroups = restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\" ? [{\n      matcher: ignore().add(restrictedPatterns)\n    }] : restrictedPatterns.map(_ref => {\n      let {\n        group,\n        message\n      } = _ref;\n      return {\n        matcher: ignore().add(group),\n        customMessage: message\n      };\n    }); // if no imports are restricted we don\"t need to check\n\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n      return {};\n    }\n    /**\n     * Report a restricted path.\n     * @param {string} importSource path of the import\n     * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n     * @param {node} node representing the restricted path reference\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkRestrictedPathAndReport(importSource, importNames, node) {\n      if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n        return;\n      }\n\n      const customMessage = restrictedPathMessages[importSource].message;\n      const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n\n      if (restrictedImportNames) {\n        if (importNames.has(\"*\")) {\n          const specifierData = importNames.get(\"*\")[0];\n          context.report({\n            node,\n            messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n            loc: specifierData.loc,\n            data: {\n              importSource,\n              importNames: restrictedImportNames,\n              customMessage\n            }\n          });\n        }\n\n        restrictedImportNames.forEach(importName => {\n          if (importNames.has(importName)) {\n            const specifiers = importNames.get(importName);\n            specifiers.forEach(specifier => {\n              context.report({\n                node,\n                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                loc: specifier.loc,\n                data: {\n                  importSource,\n                  customMessage,\n                  importName\n                }\n              });\n            });\n          }\n        });\n      } else {\n        context.report({\n          node,\n          messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n          data: {\n            importSource,\n            customMessage\n          }\n        });\n      }\n    }\n    /**\n     * Report a restricted path specifically for patterns.\n     * @param {node} node representing the restricted path reference\n     * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n     * @returns {void}\n     * @private\n     */\n\n\n    function reportPathForPatterns(node, group) {\n      const importSource = node.source.value.trim();\n      context.report({\n        node,\n        messageId: group.customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n        data: {\n          importSource,\n          customMessage: group.customMessage\n        }\n      });\n    }\n    /**\n     * Check if the given importSource is restricted by a pattern.\n     * @param {string} importSource path of the import\n     * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n     * @returns {boolean} whether the variable is a restricted pattern or not\n     * @private\n     */\n\n\n    function isRestrictedPattern(importSource, group) {\n      return group.matcher.ignores(importSource);\n    }\n    /**\n     * Checks a node to see if any problems should be reported.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkNode(node) {\n      const importSource = node.source.value.trim();\n      const importNames = new Map();\n\n      if (node.type === \"ExportAllDeclaration\") {\n        const starToken = sourceCode.getFirstToken(node, 1);\n        importNames.set(\"*\", [{\n          loc: starToken.loc\n        }]);\n      } else if (node.specifiers) {\n        for (const specifier of node.specifiers) {\n          let name;\n          const specifierData = {\n            loc: specifier.loc\n          };\n\n          if (specifier.type === \"ImportDefaultSpecifier\") {\n            name = \"default\";\n          } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n            name = \"*\";\n          } else if (specifier.imported) {\n            name = specifier.imported.name;\n          } else if (specifier.local) {\n            name = specifier.local.name;\n          }\n\n          if (name) {\n            if (importNames.has(name)) {\n              importNames.get(name).push(specifierData);\n            } else {\n              importNames.set(name, [specifierData]);\n            }\n          }\n        }\n      }\n\n      checkRestrictedPathAndReport(importSource, importNames, node);\n      restrictedPatternGroups.forEach(group => {\n        if (isRestrictedPattern(importSource, group)) {\n          reportPathForPatterns(node, group);\n        }\n      });\n    }\n\n    return {\n      ImportDeclaration: checkNode,\n\n      ExportNamedDeclaration(node) {\n        if (node.source) {\n          checkNode(node);\n        }\n      },\n\n      ExportAllDeclaration: checkNode\n    };\n  }\n\n};","map":{"version":3,"names":["ignore","require","arrayOfStringsOrObjects","type","items","anyOf","properties","name","message","minLength","importNames","additionalProperties","required","uniqueItems","arrayOfStringsOrObjectPatterns","group","minItems","module","exports","meta","docs","description","category","recommended","url","messages","path","pathWithCustomMessage","patterns","patternWithCustomMessage","everything","everythingWithCustomMessage","importName","importNameWithCustomMessage","schema","paths","additionalItems","create","context","sourceCode","getSourceCode","options","Array","isArray","isPathAndPatternsObject","Object","prototype","hasOwnProperty","call","restrictedPaths","restrictedPathMessages","reduce","memo","importSource","restrictedPatterns","restrictedPatternGroups","length","matcher","add","map","customMessage","keys","checkRestrictedPathAndReport","node","restrictedImportNames","has","specifierData","get","report","messageId","loc","data","forEach","specifiers","specifier","reportPathForPatterns","source","value","trim","isRestrictedPattern","ignores","checkNode","Map","starToken","getFirstToken","set","imported","local","push","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-restricted-imports.js"],"sourcesContent":["/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjectPatterns = {\n    anyOf: [\n        {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        {\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    group: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    }\n                },\n                additionalProperties: false,\n                required: [\"group\"]\n            },\n            uniqueItems: true\n        }\n    ]\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified modules when loaded by `import`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n        },\n\n        messages: {\n            path: \"'{{importSource}}' import is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n\n            patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n\n            everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n\n            importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStringsOrObjectPatterns\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n            if (typeof importSource === \"string\") {\n                memo[importSource] = { message: null };\n            } else {\n                memo[importSource.name] = {\n                    message: importSource.message,\n                    importNames: importSource.importNames\n                };\n            }\n            return memo;\n        }, {});\n\n        // Handle patterns too, either as strings or groups\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n        const restrictedPatternGroups = restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\"\n            ? [{ matcher: ignore().add(restrictedPatterns) }]\n            : restrictedPatterns.map(({ group, message }) => ({ matcher: ignore().add(group), customMessage: message }));\n\n        // if no imports are restricted we don\"t need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n            return {};\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {string} importSource path of the import\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function checkRestrictedPathAndReport(importSource, importNames, node) {\n            if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n                return;\n            }\n\n            const customMessage = restrictedPathMessages[importSource].message;\n            const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n\n            if (restrictedImportNames) {\n                if (importNames.has(\"*\")) {\n                    const specifierData = importNames.get(\"*\")[0];\n\n                    context.report({\n                        node,\n                        messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n                        loc: specifierData.loc,\n                        data: {\n                            importSource,\n                            importNames: restrictedImportNames,\n                            customMessage\n                        }\n                    });\n                }\n\n                restrictedImportNames.forEach(importName => {\n                    if (importNames.has(importName)) {\n                        const specifiers = importNames.get(importName);\n\n                        specifiers.forEach(specifier => {\n                            context.report({\n                                node,\n                                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                                loc: specifier.loc,\n                                data: {\n                                    importSource,\n                                    customMessage,\n                                    importName\n                                }\n                            });\n                        });\n                    }\n                });\n            } else {\n                context.report({\n                    node,\n                    messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n                    data: {\n                        importSource,\n                        customMessage\n                    }\n                });\n            }\n        }\n\n        /**\n         * Report a restricted path specifically for patterns.\n         * @param {node} node representing the restricted path reference\n         * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n         * @returns {void}\n         * @private\n         */\n        function reportPathForPatterns(node, group) {\n            const importSource = node.source.value.trim();\n\n            context.report({\n                node,\n                messageId: group.customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n                data: {\n                    importSource,\n                    customMessage: group.customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given importSource is restricted by a pattern.\n         * @param {string} importSource path of the import\n         * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n         * @returns {boolean} whether the variable is a restricted pattern or not\n         * @private\n         */\n        function isRestrictedPattern(importSource, group) {\n            return group.matcher.ignores(importSource);\n        }\n\n        /**\n         * Checks a node to see if any problems should be reported.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkNode(node) {\n            const importSource = node.source.value.trim();\n            const importNames = new Map();\n\n            if (node.type === \"ExportAllDeclaration\") {\n                const starToken = sourceCode.getFirstToken(node, 1);\n\n                importNames.set(\"*\", [{ loc: starToken.loc }]);\n            } else if (node.specifiers) {\n                for (const specifier of node.specifiers) {\n                    let name;\n                    const specifierData = { loc: specifier.loc };\n\n                    if (specifier.type === \"ImportDefaultSpecifier\") {\n                        name = \"default\";\n                    } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                        name = \"*\";\n                    } else if (specifier.imported) {\n                        name = specifier.imported.name;\n                    } else if (specifier.local) {\n                        name = specifier.local.name;\n                    }\n\n                    if (name) {\n                        if (importNames.has(name)) {\n                            importNames.get(name).push(specifierData);\n                        } else {\n                            importNames.set(name, [specifierData]);\n                        }\n                    }\n                }\n            }\n\n            checkRestrictedPathAndReport(importSource, importNames, node);\n            restrictedPatternGroups.forEach(group => {\n                if (isRestrictedPattern(importSource, group)) {\n                    reportPathForPatterns(node, group);\n                }\n            });\n        }\n\n        return {\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration(node) {\n                if (node.source) {\n                    checkNode(node);\n                }\n            },\n            ExportAllDeclaration: checkNode\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}