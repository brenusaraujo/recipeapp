{"ast":null,"code":"/**\n * @fileoverview This rule should require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before or after unary operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-unary-ops\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        words: {\n          type: \"boolean\",\n          default: true\n        },\n        nonwords: {\n          type: \"boolean\",\n          default: false\n        },\n        overrides: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n      unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n      unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n      wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n      operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n      beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      words: true,\n      nonwords: false\n    };\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n     * @param {ASTnode} node AST node\n     * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n     */\n\n    function isFirstBangInBangBangExpression(node) {\n      return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" && node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n    }\n    /**\n     * Checks if an override exists for a given operator.\n     * @param {string} operator Operator\n     * @returns {boolean} Whether or not an override has been provided for the operator\n     */\n\n\n    function overrideExistsForOperator(operator) {\n      return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n    }\n    /**\n     * Gets the value that the override was set to for this operator\n     * @param {string} operator Operator\n     * @returns {boolean} Whether or not an override enforces a space with this operator\n     */\n\n\n    function overrideEnforcesSpaces(operator) {\n      return options.overrides[operator];\n    }\n    /**\n     * Verify Unary Word Operator has spaces after the word operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken first token from the AST node\n     * @param {Object} secondToken second token from the AST node\n     * @param {string} word The word to be used for reporting\n     * @returns {void}\n     */\n\n\n    function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n      if (secondToken.range[0] === firstToken.range[1]) {\n        context.report({\n          node,\n          messageId: \"wordOperator\",\n          data: {\n            word\n          },\n\n          fix(fixer) {\n            return fixer.insertTextAfter(firstToken, \" \");\n          }\n\n        });\n      }\n    }\n    /**\n     * Verify Unary Word Operator doesn't have spaces after the word operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken first token from the AST node\n     * @param {Object} secondToken second token from the AST node\n     * @param {string} word The word to be used for reporting\n     * @returns {void}\n     */\n\n\n    function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n      if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfterWord\",\n            data: {\n              word\n            },\n\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n    /**\n     * Check Unary Word Operators for spaces after the word operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken first token from the AST node\n     * @param {Object} secondToken second token from the AST node\n     * @param {string} word The word to be used for reporting\n     * @returns {void}\n     */\n\n\n    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n      if (overrideExistsForOperator(word)) {\n        if (overrideEnforcesSpaces(word)) {\n          verifyWordHasSpaces(node, firstToken, secondToken, word);\n        } else {\n          verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n        }\n      } else if (options.words) {\n        verifyWordHasSpaces(node, firstToken, secondToken, word);\n      } else {\n        verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n      }\n    }\n    /**\n     * Verifies YieldExpressions satisfy spacing requirements\n     * @param {ASTnode} node AST node\n     * @returns {void}\n     */\n\n\n    function checkForSpacesAfterYield(node) {\n      const tokens = sourceCode.getFirstTokens(node, 3),\n            word = \"yield\";\n\n      if (!node.argument || node.delegate) {\n        return;\n      }\n\n      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n    }\n    /**\n     * Verifies AwaitExpressions satisfy spacing requirements\n     * @param {ASTNode} node AwaitExpression AST node\n     * @returns {void}\n     */\n\n\n    function checkForSpacesAfterAwait(node) {\n      const tokens = sourceCode.getFirstTokens(node, 3);\n      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n    }\n    /**\n     * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken First token in the expression\n     * @param {Object} secondToken Second token in the expression\n     * @returns {void}\n     */\n\n\n    function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (isFirstBangInBangBangExpression(node)) {\n          return;\n        }\n\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"operator\",\n            data: {\n              operator: firstToken.value\n            },\n\n            fix(fixer) {\n              return fixer.insertTextAfter(firstToken, \" \");\n            }\n\n          });\n        }\n      } else {\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"beforeUnaryExpressions\",\n            data: {\n              token: secondToken.value\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(secondToken, \" \");\n            }\n\n          });\n        }\n      }\n    }\n    /**\n     * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken First token in the expression\n     * @param {Object} secondToken Second token in the expression\n     * @returns {void}\n     */\n\n\n    function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfter\",\n            data: {\n              operator: firstToken.value\n            },\n\n            fix(fixer) {\n              if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n              }\n\n              return null;\n            }\n\n          });\n        }\n      } else {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedBefore\",\n            data: {\n              operator: secondToken.value\n            },\n\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n    /**\n     * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n     * @param {ASTnode} node AST node\n     * @returns {void}\n     */\n\n\n    function checkForSpaces(node) {\n      const tokens = node.type === \"UpdateExpression\" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);\n      const firstToken = tokens[0];\n      const secondToken = tokens[1];\n\n      if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n        checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n        return;\n      }\n\n      const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n      if (overrideExistsForOperator(operator)) {\n        if (overrideEnforcesSpaces(operator)) {\n          verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n        } else {\n          verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n        }\n      } else if (options.nonwords) {\n        verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n      } else {\n        verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      UnaryExpression: checkForSpaces,\n      UpdateExpression: checkForSpaces,\n      NewExpression: checkForSpaces,\n      YieldExpression: checkForSpacesAfterYield,\n      AwaitExpression: checkForSpacesAfterAwait\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","words","default","nonwords","overrides","additionalProperties","messages","unexpectedBefore","unexpectedAfter","unexpectedAfterWord","wordOperator","operator","beforeUnaryExpressions","create","context","options","sourceCode","getSourceCode","isFirstBangInBangBangExpression","node","argument","overrideExistsForOperator","Object","prototype","hasOwnProperty","call","overrideEnforcesSpaces","verifyWordHasSpaces","firstToken","secondToken","word","range","report","messageId","data","fix","fixer","insertTextAfter","verifyWordDoesntHaveSpaces","canTokensBeAdjacent","removeRange","checkUnaryWordOperatorForSpaces","checkForSpacesAfterYield","tokens","getFirstTokens","delegate","checkForSpacesAfterAwait","verifyNonWordsHaveSpaces","prefix","value","token","insertTextBefore","verifyNonWordsDontHaveSpaces","checkForSpaces","getLastTokens","UnaryExpression","UpdateExpression","NewExpression","YieldExpression","AwaitExpression"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/space-unary-ops.js"],"sourcesContent":["/**\n * @fileoverview This rule should require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before or after unary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-unary-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    words: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    nonwords: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n            unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n            unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n            wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n            operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n            beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || { words: true, nonwords: false };\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n         * @param {ASTnode} node AST node\n         * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n         */\n        function isFirstBangInBangBangExpression(node) {\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n        }\n\n        /**\n         * Checks if an override exists for a given operator.\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override has been provided for the operator\n         */\n        function overrideExistsForOperator(operator) {\n            return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n        }\n\n        /**\n         * Gets the value that the override was set to for this operator\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override enforces a space with this operator\n         */\n        function overrideEnforcesSpaces(operator) {\n            return options.overrides[operator];\n        }\n\n        /**\n         * Verify Unary Word Operator has spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node,\n                    messageId: \"wordOperator\",\n                    data: {\n                        word\n                    },\n                    fix(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Verify Unary Word Operator doesn't have spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfterWord\",\n                        data: {\n                            word\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check Unary Word Operators for spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n            if (overrideExistsForOperator(word)) {\n                if (overrideEnforcesSpaces(word)) {\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\n                } else {\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n                }\n            } else if (options.words) {\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\n            } else {\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n            }\n        }\n\n        /**\n         * Verifies YieldExpressions satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterYield(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument || node.delegate) {\n                return;\n            }\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n        }\n\n        /**\n         * Verifies AwaitExpressions satisfy spacing requirements\n         * @param {ASTNode} node AwaitExpression AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterAwait(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3);\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"operator\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"beforeUnaryExpressions\",\n                        data: {\n                            token: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfter\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedBefore\",\n                        data: {\n                            operator: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpaces(node) {\n            const tokens = node.type === \"UpdateExpression\" && !node.prefix\n                ? sourceCode.getLastTokens(node, 2)\n                : sourceCode.getFirstTokens(node, 2);\n            const firstToken = tokens[0];\n            const secondToken = tokens[1];\n\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n                return;\n            }\n\n            const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n            if (overrideExistsForOperator(operator)) {\n                if (overrideEnforcesSpaces(operator)) {\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n                } else {\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n                }\n            } else if (options.nonwords) {\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n            } else {\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression: checkForSpaces,\n            UpdateExpression: checkForSpaces,\n            NewExpression: checkForSpaces,\n            YieldExpression: checkForSpacesAfterYield,\n            AwaitExpression: checkForSpacesAfterAwait\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}