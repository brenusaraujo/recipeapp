{"ast":null,"code":"/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst keywords = require(\"./utils/keywords\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require quotes around object literal property names\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/quote-props\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            keywords: {\n              type: \"boolean\"\n            },\n            unnecessary: {\n              type: \"boolean\"\n            },\n            numbers: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      requireQuotesDueToReservedWord: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n      inconsistentlyQuotedProperty: \"Inconsistently quoted property '{{key}}' found.\",\n      unnecessarilyQuotedProperty: \"Unnecessarily quoted property '{{property}}' found.\",\n      unquotedReservedProperty: \"Unquoted reserved word '{{property}}' used as key.\",\n      unquotedNumericProperty: \"Unquoted number literal '{{property}}' used as key.\",\n      unquotedPropertyFound: \"Unquoted property '{{property}}' found.\",\n      redundantQuoting: \"Properties shouldn't be quoted as all quotes are redundant.\"\n    }\n  },\n\n  create(context) {\n    const MODE = context.options[0],\n          KEYWORDS = context.options[1] && context.options[1].keywords,\n          CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n          NUMBERS = context.options[1] && context.options[1].numbers,\n          sourceCode = context.getSourceCode();\n    /**\n     * Checks whether a certain string constitutes an ES3 token\n     * @param   {string} tokenStr The string to be checked.\n     * @returns {boolean} `true` if it is an ES3 token.\n     */\n\n    function isKeyword(tokenStr) {\n      return keywords.indexOf(tokenStr) >= 0;\n    }\n    /**\n     * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n     * @param   {string} rawKey The raw key value from the source\n     * @param   {espreeTokens} tokens The espree-tokenized node key\n     * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n     * @returns {boolean} Whether or not a key has redundant quotes.\n     * @private\n     */\n\n\n    function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n      return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 || tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);\n    }\n    /**\n     * Returns a string representation of a property node with quotes removed\n     * @param {ASTNode} key Key AST Node, which may or may not be quoted\n     * @returns {string} A replacement string for this property\n     */\n\n\n    function getUnquotedKey(key) {\n      return key.type === \"Identifier\" ? key.name : key.value;\n    }\n    /**\n     * Returns a string representation of a property node with quotes added\n     * @param {ASTNode} key Key AST Node, which may or may not be quoted\n     * @returns {string} A replacement string for this property\n     */\n\n\n    function getQuotedKey(key) {\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        // If the key is already a string literal, don't replace the quotes with double quotes.\n        return sourceCode.getText(key);\n      } // Otherwise, the key is either an identifier or a number literal.\n\n\n      return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n    }\n    /**\n     * Ensures that a property's key is quoted only when necessary\n     * @param   {ASTNode} node Property AST node\n     * @returns {void}\n     */\n\n\n    function checkUnnecessaryQuotes(node) {\n      const key = node.key;\n\n      if (node.method || node.computed || node.shorthand) {\n        return;\n      }\n\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        let tokens;\n\n        try {\n          tokens = espree.tokenize(key.value);\n        } catch {\n          return;\n        }\n\n        if (tokens.length !== 1) {\n          return;\n        }\n\n        const isKeywordToken = isKeyword(tokens[0].value);\n\n        if (isKeywordToken && KEYWORDS) {\n          return;\n        }\n\n        if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n          context.report({\n            node,\n            messageId: \"unnecessarilyQuotedProperty\",\n            data: {\n              property: key.value\n            },\n            fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n          });\n        }\n      } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n        context.report({\n          node,\n          messageId: \"unquotedReservedProperty\",\n          data: {\n            property: key.name\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      } else if (NUMBERS && key.type === \"Literal\" && astUtils.isNumericLiteral(key)) {\n        context.report({\n          node,\n          messageId: \"unquotedNumericProperty\",\n          data: {\n            property: key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n    /**\n     * Ensures that a property's key is quoted\n     * @param   {ASTNode} node Property AST node\n     * @returns {void}\n     */\n\n\n    function checkOmittedQuotes(node) {\n      const key = node.key;\n\n      if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n        context.report({\n          node,\n          messageId: \"unquotedPropertyFound\",\n          data: {\n            property: key.name || key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n    /**\n     * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n     * @param   {ASTNode} node Property AST node\n     * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n     * @returns {void}\n     */\n\n\n    function checkConsistency(node, checkQuotesRedundancy) {\n      const quotedProps = [],\n            unquotedProps = [];\n      let keywordKeyName = null,\n          necessaryQuotes = false;\n      node.properties.forEach(property => {\n        const key = property.key;\n\n        if (!key || property.method || property.computed || property.shorthand) {\n          return;\n        }\n\n        if (key.type === \"Literal\" && typeof key.value === \"string\") {\n          quotedProps.push(property);\n\n          if (checkQuotesRedundancy) {\n            let tokens;\n\n            try {\n              tokens = espree.tokenize(key.value);\n            } catch {\n              necessaryQuotes = true;\n              return;\n            }\n\n            necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n          }\n        } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n          unquotedProps.push(property);\n          necessaryQuotes = true;\n          keywordKeyName = key.name;\n        } else {\n          unquotedProps.push(property);\n        }\n      });\n\n      if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n        quotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"redundantQuoting\",\n            fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n          });\n        });\n      } else if (unquotedProps.length && keywordKeyName) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"requireQuotesDueToReservedWord\",\n            data: {\n              property: keywordKeyName\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      } else if (quotedProps.length && unquotedProps.length) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"inconsistentlyQuotedProperty\",\n            data: {\n              key: property.key.name || property.key.value\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      }\n    }\n\n    return {\n      Property(node) {\n        if (MODE === \"always\" || !MODE) {\n          checkOmittedQuotes(node);\n        }\n\n        if (MODE === \"as-needed\") {\n          checkUnnecessaryQuotes(node);\n        }\n      },\n\n      ObjectExpression(node) {\n        if (MODE === \"consistent\") {\n          checkConsistency(node, false);\n        }\n\n        if (MODE === \"consistent-as-needed\") {\n          checkConsistency(node, true);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["espree","require","astUtils","keywords","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","minItems","maxItems","properties","unnecessary","numbers","additionalProperties","fixable","messages","requireQuotesDueToReservedWord","inconsistentlyQuotedProperty","unnecessarilyQuotedProperty","unquotedReservedProperty","unquotedNumericProperty","unquotedPropertyFound","redundantQuoting","create","context","MODE","options","KEYWORDS","CHECK_UNNECESSARY","NUMBERS","sourceCode","getSourceCode","isKeyword","tokenStr","indexOf","areQuotesRedundant","rawKey","tokens","skipNumberLiterals","length","start","end","String","value","getUnquotedKey","key","name","getQuotedKey","getText","checkUnnecessaryQuotes","node","method","computed","shorthand","tokenize","isKeywordToken","report","messageId","data","property","fix","fixer","replaceText","isNumericLiteral","checkOmittedQuotes","checkConsistency","checkQuotesRedundancy","quotedProps","unquotedProps","keywordKeyName","necessaryQuotes","forEach","push","Property","ObjectExpression"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/quote-props.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\");\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require quotes around object literal property names\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/quote-props\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                keywords: {\n                                    type: \"boolean\"\n                                },\n                                unnecessary: {\n                                    type: \"boolean\"\n                                },\n                                numbers: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n        messages: {\n            requireQuotesDueToReservedWord: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n            inconsistentlyQuotedProperty: \"Inconsistently quoted property '{{key}}' found.\",\n            unnecessarilyQuotedProperty: \"Unnecessarily quoted property '{{property}}' found.\",\n            unquotedReservedProperty: \"Unquoted reserved word '{{property}}' used as key.\",\n            unquotedNumericProperty: \"Unquoted number literal '{{property}}' used as key.\",\n            unquotedPropertyFound: \"Unquoted property '{{property}}' found.\",\n            redundantQuoting: \"Properties shouldn't be quoted as all quotes are redundant.\"\n        }\n    },\n\n    create(context) {\n\n        const MODE = context.options[0],\n            KEYWORDS = context.options[1] && context.options[1].keywords,\n            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n            NUMBERS = context.options[1] && context.options[1].numbers,\n\n            sourceCode = context.getSourceCode();\n\n\n        /**\n         * Checks whether a certain string constitutes an ES3 token\n         * @param   {string} tokenStr The string to be checked.\n         * @returns {boolean} `true` if it is an ES3 token.\n         */\n        function isKeyword(tokenStr) {\n            return keywords.indexOf(tokenStr) >= 0;\n        }\n\n        /**\n         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n         * @param   {string} rawKey The raw key value from the source\n         * @param   {espreeTokens} tokens The espree-tokenized node key\n         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n         * @returns {boolean} Whether or not a key has redundant quotes.\n         * @private\n         */\n        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&\n                ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 ||\n                (tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes removed\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getUnquotedKey(key) {\n            return key.type === \"Identifier\" ? key.name : key.value;\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes added\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getQuotedKey(key) {\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                // If the key is already a string literal, don't replace the quotes with double quotes.\n                return sourceCode.getText(key);\n            }\n\n            // Otherwise, the key is either an identifier or a number literal.\n            return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n        }\n\n        /**\n         * Ensures that a property's key is quoted only when necessary\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkUnnecessaryQuotes(node) {\n            const key = node.key;\n\n            if (node.method || node.computed || node.shorthand) {\n                return;\n            }\n\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n                let tokens;\n\n                try {\n                    tokens = espree.tokenize(key.value);\n                } catch {\n                    return;\n                }\n\n                if (tokens.length !== 1) {\n                    return;\n                }\n\n                const isKeywordToken = isKeyword(tokens[0].value);\n\n                if (isKeywordToken && KEYWORDS) {\n                    return;\n                }\n\n                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessarilyQuotedProperty\",\n                        data: { property: key.value },\n                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n                    });\n                }\n            } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n                context.report({\n                    node,\n                    messageId: \"unquotedReservedProperty\",\n                    data: { property: key.name },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            } else if (NUMBERS && key.type === \"Literal\" && astUtils.isNumericLiteral(key)) {\n                context.report({\n                    node,\n                    messageId: \"unquotedNumericProperty\",\n                    data: { property: key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that a property's key is quoted\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkOmittedQuotes(node) {\n            const key = node.key;\n\n            if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n                context.report({\n                    node,\n                    messageId: \"unquotedPropertyFound\",\n                    data: { property: key.name || key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n         * @returns {void}\n         */\n        function checkConsistency(node, checkQuotesRedundancy) {\n            const quotedProps = [],\n                unquotedProps = [];\n            let keywordKeyName = null,\n                necessaryQuotes = false;\n\n            node.properties.forEach(property => {\n                const key = property.key;\n\n                if (!key || property.method || property.computed || property.shorthand) {\n                    return;\n                }\n\n                if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                    quotedProps.push(property);\n\n                    if (checkQuotesRedundancy) {\n                        let tokens;\n\n                        try {\n                            tokens = espree.tokenize(key.value);\n                        } catch {\n                            necessaryQuotes = true;\n                            return;\n                        }\n\n                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n                    }\n                } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n                    unquotedProps.push(property);\n                    necessaryQuotes = true;\n                    keywordKeyName = key.name;\n                } else {\n                    unquotedProps.push(property);\n                }\n            });\n\n            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n                quotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        messageId: \"redundantQuoting\",\n                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n                    });\n                });\n            } else if (unquotedProps.length && keywordKeyName) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        messageId: \"requireQuotesDueToReservedWord\",\n                        data: { property: keywordKeyName },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            } else if (quotedProps.length && unquotedProps.length) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        messageId: \"inconsistentlyQuotedProperty\",\n                        data: { key: property.key.name || property.key.value },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            }\n        }\n\n        return {\n            Property(node) {\n                if (MODE === \"always\" || !MODE) {\n                    checkOmittedQuotes(node);\n                }\n                if (MODE === \"as-needed\") {\n                    checkUnnecessaryQuotes(node);\n                }\n            },\n            ObjectExpression(node) {\n                if (MODE === \"consistent\") {\n                    checkConsistency(node, false);\n                }\n                if (MODE === \"consistent-as-needed\") {\n                    checkConsistency(node, true);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}