{"ast":null,"code":"/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks after each array element\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-element-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        basicConfig: {\n          oneOf: [{\n            enum: [\"always\", \"never\", \"consistent\"]\n          }, {\n            type: \"object\",\n            properties: {\n              multiline: {\n                type: \"boolean\"\n              },\n              minItems: {\n                type: [\"integer\", \"null\"],\n                minimum: 0\n              }\n            },\n            additionalProperties: false\n          }]\n        }\n      },\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/basicConfig\"\n        }, {\n          type: \"object\",\n          properties: {\n            ArrayExpression: {\n              $ref: \"#/definitions/basicConfig\"\n            },\n            ArrayPattern: {\n              $ref: \"#/definitions/basicConfig\"\n            }\n          },\n          additionalProperties: false,\n          minProperties: 1\n        }]\n      }]\n    },\n    messages: {\n      unexpectedLineBreak: \"There should be no linebreak here.\",\n      missingLineBreak: \"There should be a linebreak after this element.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} providedOption An option value to parse.\n     * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n     */\n\n    function normalizeOptionValue(providedOption) {\n      let consistent = false;\n      let multiline = false;\n      let minItems;\n      const option = providedOption || \"always\";\n\n      if (!option || option === \"always\" || option.minItems === 0) {\n        minItems = 0;\n      } else if (option === \"never\") {\n        minItems = Number.POSITIVE_INFINITY;\n      } else if (option === \"consistent\") {\n        consistent = true;\n        minItems = Number.POSITIVE_INFINITY;\n      } else {\n        multiline = Boolean(option.multiline);\n        minItems = option.minItems || Number.POSITIVE_INFINITY;\n      }\n\n      return {\n        consistent,\n        multiline,\n        minItems\n      };\n    }\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} options An option value to parse.\n     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n     */\n\n\n    function normalizeOptions(options) {\n      if (options && (options.ArrayExpression || options.ArrayPattern)) {\n        let expressionOptions, patternOptions;\n\n        if (options.ArrayExpression) {\n          expressionOptions = normalizeOptionValue(options.ArrayExpression);\n        }\n\n        if (options.ArrayPattern) {\n          patternOptions = normalizeOptionValue(options.ArrayPattern);\n        }\n\n        return {\n          ArrayExpression: expressionOptions,\n          ArrayPattern: patternOptions\n        };\n      }\n\n      const value = normalizeOptionValue(options);\n      return {\n        ArrayExpression: value,\n        ArrayPattern: value\n      };\n    }\n    /**\n     * Reports that there shouldn't be a line break after the first token\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportNoLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"unexpectedLineBreak\",\n\n        fix(fixer) {\n          if (astUtils.isCommentToken(tokenBefore)) {\n            return null;\n          }\n\n          if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n            return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n          }\n          /*\n           * This will check if the comma is on the same line as the next element\n           * Following array:\n           * [\n           *     1\n           *     , 2\n           *     , 3\n           * ]\n           *\n           * will be fixed to:\n           * [\n           *     1, 2, 3\n           * ]\n           */\n\n\n          const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(twoTokensBefore)) {\n            return null;\n          }\n\n          return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n        }\n\n      });\n    }\n    /**\n     * Reports that there should be a line break after the first token\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportRequiredLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"missingLineBreak\",\n\n        fix(fixer) {\n          return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n        }\n\n      });\n    }\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\n     * @returns {void}\n     */\n\n\n    function check(node) {\n      const elements = node.elements;\n      const normalizedOptions = normalizeOptions(context.options[0]);\n      const options = normalizedOptions[node.type];\n\n      if (!options) {\n        return;\n      }\n\n      let elementBreak = false;\n      /*\n       * MULTILINE: true\n       * loop through every element and check\n       * if at least one element has linebreaks inside\n       * this ensures that following is not valid (due to elements are on the same line):\n       *\n       * [\n       *      1,\n       *      2,\n       *      3\n       * ]\n       */\n\n      if (options.multiline) {\n        elementBreak = elements.filter(element => element !== null).some(element => element.loc.start.line !== element.loc.end.line);\n      }\n\n      const linebreaksCount = node.elements.map((element, i) => {\n        const previousElement = elements[i - 1];\n\n        if (i === 0 || element === null || previousElement === null) {\n          return false;\n        }\n\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n        return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n      }).filter(isBreak => isBreak === true).length;\n      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;\n      elements.forEach((element, i) => {\n        const previousElement = elements[i - 1];\n\n        if (i === 0 || element === null || previousElement === null) {\n          return;\n        }\n\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n        if (needsLinebreaks) {\n          if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportRequiredLineBreak(firstTokenOfCurrentElement);\n          }\n        } else {\n          if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportNoLineBreak(firstTokenOfCurrentElement);\n          }\n        }\n      });\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      ArrayPattern: check,\n      ArrayExpression: check\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","definitions","basicConfig","oneOf","enum","properties","multiline","minItems","minimum","additionalProperties","items","$ref","ArrayExpression","ArrayPattern","minProperties","messages","unexpectedLineBreak","missingLineBreak","create","context","sourceCode","getSourceCode","normalizeOptionValue","providedOption","consistent","option","Number","POSITIVE_INFINITY","Boolean","normalizeOptions","options","expressionOptions","patternOptions","value","reportNoLineBreak","token","tokenBefore","getTokenBefore","includeComments","report","loc","start","end","messageId","fix","fixer","isCommentToken","isTokenOnSameLine","replaceTextRange","range","twoTokensBefore","reportRequiredLineBreak","check","node","elements","normalizedOptions","elementBreak","filter","element","some","line","linebreaksCount","map","i","previousElement","commaToken","getFirstTokenBetween","isCommaToken","lastTokenOfPreviousElement","firstTokenOfCurrentElement","getTokenAfter","isBreak","length","needsLinebreaks","forEach"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/array-element-newline.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce line breaks after each array element\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-element-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                basicConfig: {\n                    oneOf: [\n                        {\n                            enum: [\"always\", \"never\", \"consistent\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                multiline: {\n                                    type: \"boolean\"\n                                },\n                                minItems: {\n                                    type: [\"integer\", \"null\"],\n                                    minimum: 0\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            },\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/basicConfig\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ArrayExpression: {\n                                    $ref: \"#/definitions/basicConfig\"\n                                },\n                                ArrayPattern: {\n                                    $ref: \"#/definitions/basicConfig\"\n                                }\n                            },\n                            additionalProperties: false,\n                            minProperties: 1\n                        }\n                    ]\n                }\n            ]\n        },\n\n        messages: {\n            unexpectedLineBreak: \"There should be no linebreak here.\",\n            missingLineBreak: \"There should be a linebreak after this element.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} providedOption An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(providedOption) {\n            let consistent = false;\n            let multiline = false;\n            let minItems;\n\n            const option = providedOption || \"always\";\n\n            if (!option || option === \"always\" || option.minItems === 0) {\n                minItems = 0;\n            } else if (option === \"never\") {\n                minItems = Number.POSITIVE_INFINITY;\n            } else if (option === \"consistent\") {\n                consistent = true;\n                minItems = Number.POSITIVE_INFINITY;\n            } else {\n                multiline = Boolean(option.multiline);\n                minItems = option.minItems || Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            if (options && (options.ArrayExpression || options.ArrayPattern)) {\n                let expressionOptions, patternOptions;\n\n                if (options.ArrayExpression) {\n                    expressionOptions = normalizeOptionValue(options.ArrayExpression);\n                }\n\n                if (options.ArrayPattern) {\n                    patternOptions = normalizeOptionValue(options.ArrayPattern);\n                }\n\n                return { ArrayExpression: expressionOptions, ArrayPattern: patternOptions };\n            }\n\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"unexpectedLineBreak\",\n                fix(fixer) {\n                    if (astUtils.isCommentToken(tokenBefore)) {\n                        return null;\n                    }\n\n                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n                    }\n\n                    /*\n                     * This will check if the comma is on the same line as the next element\n                     * Following array:\n                     * [\n                     *     1\n                     *     , 2\n                     *     , 3\n                     * ]\n                     *\n                     * will be fixed to:\n                     * [\n                     *     1, 2, 3\n                     * ]\n                     */\n                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });\n\n                    if (astUtils.isCommentToken(twoTokensBefore)) {\n                        return null;\n                    }\n\n                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"missingLineBreak\",\n                fix(fixer) {\n                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n\n            if (!options) {\n                return;\n            }\n\n            let elementBreak = false;\n\n            /*\n             * MULTILINE: true\n             * loop through every element and check\n             * if at least one element has linebreaks inside\n             * this ensures that following is not valid (due to elements are on the same line):\n             *\n             * [\n             *      1,\n             *      2,\n             *      3\n             * ]\n             */\n            if (options.multiline) {\n                elementBreak = elements\n                    .filter(element => element !== null)\n                    .some(element => element.loc.start.line !== element.loc.end.line);\n            }\n\n            const linebreaksCount = node.elements.map((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return false;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n            }).filter(isBreak => isBreak === true).length;\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elementBreak\n                ) ||\n                (\n                    options.consistent &&\n                    linebreaksCount > 0 &&\n                    linebreaksCount < node.elements.length\n                )\n            );\n\n            elements.forEach((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                if (needsLinebreaks) {\n                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportRequiredLineBreak(firstTokenOfCurrentElement);\n                    }\n                } else {\n                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportNoLineBreak(firstTokenOfCurrentElement);\n                    }\n                }\n            });\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}