{"ast":null,"code":"/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent naming when capturing the current execution context\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/consistent-this\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        minLength: 1\n      },\n      uniqueItems: true\n    },\n    messages: {\n      aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n      unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n    }\n  },\n\n  create(context) {\n    let aliases = [];\n\n    if (context.options.length === 0) {\n      aliases.push(\"that\");\n    } else {\n      aliases = context.options;\n    }\n    /**\n     * Reports that a variable declarator or assignment expression is assigning\n     * a non-'this' value to the specified alias.\n     * @param {ASTNode} node The assigning node.\n     * @param {string}  name the name of the alias that was incorrectly used.\n     * @returns {void}\n     */\n\n\n    function reportBadAssignment(node, name) {\n      context.report({\n        node,\n        messageId: \"aliasNotAssignedToThis\",\n        data: {\n          name\n        }\n      });\n    }\n    /**\n     * Checks that an assignment to an identifier only assigns 'this' to the\n     * appropriate alias, and the alias is only assigned to 'this'.\n     * @param {ASTNode} node The assigning node.\n     * @param {Identifier} name The name of the variable assigned to.\n     * @param {Expression} value The value of the assignment.\n     * @returns {void}\n     */\n\n\n    function checkAssignment(node, name, value) {\n      const isThis = value.type === \"ThisExpression\";\n\n      if (aliases.indexOf(name) !== -1) {\n        if (!isThis || node.operator && node.operator !== \"=\") {\n          reportBadAssignment(node, name);\n        }\n      } else if (isThis) {\n        context.report({\n          node,\n          messageId: \"unexpectedAlias\",\n          data: {\n            name\n          }\n        });\n      }\n    }\n    /**\n     * Ensures that a variable declaration of the alias in a program or function\n     * is assigned to the correct value.\n     * @param {string} alias alias the check the assignment of.\n     * @param {Object} scope scope of the current code we are checking.\n     * @private\n     * @returns {void}\n     */\n\n\n    function checkWasAssigned(alias, scope) {\n      const variable = scope.set.get(alias);\n\n      if (!variable) {\n        return;\n      }\n\n      if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" && def.node.init !== null)) {\n        return;\n      }\n      /*\n       * The alias has been declared and not assigned: check it was\n       * assigned later in the same scope.\n       */\n\n\n      if (!variable.references.some(reference => {\n        const write = reference.writeExpr;\n        return reference.from === scope && write && write.type === \"ThisExpression\" && write.parent.operator === \"=\";\n      })) {\n        variable.defs.map(def => def.node).forEach(node => {\n          reportBadAssignment(node, alias);\n        });\n      }\n    }\n    /**\n     * Check each alias to ensure that is was assigned to the correct value.\n     * @returns {void}\n     */\n\n\n    function ensureWasAssigned() {\n      const scope = context.getScope();\n      aliases.forEach(alias => {\n        checkWasAssigned(alias, scope);\n      });\n    }\n\n    return {\n      \"Program:exit\": ensureWasAssigned,\n      \"FunctionExpression:exit\": ensureWasAssigned,\n      \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n      VariableDeclarator(node) {\n        const id = node.id;\n        const isDestructuring = id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n        if (node.init !== null && !isDestructuring) {\n          checkAssignment(node, id.name, node.init);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (node.left.type === \"Identifier\") {\n          checkAssignment(node, node.left.name, node.right);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","items","minLength","uniqueItems","messages","aliasNotAssignedToThis","unexpectedAlias","create","context","aliases","options","length","push","reportBadAssignment","node","name","report","messageId","data","checkAssignment","value","isThis","indexOf","operator","checkWasAssigned","alias","scope","variable","set","get","defs","some","def","init","references","reference","write","writeExpr","from","parent","map","forEach","ensureWasAssigned","getScope","VariableDeclarator","id","isDestructuring","AssignmentExpression","left","right"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/consistent-this.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent naming when capturing the current execution context\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/consistent-this\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                minLength: 1\n            },\n            uniqueItems: true\n        },\n\n        messages: {\n            aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n            unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n        }\n    },\n\n    create(context) {\n        let aliases = [];\n\n        if (context.options.length === 0) {\n            aliases.push(\"that\");\n        } else {\n            aliases = context.options;\n        }\n\n        /**\n         * Reports that a variable declarator or assignment expression is assigning\n         * a non-'this' value to the specified alias.\n         * @param {ASTNode} node The assigning node.\n         * @param {string}  name the name of the alias that was incorrectly used.\n         * @returns {void}\n         */\n        function reportBadAssignment(node, name) {\n            context.report({ node, messageId: \"aliasNotAssignedToThis\", data: { name } });\n        }\n\n        /**\n         * Checks that an assignment to an identifier only assigns 'this' to the\n         * appropriate alias, and the alias is only assigned to 'this'.\n         * @param {ASTNode} node The assigning node.\n         * @param {Identifier} name The name of the variable assigned to.\n         * @param {Expression} value The value of the assignment.\n         * @returns {void}\n         */\n        function checkAssignment(node, name, value) {\n            const isThis = value.type === \"ThisExpression\";\n\n            if (aliases.indexOf(name) !== -1) {\n                if (!isThis || node.operator && node.operator !== \"=\") {\n                    reportBadAssignment(node, name);\n                }\n            } else if (isThis) {\n                context.report({ node, messageId: \"unexpectedAlias\", data: { name } });\n            }\n        }\n\n        /**\n         * Ensures that a variable declaration of the alias in a program or function\n         * is assigned to the correct value.\n         * @param {string} alias alias the check the assignment of.\n         * @param {Object} scope scope of the current code we are checking.\n         * @private\n         * @returns {void}\n         */\n        function checkWasAssigned(alias, scope) {\n            const variable = scope.set.get(alias);\n\n            if (!variable) {\n                return;\n            }\n\n            if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" &&\n                def.node.init !== null)) {\n                return;\n            }\n\n            /*\n             * The alias has been declared and not assigned: check it was\n             * assigned later in the same scope.\n             */\n            if (!variable.references.some(reference => {\n                const write = reference.writeExpr;\n\n                return (\n                    reference.from === scope &&\n                    write && write.type === \"ThisExpression\" &&\n                    write.parent.operator === \"=\"\n                );\n            })) {\n                variable.defs.map(def => def.node).forEach(node => {\n                    reportBadAssignment(node, alias);\n                });\n            }\n        }\n\n        /**\n         * Check each alias to ensure that is was assigned to the correct value.\n         * @returns {void}\n         */\n        function ensureWasAssigned() {\n            const scope = context.getScope();\n\n            aliases.forEach(alias => {\n                checkWasAssigned(alias, scope);\n            });\n        }\n\n        return {\n            \"Program:exit\": ensureWasAssigned,\n            \"FunctionExpression:exit\": ensureWasAssigned,\n            \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n            VariableDeclarator(node) {\n                const id = node.id;\n                const isDestructuring =\n                    id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n                if (node.init !== null && !isDestructuring) {\n                    checkAssignment(node, id.name, node.init);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (node.left.type === \"Identifier\") {\n                    checkAssignment(node, node.left.name, node.right);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}