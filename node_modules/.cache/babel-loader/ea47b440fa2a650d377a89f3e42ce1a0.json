{"ast":null,"code":"/**\n * @fileoverview Main API Class\n * @author Kai Cataldo\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nconst {\n  CLIEngine,\n  getCLIEngineInternalSlots\n} = require(\"../cli-engine/cli-engine\");\n\nconst BuiltinRules = require(\"../rules\");\n\nconst {\n  Legacy: {\n    ConfigOps: {\n      getRuleSeverity\n    }\n  }\n} = require(\"@eslint/eslintrc\");\n\nconst {\n  version\n} = require(\"../../package.json\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../cli-engine/cli-engine\").LintReport} CLIEngineLintReport */\n\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/** @typedef {import(\"./load-formatter\").Formatter} Formatter */\n\n/**\n * The options with which to configure the ESLint instance.\n * @typedef {Object} ESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {string[]} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\n * @property {string} [overrideConfigFile] The configuration file to use.\n * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.\n * @property {\"error\" | \"warn\" | \"off\"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc.* files.\n */\n\n/**\n * A rules metadata object.\n * @typedef {Object} RulesMeta\n * @property {string} id The plugin ID.\n * @property {Object} definition The plugin definition.\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string} [source] The source code of the file that was linted.\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\n */\n\n/**\n * Private members for the `ESLint` instance.\n * @typedef {Object} ESLintPrivateMembers\n * @property {CLIEngine} cliEngine The wrapped CLIEngine instance.\n * @property {ESLintOptions} options The options used to instantiate the ESLint instance.\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst writeFile = promisify(fs.writeFile);\n/**\n * The map with which to store private class members.\n * @type {WeakMap<ESLint, ESLintPrivateMembers>}\n */\n\nconst privateMembersMap = new WeakMap();\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is a non-empty string.\n */\n\nfunction isNonEmptyString(x) {\n  return typeof x === \"string\" && x.trim() !== \"\";\n}\n/**\n * Check if a given value is an array of non-empty stringss or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of non-empty stringss.\n */\n\n\nfunction isArrayOfNonEmptyString(x) {\n  return Array.isArray(x) && x.every(isNonEmptyString);\n}\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is valid fix type.\n */\n\n\nfunction isFixType(x) {\n  return x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of fix types.\n */\n\n\nfunction isFixTypeArray(x) {\n  return Array.isArray(x) && x.every(isFixType);\n}\n/**\n * The error for invalid options.\n */\n\n\nclass ESLintInvalidOptionsError extends Error {\n  constructor(messages) {\n    super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n    this.code = \"ESLINT_INVALID_OPTIONS\";\n    Error.captureStackTrace(this, ESLintInvalidOptionsError);\n  }\n\n}\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {ESLintOptions} options The options to process.\n * @returns {ESLintOptions} The normalized options.\n */\n\n\nfunction processOptions(_ref) {\n  let {\n    allowInlineConfig = true,\n    // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n    baseConfig = null,\n    cache = false,\n    cacheLocation = \".eslintcache\",\n    cacheStrategy = \"metadata\",\n    cwd = process.cwd(),\n    errorOnUnmatchedPattern = true,\n    extensions = null,\n    // ← should be null by default because if it's an array then it suppresses RFC20 feature.\n    fix = false,\n    fixTypes = null,\n    // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n    globInputPaths = true,\n    ignore = true,\n    ignorePath = null,\n    // ← should be null by default because if it's a string then it may throw ENOENT.\n    overrideConfig = null,\n    overrideConfigFile = null,\n    plugins = {},\n    reportUnusedDisableDirectives = null,\n    // ← should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.\n    resolvePluginsRelativeTo = null,\n    // ← should be null by default because if it's a string then it suppresses RFC47 feature.\n    rulePaths = [],\n    useEslintrc = true,\n    ...unknownOptions\n  } = _ref;\n  const errors = [];\n  const unknownOptionKeys = Object.keys(unknownOptions);\n\n  if (unknownOptionKeys.length >= 1) {\n    errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n\n    if (unknownOptionKeys.includes(\"cacheFile\")) {\n      errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"configFile\")) {\n      errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"envs\")) {\n      errors.push(\"'envs' has been removed. Please use the 'overrideConfig.env' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"globals\")) {\n      errors.push(\"'globals' has been removed. Please use the 'overrideConfig.globals' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"ignorePattern\")) {\n      errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"parser\")) {\n      errors.push(\"'parser' has been removed. Please use the 'overrideConfig.parser' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"parserOptions\")) {\n      errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.parserOptions' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"rules\")) {\n      errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n    }\n  }\n\n  if (typeof allowInlineConfig !== \"boolean\") {\n    errors.push(\"'allowInlineConfig' must be a boolean.\");\n  }\n\n  if (typeof baseConfig !== \"object\") {\n    errors.push(\"'baseConfig' must be an object or null.\");\n  }\n\n  if (typeof cache !== \"boolean\") {\n    errors.push(\"'cache' must be a boolean.\");\n  }\n\n  if (!isNonEmptyString(cacheLocation)) {\n    errors.push(\"'cacheLocation' must be a non-empty string.\");\n  }\n\n  if (cacheStrategy !== \"metadata\" && cacheStrategy !== \"content\") {\n    errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n  }\n\n  if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n    errors.push(\"'cwd' must be an absolute path.\");\n  }\n\n  if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n    errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n  }\n\n  if (!isArrayOfNonEmptyString(extensions) && extensions !== null) {\n    errors.push(\"'extensions' must be an array of non-empty strings or null.\");\n  }\n\n  if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n    errors.push(\"'fix' must be a boolean or a function.\");\n  }\n\n  if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n    errors.push(\"'fixTypes' must be an array of any of \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n  }\n\n  if (typeof globInputPaths !== \"boolean\") {\n    errors.push(\"'globInputPaths' must be a boolean.\");\n  }\n\n  if (typeof ignore !== \"boolean\") {\n    errors.push(\"'ignore' must be a boolean.\");\n  }\n\n  if (!isNonEmptyString(ignorePath) && ignorePath !== null) {\n    errors.push(\"'ignorePath' must be a non-empty string or null.\");\n  }\n\n  if (typeof overrideConfig !== \"object\") {\n    errors.push(\"'overrideConfig' must be an object or null.\");\n  }\n\n  if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null) {\n    errors.push(\"'overrideConfigFile' must be a non-empty string or null.\");\n  }\n\n  if (typeof plugins !== \"object\") {\n    errors.push(\"'plugins' must be an object or null.\");\n  } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n    errors.push(\"'plugins' must not include an empty string.\");\n  }\n\n  if (Array.isArray(plugins)) {\n    errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n  }\n\n  if (reportUnusedDisableDirectives !== \"error\" && reportUnusedDisableDirectives !== \"warn\" && reportUnusedDisableDirectives !== \"off\" && reportUnusedDisableDirectives !== null) {\n    errors.push(\"'reportUnusedDisableDirectives' must be any of \\\"error\\\", \\\"warn\\\", \\\"off\\\", and null.\");\n  }\n\n  if (!isNonEmptyString(resolvePluginsRelativeTo) && resolvePluginsRelativeTo !== null) {\n    errors.push(\"'resolvePluginsRelativeTo' must be a non-empty string or null.\");\n  }\n\n  if (!isArrayOfNonEmptyString(rulePaths)) {\n    errors.push(\"'rulePaths' must be an array of non-empty strings.\");\n  }\n\n  if (typeof useEslintrc !== \"boolean\") {\n    errors.push(\"'useEslintrc' must be a boolean.\");\n  }\n\n  if (errors.length > 0) {\n    throw new ESLintInvalidOptionsError(errors);\n  }\n\n  return {\n    allowInlineConfig,\n    baseConfig,\n    cache,\n    cacheLocation,\n    cacheStrategy,\n    configFile: overrideConfigFile,\n    cwd,\n    errorOnUnmatchedPattern,\n    extensions,\n    fix,\n    fixTypes,\n    globInputPaths,\n    ignore,\n    ignorePath,\n    reportUnusedDisableDirectives,\n    resolvePluginsRelativeTo,\n    rulePaths,\n    useEslintrc\n  };\n}\n/**\n * Check if a value has one or more properties and that value is not undefined.\n * @param {any} obj The value to check.\n * @returns {boolean} `true` if `obj` has one or more properties that that value is not undefined.\n */\n\n\nfunction hasDefinedProperty(obj) {\n  if (typeof obj === \"object\" && obj !== null) {\n    for (const key in obj) {\n      if (typeof obj[key] !== \"undefined\") {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\n\n\nfunction createRulesMeta(rules) {\n  return Array.from(rules).reduce((retVal, _ref2) => {\n    let [id, rule] = _ref2;\n    retVal[id] = rule.meta;\n    return retVal;\n  }, {});\n}\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\n\n\nconst usedDeprecatedRulesCache = new WeakMap();\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\n\nfunction getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {\n  const {\n    configArrayFactory,\n    options: {\n      cwd\n    }\n  } = getCLIEngineInternalSlots(cliEngine);\n  const filePath = path.isAbsolute(maybeFilePath) ? maybeFilePath : path.join(cwd, \"__placeholder__.js\");\n  const configArray = configArrayFactory.getConfigArrayForFile(filePath);\n  const config = configArray.extractConfig(filePath); // Most files use the same config, so cache it.\n\n  if (!usedDeprecatedRulesCache.has(config)) {\n    const pluginRules = configArray.pluginRules;\n    const retv = [];\n\n    for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n      if (getRuleSeverity(ruleConf) === 0) {\n        continue;\n      }\n\n      const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);\n      const meta = rule && rule.meta;\n\n      if (meta && meta.deprecated) {\n        retv.push({\n          ruleId,\n          replacedBy: meta.replacedBy || []\n        });\n      }\n    }\n\n    usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n  }\n\n  return usedDeprecatedRulesCache.get(config);\n}\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\n\n\nfunction processCLIEngineLintReport(cliEngine, _ref3) {\n  let {\n    results\n  } = _ref3;\n  const descriptor = {\n    configurable: true,\n    enumerable: true,\n\n    get() {\n      return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);\n    }\n\n  };\n\n  for (const result of results) {\n    Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n  }\n\n  return results;\n}\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\n\n\nfunction compareResultsByFilePath(a, b) {\n  if (a.filePath < b.filePath) {\n    return -1;\n  }\n\n  if (a.filePath > b.filePath) {\n    return 1;\n  }\n\n  return 0;\n}\n\nclass ESLint {\n  /**\n   * Creates a new instance of the main ESLint API.\n   * @param {ESLintOptions} options The options for this instance.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const processedOptions = processOptions(options);\n    const cliEngine = new CLIEngine(processedOptions);\n    const {\n      additionalPluginPool,\n      configArrayFactory,\n      lastConfigArrays\n    } = getCLIEngineInternalSlots(cliEngine);\n    let updated = false;\n    /*\n     * Address `plugins` to add plugin implementations.\n     * Operate the `additionalPluginPool` internal slot directly to avoid\n     * using `addPlugin(id, plugin)` method that resets cache everytime.\n     */\n\n    if (options.plugins) {\n      for (const [id, plugin] of Object.entries(options.plugins)) {\n        additionalPluginPool.set(id, plugin);\n        updated = true;\n      }\n    }\n    /*\n     * Address `overrideConfig` to set override config.\n     * Operate the `configArrayFactory` internal slot directly because this\n     * functionality doesn't exist as the public API of CLIEngine.\n     */\n\n\n    if (hasDefinedProperty(options.overrideConfig)) {\n      configArrayFactory.setOverrideConfig(options.overrideConfig);\n      updated = true;\n    } // Update caches.\n\n\n    if (updated) {\n      configArrayFactory.clearCache();\n      lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();\n    } // Initialize private properties.\n\n\n    privateMembersMap.set(this, {\n      cliEngine,\n      options: processedOptions\n    });\n  }\n  /**\n   * The version text.\n   * @type {string}\n   */\n\n\n  static get version() {\n    return version;\n  }\n  /**\n   * Outputs fixes from the given results to files.\n   * @param {LintResult[]} results The lint results.\n   * @returns {Promise<void>} Returns a promise that is used to track side effects.\n   */\n\n\n  static async outputFixes(results) {\n    if (!Array.isArray(results)) {\n      throw new Error(\"'results' must be an array\");\n    }\n\n    await Promise.all(results.filter(result => {\n      if (typeof result !== \"object\" || result === null) {\n        throw new Error(\"'results' must include only objects\");\n      }\n\n      return typeof result.output === \"string\" && path.isAbsolute(result.filePath);\n    }).map(r => writeFile(r.filePath, r.output)));\n  }\n  /**\n   * Returns results that only contains errors.\n   * @param {LintResult[]} results The results to filter.\n   * @returns {LintResult[]} The filtered results.\n   */\n\n\n  static getErrorResults(results) {\n    return CLIEngine.getErrorResults(results);\n  }\n  /**\n   * Returns meta objects for each rule represented in the lint results.\n   * @param {LintResult[]} results The results to fetch rules meta for.\n   * @returns {Object} A mapping of ruleIds to rule meta objects.\n   */\n\n\n  getRulesMetaForResults(results) {\n    const resultRuleIds = new Set(); // first gather all ruleIds from all results\n\n    for (const result of results) {\n      for (const {\n        ruleId\n      } of result.messages) {\n        resultRuleIds.add(ruleId);\n      }\n    } // create a map of all rules in the results\n\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    const rules = cliEngine.getRules();\n    const resultRules = new Map();\n\n    for (const [ruleId, rule] of rules) {\n      if (resultRuleIds.has(ruleId)) {\n        resultRules.set(ruleId, rule);\n      }\n    }\n\n    return createRulesMeta(resultRules);\n  }\n  /**\n   * Executes the current configuration on an array of file and directory names.\n   * @param {string[]} patterns An array of file and directory names.\n   * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n   */\n\n\n  async lintFiles(patterns) {\n    if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n      throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n    }\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return processCLIEngineLintReport(cliEngine, cliEngine.executeOnFiles(patterns));\n  }\n  /**\n   * Executes the current configuration on text.\n   * @param {string} code A string of JavaScript code to lint.\n   * @param {Object} [options] The options.\n   * @param {string} [options.filePath] The path to the file of the source code.\n   * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n   * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n   */\n\n\n  async lintText(code) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof code !== \"string\") {\n      throw new Error(\"'code' must be a string\");\n    }\n\n    if (typeof options !== \"object\") {\n      throw new Error(\"'options' must be an object, null, or undefined\");\n    }\n\n    const {\n      filePath,\n      warnIgnored = false,\n      ...unknownOptions\n    } = options || {};\n    const unknownOptionKeys = Object.keys(unknownOptions);\n\n    if (unknownOptionKeys.length > 0) {\n      throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n    }\n\n    if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n      throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n    }\n\n    if (typeof warnIgnored !== \"boolean\") {\n      throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n    }\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return processCLIEngineLintReport(cliEngine, cliEngine.executeOnText(code, filePath, warnIgnored));\n  }\n  /**\n   * Returns the formatter representing the given formatter name.\n   * @param {string} [name] The name of the formatter to load.\n   * The following values are allowed:\n   * - `undefined` ... Load `stylish` builtin formatter.\n   * - A builtin formatter name ... Load the builtin formatter.\n   * - A thirdparty formatter name:\n   *   - `foo` → `eslint-formatter-foo`\n   *   - `@foo` → `@foo/eslint-formatter`\n   *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n   * - A file path ... Load the file.\n   * @returns {Promise<Formatter>} A promise resolving to the formatter object.\n   * This promise will be rejected if the given formatter was not found or not\n   * a function.\n   */\n\n\n  async loadFormatter() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"stylish\";\n\n    if (typeof name !== \"string\") {\n      throw new Error(\"'name' must be a string\");\n    }\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    const formatter = cliEngine.getFormatter(name);\n\n    if (typeof formatter !== \"function\") {\n      throw new Error(`Formatter must be a function, but got a ${typeof formatter}.`);\n    }\n\n    return {\n      /**\n       * The main formatter method.\n       * @param {LintResults[]} results The lint results to format.\n       * @returns {string} The formatted lint results.\n       */\n      format(results) {\n        let rulesMeta = null;\n        results.sort(compareResultsByFilePath);\n        return formatter(results, {\n          get rulesMeta() {\n            if (!rulesMeta) {\n              rulesMeta = createRulesMeta(cliEngine.getRules());\n            }\n\n            return rulesMeta;\n          }\n\n        });\n      }\n\n    };\n  }\n  /**\n   * Returns a configuration object for the given file based on the CLI options.\n   * This is the same logic used by the ESLint CLI executable to determine\n   * configuration for each file it processes.\n   * @param {string} filePath The path of the file to retrieve a config object for.\n   * @returns {Promise<ConfigData>} A configuration object for the file.\n   */\n\n\n  async calculateConfigForFile(filePath) {\n    if (!isNonEmptyString(filePath)) {\n      throw new Error(\"'filePath' must be a non-empty string\");\n    }\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return cliEngine.getConfigForFile(filePath);\n  }\n  /**\n   * Checks if a given path is ignored by ESLint.\n   * @param {string} filePath The path of the file to check.\n   * @returns {Promise<boolean>} Whether or not the given path is ignored.\n   */\n\n\n  async isPathIgnored(filePath) {\n    if (!isNonEmptyString(filePath)) {\n      throw new Error(\"'filePath' must be a non-empty string\");\n    }\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return cliEngine.isPathIgnored(filePath);\n  }\n\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  ESLint,\n\n  /**\n   * Get the private class members of a given ESLint instance for tests.\n   * @param {ESLint} instance The ESLint instance to get.\n   * @returns {ESLintPrivateMembers} The instance's private class members.\n   */\n  getESLintPrivateMembers(instance) {\n    return privateMembersMap.get(instance);\n  }\n\n};","map":{"version":3,"names":["path","require","fs","promisify","CLIEngine","getCLIEngineInternalSlots","BuiltinRules","Legacy","ConfigOps","getRuleSeverity","version","writeFile","privateMembersMap","WeakMap","isNonEmptyString","x","trim","isArrayOfNonEmptyString","Array","isArray","every","isFixType","isFixTypeArray","ESLintInvalidOptionsError","Error","constructor","messages","join","code","captureStackTrace","processOptions","allowInlineConfig","baseConfig","cache","cacheLocation","cacheStrategy","cwd","process","errorOnUnmatchedPattern","extensions","fix","fixTypes","globInputPaths","ignore","ignorePath","overrideConfig","overrideConfigFile","plugins","reportUnusedDisableDirectives","resolvePluginsRelativeTo","rulePaths","useEslintrc","unknownOptions","errors","unknownOptionKeys","Object","keys","length","push","includes","isAbsolute","configFile","hasDefinedProperty","obj","key","createRulesMeta","rules","from","reduce","retVal","id","rule","meta","usedDeprecatedRulesCache","getOrFindUsedDeprecatedRules","cliEngine","maybeFilePath","configArrayFactory","options","filePath","configArray","getConfigArrayForFile","config","extractConfig","has","pluginRules","retv","ruleId","ruleConf","entries","get","deprecated","replacedBy","set","freeze","processCLIEngineLintReport","results","descriptor","configurable","enumerable","result","defineProperty","compareResultsByFilePath","a","b","ESLint","processedOptions","additionalPluginPool","lastConfigArrays","updated","plugin","setOverrideConfig","clearCache","outputFixes","Promise","all","filter","output","map","r","getErrorResults","getRulesMetaForResults","resultRuleIds","Set","add","getRules","resultRules","Map","lintFiles","patterns","executeOnFiles","lintText","warnIgnored","executeOnText","loadFormatter","name","formatter","getFormatter","format","rulesMeta","sort","calculateConfigForFile","getConfigForFile","isPathIgnored","module","exports","getESLintPrivateMembers","instance"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/eslint/eslint.js"],"sourcesContent":["/**\n * @fileoverview Main API Class\n * @author Kai Cataldo\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst { promisify } = require(\"util\");\nconst { CLIEngine, getCLIEngineInternalSlots } = require(\"../cli-engine/cli-engine\");\nconst BuiltinRules = require(\"../rules\");\nconst {\n    Legacy: {\n        ConfigOps: {\n            getRuleSeverity\n        }\n    }\n} = require(\"@eslint/eslintrc\");\nconst { version } = require(\"../../package.json\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../cli-engine/cli-engine\").LintReport} CLIEngineLintReport */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {import(\"./load-formatter\").Formatter} Formatter */\n\n/**\n * The options with which to configure the ESLint instance.\n * @typedef {Object} ESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {string[]} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\n * @property {string} [overrideConfigFile] The configuration file to use.\n * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.\n * @property {\"error\" | \"warn\" | \"off\"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc.* files.\n */\n\n/**\n * A rules metadata object.\n * @typedef {Object} RulesMeta\n * @property {string} id The plugin ID.\n * @property {Object} definition The plugin definition.\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string} [source] The source code of the file that was linted.\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\n */\n\n/**\n * Private members for the `ESLint` instance.\n * @typedef {Object} ESLintPrivateMembers\n * @property {CLIEngine} cliEngine The wrapped CLIEngine instance.\n * @property {ESLintOptions} options The options used to instantiate the ESLint instance.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst writeFile = promisify(fs.writeFile);\n\n/**\n * The map with which to store private class members.\n * @type {WeakMap<ESLint, ESLintPrivateMembers>}\n */\nconst privateMembersMap = new WeakMap();\n\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is a non-empty string.\n */\nfunction isNonEmptyString(x) {\n    return typeof x === \"string\" && x.trim() !== \"\";\n}\n\n/**\n * Check if a given value is an array of non-empty stringss or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of non-empty stringss.\n */\nfunction isArrayOfNonEmptyString(x) {\n    return Array.isArray(x) && x.every(isNonEmptyString);\n}\n\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is valid fix type.\n */\nfunction isFixType(x) {\n    return x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of fix types.\n */\nfunction isFixTypeArray(x) {\n    return Array.isArray(x) && x.every(isFixType);\n}\n\n/**\n * The error for invalid options.\n */\nclass ESLintInvalidOptionsError extends Error {\n    constructor(messages) {\n        super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n        this.code = \"ESLINT_INVALID_OPTIONS\";\n        Error.captureStackTrace(this, ESLintInvalidOptionsError);\n    }\n}\n\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {ESLintOptions} options The options to process.\n * @returns {ESLintOptions} The normalized options.\n */\nfunction processOptions({\n    allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n    baseConfig = null,\n    cache = false,\n    cacheLocation = \".eslintcache\",\n    cacheStrategy = \"metadata\",\n    cwd = process.cwd(),\n    errorOnUnmatchedPattern = true,\n    extensions = null, // ← should be null by default because if it's an array then it suppresses RFC20 feature.\n    fix = false,\n    fixTypes = null, // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n    globInputPaths = true,\n    ignore = true,\n    ignorePath = null, // ← should be null by default because if it's a string then it may throw ENOENT.\n    overrideConfig = null,\n    overrideConfigFile = null,\n    plugins = {},\n    reportUnusedDisableDirectives = null, // ← should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.\n    resolvePluginsRelativeTo = null, // ← should be null by default because if it's a string then it suppresses RFC47 feature.\n    rulePaths = [],\n    useEslintrc = true,\n    ...unknownOptions\n}) {\n    const errors = [];\n    const unknownOptionKeys = Object.keys(unknownOptions);\n\n    if (unknownOptionKeys.length >= 1) {\n        errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n        if (unknownOptionKeys.includes(\"cacheFile\")) {\n            errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"configFile\")) {\n            errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"envs\")) {\n            errors.push(\"'envs' has been removed. Please use the 'overrideConfig.env' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"globals\")) {\n            errors.push(\"'globals' has been removed. Please use the 'overrideConfig.globals' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"ignorePattern\")) {\n            errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parser\")) {\n            errors.push(\"'parser' has been removed. Please use the 'overrideConfig.parser' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parserOptions\")) {\n            errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.parserOptions' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"rules\")) {\n            errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n        }\n    }\n    if (typeof allowInlineConfig !== \"boolean\") {\n        errors.push(\"'allowInlineConfig' must be a boolean.\");\n    }\n    if (typeof baseConfig !== \"object\") {\n        errors.push(\"'baseConfig' must be an object or null.\");\n    }\n    if (typeof cache !== \"boolean\") {\n        errors.push(\"'cache' must be a boolean.\");\n    }\n    if (!isNonEmptyString(cacheLocation)) {\n        errors.push(\"'cacheLocation' must be a non-empty string.\");\n    }\n    if (\n        cacheStrategy !== \"metadata\" &&\n        cacheStrategy !== \"content\"\n    ) {\n        errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n    }\n    if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n        errors.push(\"'cwd' must be an absolute path.\");\n    }\n    if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n        errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n    }\n    if (!isArrayOfNonEmptyString(extensions) && extensions !== null) {\n        errors.push(\"'extensions' must be an array of non-empty strings or null.\");\n    }\n    if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n        errors.push(\"'fix' must be a boolean or a function.\");\n    }\n    if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n        errors.push(\"'fixTypes' must be an array of any of \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n    }\n    if (typeof globInputPaths !== \"boolean\") {\n        errors.push(\"'globInputPaths' must be a boolean.\");\n    }\n    if (typeof ignore !== \"boolean\") {\n        errors.push(\"'ignore' must be a boolean.\");\n    }\n    if (!isNonEmptyString(ignorePath) && ignorePath !== null) {\n        errors.push(\"'ignorePath' must be a non-empty string or null.\");\n    }\n    if (typeof overrideConfig !== \"object\") {\n        errors.push(\"'overrideConfig' must be an object or null.\");\n    }\n    if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null) {\n        errors.push(\"'overrideConfigFile' must be a non-empty string or null.\");\n    }\n    if (typeof plugins !== \"object\") {\n        errors.push(\"'plugins' must be an object or null.\");\n    } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n        errors.push(\"'plugins' must not include an empty string.\");\n    }\n    if (Array.isArray(plugins)) {\n        errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n    }\n    if (\n        reportUnusedDisableDirectives !== \"error\" &&\n        reportUnusedDisableDirectives !== \"warn\" &&\n        reportUnusedDisableDirectives !== \"off\" &&\n        reportUnusedDisableDirectives !== null\n    ) {\n        errors.push(\"'reportUnusedDisableDirectives' must be any of \\\"error\\\", \\\"warn\\\", \\\"off\\\", and null.\");\n    }\n    if (\n        !isNonEmptyString(resolvePluginsRelativeTo) &&\n        resolvePluginsRelativeTo !== null\n    ) {\n        errors.push(\"'resolvePluginsRelativeTo' must be a non-empty string or null.\");\n    }\n    if (!isArrayOfNonEmptyString(rulePaths)) {\n        errors.push(\"'rulePaths' must be an array of non-empty strings.\");\n    }\n    if (typeof useEslintrc !== \"boolean\") {\n        errors.push(\"'useEslintrc' must be a boolean.\");\n    }\n\n    if (errors.length > 0) {\n        throw new ESLintInvalidOptionsError(errors);\n    }\n\n    return {\n        allowInlineConfig,\n        baseConfig,\n        cache,\n        cacheLocation,\n        cacheStrategy,\n        configFile: overrideConfigFile,\n        cwd,\n        errorOnUnmatchedPattern,\n        extensions,\n        fix,\n        fixTypes,\n        globInputPaths,\n        ignore,\n        ignorePath,\n        reportUnusedDisableDirectives,\n        resolvePluginsRelativeTo,\n        rulePaths,\n        useEslintrc\n    };\n}\n\n/**\n * Check if a value has one or more properties and that value is not undefined.\n * @param {any} obj The value to check.\n * @returns {boolean} `true` if `obj` has one or more properties that that value is not undefined.\n */\nfunction hasDefinedProperty(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        for (const key in obj) {\n            if (typeof obj[key] !== \"undefined\") {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\nfunction createRulesMeta(rules) {\n    return Array.from(rules).reduce((retVal, [id, rule]) => {\n        retVal[id] = rule.meta;\n        return retVal;\n    }, {});\n}\n\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\nconst usedDeprecatedRulesCache = new WeakMap();\n\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\nfunction getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {\n    const {\n        configArrayFactory,\n        options: { cwd }\n    } = getCLIEngineInternalSlots(cliEngine);\n    const filePath = path.isAbsolute(maybeFilePath)\n        ? maybeFilePath\n        : path.join(cwd, \"__placeholder__.js\");\n    const configArray = configArrayFactory.getConfigArrayForFile(filePath);\n    const config = configArray.extractConfig(filePath);\n\n    // Most files use the same config, so cache it.\n    if (!usedDeprecatedRulesCache.has(config)) {\n        const pluginRules = configArray.pluginRules;\n        const retv = [];\n\n        for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n            if (getRuleSeverity(ruleConf) === 0) {\n                continue;\n            }\n            const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);\n            const meta = rule && rule.meta;\n\n            if (meta && meta.deprecated) {\n                retv.push({ ruleId, replacedBy: meta.replacedBy || [] });\n            }\n        }\n\n        usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n    }\n\n    return usedDeprecatedRulesCache.get(config);\n}\n\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\nfunction processCLIEngineLintReport(cliEngine, { results }) {\n    const descriptor = {\n        configurable: true,\n        enumerable: true,\n        get() {\n            return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);\n        }\n    };\n\n    for (const result of results) {\n        Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n    }\n\n    return results;\n}\n\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\nfunction compareResultsByFilePath(a, b) {\n    if (a.filePath < b.filePath) {\n        return -1;\n    }\n\n    if (a.filePath > b.filePath) {\n        return 1;\n    }\n\n    return 0;\n}\n\nclass ESLint {\n\n    /**\n     * Creates a new instance of the main ESLint API.\n     * @param {ESLintOptions} options The options for this instance.\n     */\n    constructor(options = {}) {\n        const processedOptions = processOptions(options);\n        const cliEngine = new CLIEngine(processedOptions);\n        const {\n            additionalPluginPool,\n            configArrayFactory,\n            lastConfigArrays\n        } = getCLIEngineInternalSlots(cliEngine);\n        let updated = false;\n\n        /*\n         * Address `plugins` to add plugin implementations.\n         * Operate the `additionalPluginPool` internal slot directly to avoid\n         * using `addPlugin(id, plugin)` method that resets cache everytime.\n         */\n        if (options.plugins) {\n            for (const [id, plugin] of Object.entries(options.plugins)) {\n                additionalPluginPool.set(id, plugin);\n                updated = true;\n            }\n        }\n\n        /*\n         * Address `overrideConfig` to set override config.\n         * Operate the `configArrayFactory` internal slot directly because this\n         * functionality doesn't exist as the public API of CLIEngine.\n         */\n        if (hasDefinedProperty(options.overrideConfig)) {\n            configArrayFactory.setOverrideConfig(options.overrideConfig);\n            updated = true;\n        }\n\n        // Update caches.\n        if (updated) {\n            configArrayFactory.clearCache();\n            lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();\n        }\n\n        // Initialize private properties.\n        privateMembersMap.set(this, {\n            cliEngine,\n            options: processedOptions\n        });\n    }\n\n    /**\n     * The version text.\n     * @type {string}\n     */\n    static get version() {\n        return version;\n    }\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintResult[]} results The lint results.\n     * @returns {Promise<void>} Returns a promise that is used to track side effects.\n     */\n    static async outputFixes(results) {\n        if (!Array.isArray(results)) {\n            throw new Error(\"'results' must be an array\");\n        }\n\n        await Promise.all(\n            results\n                .filter(result => {\n                    if (typeof result !== \"object\" || result === null) {\n                        throw new Error(\"'results' must include only objects\");\n                    }\n                    return (\n                        typeof result.output === \"string\" &&\n                        path.isAbsolute(result.filePath)\n                    );\n                })\n                .map(r => writeFile(r.filePath, r.output))\n        );\n    }\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n    static getErrorResults(results) {\n        return CLIEngine.getErrorResults(results);\n    }\n\n    /**\n     * Returns meta objects for each rule represented in the lint results.\n     * @param {LintResult[]} results The results to fetch rules meta for.\n     * @returns {Object} A mapping of ruleIds to rule meta objects.\n     */\n    getRulesMetaForResults(results) {\n\n        const resultRuleIds = new Set();\n\n        // first gather all ruleIds from all results\n\n        for (const result of results) {\n            for (const { ruleId } of result.messages) {\n                resultRuleIds.add(ruleId);\n            }\n        }\n\n        // create a map of all rules in the results\n\n        const { cliEngine } = privateMembersMap.get(this);\n        const rules = cliEngine.getRules();\n        const resultRules = new Map();\n\n        for (const [ruleId, rule] of rules) {\n            if (resultRuleIds.has(ruleId)) {\n                resultRules.set(ruleId, rule);\n            }\n        }\n\n        return createRulesMeta(resultRules);\n\n    }\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n     */\n    async lintFiles(patterns) {\n        if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n            throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n        }\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return processCLIEngineLintReport(\n            cliEngine,\n            cliEngine.executeOnFiles(patterns)\n        );\n    }\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} code A string of JavaScript code to lint.\n     * @param {Object} [options] The options.\n     * @param {string} [options.filePath] The path to the file of the source code.\n     * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n     * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n     */\n    async lintText(code, options = {}) {\n        if (typeof code !== \"string\") {\n            throw new Error(\"'code' must be a string\");\n        }\n        if (typeof options !== \"object\") {\n            throw new Error(\"'options' must be an object, null, or undefined\");\n        }\n        const {\n            filePath,\n            warnIgnored = false,\n            ...unknownOptions\n        } = options || {};\n\n        const unknownOptionKeys = Object.keys(unknownOptions);\n\n        if (unknownOptionKeys.length > 0) {\n            throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n        }\n\n        if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n            throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n        }\n        if (typeof warnIgnored !== \"boolean\") {\n            throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n        }\n\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return processCLIEngineLintReport(\n            cliEngine,\n            cliEngine.executeOnText(code, filePath, warnIgnored)\n        );\n    }\n\n    /**\n     * Returns the formatter representing the given formatter name.\n     * @param {string} [name] The name of the formatter to load.\n     * The following values are allowed:\n     * - `undefined` ... Load `stylish` builtin formatter.\n     * - A builtin formatter name ... Load the builtin formatter.\n     * - A thirdparty formatter name:\n     *   - `foo` → `eslint-formatter-foo`\n     *   - `@foo` → `@foo/eslint-formatter`\n     *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n     * - A file path ... Load the file.\n     * @returns {Promise<Formatter>} A promise resolving to the formatter object.\n     * This promise will be rejected if the given formatter was not found or not\n     * a function.\n     */\n    async loadFormatter(name = \"stylish\") {\n        if (typeof name !== \"string\") {\n            throw new Error(\"'name' must be a string\");\n        }\n\n        const { cliEngine } = privateMembersMap.get(this);\n        const formatter = cliEngine.getFormatter(name);\n\n        if (typeof formatter !== \"function\") {\n            throw new Error(`Formatter must be a function, but got a ${typeof formatter}.`);\n        }\n\n        return {\n\n            /**\n             * The main formatter method.\n             * @param {LintResults[]} results The lint results to format.\n             * @returns {string} The formatted lint results.\n             */\n            format(results) {\n                let rulesMeta = null;\n\n                results.sort(compareResultsByFilePath);\n\n                return formatter(results, {\n                    get rulesMeta() {\n                        if (!rulesMeta) {\n                            rulesMeta = createRulesMeta(cliEngine.getRules());\n                        }\n\n                        return rulesMeta;\n                    }\n                });\n            }\n        };\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Promise<ConfigData>} A configuration object for the file.\n     */\n    async calculateConfigForFile(filePath) {\n        if (!isNonEmptyString(filePath)) {\n            throw new Error(\"'filePath' must be a non-empty string\");\n        }\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return cliEngine.getConfigForFile(filePath);\n    }\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {Promise<boolean>} Whether or not the given path is ignored.\n     */\n    async isPathIgnored(filePath) {\n        if (!isNonEmptyString(filePath)) {\n            throw new Error(\"'filePath' must be a non-empty string\");\n        }\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return cliEngine.isPathIgnored(filePath);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    ESLint,\n\n    /**\n     * Get the private class members of a given ESLint instance for tests.\n     * @param {ESLint} instance The ESLint instance to get.\n     * @returns {ESLintPrivateMembers} The instance's private class members.\n     */\n    getESLintPrivateMembers(instance) {\n        return privateMembersMap.get(instance);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}