{"ast":null,"code":"var path = require('path');\n\nvar crypto = require('crypto');\n\nmodule.exports = {\n  createFromFile: function (filePath, useChecksum) {\n    var fname = path.basename(filePath);\n    var dir = path.dirname(filePath);\n    return this.create(fname, dir, useChecksum);\n  },\n  create: function (cacheId, _path, useChecksum) {\n    var fs = require('fs');\n\n    var flatCache = require('flat-cache');\n\n    var cache = flatCache.load(cacheId, _path);\n    var normalizedEntries = {};\n\n    var removeNotFoundFiles = function removeNotFoundFiles() {\n      const cachedEntries = cache.keys(); // remove not found entries\n\n      cachedEntries.forEach(function remover(fPath) {\n        try {\n          fs.statSync(fPath);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            cache.removeKey(fPath);\n          }\n        }\n      });\n    };\n\n    removeNotFoundFiles();\n    return {\n      /**\n       * the flat cache storage used to persist the metadata of the `files\n       * @type {Object}\n       */\n      cache: cache,\n\n      /**\n       * Given a buffer, calculate md5 hash of its content.\n       * @method getHash\n       * @param  {Buffer} buffer   buffer to calculate hash on\n       * @return {String}          content hash digest\n       */\n      getHash: function (buffer) {\n        return crypto.createHash('md5').update(buffer).digest('hex');\n      },\n\n      /**\n       * Return whether or not a file has changed since last time reconcile was called.\n       * @method hasFileChanged\n       * @param  {String}  file  the filepath to check\n       * @return {Boolean}       wheter or not the file has changed\n       */\n      hasFileChanged: function (file) {\n        return this.getFileDescriptor(file).changed;\n      },\n\n      /**\n       * given an array of file paths it return and object with three arrays:\n       *  - changedFiles: Files that changed since previous run\n       *  - notChangedFiles: Files that haven't change\n       *  - notFoundFiles: Files that were not found, probably deleted\n       *\n       * @param  {Array} files the files to analyze and compare to the previous seen files\n       * @return {[type]}       [description]\n       */\n      analyzeFiles: function (files) {\n        var me = this;\n        files = files || [];\n        var res = {\n          changedFiles: [],\n          notFoundFiles: [],\n          notChangedFiles: []\n        };\n        me.normalizeEntries(files).forEach(function (entry) {\n          if (entry.changed) {\n            res.changedFiles.push(entry.key);\n            return;\n          }\n\n          if (entry.notFound) {\n            res.notFoundFiles.push(entry.key);\n            return;\n          }\n\n          res.notChangedFiles.push(entry.key);\n        });\n        return res;\n      },\n      getFileDescriptor: function (file) {\n        var fstat;\n\n        try {\n          fstat = fs.statSync(file);\n        } catch (ex) {\n          this.removeEntry(file);\n          return {\n            key: file,\n            notFound: true,\n            err: ex\n          };\n        }\n\n        if (useChecksum) {\n          return this._getFileDescriptorUsingChecksum(file);\n        }\n\n        return this._getFileDescriptorUsingMtimeAndSize(file, fstat);\n      },\n      _getFileDescriptorUsingMtimeAndSize: function (file, fstat) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n        var cSize = fstat.size;\n        var cTime = fstat.mtime.getTime();\n        var isDifferentDate;\n        var isDifferentSize;\n\n        if (!meta) {\n          meta = {\n            size: cSize,\n            mtime: cTime\n          };\n        } else {\n          isDifferentDate = cTime !== meta.mtime;\n          isDifferentSize = cSize !== meta.size;\n        }\n\n        var nEntry = normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferentDate || isDifferentSize,\n          meta: meta\n        };\n        return nEntry;\n      },\n      _getFileDescriptorUsingChecksum: function (file) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n        var contentBuffer;\n\n        try {\n          contentBuffer = fs.readFileSync(file);\n        } catch (ex) {\n          contentBuffer = '';\n        }\n\n        var isDifferent = true;\n        var hash = this.getHash(contentBuffer);\n\n        if (!meta) {\n          meta = {\n            hash: hash\n          };\n        } else {\n          isDifferent = hash !== meta.hash;\n        }\n\n        var nEntry = normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferent,\n          meta: meta\n        };\n        return nEntry;\n      },\n\n      /**\n       * Return the list o the files that changed compared\n       * against the ones stored in the cache\n       *\n       * @method getUpdated\n       * @param files {Array} the array of files to compare against the ones in the cache\n       * @returns {Array}\n       */\n      getUpdatedFiles: function (files) {\n        var me = this;\n        files = files || [];\n        return me.normalizeEntries(files).filter(function (entry) {\n          return entry.changed;\n        }).map(function (entry) {\n          return entry.key;\n        });\n      },\n\n      /**\n       * return the list of files\n       * @method normalizeEntries\n       * @param files\n       * @returns {*}\n       */\n      normalizeEntries: function (files) {\n        files = files || [];\n        var me = this;\n        var nEntries = files.map(function (file) {\n          return me.getFileDescriptor(file);\n        }); //normalizeEntries = nEntries;\n\n        return nEntries;\n      },\n\n      /**\n       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered\n       * modified the next time the process is run\n       *\n       * @method removeEntry\n       * @param entryName\n       */\n      removeEntry: function (entryName) {\n        delete normalizedEntries[entryName];\n        cache.removeKey(entryName);\n      },\n\n      /**\n       * Delete the cache file from the disk\n       * @method deleteCacheFile\n       */\n      deleteCacheFile: function () {\n        cache.removeCacheFile();\n      },\n\n      /**\n       * remove the cache from the file and clear the memory cache\n       */\n      destroy: function () {\n        normalizedEntries = {};\n        cache.destroy();\n      },\n      _getMetaForFileUsingCheckSum: function (cacheEntry) {\n        var contentBuffer = fs.readFileSync(cacheEntry.key);\n        var hash = this.getHash(contentBuffer);\n        var meta = Object.assign(cacheEntry.meta, {\n          hash: hash\n        });\n        delete meta.size;\n        delete meta.mtime;\n        return meta;\n      },\n      _getMetaForFileUsingMtimeAndSize: function (cacheEntry) {\n        var stat = fs.statSync(cacheEntry.key);\n        var meta = Object.assign(cacheEntry.meta, {\n          size: stat.size,\n          mtime: stat.mtime.getTime()\n        });\n        delete meta.hash;\n        return meta;\n      },\n\n      /**\n       * Sync the files and persist them to the cache\n       * @method reconcile\n       */\n      reconcile: function (noPrune) {\n        removeNotFoundFiles();\n        noPrune = typeof noPrune === 'undefined' ? true : noPrune;\n        var entries = normalizedEntries;\n        var keys = Object.keys(entries);\n\n        if (keys.length === 0) {\n          return;\n        }\n\n        var me = this;\n        keys.forEach(function (entryName) {\n          var cacheEntry = entries[entryName];\n\n          try {\n            var meta = useChecksum ? me._getMetaForFileUsingCheckSum(cacheEntry) : me._getMetaForFileUsingMtimeAndSize(cacheEntry);\n            cache.setKey(entryName, meta);\n          } catch (err) {\n            // if the file does not exists we don't save it\n            // other errors are just thrown\n            if (err.code !== 'ENOENT') {\n              throw err;\n            }\n          }\n        });\n        cache.save(noPrune);\n      }\n    };\n  }\n};","map":{"version":3,"names":["path","require","crypto","module","exports","createFromFile","filePath","useChecksum","fname","basename","dir","dirname","create","cacheId","_path","fs","flatCache","cache","load","normalizedEntries","removeNotFoundFiles","cachedEntries","keys","forEach","remover","fPath","statSync","err","code","removeKey","getHash","buffer","createHash","update","digest","hasFileChanged","file","getFileDescriptor","changed","analyzeFiles","files","me","res","changedFiles","notFoundFiles","notChangedFiles","normalizeEntries","entry","push","key","notFound","fstat","ex","removeEntry","_getFileDescriptorUsingChecksum","_getFileDescriptorUsingMtimeAndSize","meta","getKey","cacheExists","cSize","size","cTime","mtime","getTime","isDifferentDate","isDifferentSize","nEntry","contentBuffer","readFileSync","isDifferent","hash","getUpdatedFiles","filter","map","nEntries","entryName","deleteCacheFile","removeCacheFile","destroy","_getMetaForFileUsingCheckSum","cacheEntry","Object","assign","_getMetaForFileUsingMtimeAndSize","stat","reconcile","noPrune","entries","length","setKey","save"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/node_modules/file-entry-cache/cache.js"],"sourcesContent":["var path = require('path');\nvar crypto = require('crypto');\n\nmodule.exports = {\n  createFromFile: function (filePath, useChecksum) {\n    var fname = path.basename(filePath);\n    var dir = path.dirname(filePath);\n    return this.create(fname, dir, useChecksum);\n  },\n\n  create: function (cacheId, _path, useChecksum) {\n    var fs = require('fs');\n    var flatCache = require('flat-cache');\n    var cache = flatCache.load(cacheId, _path);\n    var normalizedEntries = {};\n\n    var removeNotFoundFiles = function removeNotFoundFiles() {\n      const cachedEntries = cache.keys();\n      // remove not found entries\n      cachedEntries.forEach(function remover(fPath) {\n        try {\n          fs.statSync(fPath);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            cache.removeKey(fPath);\n          }\n        }\n      });\n    };\n\n    removeNotFoundFiles();\n\n    return {\n      /**\n       * the flat cache storage used to persist the metadata of the `files\n       * @type {Object}\n       */\n      cache: cache,\n\n      /**\n       * Given a buffer, calculate md5 hash of its content.\n       * @method getHash\n       * @param  {Buffer} buffer   buffer to calculate hash on\n       * @return {String}          content hash digest\n       */\n      getHash: function (buffer) {\n        return crypto.createHash('md5').update(buffer).digest('hex');\n      },\n\n      /**\n       * Return whether or not a file has changed since last time reconcile was called.\n       * @method hasFileChanged\n       * @param  {String}  file  the filepath to check\n       * @return {Boolean}       wheter or not the file has changed\n       */\n      hasFileChanged: function (file) {\n        return this.getFileDescriptor(file).changed;\n      },\n\n      /**\n       * given an array of file paths it return and object with three arrays:\n       *  - changedFiles: Files that changed since previous run\n       *  - notChangedFiles: Files that haven't change\n       *  - notFoundFiles: Files that were not found, probably deleted\n       *\n       * @param  {Array} files the files to analyze and compare to the previous seen files\n       * @return {[type]}       [description]\n       */\n      analyzeFiles: function (files) {\n        var me = this;\n        files = files || [];\n\n        var res = {\n          changedFiles: [],\n          notFoundFiles: [],\n          notChangedFiles: [],\n        };\n\n        me.normalizeEntries(files).forEach(function (entry) {\n          if (entry.changed) {\n            res.changedFiles.push(entry.key);\n            return;\n          }\n          if (entry.notFound) {\n            res.notFoundFiles.push(entry.key);\n            return;\n          }\n          res.notChangedFiles.push(entry.key);\n        });\n        return res;\n      },\n\n      getFileDescriptor: function (file) {\n        var fstat;\n\n        try {\n          fstat = fs.statSync(file);\n        } catch (ex) {\n          this.removeEntry(file);\n          return { key: file, notFound: true, err: ex };\n        }\n\n        if (useChecksum) {\n          return this._getFileDescriptorUsingChecksum(file);\n        }\n\n        return this._getFileDescriptorUsingMtimeAndSize(file, fstat);\n      },\n\n      _getFileDescriptorUsingMtimeAndSize: function (file, fstat) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n\n        var cSize = fstat.size;\n        var cTime = fstat.mtime.getTime();\n\n        var isDifferentDate;\n        var isDifferentSize;\n\n        if (!meta) {\n          meta = { size: cSize, mtime: cTime };\n        } else {\n          isDifferentDate = cTime !== meta.mtime;\n          isDifferentSize = cSize !== meta.size;\n        }\n\n        var nEntry = (normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferentDate || isDifferentSize,\n          meta: meta,\n        });\n\n        return nEntry;\n      },\n\n      _getFileDescriptorUsingChecksum: function (file) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n\n        var contentBuffer;\n        try {\n          contentBuffer = fs.readFileSync(file);\n        } catch (ex) {\n          contentBuffer = '';\n        }\n\n        var isDifferent = true;\n        var hash = this.getHash(contentBuffer);\n\n        if (!meta) {\n          meta = { hash: hash };\n        } else {\n          isDifferent = hash !== meta.hash;\n        }\n\n        var nEntry = (normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferent,\n          meta: meta,\n        });\n\n        return nEntry;\n      },\n\n      /**\n       * Return the list o the files that changed compared\n       * against the ones stored in the cache\n       *\n       * @method getUpdated\n       * @param files {Array} the array of files to compare against the ones in the cache\n       * @returns {Array}\n       */\n      getUpdatedFiles: function (files) {\n        var me = this;\n        files = files || [];\n\n        return me\n          .normalizeEntries(files)\n          .filter(function (entry) {\n            return entry.changed;\n          })\n          .map(function (entry) {\n            return entry.key;\n          });\n      },\n\n      /**\n       * return the list of files\n       * @method normalizeEntries\n       * @param files\n       * @returns {*}\n       */\n      normalizeEntries: function (files) {\n        files = files || [];\n\n        var me = this;\n        var nEntries = files.map(function (file) {\n          return me.getFileDescriptor(file);\n        });\n\n        //normalizeEntries = nEntries;\n        return nEntries;\n      },\n\n      /**\n       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered\n       * modified the next time the process is run\n       *\n       * @method removeEntry\n       * @param entryName\n       */\n      removeEntry: function (entryName) {\n        delete normalizedEntries[entryName];\n        cache.removeKey(entryName);\n      },\n\n      /**\n       * Delete the cache file from the disk\n       * @method deleteCacheFile\n       */\n      deleteCacheFile: function () {\n        cache.removeCacheFile();\n      },\n\n      /**\n       * remove the cache from the file and clear the memory cache\n       */\n      destroy: function () {\n        normalizedEntries = {};\n        cache.destroy();\n      },\n\n      _getMetaForFileUsingCheckSum: function (cacheEntry) {\n        var contentBuffer = fs.readFileSync(cacheEntry.key);\n        var hash = this.getHash(contentBuffer);\n        var meta = Object.assign(cacheEntry.meta, { hash: hash });\n        delete meta.size;\n        delete meta.mtime;\n        return meta;\n      },\n\n      _getMetaForFileUsingMtimeAndSize: function (cacheEntry) {\n        var stat = fs.statSync(cacheEntry.key);\n        var meta = Object.assign(cacheEntry.meta, {\n          size: stat.size,\n          mtime: stat.mtime.getTime(),\n        });\n        delete meta.hash;\n        return meta;\n      },\n\n      /**\n       * Sync the files and persist them to the cache\n       * @method reconcile\n       */\n      reconcile: function (noPrune) {\n        removeNotFoundFiles();\n\n        noPrune = typeof noPrune === 'undefined' ? true : noPrune;\n\n        var entries = normalizedEntries;\n        var keys = Object.keys(entries);\n\n        if (keys.length === 0) {\n          return;\n        }\n\n        var me = this;\n\n        keys.forEach(function (entryName) {\n          var cacheEntry = entries[entryName];\n\n          try {\n            var meta = useChecksum\n              ? me._getMetaForFileUsingCheckSum(cacheEntry)\n              : me._getMetaForFileUsingMtimeAndSize(cacheEntry);\n            cache.setKey(entryName, meta);\n          } catch (err) {\n            // if the file does not exists we don't save it\n            // other errors are just thrown\n            if (err.code !== 'ENOENT') {\n              throw err;\n            }\n          }\n        });\n\n        cache.save(noPrune);\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}