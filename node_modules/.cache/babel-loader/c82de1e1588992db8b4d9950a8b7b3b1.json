{"ast":null,"code":"/**\n * @fileoverview enforce a maximum file length\n * @author Alberto Rodríguez\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Creates an array of numbers from `start` up to, but not including, `end`\n * @param {number} start The start of the range\n * @param {number} end The end of the range\n * @returns {number[]} The range of numbers\n */\n\n\nfunction range(start, end) {\n  return [...Array(end - start).keys()].map(x => x + start);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of lines per file\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-lines\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          max: {\n            type: \"integer\",\n            minimum: 0\n          },\n          skipComments: {\n            type: \"boolean\"\n          },\n          skipBlankLines: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      exceed: \"File has too many lines ({{actual}}). Maximum allowed is {{max}}.\"\n    }\n  },\n\n  create(context) {\n    const option = context.options[0];\n    let max = 300;\n\n    if (typeof option === \"object\" && Object.prototype.hasOwnProperty.call(option, \"max\")) {\n      max = option.max;\n    } else if (typeof option === \"number\") {\n      max = option;\n    }\n\n    const skipComments = option && option.skipComments;\n    const skipBlankLines = option && option.skipBlankLines;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Returns whether or not a token is a comment node type\n     * @param {Token} token The token to check\n     * @returns {boolean} True if the token is a comment node\n     */\n\n    function isCommentNodeType(token) {\n      return token && (token.type === \"Block\" || token.type === \"Line\");\n    }\n    /**\n     * Returns the line numbers of a comment that don't have any code on the same line\n     * @param {Node} comment The comment node to check\n     * @returns {number[]} The line numbers\n     */\n\n\n    function getLinesWithoutCode(comment) {\n      let start = comment.loc.start.line;\n      let end = comment.loc.end.line;\n      let token;\n      token = comment;\n\n      do {\n        token = sourceCode.getTokenBefore(token, {\n          includeComments: true\n        });\n      } while (isCommentNodeType(token));\n\n      if (token && astUtils.isTokenOnSameLine(token, comment)) {\n        start += 1;\n      }\n\n      token = comment;\n\n      do {\n        token = sourceCode.getTokenAfter(token, {\n          includeComments: true\n        });\n      } while (isCommentNodeType(token));\n\n      if (token && astUtils.isTokenOnSameLine(comment, token)) {\n        end -= 1;\n      }\n\n      if (start <= end) {\n        return range(start, end + 1);\n      }\n\n      return [];\n    }\n    /**\n     * Returns a new array formed by applying a given callback function to each element of the array, and then flattening the result by one level.\n     * TODO(stephenwade): Replace this with array.flatMap when we drop support for Node v10\n     * @param {any[]} array The array to process\n     * @param {Function} fn The function to use\n     * @returns {any[]} The result array\n     */\n\n\n    function flatMap(array, fn) {\n      const mapped = array.map(fn);\n      const flattened = [].concat(...mapped);\n      return flattened;\n    }\n\n    return {\n      \"Program:exit\"() {\n        let lines = sourceCode.lines.map((text, i) => ({\n          lineNumber: i + 1,\n          text\n        }));\n        /*\n         * If file ends with a linebreak, `sourceCode.lines` will have one extra empty line at the end.\n         * That isn't a real line, so we shouldn't count it.\n         */\n\n        if (lines.length > 1 && lines[lines.length - 1].text === \"\") {\n          lines.pop();\n        }\n\n        if (skipBlankLines) {\n          lines = lines.filter(l => l.text.trim() !== \"\");\n        }\n\n        if (skipComments) {\n          const comments = sourceCode.getAllComments();\n          const commentLines = flatMap(comments, comment => getLinesWithoutCode(comment));\n          lines = lines.filter(l => !commentLines.includes(l.lineNumber));\n        }\n\n        if (lines.length > max) {\n          const loc = {\n            start: {\n              line: lines[max].lineNumber,\n              column: 0\n            },\n            end: {\n              line: sourceCode.lines.length,\n              column: sourceCode.lines[sourceCode.lines.length - 1].length\n            }\n          };\n          context.report({\n            loc,\n            messageId: \"exceed\",\n            data: {\n              max,\n              actual: lines.length\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","range","start","end","Array","keys","map","x","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","minimum","properties","max","skipComments","skipBlankLines","additionalProperties","messages","exceed","create","context","option","options","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","isCommentNodeType","token","getLinesWithoutCode","comment","loc","line","getTokenBefore","includeComments","isTokenOnSameLine","getTokenAfter","flatMap","array","fn","mapped","flattened","concat","lines","text","i","lineNumber","length","pop","filter","l","trim","comments","getAllComments","commentLines","includes","column","report","messageId","data","actual"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/max-lines.js"],"sourcesContent":["/**\n * @fileoverview enforce a maximum file length\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Creates an array of numbers from `start` up to, but not including, `end`\n * @param {number} start The start of the range\n * @param {number} end The end of the range\n * @returns {number[]} The range of numbers\n */\nfunction range(start, end) {\n    return [...Array(end - start).keys()].map(x => x + start);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of lines per file\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-lines\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            skipComments: {\n                                type: \"boolean\"\n                            },\n                            skipBlankLines: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            exceed:\n                \"File has too many lines ({{actual}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let max = 300;\n\n        if (\n            typeof option === \"object\" &&\n            Object.prototype.hasOwnProperty.call(option, \"max\")\n        ) {\n            max = option.max;\n        } else if (typeof option === \"number\") {\n            max = option;\n        }\n\n        const skipComments = option && option.skipComments;\n        const skipBlankLines = option && option.skipBlankLines;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns whether or not a token is a comment node type\n         * @param {Token} token The token to check\n         * @returns {boolean} True if the token is a comment node\n         */\n        function isCommentNodeType(token) {\n            return token && (token.type === \"Block\" || token.type === \"Line\");\n        }\n\n        /**\n         * Returns the line numbers of a comment that don't have any code on the same line\n         * @param {Node} comment The comment node to check\n         * @returns {number[]} The line numbers\n         */\n        function getLinesWithoutCode(comment) {\n            let start = comment.loc.start.line;\n            let end = comment.loc.end.line;\n\n            let token;\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenBefore(token, {\n                    includeComments: true\n                });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(token, comment)) {\n                start += 1;\n            }\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenAfter(token, {\n                    includeComments: true\n                });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(comment, token)) {\n                end -= 1;\n            }\n\n            if (start <= end) {\n                return range(start, end + 1);\n            }\n            return [];\n        }\n\n        /**\n         * Returns a new array formed by applying a given callback function to each element of the array, and then flattening the result by one level.\n         * TODO(stephenwade): Replace this with array.flatMap when we drop support for Node v10\n         * @param {any[]} array The array to process\n         * @param {Function} fn The function to use\n         * @returns {any[]} The result array\n         */\n        function flatMap(array, fn) {\n            const mapped = array.map(fn);\n            const flattened = [].concat(...mapped);\n\n            return flattened;\n        }\n\n        return {\n            \"Program:exit\"() {\n                let lines = sourceCode.lines.map((text, i) => ({\n                    lineNumber: i + 1,\n                    text\n                }));\n\n                /*\n                 * If file ends with a linebreak, `sourceCode.lines` will have one extra empty line at the end.\n                 * That isn't a real line, so we shouldn't count it.\n                 */\n                if (lines.length > 1 && lines[lines.length - 1].text === \"\") {\n                    lines.pop();\n                }\n\n                if (skipBlankLines) {\n                    lines = lines.filter(l => l.text.trim() !== \"\");\n                }\n\n                if (skipComments) {\n                    const comments = sourceCode.getAllComments();\n\n                    const commentLines = flatMap(comments, comment => getLinesWithoutCode(comment));\n\n                    lines = lines.filter(\n                        l => !commentLines.includes(l.lineNumber)\n                    );\n                }\n\n                if (lines.length > max) {\n                    const loc = {\n                        start: {\n                            line: lines[max].lineNumber,\n                            column: 0\n                        },\n                        end: {\n                            line: sourceCode.lines.length,\n                            column: sourceCode.lines[sourceCode.lines.length - 1].length\n                        }\n                    };\n\n                    context.report({\n                        loc,\n                        messageId: \"exceed\",\n                        data: {\n                            max,\n                            actual: lines.length\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}