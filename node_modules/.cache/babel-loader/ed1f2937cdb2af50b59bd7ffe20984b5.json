{"ast":null,"code":"/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\n\nfunction isInitialized(node) {\n  return Boolean(node.init);\n}\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\n\n\nfunction isUnreachable(segment) {\n  return !segment.reachable;\n}\n/**\n * The class to distinguish consecutive unreachable statements.\n */\n\n\nclass ConsecutiveRange {\n  constructor(sourceCode) {\n    this.sourceCode = sourceCode;\n    this.startNode = null;\n    this.endNode = null;\n  }\n  /**\n   * The location object of this range.\n   * @type {Object}\n   */\n\n\n  get location() {\n    return {\n      start: this.startNode.loc.start,\n      end: this.endNode.loc.end\n    };\n  }\n  /**\n   * `true` if this range is empty.\n   * @type {boolean}\n   */\n\n\n  get isEmpty() {\n    return !(this.startNode && this.endNode);\n  }\n  /**\n   * Checks whether the given node is inside of this range.\n   * @param {ASTNode|Token} node The node to check.\n   * @returns {boolean} `true` if the node is inside of this range.\n   */\n\n\n  contains(node) {\n    return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];\n  }\n  /**\n   * Checks whether the given node is consecutive to this range.\n   * @param {ASTNode} node The node to check.\n   * @returns {boolean} `true` if the node is consecutive to this range.\n   */\n\n\n  isConsecutive(node) {\n    return this.contains(this.sourceCode.getTokenBefore(node));\n  }\n  /**\n   * Merges the given node to this range.\n   * @param {ASTNode} node The node to merge.\n   * @returns {void}\n   */\n\n\n  merge(node) {\n    this.endNode = node;\n  }\n  /**\n   * Resets this range by the given node or null.\n   * @param {ASTNode|null} node The node to reset, or null.\n   * @returns {void}\n   */\n\n\n  reset(node) {\n    this.startNode = this.endNode = node;\n  }\n\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unreachable\"\n    },\n    schema: [],\n    messages: {\n      unreachableCode: \"Unreachable code.\"\n    }\n  },\n\n  create(context) {\n    let currentCodePath = null;\n    const range = new ConsecutiveRange(context.getSourceCode());\n    /**\n     * Reports a given node if it's unreachable.\n     * @param {ASTNode} node A statement node to report.\n     * @returns {void}\n     */\n\n    function reportIfUnreachable(node) {\n      let nextNode = null;\n\n      if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n        // Store this statement to distinguish consecutive statements.\n        if (range.isEmpty) {\n          range.reset(node);\n          return;\n        } // Skip if this statement is inside of the current range.\n\n\n        if (range.contains(node)) {\n          return;\n        } // Merge if this statement is consecutive to the current range.\n\n\n        if (range.isConsecutive(node)) {\n          range.merge(node);\n          return;\n        }\n\n        nextNode = node;\n      }\n      /*\n       * Report the current range since this statement is reachable or is\n       * not consecutive to the current range.\n       */\n\n\n      if (!range.isEmpty) {\n        context.report({\n          messageId: \"unreachableCode\",\n          loc: range.location,\n          node: range.startNode\n        });\n      } // Update the current range.\n\n\n      range.reset(nextNode);\n    }\n\n    return {\n      // Manages the current code path.\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      // Registers for all statement nodes (excludes FunctionDeclaration).\n      BlockStatement: reportIfUnreachable,\n      BreakStatement: reportIfUnreachable,\n      ClassDeclaration: reportIfUnreachable,\n      ContinueStatement: reportIfUnreachable,\n      DebuggerStatement: reportIfUnreachable,\n      DoWhileStatement: reportIfUnreachable,\n      ExpressionStatement: reportIfUnreachable,\n      ForInStatement: reportIfUnreachable,\n      ForOfStatement: reportIfUnreachable,\n      ForStatement: reportIfUnreachable,\n      IfStatement: reportIfUnreachable,\n      ImportDeclaration: reportIfUnreachable,\n      LabeledStatement: reportIfUnreachable,\n      ReturnStatement: reportIfUnreachable,\n      SwitchStatement: reportIfUnreachable,\n      ThrowStatement: reportIfUnreachable,\n      TryStatement: reportIfUnreachable,\n\n      VariableDeclaration(node) {\n        if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n          reportIfUnreachable(node);\n        }\n      },\n\n      WhileStatement: reportIfUnreachable,\n      WithStatement: reportIfUnreachable,\n      ExportNamedDeclaration: reportIfUnreachable,\n      ExportDefaultDeclaration: reportIfUnreachable,\n      ExportAllDeclaration: reportIfUnreachable,\n\n      \"Program:exit\"() {\n        reportIfUnreachable();\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["isInitialized","node","Boolean","init","isUnreachable","segment","reachable","ConsecutiveRange","constructor","sourceCode","startNode","endNode","location","start","loc","end","isEmpty","contains","range","isConsecutive","getTokenBefore","merge","reset","module","exports","meta","type","docs","description","category","recommended","url","schema","messages","unreachableCode","create","context","currentCodePath","getSourceCode","reportIfUnreachable","nextNode","currentSegments","every","report","messageId","onCodePathStart","codePath","onCodePathEnd","upper","BlockStatement","BreakStatement","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","ReturnStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","kind","declarations","some","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-unreachable.js"],"sourcesContent":["/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unreachable\"\n        },\n\n        schema: [],\n\n        messages: {\n            unreachableCode: \"Unreachable code.\"\n        }\n    },\n\n    create(context) {\n        let currentCodePath = null;\n\n        const range = new ConsecutiveRange(context.getSourceCode());\n\n        /**\n         * Reports a given node if it's unreachable.\n         * @param {ASTNode} node A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            /*\n             * Report the current range since this statement is reachable or is\n             * not consecutive to the current range.\n             */\n            if (!range.isEmpty) {\n                context.report({\n                    messageId: \"unreachableCode\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}