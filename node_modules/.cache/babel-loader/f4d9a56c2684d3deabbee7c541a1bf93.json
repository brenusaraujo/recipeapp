{"ast":null,"code":"/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent indentation\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/indent-legacy\"\n    },\n    deprecated: true,\n    replacedBy: [\"indent\"],\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"tab\"]\n      }, {\n        type: \"integer\",\n        minimum: 0\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        SwitchCase: {\n          type: \"integer\",\n          minimum: 0\n        },\n        VariableDeclarator: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            type: \"object\",\n            properties: {\n              var: {\n                type: \"integer\",\n                minimum: 0\n              },\n              let: {\n                type: \"integer\",\n                minimum: 0\n              },\n              const: {\n                type: \"integer\",\n                minimum: 0\n              }\n            }\n          }]\n        },\n        outerIIFEBody: {\n          type: \"integer\",\n          minimum: 0\n        },\n        MemberExpression: {\n          type: \"integer\",\n          minimum: 0\n        },\n        FunctionDeclaration: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        FunctionExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        CallExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            }\n          }\n        },\n        ArrayExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        },\n        ObjectExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n    }\n  },\n\n  create(context) {\n    const DEFAULT_VARIABLE_INDENT = 1;\n    const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n\n    const DEFAULT_FUNCTION_BODY_INDENT = 1;\n    let indentType = \"space\";\n    let indentSize = 4;\n    const options = {\n      SwitchCase: 0,\n      VariableDeclarator: {\n        var: DEFAULT_VARIABLE_INDENT,\n        let: DEFAULT_VARIABLE_INDENT,\n        const: DEFAULT_VARIABLE_INDENT\n      },\n      outerIIFEBody: null,\n      FunctionDeclaration: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      FunctionExpression: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      CallExpression: {\n        arguments: DEFAULT_PARAMETER_INDENT\n      },\n      ArrayExpression: 1,\n      ObjectExpression: 1\n    };\n    const sourceCode = context.getSourceCode();\n\n    if (context.options.length) {\n      if (context.options[0] === \"tab\") {\n        indentSize = 1;\n        indentType = \"tab\";\n      } else\n        /* istanbul ignore else : this will be caught by options validation */\n        if (typeof context.options[0] === \"number\") {\n          indentSize = context.options[0];\n          indentType = \"space\";\n        }\n\n      if (context.options[1]) {\n        const opts = context.options[1];\n        options.SwitchCase = opts.SwitchCase || 0;\n        const variableDeclaratorRules = opts.VariableDeclarator;\n\n        if (typeof variableDeclaratorRules === \"number\") {\n          options.VariableDeclarator = {\n            var: variableDeclaratorRules,\n            let: variableDeclaratorRules,\n            const: variableDeclaratorRules\n          };\n        } else if (typeof variableDeclaratorRules === \"object\") {\n          Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n        }\n\n        if (typeof opts.outerIIFEBody === \"number\") {\n          options.outerIIFEBody = opts.outerIIFEBody;\n        }\n\n        if (typeof opts.MemberExpression === \"number\") {\n          options.MemberExpression = opts.MemberExpression;\n        }\n\n        if (typeof opts.FunctionDeclaration === \"object\") {\n          Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n        }\n\n        if (typeof opts.FunctionExpression === \"object\") {\n          Object.assign(options.FunctionExpression, opts.FunctionExpression);\n        }\n\n        if (typeof opts.CallExpression === \"object\") {\n          Object.assign(options.CallExpression, opts.CallExpression);\n        }\n\n        if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n          options.ArrayExpression = opts.ArrayExpression;\n        }\n\n        if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n          options.ObjectExpression = opts.ObjectExpression;\n        }\n      }\n    }\n\n    const caseIndentStore = {};\n    /**\n     * Creates an error message for a line, given the expected/actual indentation.\n     * @param {int} expectedAmount The expected amount of indentation characters for this line\n     * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n     * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n     * @returns {string} An error message for this line\n     */\n\n    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n\n      const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n\n      const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n\n      let foundStatement;\n\n      if (actualSpaces > 0 && actualTabs > 0) {\n        foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n      } else if (actualSpaces > 0) {\n        /*\n         * Abbreviate the message if the expected indentation is also spaces.\n         * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n         */\n        foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n      } else if (actualTabs > 0) {\n        foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n      } else {\n        foundStatement = \"0\";\n      }\n\n      return {\n        expected: expectedStatement,\n        actual: foundStatement\n      };\n    }\n    /**\n     * Reports a given indent violation\n     * @param {ASTNode} node Node violating the indent rule\n     * @param {int} needed Expected indentation character count\n     * @param {int} gottenSpaces Indentation space count in the actual node/code\n     * @param {int} gottenTabs Indentation tab count in the actual node/code\n     * @param {Object} [loc] Error line and column location\n     * @param {boolean} isLastNodeCheck Is the error for last node check\n     * @returns {void}\n     */\n\n\n    function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n      if (gottenSpaces && gottenTabs) {\n        // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n        return;\n      }\n\n      const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n      const textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n      context.report({\n        node,\n        loc,\n        messageId: \"expected\",\n        data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n        fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n      });\n    }\n    /**\n     * Get the actual indent of node\n     * @param {ASTNode|Token} node Node to examine\n     * @param {boolean} [byLastLine=false] get indent of node's last line\n     * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n     * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n     * `badChar` is the amount of the other indentation character.\n     */\n\n\n    function getNodeIndent(node, byLastLine) {\n      const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n      const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n      const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n      const spaces = indentChars.filter(char => char === \" \").length;\n      const tabs = indentChars.filter(char => char === \"\\t\").length;\n      return {\n        space: spaces,\n        tab: tabs,\n        goodChar: indentType === \"space\" ? spaces : tabs,\n        badChar: indentType === \"space\" ? tabs : spaces\n      };\n    }\n    /**\n     * Checks node is the first in its own start line. By default it looks by start line.\n     * @param {ASTNode} node The node to check\n     * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n     * @returns {boolean} true if its the first in the its start line\n     */\n\n\n    function isNodeFirstInLine(node, byEndLocation) {\n      const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n            startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n            endLine = firstToken ? firstToken.loc.end.line : -1;\n      return startLine !== endLine;\n    }\n    /**\n     * Check indent for node\n     * @param {ASTNode} node Node to check\n     * @param {int} neededIndent needed indent\n     * @returns {void}\n     */\n\n\n    function checkNodeIndent(node, neededIndent) {\n      const actualIndent = getNodeIndent(node, false);\n\n      if (node.type !== \"ArrayExpression\" && node.type !== \"ObjectExpression\" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, neededIndent, actualIndent.space, actualIndent.tab);\n      }\n\n      if (node.type === \"IfStatement\" && node.alternate) {\n        const elseToken = sourceCode.getTokenBefore(node.alternate);\n        checkNodeIndent(elseToken, neededIndent);\n\n        if (!isNodeFirstInLine(node.alternate)) {\n          checkNodeIndent(node.alternate, neededIndent);\n        }\n      }\n\n      if (node.type === \"TryStatement\" && node.handler) {\n        const catchToken = sourceCode.getFirstToken(node.handler);\n        checkNodeIndent(catchToken, neededIndent);\n      }\n\n      if (node.type === \"TryStatement\" && node.finalizer) {\n        const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n        checkNodeIndent(finallyToken, neededIndent);\n      }\n\n      if (node.type === \"DoWhileStatement\") {\n        const whileToken = sourceCode.getTokenAfter(node.body);\n        checkNodeIndent(whileToken, neededIndent);\n      }\n    }\n    /**\n     * Check indent for nodes list\n     * @param {ASTNode[]} nodes list of node objects\n     * @param {int} indent needed indent\n     * @returns {void}\n     */\n\n\n    function checkNodesIndent(nodes, indent) {\n      nodes.forEach(node => checkNodeIndent(node, indent));\n    }\n    /**\n     * Check last node line indent this detects, that block closed correctly\n     * @param {ASTNode} node Node to examine\n     * @param {int} lastLineIndent needed indent\n     * @returns {void}\n     */\n\n\n    function checkLastNodeLineIndent(node, lastLineIndent) {\n      const lastToken = sourceCode.getLastToken(node);\n      const endIndent = getNodeIndent(lastToken, true);\n\n      if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n        report(node, lastLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n    /**\n     * Check last node line indent this detects, that block closed correctly\n     * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n     * @param {ASTNode} node Node to examine\n     * @param {int} firstLineIndent first line needed indent\n     * @returns {void}\n     */\n\n\n    function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n      /*\n       * in case if return statement ends with ');' we have traverse back to ')'\n       * otherwise we'll measure indent for ';' and replace ')'\n       */\n      const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n      const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n      if (textBeforeClosingParenthesis.trim()) {\n        // There are tokens before the closing paren, don't report this case\n        return;\n      }\n\n      const endIndent = getNodeIndent(lastToken, true);\n\n      if (endIndent.goodChar !== firstLineIndent) {\n        report(node, firstLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n    /**\n     * Check first node line indent is correct\n     * @param {ASTNode} node Node to examine\n     * @param {int} firstLineIndent needed indent\n     * @returns {void}\n     */\n\n\n    function checkFirstNodeLineIndent(node, firstLineIndent) {\n      const startIndent = getNodeIndent(node, false);\n\n      if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, firstLineIndent, startIndent.space, startIndent.tab, {\n          line: node.loc.start.line,\n          column: node.loc.start.column\n        });\n      }\n    }\n    /**\n     * Returns a parent node of given node based on a specified type\n     * if not present then return null\n     * @param {ASTNode} node node to examine\n     * @param {string} type type that is being looked for\n     * @param {string} stopAtList end points for the evaluating code\n     * @returns {ASTNode|void} if found then node otherwise null\n     */\n\n\n    function getParentNodeByType(node, type, stopAtList) {\n      let parent = node.parent;\n      const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n      while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n        parent = parent.parent;\n      }\n\n      return parent.type === type ? parent : null;\n    }\n    /**\n     * Returns the VariableDeclarator based on the current node\n     * if not present then return null\n     * @param {ASTNode} node node to examine\n     * @returns {ASTNode|void} if found then node otherwise null\n     */\n\n\n    function getVariableDeclaratorNode(node) {\n      return getParentNodeByType(node, \"VariableDeclarator\");\n    }\n    /**\n     * Check to see if the node is part of the multi-line variable declaration.\n     * Also if its on the same line as the varNode\n     * @param {ASTNode} node node to check\n     * @param {ASTNode} varNode variable declaration node to check against\n     * @returns {boolean} True if all the above condition satisfy\n     */\n\n\n    function isNodeInVarOnTop(node, varNode) {\n      return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;\n    }\n    /**\n     * Check to see if the argument before the callee node is multi-line and\n     * there should only be 1 argument before the callee node\n     * @param {ASTNode} node node to check\n     * @returns {boolean} True if arguments are multi-line\n     */\n\n\n    function isArgBeforeCalleeNodeMultiline(node) {\n      const parent = node.parent;\n\n      if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n        return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n      }\n\n      return false;\n    }\n    /**\n     * Check to see if the node is a file level IIFE\n     * @param {ASTNode} node The function node to check.\n     * @returns {boolean} True if the node is the outer IIFE\n     */\n\n\n    function isOuterIIFE(node) {\n      const parent = node.parent;\n      let stmt = parent.parent;\n      /*\n       * Verify that the node is an IIEF\n       */\n\n      if (parent.type !== \"CallExpression\" || parent.callee !== node) {\n        return false;\n      }\n      /*\n       * Navigate legal ancestors to determine whether this IIEF is outer\n       */\n\n\n      while (stmt.type === \"UnaryExpression\" && (stmt.operator === \"!\" || stmt.operator === \"~\" || stmt.operator === \"+\" || stmt.operator === \"-\") || stmt.type === \"AssignmentExpression\" || stmt.type === \"LogicalExpression\" || stmt.type === \"SequenceExpression\" || stmt.type === \"VariableDeclarator\") {\n        stmt = stmt.parent;\n      }\n\n      return (stmt.type === \"ExpressionStatement\" || stmt.type === \"VariableDeclaration\") && stmt.parent && stmt.parent.type === \"Program\";\n    }\n    /**\n     * Check indent for function block content\n     * @param {ASTNode} node A BlockStatement node that is inside of a function.\n     * @returns {void}\n     */\n\n\n    function checkIndentInFunctionBlock(node) {\n      /*\n       * Search first caller in chain.\n       * Ex.:\n       *\n       * Models <- Identifier\n       *   .User\n       *   .find()\n       *   .exec(function() {\n       *   // function body\n       * });\n       *\n       * Looks for 'Models'\n       */\n      const calleeNode = node.parent; // FunctionExpression\n\n      let indent;\n\n      if (calleeNode.parent && (calleeNode.parent.type === \"Property\" || calleeNode.parent.type === \"ArrayExpression\")) {\n        // If function is part of array or object, comma can be put at left\n        indent = getNodeIndent(calleeNode, false).goodChar;\n      } else {\n        // If function is standalone, simple calculate indent\n        indent = getNodeIndent(calleeNode).goodChar;\n      }\n\n      if (calleeNode.parent.type === \"CallExpression\") {\n        const calleeParent = calleeNode.parent;\n\n        if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n          if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        } else {\n          if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        }\n      }\n      /*\n       * function body indent should be indent + indent size, unless this\n       * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n       */\n\n\n      let functionOffset = indentSize;\n\n      if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n        functionOffset = options.outerIIFEBody * indentSize;\n      } else if (calleeNode.type === \"FunctionExpression\") {\n        functionOffset = options.FunctionExpression.body * indentSize;\n      } else if (calleeNode.type === \"FunctionDeclaration\") {\n        functionOffset = options.FunctionDeclaration.body * indentSize;\n      }\n\n      indent += functionOffset; // check if the node is inside a variable\n\n      const parentVarNode = getVariableDeclaratorNode(node);\n\n      if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n        indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n\n      if (node.body.length > 0) {\n        checkNodesIndent(node.body, indent);\n      }\n\n      checkLastNodeLineIndent(node, indent - functionOffset);\n    }\n    /**\n     * Checks if the given node starts and ends on the same line\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} Whether or not the block starts and ends on the same line.\n     */\n\n\n    function isSingleLineNode(node) {\n      const lastToken = sourceCode.getLastToken(node),\n            startLine = node.loc.start.line,\n            endLine = lastToken.loc.end.line;\n      return startLine === endLine;\n    }\n    /**\n     * Check indent for array block content or object block content\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n\n\n    function checkIndentInArrayOrObjectBlock(node) {\n      // Skip inline\n      if (isSingleLineNode(node)) {\n        return;\n      }\n\n      let elements = node.type === \"ArrayExpression\" ? node.elements : node.properties; // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n\n      elements = elements.filter(elem => elem !== null);\n      let nodeIndent;\n      let elementsIndent;\n      const parentVarNode = getVariableDeclaratorNode(node); // TODO - come up with a better strategy in future\n\n      if (isNodeFirstInLine(node)) {\n        const parent = node.parent;\n        nodeIndent = getNodeIndent(parent).goodChar;\n\n        if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n          if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n            if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n              nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n              const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n              if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {\n                /*\n                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                 * e.g. [{\n                 *        foo: 1\n                 *      },\n                 *      {\n                 *        bar: 1\n                 *      }]\n                 * the second object is not indented.\n                 */\n              } else if (typeof options[parent.type] === \"number\") {\n                nodeIndent += options[parent.type] * indentSize;\n              } else {\n                nodeIndent = parentElements[0].loc.start.column;\n              }\n            } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n              if (typeof options.CallExpression.arguments === \"number\") {\n                nodeIndent += options.CallExpression.arguments * indentSize;\n              } else if (options.CallExpression.arguments === \"first\") {\n                if (parent.arguments.indexOf(node) !== -1) {\n                  nodeIndent = parent.arguments[0].loc.start.column;\n                }\n              } else {\n                nodeIndent += indentSize;\n              }\n            } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n              nodeIndent += indentSize;\n            }\n          }\n        }\n\n        checkFirstNodeLineIndent(node, nodeIndent);\n      } else {\n        nodeIndent = getNodeIndent(node).goodChar;\n      }\n\n      if (options[node.type] === \"first\") {\n        elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n      } else {\n        elementsIndent = nodeIndent + indentSize * options[node.type];\n      }\n      /*\n       * Check if the node is a multiple variable declaration; if so, then\n       * make sure indentation takes that into account.\n       */\n\n\n      if (isNodeInVarOnTop(node, parentVarNode)) {\n        elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n\n      checkNodesIndent(elements, elementsIndent);\n\n      if (elements.length > 0) {\n        // Skip last block line check if last item in same line\n        if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n          return;\n        }\n      }\n\n      checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n    }\n    /**\n     * Check if the node or node body is a BlockStatement or not\n     * @param {ASTNode} node node to test\n     * @returns {boolean} True if it or its body is a block statement\n     */\n\n\n    function isNodeBodyBlock(node) {\n      return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || node.body && node.body.type === \"BlockStatement\" || node.consequent && node.consequent.type === \"BlockStatement\";\n    }\n    /**\n     * Check indentation for blocks\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n\n\n    function blockIndentationCheck(node) {\n      // Skip inline blocks\n      if (isSingleLineNode(node)) {\n        return;\n      }\n\n      if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"FunctionDeclaration\" || node.parent.type === \"ArrowFunctionExpression\")) {\n        checkIndentInFunctionBlock(node);\n        return;\n      }\n\n      let indent;\n      let nodesToCheck = [];\n      /*\n       * For this statements we should check indent from statement beginning,\n       * not from the beginning of the block.\n       */\n\n      const statementsWithProperties = [\"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"];\n\n      if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n        indent = getNodeIndent(node.parent).goodChar;\n      } else if (node.parent && node.parent.type === \"CatchClause\") {\n        indent = getNodeIndent(node.parent.parent).goodChar;\n      } else {\n        indent = getNodeIndent(node).goodChar;\n      }\n\n      if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n        nodesToCheck = [node.consequent];\n      } else if (Array.isArray(node.body)) {\n        nodesToCheck = node.body;\n      } else {\n        nodesToCheck = [node.body];\n      }\n\n      if (nodesToCheck.length > 0) {\n        checkNodesIndent(nodesToCheck, indent + indentSize);\n      }\n\n      if (node.type === \"BlockStatement\") {\n        checkLastNodeLineIndent(node, indent);\n      }\n    }\n    /**\n     * Filter out the elements which are on the same line of each other or the node.\n     * basically have only 1 elements from each line except the variable declaration line.\n     * @param {ASTNode} node Variable declaration node\n     * @returns {ASTNode[]} Filtered elements\n     */\n\n\n    function filterOutSameLineVars(node) {\n      return node.declarations.reduce((finalCollection, elem) => {\n        const lastElem = finalCollection[finalCollection.length - 1];\n\n        if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {\n          finalCollection.push(elem);\n        }\n\n        return finalCollection;\n      }, []);\n    }\n    /**\n     * Check indentation for variable declarations\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n\n\n    function checkIndentInVariableDeclarations(node) {\n      const elements = filterOutSameLineVars(node);\n      const nodeIndent = getNodeIndent(node).goodChar;\n      const lastElement = elements[elements.length - 1];\n      const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n      checkNodesIndent(elements, elementsIndent); // Only check the last line if there is any token after the last item\n\n      if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n        return;\n      }\n\n      const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n      if (tokenBeforeLastElement.value === \",\") {\n        // Special case for comma-first syntax where the semicolon is indented\n        checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n      } else {\n        checkLastNodeLineIndent(node, elementsIndent - indentSize);\n      }\n    }\n    /**\n     * Check and decide whether to check for indentation for blockless nodes\n     * Scenarios are for or while statements without braces around them\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n\n\n    function blockLessNodes(node) {\n      if (node.body.type !== \"BlockStatement\") {\n        blockIndentationCheck(node);\n      }\n    }\n    /**\n     * Returns the expected indentation for the case statement\n     * @param {ASTNode} node node to examine\n     * @param {int} [providedSwitchIndent] indent for switch statement\n     * @returns {int} indent size\n     */\n\n\n    function expectedCaseIndent(node, providedSwitchIndent) {\n      const switchNode = node.type === \"SwitchStatement\" ? node : node.parent;\n      const switchIndent = typeof providedSwitchIndent === \"undefined\" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;\n      let caseIndent;\n\n      if (caseIndentStore[switchNode.loc.start.line]) {\n        return caseIndentStore[switchNode.loc.start.line];\n      }\n\n      if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n        caseIndent = switchIndent;\n      } else {\n        caseIndent = switchIndent + indentSize * options.SwitchCase;\n      }\n\n      caseIndentStore[switchNode.loc.start.line] = caseIndent;\n      return caseIndent;\n    }\n    /**\n     * Checks whether a return statement is wrapped in ()\n     * @param {ASTNode} node node to examine\n     * @returns {boolean} the result\n     */\n\n\n    function isWrappedInParenthesis(node) {\n      const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n      const statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), \"\");\n      return regex.test(statementWithoutArgument);\n    }\n\n    return {\n      Program(node) {\n        if (node.body.length > 0) {\n          // Root nodes should have no indent\n          checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n        }\n      },\n\n      ClassBody: blockIndentationCheck,\n      BlockStatement: blockIndentationCheck,\n      WhileStatement: blockLessNodes,\n      ForStatement: blockLessNodes,\n      ForInStatement: blockLessNodes,\n      ForOfStatement: blockLessNodes,\n      DoWhileStatement: blockLessNodes,\n\n      IfStatement(node) {\n        if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n          blockIndentationCheck(node);\n        }\n      },\n\n      VariableDeclaration(node) {\n        if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n          checkIndentInVariableDeclarations(node);\n        }\n      },\n\n      ObjectExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n\n      ArrayExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n\n      MemberExpression(node) {\n        if (typeof options.MemberExpression === \"undefined\") {\n          return;\n        }\n\n        if (isSingleLineNode(node)) {\n          return;\n        }\n        /*\n         * The typical layout of variable declarations and assignments\n         * alter the expectation of correct indentation. Skip them.\n         * TODO: Add appropriate configuration options for variable\n         * declarations and assignments.\n         */\n\n\n        if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          return;\n        }\n\n        if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n          return;\n        }\n\n        const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n        const checkNodes = [node.property];\n        const dot = sourceCode.getTokenBefore(node.property);\n\n        if (dot.type === \"Punctuator\" && dot.value === \".\") {\n          checkNodes.push(dot);\n        }\n\n        checkNodesIndent(checkNodes, propertyIndent);\n      },\n\n      SwitchStatement(node) {\n        // Switch is not a 'BlockStatement'\n        const switchIndent = getNodeIndent(node).goodChar;\n        const caseIndent = expectedCaseIndent(node, switchIndent);\n        checkNodesIndent(node.cases, caseIndent);\n        checkLastNodeLineIndent(node, switchIndent);\n      },\n\n      SwitchCase(node) {\n        // Skip inline cases\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        const caseIndent = expectedCaseIndent(node);\n        checkNodesIndent(node.consequent, caseIndent + indentSize);\n      },\n\n      FunctionDeclaration(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionDeclaration.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n        }\n      },\n\n      FunctionExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionExpression.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n        }\n      },\n\n      ReturnStatement(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        const firstLineIndent = getNodeIndent(node).goodChar; // in case if return statement is wrapped in parenthesis\n\n        if (isWrappedInParenthesis(node)) {\n          checkLastReturnStatementLineIndent(node, firstLineIndent);\n        } else {\n          checkNodeIndent(node, firstLineIndent);\n        }\n      },\n\n      CallExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n          checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n        } else if (options.CallExpression.arguments !== null) {\n          checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","deprecated","replacedBy","fixable","schema","oneOf","enum","minimum","properties","SwitchCase","VariableDeclarator","var","let","const","outerIIFEBody","MemberExpression","FunctionDeclaration","parameters","body","FunctionExpression","CallExpression","ArrayExpression","ObjectExpression","additionalProperties","messages","expected","create","context","DEFAULT_VARIABLE_INDENT","DEFAULT_PARAMETER_INDENT","DEFAULT_FUNCTION_BODY_INDENT","indentType","indentSize","options","arguments","sourceCode","getSourceCode","length","opts","variableDeclaratorRules","Object","assign","caseIndentStore","createErrorMessageData","expectedAmount","actualSpaces","actualTabs","expectedStatement","foundSpacesWord","foundTabsWord","foundStatement","actual","report","node","needed","gottenSpaces","gottenTabs","loc","isLastNodeCheck","desiredIndent","repeat","textRange","range","end","column","start","messageId","data","fix","fixer","replaceTextRange","getNodeIndent","byLastLine","token","getLastToken","getFirstToken","srcCharsBeforeNode","getText","split","indentChars","slice","findIndex","char","spaces","filter","tabs","space","tab","goodChar","badChar","isNodeFirstInLine","byEndLocation","firstToken","getTokenBefore","startLine","line","endLine","checkNodeIndent","neededIndent","actualIndent","alternate","elseToken","handler","catchToken","finalizer","finallyToken","whileToken","getTokenAfter","checkNodesIndent","nodes","indent","forEach","checkLastNodeLineIndent","lastLineIndent","lastToken","endIndent","checkLastReturnStatementLineIndent","firstLineIndent","isClosingParenToken","textBeforeClosingParenthesis","trim","checkFirstNodeLineIndent","startIndent","getParentNodeByType","stopAtList","parent","stopAtSet","Set","has","getVariableDeclaratorNode","isNodeInVarOnTop","varNode","declarations","isArgBeforeCalleeNodeMultiline","isOuterIIFE","stmt","callee","operator","checkIndentInFunctionBlock","calleeNode","calleeParent","functionOffset","parentVarNode","kind","isSingleLineNode","checkIndentInArrayOrObjectBlock","elements","elem","nodeIndent","elementsIndent","parentElements","indexOf","isNodeBodyBlock","consequent","blockIndentationCheck","nodesToCheck","statementsWithProperties","Array","isArray","filterOutSameLineVars","reduce","finalCollection","lastElem","push","checkIndentInVariableDeclarations","lastElement","tokenBeforeLastElement","value","blockLessNodes","expectedCaseIndent","providedSwitchIndent","switchNode","switchIndent","caseIndent","cases","isWrappedInParenthesis","regex","statementWithoutArgument","replace","argument","test","Program","ClassBody","BlockStatement","WhileStatement","ForStatement","ForInStatement","ForOfStatement","DoWhileStatement","IfStatement","VariableDeclaration","propertyIndent","checkNodes","property","dot","SwitchStatement","params","ReturnStatement"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/indent-legacy.js"],"sourcesContent":["/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/indent-legacy\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"indent\"],\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                }\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            }\n                        }\n                    },\n                    ArrayExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    },\n                    ObjectExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: null,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            ArrayExpression: 1,\n            ObjectExpression: 1\n        };\n\n        const sourceCode = context.getSourceCode();\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === \"number\") {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                const opts = context.options[1];\n\n                options.SwitchCase = opts.SwitchCase || 0;\n                const variableDeclaratorRules = opts.VariableDeclarator;\n\n                if (typeof variableDeclaratorRules === \"number\") {\n                    options.VariableDeclarator = {\n                        var: variableDeclaratorRules,\n                        let: variableDeclaratorRules,\n                        const: variableDeclaratorRules\n                    };\n                } else if (typeof variableDeclaratorRules === \"object\") {\n                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n                }\n\n                if (typeof opts.outerIIFEBody === \"number\") {\n                    options.outerIIFEBody = opts.outerIIFEBody;\n                }\n\n                if (typeof opts.MemberExpression === \"number\") {\n                    options.MemberExpression = opts.MemberExpression;\n                }\n\n                if (typeof opts.FunctionDeclaration === \"object\") {\n                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n                }\n\n                if (typeof opts.FunctionExpression === \"object\") {\n                    Object.assign(options.FunctionExpression, opts.FunctionExpression);\n                }\n\n                if (typeof opts.CallExpression === \"object\") {\n                    Object.assign(options.CallExpression, opts.CallExpression);\n                }\n\n                if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n                    options.ArrayExpression = opts.ArrayExpression;\n                }\n\n                if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n                    options.ObjectExpression = opts.ObjectExpression;\n                }\n            }\n        }\n\n        const caseIndentStore = {};\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0 && actualTabs > 0) {\n                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n            } else if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {ASTNode} node Node violating the indent rule\n         * @param {int} needed Expected indentation character count\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\n         * @param {Object} [loc] Error line and column location\n         * @param {boolean} isLastNodeCheck Is the error for last node check\n         * @returns {void}\n         */\n        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n            if (gottenSpaces && gottenTabs) {\n\n                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n                return;\n            }\n\n            const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n\n            const textRange = isLastNodeCheck\n                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]\n                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n\n            context.report({\n                node,\n                loc,\n                messageId: \"expected\",\n                data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n            });\n        }\n\n        /**\n         * Get the actual indent of node\n         * @param {ASTNode|Token} node Node to examine\n         * @param {boolean} [byLastLine=false] get indent of node's last line\n         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n         * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n         * `badChar` is the amount of the other indentation character.\n         */\n        function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }\n\n        /**\n         * Checks node is the first in its own start line. By default it looks by start line.\n         * @param {ASTNode} node The node to check\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n         * @returns {boolean} true if its the first in the its start line\n         */\n        function isNodeFirstInLine(node, byEndLocation) {\n            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n                endLine = firstToken ? firstToken.loc.end.line : -1;\n\n            return startLine !== endLine;\n        }\n\n        /**\n         * Check indent for node\n         * @param {ASTNode} node Node to check\n         * @param {int} neededIndent needed indent\n         * @returns {void}\n         */\n        function checkNodeIndent(node, neededIndent) {\n            const actualIndent = getNodeIndent(node, false);\n\n            if (\n                node.type !== \"ArrayExpression\" &&\n                node.type !== \"ObjectExpression\" &&\n                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&\n                isNodeFirstInLine(node)\n            ) {\n                report(node, neededIndent, actualIndent.space, actualIndent.tab);\n            }\n\n            if (node.type === \"IfStatement\" && node.alternate) {\n                const elseToken = sourceCode.getTokenBefore(node.alternate);\n\n                checkNodeIndent(elseToken, neededIndent);\n\n                if (!isNodeFirstInLine(node.alternate)) {\n                    checkNodeIndent(node.alternate, neededIndent);\n                }\n            }\n\n            if (node.type === \"TryStatement\" && node.handler) {\n                const catchToken = sourceCode.getFirstToken(node.handler);\n\n                checkNodeIndent(catchToken, neededIndent);\n            }\n\n            if (node.type === \"TryStatement\" && node.finalizer) {\n                const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n\n                checkNodeIndent(finallyToken, neededIndent);\n            }\n\n            if (node.type === \"DoWhileStatement\") {\n                const whileToken = sourceCode.getTokenAfter(node.body);\n\n                checkNodeIndent(whileToken, neededIndent);\n            }\n        }\n\n        /**\n         * Check indent for nodes list\n         * @param {ASTNode[]} nodes list of node objects\n         * @param {int} indent needed indent\n         * @returns {void}\n         */\n        function checkNodesIndent(nodes, indent) {\n            nodes.forEach(node => checkNodeIndent(node, indent));\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * @param {ASTNode} node Node to examine\n         * @param {int} lastLineIndent needed indent\n         * @returns {void}\n         */\n        function checkLastNodeLineIndent(node, lastLineIndent) {\n            const lastToken = sourceCode.getLastToken(node);\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n                report(\n                    node,\n                    lastLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent first line needed indent\n         * @returns {void}\n         */\n        function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n\n            /*\n             * in case if return statement ends with ');' we have traverse back to ')'\n             * otherwise we'll measure indent for ';' and replace ')'\n             */\n            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n            if (textBeforeClosingParenthesis.trim()) {\n\n                // There are tokens before the closing paren, don't report this case\n                return;\n            }\n\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if (endIndent.goodChar !== firstLineIndent) {\n                report(\n                    node,\n                    firstLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check first node line indent is correct\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent needed indent\n         * @returns {void}\n         */\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\n            const startIndent = getNodeIndent(node, false);\n\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent.space,\n                    startIndent.tab,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n\n        /**\n         * Returns a parent node of given node based on a specified type\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @param {string} type type that is being looked for\n         * @param {string} stopAtList end points for the evaluating code\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getParentNodeByType(node, type, stopAtList) {\n            let parent = node.parent;\n            const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n            while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n                parent = parent.parent;\n            }\n\n            return parent.type === type ? parent : null;\n        }\n\n        /**\n         * Returns the VariableDeclarator based on the current node\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getVariableDeclaratorNode(node) {\n            return getParentNodeByType(node, \"VariableDeclarator\");\n        }\n\n        /**\n         * Check to see if the node is part of the multi-line variable declaration.\n         * Also if its on the same line as the varNode\n         * @param {ASTNode} node node to check\n         * @param {ASTNode} varNode variable declaration node to check against\n         * @returns {boolean} True if all the above condition satisfy\n         */\n        function isNodeInVarOnTop(node, varNode) {\n            return varNode &&\n                varNode.parent.loc.start.line === node.loc.start.line &&\n                varNode.parent.declarations.length > 1;\n        }\n\n        /**\n         * Check to see if the argument before the callee node is multi-line and\n         * there should only be 1 argument before the callee node\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if arguments are multi-line\n         */\n        function isArgBeforeCalleeNodeMultiline(node) {\n            const parent = node.parent;\n\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n            const parent = node.parent;\n            let stmt = parent.parent;\n\n            /*\n             * Verify that the node is an IIEF\n             */\n            if (\n                parent.type !== \"CallExpression\" ||\n                parent.callee !== node) {\n\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIEF is outer\n             */\n            while (\n                stmt.type === \"UnaryExpression\" && (\n                    stmt.operator === \"!\" ||\n                    stmt.operator === \"~\" ||\n                    stmt.operator === \"+\" ||\n                    stmt.operator === \"-\") ||\n                stmt.type === \"AssignmentExpression\" ||\n                stmt.type === \"LogicalExpression\" ||\n                stmt.type === \"SequenceExpression\" ||\n                stmt.type === \"VariableDeclarator\") {\n\n                stmt = stmt.parent;\n            }\n\n            return ((\n                stmt.type === \"ExpressionStatement\" ||\n                stmt.type === \"VariableDeclaration\") &&\n                stmt.parent && stmt.parent.type === \"Program\"\n            );\n        }\n\n        /**\n         * Check indent for function block content\n         * @param {ASTNode} node A BlockStatement node that is inside of a function.\n         * @returns {void}\n         */\n        function checkIndentInFunctionBlock(node) {\n\n            /*\n             * Search first caller in chain.\n             * Ex.:\n             *\n             * Models <- Identifier\n             *   .User\n             *   .find()\n             *   .exec(function() {\n             *   // function body\n             * });\n             *\n             * Looks for 'Models'\n             */\n            const calleeNode = node.parent; // FunctionExpression\n            let indent;\n\n            if (calleeNode.parent &&\n                (calleeNode.parent.type === \"Property\" ||\n                calleeNode.parent.type === \"ArrayExpression\")) {\n\n                // If function is part of array or object, comma can be put at left\n                indent = getNodeIndent(calleeNode, false).goodChar;\n            } else {\n\n                // If function is standalone, simple calculate indent\n                indent = getNodeIndent(calleeNode).goodChar;\n            }\n\n            if (calleeNode.parent.type === \"CallExpression\") {\n                const calleeParent = calleeNode.parent;\n\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                } else {\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\n                        !isNodeFirstInLine(calleeNode)) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                }\n            }\n\n            /*\n             * function body indent should be indent + indent size, unless this\n             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n             */\n            let functionOffset = indentSize;\n\n            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n                functionOffset = options.outerIIFEBody * indentSize;\n            } else if (calleeNode.type === \"FunctionExpression\") {\n                functionOffset = options.FunctionExpression.body * indentSize;\n            } else if (calleeNode.type === \"FunctionDeclaration\") {\n                functionOffset = options.FunctionDeclaration.body * indentSize;\n            }\n            indent += functionOffset;\n\n            // check if the node is inside a variable\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            if (node.body.length > 0) {\n                checkNodesIndent(node.body, indent);\n            }\n\n            checkLastNodeLineIndent(node, indent - functionOffset);\n        }\n\n\n        /**\n         * Checks if the given node starts and ends on the same line\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\n         */\n        function isSingleLineNode(node) {\n            const lastToken = sourceCode.getLastToken(node),\n                startLine = node.loc.start.line,\n                endLine = lastToken.loc.end.line;\n\n            return startLine === endLine;\n        }\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInArrayOrObjectBlock(node) {\n\n            // Skip inline\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            let elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n            elements = elements.filter(elem => elem !== null);\n\n            let nodeIndent;\n            let elementsIndent;\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            // TODO - come up with a better strategy in future\n            if (isNodeFirstInLine(node)) {\n                const parent = node.parent;\n\n                nodeIndent = getNodeIndent(parent).goodChar;\n                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n                        } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n                            const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n                            if (parentElements[0] &&\n                                    parentElements[0].loc.start.line === parent.loc.start.line &&\n                                    parentElements[0].loc.end.line !== parent.loc.start.line) {\n\n                                /*\n                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                                 * e.g. [{\n                                 *        foo: 1\n                                 *      },\n                                 *      {\n                                 *        bar: 1\n                                 *      }]\n                                 * the second object is not indented.\n                                 */\n                            } else if (typeof options[parent.type] === \"number\") {\n                                nodeIndent += options[parent.type] * indentSize;\n                            } else {\n                                nodeIndent = parentElements[0].loc.start.column;\n                            }\n                        } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n                            if (typeof options.CallExpression.arguments === \"number\") {\n                                nodeIndent += options.CallExpression.arguments * indentSize;\n                            } else if (options.CallExpression.arguments === \"first\") {\n                                if (parent.arguments.indexOf(node) !== -1) {\n                                    nodeIndent = parent.arguments[0].loc.start.column;\n                                }\n                            } else {\n                                nodeIndent += indentSize;\n                            }\n                        } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n                            nodeIndent += indentSize;\n                        }\n                    }\n                }\n\n                checkFirstNodeLineIndent(node, nodeIndent);\n            } else {\n                nodeIndent = getNodeIndent(node).goodChar;\n            }\n\n            if (options[node.type] === \"first\") {\n                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n            } else {\n                elementsIndent = nodeIndent + indentSize * options[node.type];\n            }\n\n            /*\n             * Check if the node is a multiple variable declaration; if so, then\n             * make sure indentation takes that into account.\n             */\n            if (isNodeInVarOnTop(node, parentVarNode)) {\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            checkNodesIndent(elements, elementsIndent);\n\n            if (elements.length > 0) {\n\n                // Skip last block line check if last item in same line\n                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n                    return;\n                }\n            }\n\n            checkLastNodeLineIndent(node, nodeIndent +\n                (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n        }\n\n        /**\n         * Check if the node or node body is a BlockStatement or not\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if it or its body is a block statement\n         */\n        function isNodeBodyBlock(node) {\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\n                (node.consequent && node.consequent.type === \"BlockStatement\");\n        }\n\n        /**\n         * Check indentation for blocks\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function blockIndentationCheck(node) {\n\n            // Skip inline blocks\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            if (node.parent && (\n                node.parent.type === \"FunctionExpression\" ||\n                node.parent.type === \"FunctionDeclaration\" ||\n                node.parent.type === \"ArrowFunctionExpression\")\n            ) {\n                checkIndentInFunctionBlock(node);\n                return;\n            }\n\n            let indent;\n            let nodesToCheck = [];\n\n            /*\n             * For this statements we should check indent from statement beginning,\n             * not from the beginning of the block.\n             */\n            const statementsWithProperties = [\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"\n            ];\n\n            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n                indent = getNodeIndent(node.parent).goodChar;\n            } else if (node.parent && node.parent.type === \"CatchClause\") {\n                indent = getNodeIndent(node.parent.parent).goodChar;\n            } else {\n                indent = getNodeIndent(node).goodChar;\n            }\n\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n                nodesToCheck = [node.consequent];\n            } else if (Array.isArray(node.body)) {\n                nodesToCheck = node.body;\n            } else {\n                nodesToCheck = [node.body];\n            }\n\n            if (nodesToCheck.length > 0) {\n                checkNodesIndent(nodesToCheck, indent + indentSize);\n            }\n\n            if (node.type === \"BlockStatement\") {\n                checkLastNodeLineIndent(node, indent);\n            }\n        }\n\n        /**\n         * Filter out the elements which are on the same line of each other or the node.\n         * basically have only 1 elements from each line except the variable declaration line.\n         * @param {ASTNode} node Variable declaration node\n         * @returns {ASTNode[]} Filtered elements\n         */\n        function filterOutSameLineVars(node) {\n            return node.declarations.reduce((finalCollection, elem) => {\n                const lastElem = finalCollection[finalCollection.length - 1];\n\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\n                    finalCollection.push(elem);\n                }\n\n                return finalCollection;\n            }, []);\n        }\n\n        /**\n         * Check indentation for variable declarations\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInVariableDeclarations(node) {\n            const elements = filterOutSameLineVars(node);\n            const nodeIndent = getNodeIndent(node).goodChar;\n            const lastElement = elements[elements.length - 1];\n\n            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n\n            checkNodesIndent(elements, elementsIndent);\n\n            // Only check the last line if there is any token after the last item\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n                return;\n            }\n\n            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n            if (tokenBeforeLastElement.value === \",\") {\n\n                // Special case for comma-first syntax where the semicolon is indented\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n            } else {\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\n            }\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function blockLessNodes(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                blockIndentationCheck(node);\n            }\n        }\n\n        /**\n         * Returns the expected indentation for the case statement\n         * @param {ASTNode} node node to examine\n         * @param {int} [providedSwitchIndent] indent for switch statement\n         * @returns {int} indent size\n         */\n        function expectedCaseIndent(node, providedSwitchIndent) {\n            const switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n            const switchIndent = typeof providedSwitchIndent === \"undefined\"\n                ? getNodeIndent(switchNode).goodChar\n                : providedSwitchIndent;\n            let caseIndent;\n\n            if (caseIndentStore[switchNode.loc.start.line]) {\n                return caseIndentStore[switchNode.loc.start.line];\n            }\n\n            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n                caseIndent = switchIndent;\n            } else {\n                caseIndent = switchIndent + (indentSize * options.SwitchCase);\n            }\n\n            caseIndentStore[switchNode.loc.start.line] = caseIndent;\n            return caseIndent;\n\n        }\n\n        /**\n         * Checks whether a return statement is wrapped in ()\n         * @param {ASTNode} node node to examine\n         * @returns {boolean} the result\n         */\n        function isWrappedInParenthesis(node) {\n            const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n\n            const statementWithoutArgument = sourceCode.getText(node).replace(\n                sourceCode.getText(node.argument), \"\"\n            );\n\n            return regex.test(statementWithoutArgument);\n        }\n\n        return {\n            Program(node) {\n                if (node.body.length > 0) {\n\n                    // Root nodes should have no indent\n                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n                }\n            },\n\n            ClassBody: blockIndentationCheck,\n\n            BlockStatement: blockIndentationCheck,\n\n            WhileStatement: blockLessNodes,\n\n            ForStatement: blockLessNodes,\n\n            ForInStatement: blockLessNodes,\n\n            ForOfStatement: blockLessNodes,\n\n            DoWhileStatement: blockLessNodes,\n\n            IfStatement(node) {\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n                    blockIndentationCheck(node);\n                }\n            },\n\n            VariableDeclaration(node) {\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n                    checkIndentInVariableDeclarations(node);\n                }\n            },\n\n            ObjectExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            ArrayExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            MemberExpression(node) {\n\n                if (typeof options.MemberExpression === \"undefined\") {\n                    return;\n                }\n\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                /*\n                 * The typical layout of variable declarations and assignments\n                 * alter the expectation of correct indentation. Skip them.\n                 * TODO: Add appropriate configuration options for variable\n                 * declarations and assignments.\n                 */\n                if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    return;\n                }\n\n                if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n                    return;\n                }\n\n                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n\n                const checkNodes = [node.property];\n\n                const dot = sourceCode.getTokenBefore(node.property);\n\n                if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                    checkNodes.push(dot);\n                }\n\n                checkNodesIndent(checkNodes, propertyIndent);\n            },\n\n            SwitchStatement(node) {\n\n                // Switch is not a 'BlockStatement'\n                const switchIndent = getNodeIndent(node).goodChar;\n                const caseIndent = expectedCaseIndent(node, switchIndent);\n\n                checkNodesIndent(node.cases, caseIndent);\n\n\n                checkLastNodeLineIndent(node, switchIndent);\n            },\n\n            SwitchCase(node) {\n\n                // Skip inline cases\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                const caseIndent = expectedCaseIndent(node);\n\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\n            },\n\n            FunctionDeclaration(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionDeclaration.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n                }\n            },\n\n            FunctionExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionExpression.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n                }\n            },\n\n            ReturnStatement(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                const firstLineIndent = getNodeIndent(node).goodChar;\n\n                // in case if return statement is wrapped in parenthesis\n                if (isWrappedInParenthesis(node)) {\n                    checkLastReturnStatementLineIndent(node, firstLineIndent);\n                } else {\n                    checkNodeIndent(node, firstLineIndent);\n                }\n            },\n\n            CallExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n                } else if (options.CallExpression.arguments !== null) {\n                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n                }\n            }\n\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}