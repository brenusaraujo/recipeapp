{"ast":null,"code":"/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\n\n\nfunction isFunctionName(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow named `function` expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-names\"\n    },\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always\", \"as-needed\", \"never\"]\n        }\n      },\n      items: [{\n        $ref: \"#/definitions/value\"\n      }, {\n        type: \"object\",\n        properties: {\n          generators: {\n            $ref: \"#/definitions/value\"\n          }\n        },\n        additionalProperties: false\n      }]\n    },\n    messages: {\n      unnamed: \"Unexpected unnamed {{name}}.\",\n      named: \"Unexpected named {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Returns the config option for the given node.\n     * @param {ASTNode} node A node to get the config for.\n     * @returns {string} The config option.\n     */\n\n    function getConfigForNode(node) {\n      if (node.generator && context.options.length > 1 && context.options[1].generators) {\n        return context.options[1].generators;\n      }\n\n      return context.options[0] || \"always\";\n    }\n    /**\n     * Determines whether the current FunctionExpression node is a get, set, or\n     * shorthand method in an object literal or a class.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node is a get, set, or shorthand method.\n     */\n\n\n    function isObjectOrClassMethod(node) {\n      const parent = node.parent;\n      return parent.type === \"MethodDefinition\" || parent.type === \"Property\" && (parent.method || parent.kind === \"get\" || parent.kind === \"set\");\n    }\n    /**\n     * Determines whether the current FunctionExpression node has a name that would be\n     * inferred from context in a conforming ES6 environment.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node would have a name assigned automatically.\n     */\n\n\n    function hasInferredName(node) {\n      const parent = node.parent;\n      return isObjectOrClassMethod(node) || parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node || parent.type === \"Property\" && parent.value === node || parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node || parent.type === \"AssignmentPattern\" && parent.left.type === \"Identifier\" && parent.right === node;\n    }\n    /**\n     * Reports that an unnamed function should be named\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @returns {void}\n     */\n\n\n    function reportUnexpectedUnnamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"unnamed\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n    /**\n     * Reports that a named function should be unnamed\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @returns {void}\n     */\n\n\n    function reportUnexpectedNamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"named\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n    /**\n     * The listener for function nodes.\n     * @param {ASTNode} node function node\n     * @returns {void}\n     */\n\n\n    function handleFunction(node) {\n      // Skip recursive functions.\n      const nameVar = context.getDeclaredVariables(node)[0];\n\n      if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n        return;\n      }\n\n      const hasName = Boolean(node.id && node.id.name);\n      const config = getConfigForNode(node);\n\n      if (config === \"never\") {\n        if (hasName && node.type !== \"FunctionDeclaration\") {\n          reportUnexpectedNamedFunction(node);\n        }\n      } else if (config === \"as-needed\") {\n        if (!hasName && !hasInferredName(node)) {\n          reportUnexpectedUnnamedFunction(node);\n        }\n      } else {\n        if (!hasName && !isObjectOrClassMethod(node)) {\n          reportUnexpectedUnnamedFunction(node);\n        }\n      }\n    }\n\n    return {\n      \"FunctionExpression:exit\": handleFunction,\n      \"ExportDefaultDeclaration > FunctionDeclaration\": handleFunction\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isFunctionName","variable","defs","type","module","exports","meta","docs","description","category","recommended","url","schema","definitions","value","enum","items","$ref","properties","generators","additionalProperties","messages","unnamed","named","create","context","sourceCode","getSourceCode","getConfigForNode","node","generator","options","length","isObjectOrClassMethod","parent","method","kind","hasInferredName","id","init","left","right","reportUnexpectedUnnamedFunction","report","messageId","loc","getFunctionHeadLoc","data","name","getFunctionNameWithKind","reportUnexpectedNamedFunction","handleFunction","nameVar","getDeclaredVariables","references","hasName","Boolean","config"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/func-names.js"],"sourcesContent":["/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow named `function` expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-names\"\n        },\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always\",\n                        \"as-needed\",\n                        \"never\"\n                    ]\n                }\n            },\n            items: [\n                {\n                    $ref: \"#/definitions/value\"\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        generators: {\n                            $ref: \"#/definitions/value\"\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        },\n\n        messages: {\n            unnamed: \"Unexpected unnamed {{name}}.\",\n            named: \"Unexpected named {{name}}.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the config option for the given node.\n         * @param {ASTNode} node A node to get the config for.\n         * @returns {string} The config option.\n         */\n        function getConfigForNode(node) {\n            if (\n                node.generator &&\n                context.options.length > 1 &&\n                context.options[1].generators\n            ) {\n                return context.options[1].generators;\n            }\n\n            return context.options[0] || \"always\";\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node is a get, set, or\n         * shorthand method in an object literal or a class.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is a get, set, or shorthand method.\n         */\n        function isObjectOrClassMethod(node) {\n            const parent = node.parent;\n\n            return (parent.type === \"MethodDefinition\" || (\n                parent.type === \"Property\" && (\n                    parent.method ||\n                    parent.kind === \"get\" ||\n                    parent.kind === \"set\"\n                )\n            ));\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node has a name that would be\n         * inferred from context in a conforming ES6 environment.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node would have a name assigned automatically.\n         */\n        function hasInferredName(node) {\n            const parent = node.parent;\n\n            return isObjectOrClassMethod(node) ||\n                (parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node) ||\n                (parent.type === \"Property\" && parent.value === node) ||\n                (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node) ||\n                (parent.type === \"AssignmentPattern\" && parent.left.type === \"Identifier\" && parent.right === node);\n        }\n\n        /**\n         * Reports that an unnamed function should be named\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedUnnamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"unnamed\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * Reports that a named function should be unnamed\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedNamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"named\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * The listener for function nodes.\n         * @param {ASTNode} node function node\n         * @returns {void}\n         */\n        function handleFunction(node) {\n\n            // Skip recursive functions.\n            const nameVar = context.getDeclaredVariables(node)[0];\n\n            if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                return;\n            }\n\n            const hasName = Boolean(node.id && node.id.name);\n            const config = getConfigForNode(node);\n\n            if (config === \"never\") {\n                if (hasName && node.type !== \"FunctionDeclaration\") {\n                    reportUnexpectedNamedFunction(node);\n                }\n            } else if (config === \"as-needed\") {\n                if (!hasName && !hasInferredName(node)) {\n                    reportUnexpectedUnnamedFunction(node);\n                }\n            } else {\n                if (!hasName && !isObjectOrClassMethod(node)) {\n                    reportUnexpectedUnnamedFunction(node);\n                }\n            }\n        }\n\n        return {\n            \"FunctionExpression:exit\": handleFunction,\n            \"ExportDefaultDeclaration > FunctionDeclaration\": handleFunction\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}