{"ast":null,"code":"/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst importFresh = require(\"import-fresh\");\n\nconst stripComments = require(\"strip-json-comments\");\n\nconst ConfigValidator = require(\"./shared/config-validator\");\n\nconst naming = require(\"./shared/naming\");\n\nconst ModuleResolver = require(\"./shared/relative-module-resolver\");\n\nconst {\n  ConfigArray,\n  ConfigDependency,\n  IgnorePattern,\n  OverrideTester\n} = require(\"./config-array\");\n\nconst debug = require(\"debug\")(\"eslintrc:config-array-factory\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst configFilenames = [\".eslintrc.js\", \".eslintrc.cjs\", \".eslintrc.yaml\", \".eslintrc.yml\", \".eslintrc.json\", \".eslintrc\", \"package.json\"]; // Define types for VSCode IntelliSense.\n\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"./shared/types\").OverrideConfigData} OverrideConfigData */\n\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {string} pluginBasePath The base path to resolve plugins.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\n\nconst internalSlotsMap = new WeakMap();\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\n\nfunction isFilePath(nameOrPath) {\n  return /^\\.{1,2}[/\\\\]/u.test(nameOrPath) || path.isAbsolute(nameOrPath);\n}\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\n\n\nfunction readFile(filePath) {\n  return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadYAMLConfigFile(filePath) {\n  debug(`Loading YAML config file: ${filePath}`); // lazy load YAML to improve performance when not used\n\n  const yaml = require(\"js-yaml\");\n\n  try {\n    // empty YAML file can be null, so always use\n    return yaml.safeLoad(readFile(filePath)) || {};\n  } catch (e) {\n    debug(`Error reading YAML file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadJSONConfigFile(filePath) {\n  debug(`Loading JSON config file: ${filePath}`);\n\n  try {\n    return JSON.parse(stripComments(readFile(filePath)));\n  } catch (e) {\n    debug(`Error reading JSON file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    e.messageTemplate = \"failed-to-read-json\";\n    e.messageData = {\n      path: filePath,\n      message: e.message\n    };\n    throw e;\n  }\n}\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadLegacyConfigFile(filePath) {\n  debug(`Loading legacy config file: ${filePath}`); // lazy load YAML to improve performance when not used\n\n  const yaml = require(\"js-yaml\");\n\n  try {\n    return yaml.safeLoad(stripComments(readFile(filePath))) ||\n    /* istanbul ignore next */\n    {};\n  } catch (e) {\n    debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadJSConfigFile(filePath) {\n  debug(`Loading JS config file: ${filePath}`);\n\n  try {\n    return importFresh(filePath);\n  } catch (e) {\n    debug(`Error reading JavaScript file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadPackageJSONConfigFile(filePath) {\n  debug(`Loading package.json config file: ${filePath}`);\n\n  try {\n    const packageData = loadJSONConfigFile(filePath);\n\n    if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n      throw Object.assign(new Error(\"package.json file doesn't have 'eslintConfig' field.\"), {\n        code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\"\n      });\n    }\n\n    return packageData.eslintConfig;\n  } catch (e) {\n    debug(`Error reading package.json file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\n\n\nfunction loadESLintIgnoreFile(filePath) {\n  debug(`Loading .eslintignore file: ${filePath}`);\n\n  try {\n    return readFile(filePath).split(/\\r?\\n/gu).filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n  } catch (e) {\n    debug(`Error reading .eslintignore file: ${filePath}`);\n    e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @param {string} messageTemplate The text template to source error strings from.\n * @returns {Error} The error object to throw\n * @private\n */\n\n\nfunction configInvalidError(configName, importerName, messageTemplate) {\n  return Object.assign(new Error(`Failed to load config \"${configName}\" to extend from.`), {\n    messageTemplate,\n    messageData: {\n      configName,\n      importerName\n    }\n  });\n}\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\n\n\nfunction loadConfigFile(filePath) {\n  switch (path.extname(filePath)) {\n    case \".js\":\n    case \".cjs\":\n      return loadJSConfigFile(filePath);\n\n    case \".json\":\n      if (path.basename(filePath) === \"package.json\") {\n        return loadPackageJSONConfigFile(filePath);\n      }\n\n      return loadJSONConfigFile(filePath);\n\n    case \".yaml\":\n    case \".yml\":\n      return loadYAMLConfigFile(filePath);\n\n    default:\n      return loadLegacyConfigFile(filePath);\n  }\n}\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\n\n\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n  /* istanbul ignore next */\n  if (debug.enabled) {\n    let nameAndVersion = null;\n\n    try {\n      const packageJsonPath = ModuleResolver.resolve(`${request}/package.json`, relativeTo);\n\n      const {\n        version = \"unknown\"\n      } = require(packageJsonPath);\n\n      nameAndVersion = `${request}@${version}`;\n    } catch (error) {\n      debug(\"package.json was not found:\", error.message);\n      nameAndVersion = request;\n    }\n\n    debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n  }\n}\n/**\n * Create a new context with default values.\n * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.\n * @param {\"config\" | \"ignore\" | \"implicit-processor\" | undefined} providedType The type of the current configuration. Default is `\"config\"`.\n * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.\n * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.\n * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.\n * @returns {ConfigArrayFactoryLoadingContext} The created context.\n */\n\n\nfunction createContext(_ref, providedType, providedName, providedFilePath, providedMatchBasePath) {\n  let {\n    cwd,\n    resolvePluginsRelativeTo\n  } = _ref;\n  const filePath = providedFilePath ? path.resolve(cwd, providedFilePath) : \"\";\n  const matchBasePath = providedMatchBasePath && path.resolve(cwd, providedMatchBasePath) || filePath && path.dirname(filePath) || cwd;\n  const name = providedName || filePath && path.relative(cwd, filePath) || \"\";\n  const pluginBasePath = resolvePluginsRelativeTo || filePath && path.dirname(filePath) || cwd;\n  const type = providedType || \"config\";\n  return {\n    filePath,\n    matchBasePath,\n    name,\n    pluginBasePath,\n    type\n  };\n}\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\n\n\nfunction normalizePlugin(plugin) {\n  return {\n    configs: plugin.configs || {},\n    environments: plugin.environments || {},\n    processors: plugin.processors || {},\n    rules: plugin.rules || {}\n  };\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\n\n\nclass ConfigArrayFactory {\n  /**\n   * Initialize this instance.\n   * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n   */\n  constructor() {\n    let {\n      additionalPluginPool = new Map(),\n      cwd = process.cwd(),\n      resolvePluginsRelativeTo,\n      builtInRules,\n      resolver = ModuleResolver,\n      eslintAllPath,\n      eslintRecommendedPath\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    internalSlotsMap.set(this, {\n      additionalPluginPool,\n      cwd,\n      resolvePluginsRelativeTo: resolvePluginsRelativeTo && path.resolve(cwd, resolvePluginsRelativeTo),\n      builtInRules,\n      resolver,\n      eslintAllPath,\n      eslintRecommendedPath\n    });\n  }\n  /**\n   * Create `ConfigArray` instance from a config data.\n   * @param {ConfigData|null} configData The config data to create.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.filePath] The path to this config data.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config.\n   */\n\n\n  create(configData) {\n    let {\n      basePath,\n      filePath,\n      name\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!configData) {\n      return new ConfigArray();\n    }\n\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"config\", name, filePath, basePath);\n\n    const elements = this._normalizeConfigData(configData, ctx);\n\n    return new ConfigArray(...elements);\n  }\n  /**\n   * Load a config file.\n   * @param {string} filePath The path to a config file.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config.\n   */\n\n\n  loadFile(filePath) {\n    let {\n      basePath,\n      name\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"config\", name, filePath, basePath);\n    return new ConfigArray(...this._loadConfigData(ctx));\n  }\n  /**\n   * Load the config file on a given directory if exists.\n   * @param {string} directoryPath The path to a directory.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n\n\n  loadInDirectory(directoryPath) {\n    let {\n      basePath,\n      name\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const slots = internalSlotsMap.get(this);\n\n    for (const filename of configFilenames) {\n      const ctx = createContext(slots, \"config\", name, path.join(directoryPath, filename), basePath);\n\n      if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {\n        let configData;\n\n        try {\n          configData = loadConfigFile(ctx.filePath);\n        } catch (error) {\n          if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n            throw error;\n          }\n        }\n\n        if (configData) {\n          debug(`Config file found: ${ctx.filePath}`);\n          return new ConfigArray(...this._normalizeConfigData(configData, ctx));\n        }\n      }\n    }\n\n    debug(`Config file not found on ${directoryPath}`);\n    return new ConfigArray();\n  }\n  /**\n   * Check if a config file on a given directory exists or not.\n   * @param {string} directoryPath The path to a directory.\n   * @returns {string | null} The path to the found config file. If not found then null.\n   */\n\n\n  static getPathToConfigFileInDirectory(directoryPath) {\n    for (const filename of configFilenames) {\n      const filePath = path.join(directoryPath, filename);\n\n      if (fs.existsSync(filePath)) {\n        if (filename === \"package.json\") {\n          try {\n            loadPackageJSONConfigFile(filePath);\n            return filePath;\n          } catch {\n            /* ignore */\n          }\n        } else {\n          return filePath;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Load `.eslintignore` file.\n   * @param {string} filePath The path to a `.eslintignore` file to load.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n\n\n  loadESLintIgnore(filePath) {\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"ignore\", void 0, filePath, slots.cwd);\n    const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);\n    return new ConfigArray(...this._normalizeESLintIgnoreData(ignorePatterns, ctx));\n  }\n  /**\n   * Load `.eslintignore` file in the current working directory.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n\n\n  loadDefaultESLintIgnore() {\n    const slots = internalSlotsMap.get(this);\n    const eslintIgnorePath = path.resolve(slots.cwd, \".eslintignore\");\n    const packageJsonPath = path.resolve(slots.cwd, \"package.json\");\n\n    if (fs.existsSync(eslintIgnorePath)) {\n      return this.loadESLintIgnore(eslintIgnorePath);\n    }\n\n    if (fs.existsSync(packageJsonPath)) {\n      const data = loadJSONConfigFile(packageJsonPath);\n\n      if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n        if (!Array.isArray(data.eslintIgnore)) {\n          throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n        }\n\n        const ctx = createContext(slots, \"ignore\", \"eslintIgnore in package.json\", packageJsonPath, slots.cwd);\n        return new ConfigArray(...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx));\n      }\n    }\n\n    return new ConfigArray();\n  }\n  /**\n   * Load a given config file.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n   * @private\n   */\n\n\n  _loadConfigData(ctx) {\n    return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);\n  }\n  /**\n   * Normalize a given `.eslintignore` data to config array elements.\n   * @param {string[]} ignorePatterns The patterns to ignore files.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  *_normalizeESLintIgnoreData(ignorePatterns, ctx) {\n    const elements = this._normalizeObjectConfigData({\n      ignorePatterns\n    }, ctx); // Set `ignorePattern.loose` flag for backward compatibility.\n\n\n    for (const element of elements) {\n      if (element.ignorePattern) {\n        element.ignorePattern.loose = true;\n      }\n\n      yield element;\n    }\n  }\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _normalizeConfigData(configData, ctx) {\n    const validator = new ConfigValidator();\n    validator.validateConfigSchema(configData, ctx.name || ctx.filePath);\n    return this._normalizeObjectConfigData(configData, ctx);\n  }\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  *_normalizeObjectConfigData(configData, ctx) {\n    const {\n      files,\n      excludedFiles,\n      ...configBody\n    } = configData;\n    const criteria = OverrideTester.create(files, excludedFiles, ctx.matchBasePath);\n\n    const elements = this._normalizeObjectConfigDataBody(configBody, ctx); // Apply the criteria to every element.\n\n\n    for (const element of elements) {\n      /*\n       * Merge the criteria.\n       * This is for the `overrides` entries that came from the\n       * configurations of `overrides[].extends`.\n       */\n      element.criteria = OverrideTester.and(criteria, element.criteria);\n      /*\n       * Remove `root` property to ignore `root` settings which came from\n       * `extends` in `overrides`.\n       */\n\n      if (element.criteria) {\n        element.root = void 0;\n      }\n\n      yield element;\n    }\n  }\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  *_normalizeObjectConfigDataBody(_ref2, ctx) {\n    let {\n      env,\n      extends: extend,\n      globals,\n      ignorePatterns,\n      noInlineConfig,\n      parser: parserName,\n      parserOptions,\n      plugins: pluginList,\n      processor,\n      reportUnusedDisableDirectives,\n      root,\n      rules,\n      settings,\n      overrides: overrideList = []\n    } = _ref2;\n    const extendList = Array.isArray(extend) ? extend : [extend];\n    const ignorePattern = ignorePatterns && new IgnorePattern(Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns], ctx.matchBasePath); // Flatten `extends`.\n\n    for (const extendName of extendList.filter(Boolean)) {\n      yield* this._loadExtends(extendName, ctx);\n    } // Load parser & plugins.\n\n\n    const parser = parserName && this._loadParser(parserName, ctx);\n\n    const plugins = pluginList && this._loadPlugins(pluginList, ctx); // Yield pseudo config data for file extension processors.\n\n\n    if (plugins) {\n      yield* this._takeFileExtensionProcessors(plugins, ctx);\n    } // Yield the config data except `extends` and `overrides`.\n\n\n    yield {\n      // Debug information.\n      type: ctx.type,\n      name: ctx.name,\n      filePath: ctx.filePath,\n      // Config data.\n      criteria: null,\n      env,\n      globals,\n      ignorePattern,\n      noInlineConfig,\n      parser,\n      parserOptions,\n      plugins,\n      processor,\n      reportUnusedDisableDirectives,\n      root,\n      rules,\n      settings\n    }; // Flatten `overries`.\n\n    for (let i = 0; i < overrideList.length; ++i) {\n      yield* this._normalizeObjectConfigData(overrideList[i], { ...ctx,\n        name: `${ctx.name}#overrides[${i}]`\n      });\n    }\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtends(extendName, ctx) {\n    debug(\"Loading {extends:%j} relative to %s\", extendName, ctx.filePath);\n\n    try {\n      if (extendName.startsWith(\"eslint:\")) {\n        return this._loadExtendedBuiltInConfig(extendName, ctx);\n      }\n\n      if (extendName.startsWith(\"plugin:\")) {\n        return this._loadExtendedPluginConfig(extendName, ctx);\n      }\n\n      return this._loadExtendedShareableConfig(extendName, ctx);\n    } catch (error) {\n      error.message += `\\nReferenced from: ${ctx.filePath || ctx.name}`;\n      throw error;\n    }\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtendedBuiltInConfig(extendName, ctx) {\n    const {\n      eslintAllPath,\n      eslintRecommendedPath\n    } = internalSlotsMap.get(this);\n\n    if (extendName === \"eslint:recommended\") {\n      return this._loadConfigData({ ...ctx,\n        filePath: eslintRecommendedPath,\n        name: `${ctx.name} » ${extendName}`\n      });\n    }\n\n    if (extendName === \"eslint:all\") {\n      return this._loadConfigData({ ...ctx,\n        filePath: eslintAllPath,\n        name: `${ctx.name} » ${extendName}`\n      });\n    }\n\n    throw configInvalidError(extendName, ctx.name, \"extend-config-missing\");\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtendedPluginConfig(extendName, ctx) {\n    const slashIndex = extendName.lastIndexOf(\"/\");\n\n    if (slashIndex === -1) {\n      throw configInvalidError(extendName, ctx.filePath, \"plugin-invalid\");\n    }\n\n    const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n    const configName = extendName.slice(slashIndex + 1);\n\n    if (isFilePath(pluginName)) {\n      throw new Error(\"'extends' cannot use a file path for plugins.\");\n    }\n\n    const plugin = this._loadPlugin(pluginName, ctx);\n\n    const configData = plugin.definition && plugin.definition.configs[configName];\n\n    if (configData) {\n      return this._normalizeConfigData(configData, { ...ctx,\n        filePath: plugin.filePath || ctx.filePath,\n        name: `${ctx.name} » plugin:${plugin.id}/${configName}`\n      });\n    }\n\n    throw plugin.error || configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtendedShareableConfig(extendName, ctx) {\n    const {\n      cwd,\n      resolver\n    } = internalSlotsMap.get(this);\n    const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n    let request;\n\n    if (isFilePath(extendName)) {\n      request = extendName;\n    } else if (extendName.startsWith(\".\")) {\n      request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n    } else {\n      request = naming.normalizePackageName(extendName, \"eslint-config\");\n    }\n\n    let filePath;\n\n    try {\n      filePath = resolver.resolve(request, relativeTo);\n    } catch (error) {\n      /* istanbul ignore else */\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        throw configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n      }\n\n      throw error;\n    }\n\n    writeDebugLogForLoading(request, relativeTo, filePath);\n    return this._loadConfigData({ ...ctx,\n      filePath,\n      name: `${ctx.name} » ${request}`\n    });\n  }\n  /**\n   * Load given plugins.\n   * @param {string[]} names The plugin names to load.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {Record<string,DependentPlugin>} The loaded parser.\n   * @private\n   */\n\n\n  _loadPlugins(names, ctx) {\n    return names.reduce((map, name) => {\n      if (isFilePath(name)) {\n        throw new Error(\"Plugins array cannot includes file paths.\");\n      }\n\n      const plugin = this._loadPlugin(name, ctx);\n\n      map[plugin.id] = plugin;\n      return map;\n    }, {});\n  }\n  /**\n   * Load a given parser.\n   * @param {string} nameOrPath The package name or the path to a parser file.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {DependentParser} The loaded parser.\n   */\n\n\n  _loadParser(nameOrPath, ctx) {\n    debug(\"Loading parser %j from %s\", nameOrPath, ctx.filePath);\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n\n    try {\n      const filePath = ModuleResolver.resolve(nameOrPath, relativeTo);\n      writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n      return new ConfigDependency({\n        definition: require(filePath),\n        filePath,\n        id: nameOrPath,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    } catch (error) {\n      // If the parser name is \"espree\", load the espree of ESLint.\n      if (nameOrPath === \"espree\") {\n        debug(\"Fallback espree.\");\n        return new ConfigDependency({\n          definition: require(\"espree\"),\n          filePath: require.resolve(\"espree\"),\n          id: nameOrPath,\n          importerName: ctx.name,\n          importerPath: ctx.filePath\n        });\n      }\n\n      debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, ctx.name);\n      error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;\n      return new ConfigDependency({\n        error,\n        id: nameOrPath,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n  }\n  /**\n   * Load a given plugin.\n   * @param {string} name The plugin name to load.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {DependentPlugin} The loaded plugin.\n   * @private\n   */\n\n\n  _loadPlugin(name, ctx) {\n    debug(\"Loading plugin %j from %s\", name, ctx.filePath);\n    const {\n      additionalPluginPool\n    } = internalSlotsMap.get(this);\n    const request = naming.normalizePackageName(name, \"eslint-plugin\");\n    const id = naming.getShorthandName(request, \"eslint-plugin\");\n    const relativeTo = path.join(ctx.pluginBasePath, \"__placeholder__.js\");\n\n    if (name.match(/\\s+/u)) {\n      const error = Object.assign(new Error(`Whitespace found in plugin name '${name}'`), {\n        messageTemplate: \"whitespace-found\",\n        messageData: {\n          pluginName: request\n        }\n      });\n      return new ConfigDependency({\n        error,\n        id,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    } // Check for additional pool.\n\n\n    const plugin = additionalPluginPool.get(request) || additionalPluginPool.get(id);\n\n    if (plugin) {\n      return new ConfigDependency({\n        definition: normalizePlugin(plugin),\n        filePath: \"\",\n        // It's unknown where the plugin came from.\n        id,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n\n    let filePath;\n    let error;\n\n    try {\n      filePath = ModuleResolver.resolve(request, relativeTo);\n    } catch (resolveError) {\n      error = resolveError;\n      /* istanbul ignore else */\n\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        error.messageTemplate = \"plugin-missing\";\n        error.messageData = {\n          pluginName: request,\n          resolvePluginsRelativeTo: ctx.pluginBasePath,\n          importerName: ctx.name\n        };\n      }\n    }\n\n    if (filePath) {\n      try {\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        const startTime = Date.now();\n\n        const pluginDefinition = require(filePath);\n\n        debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n        return new ConfigDependency({\n          definition: normalizePlugin(pluginDefinition),\n          filePath,\n          id,\n          importerName: ctx.name,\n          importerPath: ctx.filePath\n        });\n      } catch (loadError) {\n        error = loadError;\n      }\n    }\n\n    debug(\"Failed to load plugin '%s' declared in '%s'.\", name, ctx.name);\n    error.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error.message}`;\n    return new ConfigDependency({\n      error,\n      id,\n      importerName: ctx.name,\n      importerPath: ctx.filePath\n    });\n  }\n  /**\n   * Take file expression processors as config array elements.\n   * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n   * @private\n   */\n\n\n  *_takeFileExtensionProcessors(plugins, ctx) {\n    for (const pluginId of Object.keys(plugins)) {\n      const processors = plugins[pluginId] && plugins[pluginId].definition && plugins[pluginId].definition.processors;\n\n      if (!processors) {\n        continue;\n      }\n\n      for (const processorId of Object.keys(processors)) {\n        if (processorId.startsWith(\".\")) {\n          yield* this._normalizeObjectConfigData({\n            files: [`*${processorId}`],\n            processor: `${pluginId}/${processorId}`\n          }, { ...ctx,\n            type: \"implicit-processor\",\n            name: `${ctx.name}#processors[\"${pluginId}/${processorId}\"]`\n          });\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports = {\n  ConfigArrayFactory,\n  createContext\n};","map":{"version":3,"names":["fs","require","path","importFresh","stripComments","ConfigValidator","naming","ModuleResolver","ConfigArray","ConfigDependency","IgnorePattern","OverrideTester","debug","configFilenames","internalSlotsMap","WeakMap","isFilePath","nameOrPath","test","isAbsolute","readFile","filePath","readFileSync","replace","loadYAMLConfigFile","yaml","safeLoad","e","message","loadJSONConfigFile","JSON","parse","messageTemplate","messageData","loadLegacyConfigFile","loadJSConfigFile","loadPackageJSONConfigFile","packageData","Object","hasOwnProperty","call","assign","Error","code","eslintConfig","loadESLintIgnoreFile","split","filter","line","trim","startsWith","configInvalidError","configName","importerName","loadConfigFile","extname","basename","writeDebugLogForLoading","request","relativeTo","enabled","nameAndVersion","packageJsonPath","resolve","version","error","createContext","providedType","providedName","providedFilePath","providedMatchBasePath","cwd","resolvePluginsRelativeTo","matchBasePath","dirname","name","relative","pluginBasePath","type","normalizePlugin","plugin","configs","environments","processors","rules","ConfigArrayFactory","constructor","additionalPluginPool","Map","process","builtInRules","resolver","eslintAllPath","eslintRecommendedPath","set","create","configData","basePath","slots","get","ctx","elements","_normalizeConfigData","loadFile","_loadConfigData","loadInDirectory","directoryPath","filename","join","existsSync","statSync","isFile","getPathToConfigFileInDirectory","loadESLintIgnore","ignorePatterns","_normalizeESLintIgnoreData","loadDefaultESLintIgnore","eslintIgnorePath","data","Array","isArray","eslintIgnore","_normalizeObjectConfigData","element","ignorePattern","loose","validator","validateConfigSchema","files","excludedFiles","configBody","criteria","_normalizeObjectConfigDataBody","and","root","env","extends","extend","globals","noInlineConfig","parser","parserName","parserOptions","plugins","pluginList","processor","reportUnusedDisableDirectives","settings","overrides","overrideList","extendList","extendName","Boolean","_loadExtends","_loadParser","_loadPlugins","_takeFileExtensionProcessors","i","length","_loadExtendedBuiltInConfig","_loadExtendedPluginConfig","_loadExtendedShareableConfig","slashIndex","lastIndexOf","pluginName","slice","_loadPlugin","definition","id","normalizePackageName","names","reduce","map","importerPath","getShorthandName","match","resolveError","startTime","Date","now","pluginDefinition","loadError","pluginId","keys","processorId","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/@eslint/eslintrc/lib/config-array-factory.js"],"sourcesContent":["/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst importFresh = require(\"import-fresh\");\nconst stripComments = require(\"strip-json-comments\");\nconst ConfigValidator = require(\"./shared/config-validator\");\nconst naming = require(\"./shared/naming\");\nconst ModuleResolver = require(\"./shared/relative-module-resolver\");\nconst {\n    ConfigArray,\n    ConfigDependency,\n    IgnorePattern,\n    OverrideTester\n} = require(\"./config-array\");\nconst debug = require(\"debug\")(\"eslintrc:config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst configFilenames = [\n    \".eslintrc.js\",\n    \".eslintrc.cjs\",\n    \".eslintrc.yaml\",\n    \".eslintrc.yml\",\n    \".eslintrc.json\",\n    \".eslintrc\",\n    \"package.json\"\n];\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").OverrideConfigData} OverrideConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {string} pluginBasePath The base path to resolve plugins.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\nfunction isFilePath(nameOrPath) {\n    return (\n        /^\\.{1,2}[/\\\\]/u.test(nameOrPath) ||\n        path.isAbsolute(nameOrPath)\n    );\n}\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\nfunction readFile(filePath) {\n    return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n    debug(`Loading YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n\n        // empty YAML file can be null, so always use\n        return yaml.safeLoad(readFile(filePath)) || {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n    debug(`Loading JSON config file: ${filePath}`);\n\n    try {\n        return JSON.parse(stripComments(readFile(filePath)));\n    } catch (e) {\n        debug(`Error reading JSON file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        e.messageTemplate = \"failed-to-read-json\";\n        e.messageData = {\n            path: filePath,\n            message: e.message\n        };\n        throw e;\n    }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n    debug(`Loading legacy config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n        return yaml.safeLoad(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};\n    } catch (e) {\n        debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n    debug(`Loading JS config file: ${filePath}`);\n    try {\n        return importFresh(filePath);\n    } catch (e) {\n        debug(`Error reading JavaScript file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        const packageData = loadJSONConfigFile(filePath);\n\n        if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n            throw Object.assign(\n                new Error(\"package.json file doesn't have 'eslintConfig' field.\"),\n                { code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\" }\n            );\n        }\n\n        return packageData.eslintConfig;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\nfunction loadESLintIgnoreFile(filePath) {\n    debug(`Loading .eslintignore file: ${filePath}`);\n\n    try {\n        return readFile(filePath)\n            .split(/\\r?\\n/gu)\n            .filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n    } catch (e) {\n        debug(`Error reading .eslintignore file: ${filePath}`);\n        e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @param {string} messageTemplate The text template to source error strings from.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configInvalidError(configName, importerName, messageTemplate) {\n    return Object.assign(\n        new Error(`Failed to load config \"${configName}\" to extend from.`),\n        {\n            messageTemplate,\n            messageData: { configName, importerName }\n        }\n    );\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\nfunction loadConfigFile(filePath) {\n    switch (path.extname(filePath)) {\n        case \".js\":\n        case \".cjs\":\n            return loadJSConfigFile(filePath);\n\n        case \".json\":\n            if (path.basename(filePath) === \"package.json\") {\n                return loadPackageJSONConfigFile(filePath);\n            }\n            return loadJSONConfigFile(filePath);\n\n        case \".yaml\":\n        case \".yml\":\n            return loadYAMLConfigFile(filePath);\n\n        default:\n            return loadLegacyConfigFile(filePath);\n    }\n}\n\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n    /* istanbul ignore next */\n    if (debug.enabled) {\n        let nameAndVersion = null;\n\n        try {\n            const packageJsonPath = ModuleResolver.resolve(\n                `${request}/package.json`,\n                relativeTo\n            );\n            const { version = \"unknown\" } = require(packageJsonPath);\n\n            nameAndVersion = `${request}@${version}`;\n        } catch (error) {\n            debug(\"package.json was not found:\", error.message);\n            nameAndVersion = request;\n        }\n\n        debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n    }\n}\n\n/**\n * Create a new context with default values.\n * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.\n * @param {\"config\" | \"ignore\" | \"implicit-processor\" | undefined} providedType The type of the current configuration. Default is `\"config\"`.\n * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.\n * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.\n * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.\n * @returns {ConfigArrayFactoryLoadingContext} The created context.\n */\nfunction createContext(\n    { cwd, resolvePluginsRelativeTo },\n    providedType,\n    providedName,\n    providedFilePath,\n    providedMatchBasePath\n) {\n    const filePath = providedFilePath\n        ? path.resolve(cwd, providedFilePath)\n        : \"\";\n    const matchBasePath =\n        (providedMatchBasePath && path.resolve(cwd, providedMatchBasePath)) ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const name =\n        providedName ||\n        (filePath && path.relative(cwd, filePath)) ||\n        \"\";\n    const pluginBasePath =\n        resolvePluginsRelativeTo ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const type = providedType || \"config\";\n\n    return { filePath, matchBasePath, name, pluginBasePath, type };\n}\n\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\nfunction normalizePlugin(plugin) {\n    return {\n        configs: plugin.configs || {},\n        environments: plugin.environments || {},\n        processors: plugin.processors || {},\n        rules: plugin.rules || {}\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\nclass ConfigArrayFactory {\n\n    /**\n     * Initialize this instance.\n     * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n     */\n    constructor({\n        additionalPluginPool = new Map(),\n        cwd = process.cwd(),\n        resolvePluginsRelativeTo,\n        builtInRules,\n        resolver = ModuleResolver,\n        eslintAllPath,\n        eslintRecommendedPath\n    } = {}) {\n        internalSlotsMap.set(this, {\n            additionalPluginPool,\n            cwd,\n            resolvePluginsRelativeTo:\n                resolvePluginsRelativeTo &&\n                path.resolve(cwd, resolvePluginsRelativeTo),\n            builtInRules,\n            resolver,\n            eslintAllPath,\n            eslintRecommendedPath\n        });\n    }\n\n    /**\n     * Create `ConfigArray` instance from a config data.\n     * @param {ConfigData|null} configData The config data to create.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.filePath] The path to this config data.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    create(configData, { basePath, filePath, name } = {}) {\n        if (!configData) {\n            return new ConfigArray();\n        }\n\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n        const elements = this._normalizeConfigData(configData, ctx);\n\n        return new ConfigArray(...elements);\n    }\n\n    /**\n     * Load a config file.\n     * @param {string} filePath The path to a config file.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    loadFile(filePath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n\n        return new ConfigArray(...this._loadConfigData(ctx));\n    }\n\n    /**\n     * Load the config file on a given directory if exists.\n     * @param {string} directoryPath The path to a directory.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadInDirectory(directoryPath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n\n        for (const filename of configFilenames) {\n            const ctx = createContext(\n                slots,\n                \"config\",\n                name,\n                path.join(directoryPath, filename),\n                basePath\n            );\n\n            if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {\n                let configData;\n\n                try {\n                    configData = loadConfigFile(ctx.filePath);\n                } catch (error) {\n                    if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n                        throw error;\n                    }\n                }\n\n                if (configData) {\n                    debug(`Config file found: ${ctx.filePath}`);\n                    return new ConfigArray(\n                        ...this._normalizeConfigData(configData, ctx)\n                    );\n                }\n            }\n        }\n\n        debug(`Config file not found on ${directoryPath}`);\n        return new ConfigArray();\n    }\n\n    /**\n     * Check if a config file on a given directory exists or not.\n     * @param {string} directoryPath The path to a directory.\n     * @returns {string | null} The path to the found config file. If not found then null.\n     */\n    static getPathToConfigFileInDirectory(directoryPath) {\n        for (const filename of configFilenames) {\n            const filePath = path.join(directoryPath, filename);\n\n            if (fs.existsSync(filePath)) {\n                if (filename === \"package.json\") {\n                    try {\n                        loadPackageJSONConfigFile(filePath);\n                        return filePath;\n                    } catch { /* ignore */ }\n                } else {\n                    return filePath;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Load `.eslintignore` file.\n     * @param {string} filePath The path to a `.eslintignore` file to load.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadESLintIgnore(filePath) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(\n            slots,\n            \"ignore\",\n            void 0,\n            filePath,\n            slots.cwd\n        );\n        const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);\n\n        return new ConfigArray(\n            ...this._normalizeESLintIgnoreData(ignorePatterns, ctx)\n        );\n    }\n\n    /**\n     * Load `.eslintignore` file in the current working directory.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadDefaultESLintIgnore() {\n        const slots = internalSlotsMap.get(this);\n        const eslintIgnorePath = path.resolve(slots.cwd, \".eslintignore\");\n        const packageJsonPath = path.resolve(slots.cwd, \"package.json\");\n\n        if (fs.existsSync(eslintIgnorePath)) {\n            return this.loadESLintIgnore(eslintIgnorePath);\n        }\n        if (fs.existsSync(packageJsonPath)) {\n            const data = loadJSONConfigFile(packageJsonPath);\n\n            if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n                if (!Array.isArray(data.eslintIgnore)) {\n                    throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n                }\n                const ctx = createContext(\n                    slots,\n                    \"ignore\",\n                    \"eslintIgnore in package.json\",\n                    packageJsonPath,\n                    slots.cwd\n                );\n\n                return new ConfigArray(\n                    ...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx)\n                );\n            }\n        }\n\n        return new ConfigArray();\n    }\n\n    /**\n     * Load a given config file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n     * @private\n     */\n    _loadConfigData(ctx) {\n        return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);\n    }\n\n    /**\n     * Normalize a given `.eslintignore` data to config array elements.\n     * @param {string[]} ignorePatterns The patterns to ignore files.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeESLintIgnoreData(ignorePatterns, ctx) {\n        const elements = this._normalizeObjectConfigData(\n            { ignorePatterns },\n            ctx\n        );\n\n        // Set `ignorePattern.loose` flag for backward compatibility.\n        for (const element of elements) {\n            if (element.ignorePattern) {\n                element.ignorePattern.loose = true;\n            }\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _normalizeConfigData(configData, ctx) {\n        const validator = new ConfigValidator();\n\n        validator.validateConfigSchema(configData, ctx.name || ctx.filePath);\n        return this._normalizeObjectConfigData(configData, ctx);\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigData(configData, ctx) {\n        const { files, excludedFiles, ...configBody } = configData;\n        const criteria = OverrideTester.create(\n            files,\n            excludedFiles,\n            ctx.matchBasePath\n        );\n        const elements = this._normalizeObjectConfigDataBody(configBody, ctx);\n\n        // Apply the criteria to every element.\n        for (const element of elements) {\n\n            /*\n             * Merge the criteria.\n             * This is for the `overrides` entries that came from the\n             * configurations of `overrides[].extends`.\n             */\n            element.criteria = OverrideTester.and(criteria, element.criteria);\n\n            /*\n             * Remove `root` property to ignore `root` settings which came from\n             * `extends` in `overrides`.\n             */\n            if (element.criteria) {\n                element.root = void 0;\n            }\n\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigDataBody(\n        {\n            env,\n            extends: extend,\n            globals,\n            ignorePatterns,\n            noInlineConfig,\n            parser: parserName,\n            parserOptions,\n            plugins: pluginList,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings,\n            overrides: overrideList = []\n        },\n        ctx\n    ) {\n        const extendList = Array.isArray(extend) ? extend : [extend];\n        const ignorePattern = ignorePatterns && new IgnorePattern(\n            Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],\n            ctx.matchBasePath\n        );\n\n        // Flatten `extends`.\n        for (const extendName of extendList.filter(Boolean)) {\n            yield* this._loadExtends(extendName, ctx);\n        }\n\n        // Load parser & plugins.\n        const parser = parserName && this._loadParser(parserName, ctx);\n        const plugins = pluginList && this._loadPlugins(pluginList, ctx);\n\n        // Yield pseudo config data for file extension processors.\n        if (plugins) {\n            yield* this._takeFileExtensionProcessors(plugins, ctx);\n        }\n\n        // Yield the config data except `extends` and `overrides`.\n        yield {\n\n            // Debug information.\n            type: ctx.type,\n            name: ctx.name,\n            filePath: ctx.filePath,\n\n            // Config data.\n            criteria: null,\n            env,\n            globals,\n            ignorePattern,\n            noInlineConfig,\n            parser,\n            parserOptions,\n            plugins,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings\n        };\n\n        // Flatten `overries`.\n        for (let i = 0; i < overrideList.length; ++i) {\n            yield* this._normalizeObjectConfigData(\n                overrideList[i],\n                { ...ctx, name: `${ctx.name}#overrides[${i}]` }\n            );\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtends(extendName, ctx) {\n        debug(\"Loading {extends:%j} relative to %s\", extendName, ctx.filePath);\n        try {\n            if (extendName.startsWith(\"eslint:\")) {\n                return this._loadExtendedBuiltInConfig(extendName, ctx);\n            }\n            if (extendName.startsWith(\"plugin:\")) {\n                return this._loadExtendedPluginConfig(extendName, ctx);\n            }\n            return this._loadExtendedShareableConfig(extendName, ctx);\n        } catch (error) {\n            error.message += `\\nReferenced from: ${ctx.filePath || ctx.name}`;\n            throw error;\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedBuiltInConfig(extendName, ctx) {\n        const { eslintAllPath, eslintRecommendedPath } = internalSlotsMap.get(this);\n\n        if (extendName === \"eslint:recommended\") {\n            return this._loadConfigData({\n                ...ctx,\n                filePath: eslintRecommendedPath,\n                name: `${ctx.name} » ${extendName}`\n            });\n        }\n        if (extendName === \"eslint:all\") {\n            return this._loadConfigData({\n                ...ctx,\n                filePath: eslintAllPath,\n                name: `${ctx.name} » ${extendName}`\n            });\n        }\n\n        throw configInvalidError(extendName, ctx.name, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedPluginConfig(extendName, ctx) {\n        const slashIndex = extendName.lastIndexOf(\"/\");\n\n        if (slashIndex === -1) {\n            throw configInvalidError(extendName, ctx.filePath, \"plugin-invalid\");\n        }\n\n        const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n        const configName = extendName.slice(slashIndex + 1);\n\n        if (isFilePath(pluginName)) {\n            throw new Error(\"'extends' cannot use a file path for plugins.\");\n        }\n\n        const plugin = this._loadPlugin(pluginName, ctx);\n        const configData =\n            plugin.definition &&\n            plugin.definition.configs[configName];\n\n        if (configData) {\n            return this._normalizeConfigData(configData, {\n                ...ctx,\n                filePath: plugin.filePath || ctx.filePath,\n                name: `${ctx.name} » plugin:${plugin.id}/${configName}`\n            });\n        }\n\n        throw plugin.error || configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedShareableConfig(extendName, ctx) {\n        const { cwd, resolver } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n        let request;\n\n        if (isFilePath(extendName)) {\n            request = extendName;\n        } else if (extendName.startsWith(\".\")) {\n            request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n        } else {\n            request = naming.normalizePackageName(\n                extendName,\n                \"eslint-config\"\n            );\n        }\n\n        let filePath;\n\n        try {\n            filePath = resolver.resolve(request, relativeTo);\n        } catch (error) {\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                throw configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n            }\n            throw error;\n        }\n\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        return this._loadConfigData({\n            ...ctx,\n            filePath,\n            name: `${ctx.name} » ${request}`\n        });\n    }\n\n    /**\n     * Load given plugins.\n     * @param {string[]} names The plugin names to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {Record<string,DependentPlugin>} The loaded parser.\n     * @private\n     */\n    _loadPlugins(names, ctx) {\n        return names.reduce((map, name) => {\n            if (isFilePath(name)) {\n                throw new Error(\"Plugins array cannot includes file paths.\");\n            }\n            const plugin = this._loadPlugin(name, ctx);\n\n            map[plugin.id] = plugin;\n\n            return map;\n        }, {});\n    }\n\n    /**\n     * Load a given parser.\n     * @param {string} nameOrPath The package name or the path to a parser file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentParser} The loaded parser.\n     */\n    _loadParser(nameOrPath, ctx) {\n        debug(\"Loading parser %j from %s\", nameOrPath, ctx.filePath);\n\n        const { cwd } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n\n        try {\n            const filePath = ModuleResolver.resolve(nameOrPath, relativeTo);\n\n            writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n\n            return new ConfigDependency({\n                definition: require(filePath),\n                filePath,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        } catch (error) {\n\n            // If the parser name is \"espree\", load the espree of ESLint.\n            if (nameOrPath === \"espree\") {\n                debug(\"Fallback espree.\");\n                return new ConfigDependency({\n                    definition: require(\"espree\"),\n                    filePath: require.resolve(\"espree\"),\n                    id: nameOrPath,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            }\n\n            debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, ctx.name);\n            error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;\n\n            return new ConfigDependency({\n                error,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n    }\n\n    /**\n     * Load a given plugin.\n     * @param {string} name The plugin name to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentPlugin} The loaded plugin.\n     * @private\n     */\n    _loadPlugin(name, ctx) {\n        debug(\"Loading plugin %j from %s\", name, ctx.filePath);\n\n        const { additionalPluginPool } = internalSlotsMap.get(this);\n        const request = naming.normalizePackageName(name, \"eslint-plugin\");\n        const id = naming.getShorthandName(request, \"eslint-plugin\");\n        const relativeTo = path.join(ctx.pluginBasePath, \"__placeholder__.js\");\n\n        if (name.match(/\\s+/u)) {\n            const error = Object.assign(\n                new Error(`Whitespace found in plugin name '${name}'`),\n                {\n                    messageTemplate: \"whitespace-found\",\n                    messageData: { pluginName: request }\n                }\n            );\n\n            return new ConfigDependency({\n                error,\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        // Check for additional pool.\n        const plugin =\n            additionalPluginPool.get(request) ||\n            additionalPluginPool.get(id);\n\n        if (plugin) {\n            return new ConfigDependency({\n                definition: normalizePlugin(plugin),\n                filePath: \"\", // It's unknown where the plugin came from.\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        let filePath;\n        let error;\n\n        try {\n            filePath = ModuleResolver.resolve(request, relativeTo);\n        } catch (resolveError) {\n            error = resolveError;\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                error.messageTemplate = \"plugin-missing\";\n                error.messageData = {\n                    pluginName: request,\n                    resolvePluginsRelativeTo: ctx.pluginBasePath,\n                    importerName: ctx.name\n                };\n            }\n        }\n\n        if (filePath) {\n            try {\n                writeDebugLogForLoading(request, relativeTo, filePath);\n\n                const startTime = Date.now();\n                const pluginDefinition = require(filePath);\n\n                debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n\n                return new ConfigDependency({\n                    definition: normalizePlugin(pluginDefinition),\n                    filePath,\n                    id,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            } catch (loadError) {\n                error = loadError;\n            }\n        }\n\n        debug(\"Failed to load plugin '%s' declared in '%s'.\", name, ctx.name);\n        error.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error.message}`;\n        return new ConfigDependency({\n            error,\n            id,\n            importerName: ctx.name,\n            importerPath: ctx.filePath\n        });\n    }\n\n    /**\n     * Take file expression processors as config array elements.\n     * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n     * @private\n     */\n    *_takeFileExtensionProcessors(plugins, ctx) {\n        for (const pluginId of Object.keys(plugins)) {\n            const processors =\n                plugins[pluginId] &&\n                plugins[pluginId].definition &&\n                plugins[pluginId].definition.processors;\n\n            if (!processors) {\n                continue;\n            }\n\n            for (const processorId of Object.keys(processors)) {\n                if (processorId.startsWith(\".\")) {\n                    yield* this._normalizeObjectConfigData(\n                        {\n                            files: [`*${processorId}`],\n                            processor: `${pluginId}/${processorId}`\n                        },\n                        {\n                            ...ctx,\n                            type: \"implicit-processor\",\n                            name: `${ctx.name}#processors[\"${pluginId}/${processorId}\"]`\n                        }\n                    );\n                }\n            }\n        }\n    }\n}\n\nmodule.exports = { ConfigArrayFactory, createContext };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}