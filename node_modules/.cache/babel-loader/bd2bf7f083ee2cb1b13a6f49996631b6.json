{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst candidatesOfGlobalObject = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\n\nfunction isMember(node, name) {\n  return astUtils.isSpecificMemberAccess(node, null, name);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-eval\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowIndirect: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"eval can be harmful.\"\n    }\n  },\n\n  create(context) {\n    const allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);\n    const sourceCode = context.getSourceCode();\n    let funcInfo = null;\n    /**\n     * Pushs a variable scope (Program or Function) information to the stack.\n     *\n     * This is used in order to check whether or not `this` binding is a\n     * reference to the global object.\n     * @param {ASTNode} node A node of the scope. This is one of Program,\n     *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n     * @returns {void}\n     */\n\n    function enterVarScope(node) {\n      const strict = context.getScope().isStrict;\n      funcInfo = {\n        upper: funcInfo,\n        node,\n        strict,\n        defaultThis: false,\n        initialized: strict\n      };\n    }\n    /**\n     * Pops a variable scope from the stack.\n     * @returns {void}\n     */\n\n\n    function exitVarScope() {\n      funcInfo = funcInfo.upper;\n    }\n    /**\n     * Reports a given node.\n     *\n     * `node` is `Identifier` or `MemberExpression`.\n     * The parent of `node` might be `CallExpression`.\n     *\n     * The location of the report is always `eval` `Identifier` (or possibly\n     * `Literal`). The type of the report is `CallExpression` if the parent is\n     * `CallExpression`. Otherwise, it's the given node type.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function report(node) {\n      const parent = node.parent;\n      const locationNode = node.type === \"MemberExpression\" ? node.property : node;\n      const reportNode = parent.type === \"CallExpression\" && parent.callee === node ? parent : node;\n      context.report({\n        node: reportNode,\n        loc: locationNode.loc,\n        messageId: \"unexpected\"\n      });\n    }\n    /**\n     * Reports accesses of `eval` via the global object.\n     * @param {eslint-scope.Scope} globalScope The global scope.\n     * @returns {void}\n     */\n\n\n    function reportAccessingEvalViaGlobalObject(globalScope) {\n      for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n        const name = candidatesOfGlobalObject[i];\n        const variable = astUtils.getVariableByName(globalScope, name);\n\n        if (!variable) {\n          continue;\n        }\n\n        const references = variable.references;\n\n        for (let j = 0; j < references.length; ++j) {\n          const identifier = references[j].identifier;\n          let node = identifier.parent; // To detect code like `window.window.eval`.\n\n          while (isMember(node, name)) {\n            node = node.parent;\n          } // Reports.\n\n\n          if (isMember(node, \"eval\")) {\n            report(node);\n          }\n        }\n      }\n    }\n    /**\n     * Reports all accesses of `eval` (excludes direct calls to eval).\n     * @param {eslint-scope.Scope} globalScope The global scope.\n     * @returns {void}\n     */\n\n\n    function reportAccessingEval(globalScope) {\n      const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n      if (!variable) {\n        return;\n      }\n\n      const references = variable.references;\n\n      for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n        const id = reference.identifier;\n\n        if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n          // Is accessing to eval (excludes direct calls to eval)\n          report(id);\n        }\n      }\n    }\n\n    if (allowIndirect) {\n      // Checks only direct calls to eval. It's simple!\n      return {\n        \"CallExpression:exit\"(node) {\n          const callee = node.callee;\n          /*\n           * Optional call (`eval?.(\"code\")`) is not direct eval.\n           * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\n           * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\n           */\n\n          if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n            report(callee);\n          }\n        }\n\n      };\n    }\n\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = node.callee;\n\n        if (astUtils.isSpecificId(callee, \"eval\")) {\n          report(callee);\n        }\n      },\n\n      Program(node) {\n        const scope = context.getScope(),\n              features = context.parserOptions.ecmaFeatures || {},\n              strict = scope.isStrict || node.sourceType === \"module\" || features.globalReturn && scope.childScopes[0].isStrict;\n        funcInfo = {\n          upper: null,\n          node,\n          strict,\n          defaultThis: true,\n          initialized: true\n        };\n      },\n\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        exitVarScope();\n        reportAccessingEval(globalScope);\n        reportAccessingEvalViaGlobalObject(globalScope);\n      },\n\n      FunctionDeclaration: enterVarScope,\n      \"FunctionDeclaration:exit\": exitVarScope,\n      FunctionExpression: enterVarScope,\n      \"FunctionExpression:exit\": exitVarScope,\n      ArrowFunctionExpression: enterVarScope,\n      \"ArrowFunctionExpression:exit\": exitVarScope,\n\n      ThisExpression(node) {\n        if (!isMember(node.parent, \"eval\")) {\n          return;\n        }\n        /*\n         * `this.eval` is found.\n         * Checks whether or not the value of `this` is the global object.\n         */\n\n\n        if (!funcInfo.initialized) {\n          funcInfo.initialized = true;\n          funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);\n        }\n\n        if (!funcInfo.strict && funcInfo.defaultThis) {\n          // `this.eval` is possible built-in `eval`.\n          report(node.parent);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","candidatesOfGlobalObject","Object","freeze","isMember","node","name","isSpecificMemberAccess","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowIndirect","default","additionalProperties","messages","unexpected","create","context","Boolean","options","sourceCode","getSourceCode","funcInfo","enterVarScope","strict","getScope","isStrict","upper","defaultThis","initialized","exitVarScope","report","parent","locationNode","property","reportNode","callee","loc","messageId","reportAccessingEvalViaGlobalObject","globalScope","i","length","variable","getVariableByName","references","j","identifier","reportAccessingEval","reference","id","isCallee","optional","isSpecificId","Program","scope","features","parserOptions","ecmaFeatures","sourceType","globalReturn","childScopes","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ThisExpression","isDefaultThisBinding"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-eval.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\",\n    \"globalThis\"\n]);\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return astUtils.isSpecificMemberAccess(node, null, name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-eval\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"eval can be harmful.\"\n        }\n    },\n\n    create(context) {\n        const allowIndirect = Boolean(\n            context.options[0] &&\n            context.options[0].allowIndirect\n        );\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Pushs a variable scope (Program or Function) information to the stack.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         * @param {ASTNode} node A node of the scope. This is one of Program,\n         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function enterVarScope(node) {\n            const strict = context.getScope().isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         * @returns {void}\n         */\n        function exitVarScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const parent = node.parent;\n            const locationNode = node.type === \"MemberExpression\"\n                ? node.property\n                : node;\n\n            const reportNode = parent.type === \"CallExpression\" && parent.callee === node\n                ? parent\n                : node;\n\n            context.report({\n                node: reportNode,\n                loc: locationNode.loc,\n                messageId: \"unexpected\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                const name = candidatesOfGlobalObject[i];\n                const variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                const references = variable.references;\n\n                for (let j = 0; j < references.length; ++j) {\n                    const identifier = references[j].identifier;\n                    let node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            const references = variable.references;\n\n            for (let i = 0; i < references.length; ++i) {\n                const reference = references[i];\n                const id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\"(node) {\n                    const callee = node.callee;\n\n                    /*\n                     * Optional call (`eval?.(\"code\")`) is not direct eval.\n                     * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\n                     * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\n                     */\n                    if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = node.callee;\n\n                if (astUtils.isSpecificId(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict);\n\n                funcInfo = {\n                    upper: null,\n                    node,\n                    strict,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                exitVarScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterVarScope,\n            \"FunctionDeclaration:exit\": exitVarScope,\n            FunctionExpression: enterVarScope,\n            \"FunctionExpression:exit\": exitVarScope,\n            ArrowFunctionExpression: enterVarScope,\n            \"ArrowFunctionExpression:exit\": exitVarScope,\n\n            ThisExpression(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                if (!funcInfo.strict && funcInfo.defaultThis) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}