{"ast":null,"code":"/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n * @author aladdin-add\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\"),\n      eslintScope = require(\"eslint-scope\"),\n      evk = require(\"eslint-visitor-keys\"),\n      espree = require(\"espree\"),\n      merge = require(\"lodash.merge\"),\n      BuiltInEnvironments = require(\"@eslint/eslintrc/conf/environments\"),\n      pkg = require(\"../../package.json\"),\n      astUtils = require(\"../shared/ast-utils\"),\n      ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\"),\n      ConfigValidator = require(\"@eslint/eslintrc/lib/shared/config-validator\"),\n      Traverser = require(\"../shared/traverser\"),\n      {\n  SourceCode\n} = require(\"../source-code\"),\n      CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n      applyDisableDirectives = require(\"./apply-disable-directives\"),\n      ConfigCommentParser = require(\"./config-comment-parser\"),\n      NodeEventGenerator = require(\"./node-event-generator\"),\n      createReportTranslator = require(\"./report-translator\"),\n      Rules = require(\"./rules\"),\n      createEmitter = require(\"./safe-emitter\"),\n      SourceCodeFixer = require(\"./source-code-fixer\"),\n      timing = require(\"./timing\"),\n      ruleReplacements = require(\"../../conf/replacements.json\");\n\nconst debug = require(\"debug\")(\"eslint:linter\");\n\nconst MAX_AUTOFIX_PASSES = 10;\nconst DEFAULT_PARSER_NAME = \"espree\";\nconst DEFAULT_ECMA_VERSION = 5;\nconst commentParser = new ConfigCommentParser();\nconst DEFAULT_ERROR_LOC = {\n  start: {\n    line: 1,\n    column: 0\n  },\n  end: {\n    line: 1,\n    column: 1\n  }\n};\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\")[\"ConfigArray\"]>} ConfigArray */\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\")[\"ExtractedConfig\"]>} ExtractedConfig */\n\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"../shared/types\").Environment} Environment */\n\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n\n/** @typedef {import(\"../shared/types\").Processor} Processor */\n\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/**\n * @template T\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\n */\n\n/**\n * @typedef {Object} DisableDirective\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type\n * @property {number} line\n * @property {number} column\n * @property {(string|null)} ruleId\n */\n\n/**\n * The private data for `Linter` instance.\n * @typedef {Object} LinterInternalSlots\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\n * @property {Map<string, Parser>} parserMap The loaded parsers.\n * @property {Rules} ruleMap The loaded rules.\n */\n\n/**\n * @typedef {Object} VerifyOptions\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\n *      to change config once it is set. Defaults to true if not supplied.\n *      Useful if you want to validate JS without comments overriding rules.\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\n *      properties into the lint result.\n * @property {string} [filename] the filename of the source code.\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\n *      unused `eslint-disable` directives.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\n *      predicate function that selects adopt code blocks.\n * @property {Processor[\"postprocess\"]} [postprocess] postprocessor for report\n *      messages. If provided, this should accept an array of the message lists\n *      for each code block returned from the preprocessor, apply a mapping to\n *      the messages as appropriate, and return a one-dimensional array of\n *      messages.\n * @property {Processor[\"preprocess\"]} [preprocess] preprocessor for source text.\n *      If provided, this should accept a string of source text, and return an\n *      array of code blocks to lint.\n */\n\n/**\n * @typedef {Object} FixOptions\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\n *      whether fixes should be applied.\n */\n\n/**\n * @typedef {Object} InternalOptions\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\n * @property {\"off\" | \"warn\" | \"error\"} reportUnusedDisableDirectives (boolean values were normalized)\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} configGlobals The globals declared in configuration\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\n * @returns {void}\n */\n\nfunction addDeclaredGlobals(globalScope, configGlobals, _ref) {\n  let {\n    exportedVariables,\n    enabledGlobals\n  } = _ref;\n\n  // Define configured global variables.\n  for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {\n    /*\n     * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n     * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n     */\n    const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);\n    const commentValue = enabledGlobals[id] && enabledGlobals[id].value;\n    const value = commentValue || configValue;\n    const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;\n\n    if (value === \"off\") {\n      continue;\n    }\n\n    let variable = globalScope.set.get(id);\n\n    if (!variable) {\n      variable = new eslintScope.Variable(id, globalScope);\n      globalScope.variables.push(variable);\n      globalScope.set.set(id, variable);\n    }\n\n    variable.eslintImplicitGlobalSetting = configValue;\n    variable.eslintExplicitGlobal = sourceComments !== void 0;\n    variable.eslintExplicitGlobalComments = sourceComments;\n    variable.writeable = value === \"writable\";\n  } // mark all exported variables as such\n\n\n  Object.keys(exportedVariables).forEach(name => {\n    const variable = globalScope.set.get(name);\n\n    if (variable) {\n      variable.eslintUsed = true;\n    }\n  });\n  /*\n   * \"through\" contains all references which definitions cannot be found.\n   * Since we augment the global scope using configuration, we need to update\n   * references and remove the ones that were added by configuration.\n   */\n\n  globalScope.through = globalScope.through.filter(reference => {\n    const name = reference.identifier.name;\n    const variable = globalScope.set.get(name);\n\n    if (variable) {\n      /*\n       * Links the variable and the reference.\n       * And this reference is removed from `Scope#through`.\n       */\n      reference.resolved = variable;\n      variable.references.push(reference);\n      return false;\n    }\n\n    return true;\n  });\n}\n/**\n * creates a missing-rule message.\n * @param {string} ruleId the ruleId to create\n * @returns {string} created error message\n * @private\n */\n\n\nfunction createMissingRuleMessage(ruleId) {\n  return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId) ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(\", \")}` : `Definition for rule '${ruleId}' was not found.`;\n}\n/**\n * creates a linting problem\n * @param {Object} options to create linting error\n * @param {string} [options.ruleId] the ruleId to report\n * @param {Object} [options.loc] the loc to report\n * @param {string} [options.message] the error message to report\n * @param {string} [options.severity] the error message to report\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\n * @private\n */\n\n\nfunction createLintingProblem(options) {\n  const {\n    ruleId = null,\n    loc = DEFAULT_ERROR_LOC,\n    message = createMissingRuleMessage(options.ruleId),\n    severity = 2\n  } = options;\n  return {\n    ruleId,\n    message,\n    line: loc.start.line,\n    column: loc.start.column + 1,\n    endLine: loc.end.line,\n    endColumn: loc.end.column + 1,\n    severity,\n    nodeType: null\n  };\n}\n/**\n * Creates a collection of disable directives from a comment\n * @param {Object} options to create disable directives\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\n * @param {{line: number, column: number}} options.loc The 0-based location of the comment token\n * @param {string} options.value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules\n * @returns {Object} Directives and problems from the comment\n */\n\n\nfunction createDisableDirectives(options) {\n  const {\n    type,\n    loc,\n    value,\n    ruleMapper\n  } = options;\n  const ruleIds = Object.keys(commentParser.parseListConfig(value));\n  const directiveRules = ruleIds.length ? ruleIds : [null];\n  const result = {\n    directives: [],\n    // valid disable directives\n    directiveProblems: [] // problems in directives\n\n  };\n\n  for (const ruleId of directiveRules) {\n    // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\n    if (ruleId === null || ruleMapper(ruleId) !== null) {\n      result.directives.push({\n        type,\n        line: loc.start.line,\n        column: loc.start.column + 1,\n        ruleId\n      });\n    } else {\n      result.directiveProblems.push(createLintingProblem({\n        ruleId,\n        loc\n      }));\n    }\n  }\n\n  return result;\n}\n/**\n * Remove the ignored part from a given directive comment and trim it.\n * @param {string} value The comment text to strip.\n * @returns {string} The stripped text.\n */\n\n\nfunction stripDirectiveComment(value) {\n  return value.split(/\\s-{2,}\\s/u)[0].trim();\n}\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\n\n\nfunction getDirectiveComments(filename, ast, ruleMapper, warnInlineConfig) {\n  const configuredRules = {};\n  const enabledGlobals = Object.create(null);\n  const exportedVariables = {};\n  const problems = [];\n  const disableDirectives = [];\n  const validator = new ConfigValidator({\n    builtInRules: Rules\n  });\n  ast.comments.filter(token => token.type !== \"Shebang\").forEach(comment => {\n    const trimmedCommentText = stripDirectiveComment(comment.value);\n    const match = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\\s|$)/u.exec(trimmedCommentText);\n\n    if (!match) {\n      return;\n    }\n\n    const directiveText = match[1];\n    const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\n\n    if (comment.type === \"Line\" && !lineCommentSupported) {\n      return;\n    }\n\n    if (warnInlineConfig) {\n      const kind = comment.type === \"Block\" ? `/*${directiveText}*/` : `//${directiveText}`;\n      problems.push(createLintingProblem({\n        ruleId: null,\n        message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,\n        loc: comment.loc,\n        severity: 1\n      }));\n      return;\n    }\n\n    if (lineCommentSupported && comment.loc.start.line !== comment.loc.end.line) {\n      const message = `${directiveText} comment should not span multiple lines.`;\n      problems.push(createLintingProblem({\n        ruleId: null,\n        message,\n        loc: comment.loc\n      }));\n      return;\n    }\n\n    const directiveValue = trimmedCommentText.slice(match.index + directiveText.length);\n\n    switch (directiveText) {\n      case \"eslint-disable\":\n      case \"eslint-enable\":\n      case \"eslint-disable-next-line\":\n      case \"eslint-disable-line\":\n        {\n          const directiveType = directiveText.slice(\"eslint-\".length);\n          const options = {\n            type: directiveType,\n            loc: comment.loc,\n            value: directiveValue,\n            ruleMapper\n          };\n          const {\n            directives,\n            directiveProblems\n          } = createDisableDirectives(options);\n          disableDirectives.push(...directives);\n          problems.push(...directiveProblems);\n          break;\n        }\n\n      case \"exported\":\n        Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n        break;\n\n      case \"globals\":\n      case \"global\":\n        for (const [id, {\n          value\n        }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\n          let normalizedValue;\n\n          try {\n            normalizedValue = ConfigOps.normalizeConfigGlobal(value);\n          } catch (err) {\n            problems.push(createLintingProblem({\n              ruleId: null,\n              loc: comment.loc,\n              message: err.message\n            }));\n            continue;\n          }\n\n          if (enabledGlobals[id]) {\n            enabledGlobals[id].comments.push(comment);\n            enabledGlobals[id].value = normalizedValue;\n          } else {\n            enabledGlobals[id] = {\n              comments: [comment],\n              value: normalizedValue\n            };\n          }\n        }\n\n        break;\n\n      case \"eslint\":\n        {\n          const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n\n          if (parseResult.success) {\n            Object.keys(parseResult.config).forEach(name => {\n              const rule = ruleMapper(name);\n              const ruleValue = parseResult.config[name];\n\n              if (rule === null) {\n                problems.push(createLintingProblem({\n                  ruleId: name,\n                  loc: comment.loc\n                }));\n                return;\n              }\n\n              try {\n                validator.validateRuleOptions(rule, name, ruleValue);\n              } catch (err) {\n                problems.push(createLintingProblem({\n                  ruleId: name,\n                  message: err.message,\n                  loc: comment.loc\n                })); // do not apply the config, if found invalid options.\n\n                return;\n              }\n\n              configuredRules[name] = ruleValue;\n            });\n          } else {\n            problems.push(parseResult.error);\n          }\n\n          break;\n        }\n      // no default\n    }\n  });\n  return {\n    configuredRules,\n    enabledGlobals,\n    exportedVariables,\n    problems,\n    disableDirectives\n  };\n}\n/**\n * Normalize ECMAScript version from the initial config\n * @param {Parser} parser The parser which uses this options.\n * @param {number} ecmaVersion ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\n\n\nfunction normalizeEcmaVersion(parser, ecmaVersion) {\n  if ((parser[parserSymbol] || parser) === espree) {\n    if (ecmaVersion === \"latest\") {\n      return espree.latestEcmaVersion;\n    }\n  }\n  /*\n   * Calculate ECMAScript edition number from official year version starting with\n   * ES2015, which corresponds with ES6 (or a difference of 2009).\n   */\n\n\n  return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)\\*\\//gsu;\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\n\nfunction findEslintEnv(text) {\n  let match, retv;\n  eslintEnvPattern.lastIndex = 0;\n\n  while ((match = eslintEnvPattern.exec(text)) !== null) {\n    retv = Object.assign(retv || {}, commentParser.parseListConfig(stripDirectiveComment(match[1])));\n  }\n\n  return retv;\n}\n/**\n * Convert \"/path/to/<text>\" to \"<text>\".\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\n * was omitted because `configArray.extractConfig()` requires an absolute path.\n * But the linter should pass `<text>` to `RuleContext#getFilename()` in that\n * case.\n * Also, code blocks can have their virtual filename. If the parent filename was\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\n * it's not an absolute path).\n * @param {string} filename The filename to normalize.\n * @returns {string} The normalized filename.\n */\n\n\nfunction normalizeFilename(filename) {\n  const parts = filename.split(path.sep);\n  const index = parts.lastIndexOf(\"<text>\");\n  return index === -1 ? filename : parts.slice(index).join(path.sep);\n}\n/**\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\n * consistent shape.\n * @param {VerifyOptions} providedOptions Options\n * @param {ConfigData} config Config.\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\n */\n\n\nfunction normalizeVerifyOptions(providedOptions, config) {\n  const disableInlineConfig = config.noInlineConfig === true;\n  const ignoreInlineConfig = providedOptions.allowInlineConfig === false;\n  const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig ? ` (${config.configNameOfNoInlineConfig})` : \"\";\n  let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;\n\n  if (typeof reportUnusedDisableDirectives === \"boolean\") {\n    reportUnusedDisableDirectives = reportUnusedDisableDirectives ? \"error\" : \"off\";\n  }\n\n  if (typeof reportUnusedDisableDirectives !== \"string\") {\n    reportUnusedDisableDirectives = config.reportUnusedDisableDirectives ? \"warn\" : \"off\";\n  }\n\n  return {\n    filename: normalizeFilename(providedOptions.filename || \"<input>\"),\n    allowInlineConfig: !ignoreInlineConfig,\n    warnInlineConfig: disableInlineConfig && !ignoreInlineConfig ? `your config${configNameOfNoInlineConfig}` : null,\n    reportUnusedDisableDirectives,\n    disableFixes: Boolean(providedOptions.disableFixes)\n  };\n}\n/**\n * Combines the provided parserOptions with the options from environments\n * @param {Parser} parser The parser which uses this options.\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {ParserOptions} Resulting parser options after merge\n */\n\n\nfunction resolveParserOptions(parser, providedOptions, enabledEnvironments) {\n  const parserOptionsFromEnv = enabledEnvironments.filter(env => env.parserOptions).reduce((parserOptions, env) => merge(parserOptions, env.parserOptions), {});\n  const mergedParserOptions = merge(parserOptionsFromEnv, providedOptions || {});\n  const isModule = mergedParserOptions.sourceType === \"module\";\n\n  if (isModule) {\n    /*\n     * can't have global return inside of modules\n     * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\n     */\n    mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, {\n      globalReturn: false\n    });\n  }\n\n  mergedParserOptions.ecmaVersion = normalizeEcmaVersion(parser, mergedParserOptions.ecmaVersion);\n  return mergedParserOptions;\n}\n/**\n * Combines the provided globals object with the globals from environments\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Record<string, GlobalConf>} The resolved globals object\n */\n\n\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\n  return Object.assign({}, ...enabledEnvironments.filter(env => env.globals).map(env => env.globals), providedGlobals);\n}\n/**\n * Strips Unicode BOM from a given text.\n * @param {string} text A text to strip.\n * @returns {string} The stripped text.\n */\n\n\nfunction stripUnicodeBOM(text) {\n  /*\n   * Check Unicode BOM.\n   * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n   * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n   */\n  if (text.charCodeAt(0) === 0xFEFF) {\n    return text.slice(1);\n  }\n\n  return text;\n}\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\n\n\nfunction getRuleOptions(ruleConfig) {\n  if (Array.isArray(ruleConfig)) {\n    return ruleConfig.slice(1);\n  }\n\n  return [];\n}\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {ParserOptions} parserOptions The parser options.\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\n\n\nfunction analyzeScope(ast, parserOptions, visitorKeys) {\n  const ecmaFeatures = parserOptions.ecmaFeatures || {};\n  const ecmaVersion = parserOptions.ecmaVersion || DEFAULT_ECMA_VERSION;\n  return eslintScope.analyze(ast, {\n    ignoreEval: true,\n    nodejsScope: ecmaFeatures.globalReturn,\n    impliedStrict: ecmaFeatures.impliedStrict,\n    ecmaVersion,\n    sourceType: parserOptions.sourceType || \"script\",\n    childVisitorKeys: visitorKeys || evk.KEYS,\n    fallback: Traverser.getKeys\n  });\n}\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {Parser} parser The parser to parse.\n * @param {ParserOptions} providedParserOptions Options to pass to the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: Problem}|{success: true, sourceCode: SourceCode}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\n\n\nfunction parse(text, parser, providedParserOptions, filePath) {\n  const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);\n  const parserOptions = Object.assign({}, providedParserOptions, {\n    loc: true,\n    range: true,\n    raw: true,\n    tokens: true,\n    comment: true,\n    eslintVisitorKeys: true,\n    eslintScopeManager: true,\n    filePath\n  });\n  /*\n   * Check for parsing errors first. If there's a parsing error, nothing\n   * else can happen. However, a parsing error does not throw an error\n   * from this method - it's just considered a fatal error message, a\n   * problem that ESLint identified just like any other.\n   */\n\n  try {\n    const parseResult = typeof parser.parseForESLint === \"function\" ? parser.parseForESLint(textToParse, parserOptions) : {\n      ast: parser.parse(textToParse, parserOptions)\n    };\n    const ast = parseResult.ast;\n    const parserServices = parseResult.services || {};\n    const visitorKeys = parseResult.visitorKeys || evk.KEYS;\n    const scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);\n    return {\n      success: true,\n\n      /*\n       * Save all values that `parseForESLint()` returned.\n       * If a `SourceCode` object is given as the first parameter instead of source code text,\n       * linter skips the parsing process and reuses the source code object.\n       * In that case, linter needs all the values that `parseForESLint()` returned.\n       */\n      sourceCode: new SourceCode({\n        text,\n        ast,\n        parserServices,\n        scopeManager,\n        visitorKeys\n      })\n    };\n  } catch (ex) {\n    // If the message includes a leading line number, strip it:\n    const message = `Parsing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n    debug(\"%s\\n%s\", message, ex.stack);\n    return {\n      success: false,\n      error: {\n        ruleId: null,\n        fatal: true,\n        severity: 2,\n        message,\n        line: ex.lineNumber,\n        column: ex.column\n      }\n    };\n  }\n}\n/**\n * Gets the scope for the current node\n * @param {ScopeManager} scopeManager The scope manager for this AST\n * @param {ASTNode} currentNode The node to get the scope of\n * @returns {eslint-scope.Scope} The scope information for this node\n */\n\n\nfunction getScope(scopeManager, currentNode) {\n  // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n  const inner = currentNode.type !== \"Program\";\n\n  for (let node = currentNode; node; node = node.parent) {\n    const scope = scopeManager.acquire(node, inner);\n\n    if (scope) {\n      if (scope.type === \"function-expression-name\") {\n        return scope.childScopes[0];\n      }\n\n      return scope;\n    }\n  }\n\n  return scopeManager.scopes[0];\n}\n/**\n * Marks a variable as used in the current scope\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\n * @param {ASTNode} currentNode The node currently being traversed\n * @param {Object} parserOptions The options used to parse this text\n * @param {string} name The name of the variable that should be marked as used.\n * @returns {boolean} True if the variable was found and marked as used, false if not.\n */\n\n\nfunction markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {\n  const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;\n  const specialScope = hasGlobalReturn || parserOptions.sourceType === \"module\";\n  const currentScope = getScope(scopeManager, currentNode); // Special Node.js scope means we need to start one level deeper\n\n  const initialScope = currentScope.type === \"global\" && specialScope ? currentScope.childScopes[0] : currentScope;\n\n  for (let scope = initialScope; scope; scope = scope.upper) {\n    const variable = scope.variables.find(scopeVar => scopeVar.name === name);\n\n    if (variable) {\n      variable.eslintUsed = true;\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Runs a rule, and gets its listeners\n * @param {Rule} rule A normalized rule with a `create` method\n * @param {Context} ruleContext The context that should be passed to the rule\n * @returns {Object} A map of selector listeners provided by the rule\n */\n\n\nfunction createRuleListeners(rule, ruleContext) {\n  try {\n    return rule.create(ruleContext);\n  } catch (ex) {\n    ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\n    throw ex;\n  }\n}\n/**\n * Gets all the ancestors of a given node\n * @param {ASTNode} node The node\n * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting\n * from the root node and going inwards to the parent node.\n */\n\n\nfunction getAncestors(node) {\n  const ancestorsStartingAtParent = [];\n\n  for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n    ancestorsStartingAtParent.push(ancestor);\n  }\n\n  return ancestorsStartingAtParent.reverse();\n} // methods that exist on SourceCode object\n\n\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n  getSource: \"getText\",\n  getSourceLines: \"getLines\",\n  getAllComments: \"getAllComments\",\n  getNodeByRangeIndex: \"getNodeByRangeIndex\",\n  getComments: \"getComments\",\n  getCommentsBefore: \"getCommentsBefore\",\n  getCommentsAfter: \"getCommentsAfter\",\n  getCommentsInside: \"getCommentsInside\",\n  getJSDocComment: \"getJSDocComment\",\n  getFirstToken: \"getFirstToken\",\n  getFirstTokens: \"getFirstTokens\",\n  getLastToken: \"getLastToken\",\n  getLastTokens: \"getLastTokens\",\n  getTokenAfter: \"getTokenAfter\",\n  getTokenBefore: \"getTokenBefore\",\n  getTokenByRangeStart: \"getTokenByRangeStart\",\n  getTokens: \"getTokens\",\n  getTokensAfter: \"getTokensAfter\",\n  getTokensBefore: \"getTokensBefore\",\n  getTokensBetween: \"getTokensBetween\"\n};\nconst BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce((contextInfo, methodName) => Object.assign(contextInfo, {\n  [methodName]() {\n    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...arguments);\n  }\n\n}), {}));\n/**\n * Runs the given rules on the given SourceCode object\n * @param {SourceCode} sourceCode A SourceCode object for the given text\n * @param {Object} configuredRules The rules configuration\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\n * @param {Object} parserOptions The options that were passed to the parser\n * @param {string} parserName The name of the parser in the config\n * @param {Object} settings The settings that were enabled in the config\n * @param {string} filename The reported filename of the code\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\n * @param {string | undefined} cwd cwd of the cli\n * @param {string} physicalFilename The full path of the file on disk without any code block information\n * @returns {Problem[]} An array of reported problems\n */\n\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename, disableFixes, cwd, physicalFilename) {\n  const emitter = createEmitter();\n  const nodeQueue = [];\n  let currentNode = sourceCode.ast;\n  Traverser.traverse(sourceCode.ast, {\n    enter(node, parent) {\n      node.parent = parent;\n      nodeQueue.push({\n        isEntering: true,\n        node\n      });\n    },\n\n    leave(node) {\n      nodeQueue.push({\n        isEntering: false,\n        node\n      });\n    },\n\n    visitorKeys: sourceCode.visitorKeys\n  });\n  /*\n   * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n   * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n   * properties once for each rule.\n   */\n\n  const sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {\n    getAncestors: () => getAncestors(currentNode),\n    getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),\n    getCwd: () => cwd,\n    getFilename: () => filename,\n    getPhysicalFilename: () => physicalFilename || filename,\n    getScope: () => getScope(sourceCode.scopeManager, currentNode),\n    getSourceCode: () => sourceCode,\n    markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name),\n    parserOptions,\n    parserPath: parserName,\n    parserServices: sourceCode.parserServices,\n    settings\n  }));\n  const lintingProblems = [];\n  Object.keys(configuredRules).forEach(ruleId => {\n    const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]); // not load disabled rules\n\n    if (severity === 0) {\n      return;\n    }\n\n    const rule = ruleMapper(ruleId);\n\n    if (rule === null) {\n      lintingProblems.push(createLintingProblem({\n        ruleId\n      }));\n      return;\n    }\n\n    const messageIds = rule.meta && rule.meta.messages;\n    let reportTranslator = null;\n    const ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {\n      id: ruleId,\n      options: getRuleOptions(configuredRules[ruleId]),\n\n      report() {\n        /*\n         * Create a report translator lazily.\n         * In a vast majority of cases, any given rule reports zero errors on a given\n         * piece of code. Creating a translator lazily avoids the performance cost of\n         * creating a new translator function for each rule that usually doesn't get\n         * called.\n         *\n         * Using lazy report translators improves end-to-end performance by about 3%\n         * with Node 8.4.0.\n         */\n        if (reportTranslator === null) {\n          reportTranslator = createReportTranslator({\n            ruleId,\n            severity,\n            sourceCode,\n            messageIds,\n            disableFixes\n          });\n        }\n\n        const problem = reportTranslator(...arguments);\n\n        if (problem.fix && rule.meta && !rule.meta.fixable) {\n          throw new Error(\"Fixable rules should export a `meta.fixable` property.\");\n        }\n\n        lintingProblems.push(problem);\n      }\n\n    }));\n    const ruleListeners = createRuleListeners(rule, ruleContext); // add all the selectors from the rule as listeners\n\n    Object.keys(ruleListeners).forEach(selector => {\n      emitter.on(selector, timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector]);\n    });\n  }); // only run code path analyzer if the top level node is \"Program\", skip otherwise\n\n  const eventGenerator = nodeQueue[0].node.type === \"Program\" ? new CodePathAnalyzer(new NodeEventGenerator(emitter, {\n    visitorKeys: sourceCode.visitorKeys,\n    fallback: Traverser.getKeys\n  })) : new NodeEventGenerator(emitter, {\n    visitorKeys: sourceCode.visitorKeys,\n    fallback: Traverser.getKeys\n  });\n  nodeQueue.forEach(traversalInfo => {\n    currentNode = traversalInfo.node;\n\n    try {\n      if (traversalInfo.isEntering) {\n        eventGenerator.enterNode(currentNode);\n      } else {\n        eventGenerator.leaveNode(currentNode);\n      }\n    } catch (err) {\n      err.currentNode = currentNode;\n      throw err;\n    }\n  });\n  return lintingProblems;\n}\n/**\n * Ensure the source code to be a string.\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\n * @returns {string} The source code text.\n */\n\n\nfunction ensureText(textOrSourceCode) {\n  if (typeof textOrSourceCode === \"object\") {\n    const {\n      hasBOM,\n      text\n    } = textOrSourceCode;\n    const bom = hasBOM ? \"\\uFEFF\" : \"\";\n    return bom + text;\n  }\n\n  return String(textOrSourceCode);\n}\n/**\n * Get an environment.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} envId The environment ID to get.\n * @returns {Environment|null} The environment.\n */\n\n\nfunction getEnv(slots, envId) {\n  return slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId) || BuiltInEnvironments.get(envId) || null;\n}\n/**\n * Get a rule.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} ruleId The rule ID to get.\n * @returns {Rule|null} The rule.\n */\n\n\nfunction getRule(slots, ruleId) {\n  return slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId) || slots.ruleMap.get(ruleId);\n}\n/**\n * Normalize the value of the cwd\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\n * @returns {string | undefined} normalized cwd\n */\n\n\nfunction normalizeCwd(cwd) {\n  if (cwd) {\n    return cwd;\n  }\n\n  if (typeof process === \"object\") {\n    return process.cwd();\n  } // It's more explicit to assign the undefined\n  // eslint-disable-next-line no-undefined\n\n\n  return undefined;\n}\n/**\n * The map to store private data.\n * @type {WeakMap<Linter, LinterInternalSlots>}\n */\n\n\nconst internalSlotsMap = new WeakMap(); //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\n\nclass Linter {\n  /**\n   * Initialize the Linter.\n   * @param {Object} [config] the config object\n   * @param {string} [config.cwd]  path to a directory that should be considered as the current working directory, can be undefined.\n   */\n  constructor() {\n    let {\n      cwd\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    internalSlotsMap.set(this, {\n      cwd: normalizeCwd(cwd),\n      lastConfigArray: null,\n      lastSourceCode: null,\n      parserMap: new Map([[\"espree\", espree]]),\n      ruleMap: new Rules()\n    });\n    this.version = pkg.version;\n  }\n  /**\n   * Getter for package version.\n   * @static\n   * @returns {string} The version from package.json.\n   */\n\n\n  static get version() {\n    return pkg.version;\n  }\n  /**\n   * Same as linter.verify, except without support for processors.\n   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n   * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\n   * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n   * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n   */\n\n\n  _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n    const slots = internalSlotsMap.get(this);\n    const config = providedConfig || {};\n    const options = normalizeVerifyOptions(providedOptions, config);\n    let text; // evaluate arguments\n\n    if (typeof textOrSourceCode === \"string\") {\n      slots.lastSourceCode = null;\n      text = textOrSourceCode;\n    } else {\n      slots.lastSourceCode = textOrSourceCode;\n      text = textOrSourceCode.text;\n    } // Resolve parser.\n\n\n    let parserName = DEFAULT_PARSER_NAME;\n    let parser = espree;\n\n    if (typeof config.parser === \"object\" && config.parser !== null) {\n      parserName = config.parser.filePath;\n      parser = config.parser.definition;\n    } else if (typeof config.parser === \"string\") {\n      if (!slots.parserMap.has(config.parser)) {\n        return [{\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Configured parser '${config.parser}' was not found.`,\n          line: 0,\n          column: 0\n        }];\n      }\n\n      parserName = config.parser;\n      parser = slots.parserMap.get(config.parser);\n    } // search and apply \"eslint-env *\".\n\n\n    const envInFile = options.allowInlineConfig && !options.warnInlineConfig ? findEslintEnv(text) : {};\n    const resolvedEnvConfig = Object.assign({\n      builtin: true\n    }, config.env, envInFile);\n    const enabledEnvs = Object.keys(resolvedEnvConfig).filter(envName => resolvedEnvConfig[envName]).map(envName => getEnv(slots, envName)).filter(env => env);\n    const parserOptions = resolveParserOptions(parser, config.parserOptions || {}, enabledEnvs);\n    const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\n    const settings = config.settings || {};\n\n    if (!slots.lastSourceCode) {\n      const parseResult = parse(text, parser, parserOptions, options.filename);\n\n      if (!parseResult.success) {\n        return [parseResult.error];\n      }\n\n      slots.lastSourceCode = parseResult.sourceCode;\n    } else {\n      /*\n       * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n       * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n       */\n      if (!slots.lastSourceCode.scopeManager) {\n        slots.lastSourceCode = new SourceCode({\n          text: slots.lastSourceCode.text,\n          ast: slots.lastSourceCode.ast,\n          parserServices: slots.lastSourceCode.parserServices,\n          visitorKeys: slots.lastSourceCode.visitorKeys,\n          scopeManager: analyzeScope(slots.lastSourceCode.ast, parserOptions)\n        });\n      }\n    }\n\n    const sourceCode = slots.lastSourceCode;\n    const commentDirectives = options.allowInlineConfig ? getDirectiveComments(options.filename, sourceCode.ast, ruleId => getRule(slots, ruleId), options.warnInlineConfig) : {\n      configuredRules: {},\n      enabledGlobals: {},\n      exportedVariables: {},\n      problems: [],\n      disableDirectives: []\n    }; // augment global scope with declared global variables\n\n    addDeclaredGlobals(sourceCode.scopeManager.scopes[0], configuredGlobals, {\n      exportedVariables: commentDirectives.exportedVariables,\n      enabledGlobals: commentDirectives.enabledGlobals\n    });\n    const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n    let lintingProblems;\n\n    try {\n      lintingProblems = runRules(sourceCode, configuredRules, ruleId => getRule(slots, ruleId), parserOptions, parserName, settings, options.filename, options.disableFixes, slots.cwd, providedOptions.physicalFilename);\n    } catch (err) {\n      err.message += `\\nOccurred while linting ${options.filename}`;\n      debug(\"An error occurred while traversing\");\n      debug(\"Filename:\", options.filename);\n\n      if (err.currentNode) {\n        const {\n          line\n        } = err.currentNode.loc.start;\n        debug(\"Line:\", line);\n        err.message += `:${line}`;\n      }\n\n      debug(\"Parser Options:\", parserOptions);\n      debug(\"Parser Path:\", parserName);\n      debug(\"Settings:\", settings);\n      throw err;\n    }\n\n    return applyDisableDirectives({\n      directives: commentDirectives.disableDirectives,\n      problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n    });\n  }\n  /**\n   * Verifies the text against the rules specified by the second argument.\n   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n   * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\n   * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\n   *      If this is not set, the filename will default to '<input>' in the rule context. If\n   *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\n   * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n   */\n\n\n  verify(textOrSourceCode, config, filenameOrOptions) {\n    debug(\"Verify\");\n    const options = typeof filenameOrOptions === \"string\" ? {\n      filename: filenameOrOptions\n    } : filenameOrOptions || {}; // CLIEngine passes a `ConfigArray` object.\n\n    if (config && typeof config.extractConfig === \"function\") {\n      return this._verifyWithConfigArray(textOrSourceCode, config, options);\n    }\n    /*\n     * `Linter` doesn't support `overrides` property in configuration.\n     * So we cannot apply multiple processors.\n     */\n\n\n    if (options.preprocess || options.postprocess) {\n      return this._verifyWithProcessor(textOrSourceCode, config, options);\n    }\n\n    return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n  }\n  /**\n   * Verify a given code with `ConfigArray`.\n   * @param {string|SourceCode} textOrSourceCode The source code.\n   * @param {ConfigArray} configArray The config array.\n   * @param {VerifyOptions&ProcessorOptions} options The options.\n   * @returns {LintMessage[]} The found problems.\n   */\n\n\n  _verifyWithConfigArray(textOrSourceCode, configArray, options) {\n    debug(\"With ConfigArray: %s\", options.filename); // Store the config array in order to get plugin envs and rules later.\n\n    internalSlotsMap.get(this).lastConfigArray = configArray; // Extract the final config for this file.\n\n    const config = configArray.extractConfig(options.filename);\n    const processor = config.processor && configArray.pluginProcessors.get(config.processor); // Verify.\n\n    if (processor) {\n      debug(\"Apply the processor: %o\", config.processor);\n      const {\n        preprocess,\n        postprocess,\n        supportsAutofix\n      } = processor;\n      const disableFixes = options.disableFixes || !supportsAutofix;\n      return this._verifyWithProcessor(textOrSourceCode, config, { ...options,\n        disableFixes,\n        postprocess,\n        preprocess\n      }, configArray);\n    }\n\n    return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n  }\n  /**\n   * Verify with a processor.\n   * @param {string|SourceCode} textOrSourceCode The source code.\n   * @param {ConfigData|ExtractedConfig} config The config array.\n   * @param {VerifyOptions&ProcessorOptions} options The options.\n   * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n   * @returns {LintMessage[]} The found problems.\n   */\n\n\n  _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {\n    const filename = options.filename || \"<input>\";\n    const filenameToExpose = normalizeFilename(filename);\n    const physicalFilename = options.physicalFilename || filenameToExpose;\n    const text = ensureText(textOrSourceCode);\n\n    const preprocess = options.preprocess || (rawText => [rawText]); // TODO(stephenwade): Replace this with array.flat() when we drop support for Node v10\n\n\n    const postprocess = options.postprocess || (array => [].concat(...array));\n\n    const filterCodeBlock = options.filterCodeBlock || (blockFilename => blockFilename.endsWith(\".js\"));\n\n    const originalExtname = path.extname(filename);\n    const messageLists = preprocess(text, filenameToExpose).map((block, i) => {\n      debug(\"A code block was found: %o\", block.filename || \"(unnamed)\"); // Keep the legacy behavior.\n\n      if (typeof block === \"string\") {\n        return this._verifyWithoutProcessors(block, config, options);\n      }\n\n      const blockText = block.text;\n      const blockName = path.join(filename, `${i}_${block.filename}`); // Skip this block if filtered.\n\n      if (!filterCodeBlock(blockName, blockText)) {\n        debug(\"This code block was skipped.\");\n        return [];\n      } // Resolve configuration again if the file content or extension was changed.\n\n\n      if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\n        debug(\"Resolving configuration again because the file content or extension was changed.\");\n        return this._verifyWithConfigArray(blockText, configForRecursive, { ...options,\n          filename: blockName,\n          physicalFilename\n        });\n      } // Does lint.\n\n\n      return this._verifyWithoutProcessors(blockText, config, { ...options,\n        filename: blockName,\n        physicalFilename\n      });\n    });\n    return postprocess(messageLists, filenameToExpose);\n  }\n  /**\n   * Gets the SourceCode object representing the parsed source.\n   * @returns {SourceCode} The SourceCode object.\n   */\n\n\n  getSourceCode() {\n    return internalSlotsMap.get(this).lastSourceCode;\n  }\n  /**\n   * Defines a new linting rule.\n   * @param {string} ruleId A unique rule identifier\n   * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers\n   * @returns {void}\n   */\n\n\n  defineRule(ruleId, ruleModule) {\n    internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);\n  }\n  /**\n   * Defines many new linting rules.\n   * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule\n   * @returns {void}\n   */\n\n\n  defineRules(rulesToDefine) {\n    Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n      this.defineRule(ruleId, rulesToDefine[ruleId]);\n    });\n  }\n  /**\n   * Gets an object with all loaded rules.\n   * @returns {Map<string, Rule>} All loaded rules\n   */\n\n\n  getRules() {\n    const {\n      lastConfigArray,\n      ruleMap\n    } = internalSlotsMap.get(this);\n    return new Map(function* () {\n      yield* ruleMap;\n\n      if (lastConfigArray) {\n        yield* lastConfigArray.pluginRules;\n      }\n    }());\n  }\n  /**\n   * Define a new parser module\n   * @param {string} parserId Name of the parser\n   * @param {Parser} parserModule The parser object\n   * @returns {void}\n   */\n\n\n  defineParser(parserId, parserModule) {\n    internalSlotsMap.get(this).parserMap.set(parserId, parserModule);\n  }\n  /**\n   * Performs multiple autofix passes over the text until as many fixes as possible\n   * have been applied.\n   * @param {string} text The source text to apply fixes to.\n   * @param {ConfigData|ConfigArray} config The ESLint config object to use.\n   * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\n   * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\n   *      SourceCodeFixer.\n   */\n\n\n  verifyAndFix(text, config, options) {\n    let messages = [],\n        fixedResult,\n        fixed = false,\n        passNumber = 0,\n        currentText = text;\n    const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\n    const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\n    /**\n     * This loop continues until one of the following is true:\n     *\n     * 1. No more fixes have been applied.\n     * 2. Ten passes have been made.\n     *\n     * That means anytime a fix is successfully applied, there will be another pass.\n     * Essentially, guaranteeing a minimum of two passes.\n     */\n\n    do {\n      passNumber++;\n      debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\n      messages = this.verify(currentText, config, options);\n      debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\n      fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);\n      /*\n       * stop if there are any syntax errors.\n       * 'fixedResult.output' is a empty string.\n       */\n\n      if (messages.length === 1 && messages[0].fatal) {\n        break;\n      } // keep track if any fixes were ever applied - important for return value\n\n\n      fixed = fixed || fixedResult.fixed; // update to use the fixed output instead of the original text\n\n      currentText = fixedResult.output;\n    } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);\n    /*\n     * If the last result had fixes, we need to lint again to be sure we have\n     * the most up-to-date information.\n     */\n\n\n    if (fixedResult.fixed) {\n      fixedResult.messages = this.verify(currentText, config, options);\n    } // ensure the last result properly reflects if fixes were done\n\n\n    fixedResult.fixed = fixed;\n    fixedResult.output = currentText;\n    return fixedResult;\n  }\n\n}\n\nmodule.exports = {\n  Linter,\n\n  /**\n   * Get the internal slots of a given Linter instance for tests.\n   * @param {Linter} instance The Linter instance to get.\n   * @returns {LinterInternalSlots} The internal slots.\n   */\n  getLinterInternalSlots(instance) {\n    return internalSlotsMap.get(instance);\n  }\n\n};","map":{"version":3,"names":["path","require","eslintScope","evk","espree","merge","BuiltInEnvironments","pkg","astUtils","ConfigOps","ConfigValidator","Traverser","SourceCode","CodePathAnalyzer","applyDisableDirectives","ConfigCommentParser","NodeEventGenerator","createReportTranslator","Rules","createEmitter","SourceCodeFixer","timing","ruleReplacements","debug","MAX_AUTOFIX_PASSES","DEFAULT_PARSER_NAME","DEFAULT_ECMA_VERSION","commentParser","DEFAULT_ERROR_LOC","start","line","column","end","parserSymbol","Symbol","for","addDeclaredGlobals","globalScope","configGlobals","exportedVariables","enabledGlobals","id","Set","Object","keys","configValue","normalizeConfigGlobal","commentValue","value","sourceComments","comments","variable","set","get","Variable","variables","push","eslintImplicitGlobalSetting","eslintExplicitGlobal","eslintExplicitGlobalComments","writeable","forEach","name","eslintUsed","through","filter","reference","identifier","resolved","references","createMissingRuleMessage","ruleId","prototype","hasOwnProperty","call","rules","join","createLintingProblem","options","loc","message","severity","endLine","endColumn","nodeType","createDisableDirectives","type","ruleMapper","ruleIds","parseListConfig","directiveRules","length","result","directives","directiveProblems","stripDirectiveComment","split","trim","getDirectiveComments","filename","ast","warnInlineConfig","configuredRules","create","problems","disableDirectives","validator","builtInRules","token","comment","trimmedCommentText","match","exec","directiveText","lineCommentSupported","test","kind","directiveValue","slice","index","directiveType","assign","parseStringConfig","entries","normalizedValue","err","parseResult","parseJsonConfig","success","config","rule","ruleValue","validateRuleOptions","error","normalizeEcmaVersion","parser","ecmaVersion","latestEcmaVersion","eslintEnvPattern","findEslintEnv","text","retv","lastIndex","normalizeFilename","parts","sep","lastIndexOf","normalizeVerifyOptions","providedOptions","disableInlineConfig","noInlineConfig","ignoreInlineConfig","allowInlineConfig","configNameOfNoInlineConfig","reportUnusedDisableDirectives","disableFixes","Boolean","resolveParserOptions","enabledEnvironments","parserOptionsFromEnv","env","parserOptions","reduce","mergedParserOptions","isModule","sourceType","ecmaFeatures","globalReturn","resolveGlobals","providedGlobals","globals","map","stripUnicodeBOM","charCodeAt","getRuleOptions","ruleConfig","Array","isArray","analyzeScope","visitorKeys","analyze","ignoreEval","nodejsScope","impliedStrict","childVisitorKeys","KEYS","fallback","getKeys","parse","providedParserOptions","filePath","textToParse","replace","shebangPattern","captured","range","raw","tokens","eslintVisitorKeys","eslintScopeManager","parseForESLint","parserServices","services","scopeManager","sourceCode","ex","stack","fatal","lineNumber","getScope","currentNode","inner","node","parent","scope","acquire","childScopes","scopes","markVariableAsUsed","hasGlobalReturn","specialScope","currentScope","initialScope","upper","find","scopeVar","createRuleListeners","ruleContext","getAncestors","ancestorsStartingAtParent","ancestor","reverse","DEPRECATED_SOURCECODE_PASSTHROUGHS","getSource","getSourceLines","getAllComments","getNodeByRangeIndex","getComments","getCommentsBefore","getCommentsAfter","getCommentsInside","getJSDocComment","getFirstToken","getFirstTokens","getLastToken","getLastTokens","getTokenAfter","getTokenBefore","getTokenByRangeStart","getTokens","getTokensAfter","getTokensBefore","getTokensBetween","BASE_TRAVERSAL_CONTEXT","freeze","contextInfo","methodName","getSourceCode","runRules","parserName","settings","cwd","physicalFilename","emitter","nodeQueue","traverse","enter","isEntering","leave","sharedTraversalContext","getDeclaredVariables","bind","getCwd","getFilename","getPhysicalFilename","parserPath","lintingProblems","getRuleSeverity","messageIds","meta","messages","reportTranslator","report","problem","fix","fixable","Error","ruleListeners","selector","on","enabled","time","eventGenerator","traversalInfo","enterNode","leaveNode","ensureText","textOrSourceCode","hasBOM","bom","String","getEnv","slots","envId","lastConfigArray","pluginEnvironments","getRule","pluginRules","ruleMap","normalizeCwd","process","undefined","internalSlotsMap","WeakMap","Linter","constructor","lastSourceCode","parserMap","Map","version","_verifyWithoutProcessors","providedConfig","definition","has","envInFile","resolvedEnvConfig","builtin","enabledEnvs","envName","configuredGlobals","commentDirectives","concat","sort","problemA","problemB","verify","filenameOrOptions","extractConfig","_verifyWithConfigArray","preprocess","postprocess","_verifyWithProcessor","configArray","processor","pluginProcessors","supportsAutofix","configForRecursive","filenameToExpose","rawText","array","filterCodeBlock","blockFilename","endsWith","originalExtname","extname","messageLists","block","i","blockText","blockName","defineRule","ruleModule","define","defineRules","rulesToDefine","getOwnPropertyNames","getRules","defineParser","parserId","parserModule","verifyAndFix","fixedResult","fixed","passNumber","currentText","debugTextDescription","shouldFix","applyFixes","output","module","exports","getLinterInternalSlots","instance"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/linter.js"],"sourcesContent":["/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n * @author aladdin-add\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    path = require(\"path\"),\n    eslintScope = require(\"eslint-scope\"),\n    evk = require(\"eslint-visitor-keys\"),\n    espree = require(\"espree\"),\n    merge = require(\"lodash.merge\"),\n    BuiltInEnvironments = require(\"@eslint/eslintrc/conf/environments\"),\n    pkg = require(\"../../package.json\"),\n    astUtils = require(\"../shared/ast-utils\"),\n    ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\"),\n    ConfigValidator = require(\"@eslint/eslintrc/lib/shared/config-validator\"),\n    Traverser = require(\"../shared/traverser\"),\n    { SourceCode } = require(\"../source-code\"),\n    CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n    applyDisableDirectives = require(\"./apply-disable-directives\"),\n    ConfigCommentParser = require(\"./config-comment-parser\"),\n    NodeEventGenerator = require(\"./node-event-generator\"),\n    createReportTranslator = require(\"./report-translator\"),\n    Rules = require(\"./rules\"),\n    createEmitter = require(\"./safe-emitter\"),\n    SourceCodeFixer = require(\"./source-code-fixer\"),\n    timing = require(\"./timing\"),\n    ruleReplacements = require(\"../../conf/replacements.json\");\n\nconst debug = require(\"debug\")(\"eslint:linter\");\nconst MAX_AUTOFIX_PASSES = 10;\nconst DEFAULT_PARSER_NAME = \"espree\";\nconst DEFAULT_ECMA_VERSION = 5;\nconst commentParser = new ConfigCommentParser();\nconst DEFAULT_ERROR_LOC = { start: { line: 1, column: 0 }, end: { line: 1, column: 1 } };\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\")[\"ConfigArray\"]>} ConfigArray */\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\")[\"ExtractedConfig\"]>} ExtractedConfig */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").Environment} Environment */\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Processor} Processor */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/**\n * @template T\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\n */\n\n/**\n * @typedef {Object} DisableDirective\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type\n * @property {number} line\n * @property {number} column\n * @property {(string|null)} ruleId\n */\n\n/**\n * The private data for `Linter` instance.\n * @typedef {Object} LinterInternalSlots\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\n * @property {Map<string, Parser>} parserMap The loaded parsers.\n * @property {Rules} ruleMap The loaded rules.\n */\n\n/**\n * @typedef {Object} VerifyOptions\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\n *      to change config once it is set. Defaults to true if not supplied.\n *      Useful if you want to validate JS without comments overriding rules.\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\n *      properties into the lint result.\n * @property {string} [filename] the filename of the source code.\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\n *      unused `eslint-disable` directives.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\n *      predicate function that selects adopt code blocks.\n * @property {Processor[\"postprocess\"]} [postprocess] postprocessor for report\n *      messages. If provided, this should accept an array of the message lists\n *      for each code block returned from the preprocessor, apply a mapping to\n *      the messages as appropriate, and return a one-dimensional array of\n *      messages.\n * @property {Processor[\"preprocess\"]} [preprocess] preprocessor for source text.\n *      If provided, this should accept a string of source text, and return an\n *      array of code blocks to lint.\n */\n\n/**\n * @typedef {Object} FixOptions\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\n *      whether fixes should be applied.\n */\n\n/**\n * @typedef {Object} InternalOptions\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\n * @property {\"off\" | \"warn\" | \"error\"} reportUnusedDisableDirectives (boolean values were normalized)\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} configGlobals The globals declared in configuration\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\n * @returns {void}\n */\nfunction addDeclaredGlobals(globalScope, configGlobals, { exportedVariables, enabledGlobals }) {\n\n    // Define configured global variables.\n    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {\n\n        /*\n         * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n         */\n        const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);\n        const commentValue = enabledGlobals[id] && enabledGlobals[id].value;\n        const value = commentValue || configValue;\n        const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;\n\n        if (value === \"off\") {\n            continue;\n        }\n\n        let variable = globalScope.set.get(id);\n\n        if (!variable) {\n            variable = new eslintScope.Variable(id, globalScope);\n\n            globalScope.variables.push(variable);\n            globalScope.set.set(id, variable);\n        }\n\n        variable.eslintImplicitGlobalSetting = configValue;\n        variable.eslintExplicitGlobal = sourceComments !== void 0;\n        variable.eslintExplicitGlobalComments = sourceComments;\n        variable.writeable = (value === \"writable\");\n    }\n\n    // mark all exported variables as such\n    Object.keys(exportedVariables).forEach(name => {\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n        }\n    });\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(reference => {\n        const name = reference.identifier.name;\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * creates a missing-rule message.\n * @param {string} ruleId the ruleId to create\n * @returns {string} created error message\n * @private\n */\nfunction createMissingRuleMessage(ruleId) {\n    return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId)\n        ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(\", \")}`\n        : `Definition for rule '${ruleId}' was not found.`;\n}\n\n/**\n * creates a linting problem\n * @param {Object} options to create linting error\n * @param {string} [options.ruleId] the ruleId to report\n * @param {Object} [options.loc] the loc to report\n * @param {string} [options.message] the error message to report\n * @param {string} [options.severity] the error message to report\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\n * @private\n */\nfunction createLintingProblem(options) {\n    const {\n        ruleId = null,\n        loc = DEFAULT_ERROR_LOC,\n        message = createMissingRuleMessage(options.ruleId),\n        severity = 2\n    } = options;\n\n    return {\n        ruleId,\n        message,\n        line: loc.start.line,\n        column: loc.start.column + 1,\n        endLine: loc.end.line,\n        endColumn: loc.end.column + 1,\n        severity,\n        nodeType: null\n    };\n}\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {Object} options to create disable directives\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\n * @param {{line: number, column: number}} options.loc The 0-based location of the comment token\n * @param {string} options.value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules\n * @returns {Object} Directives and problems from the comment\n */\nfunction createDisableDirectives(options) {\n    const { type, loc, value, ruleMapper } = options;\n    const ruleIds = Object.keys(commentParser.parseListConfig(value));\n    const directiveRules = ruleIds.length ? ruleIds : [null];\n    const result = {\n        directives: [], // valid disable directives\n        directiveProblems: [] // problems in directives\n    };\n\n    for (const ruleId of directiveRules) {\n\n        // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\n        if (ruleId === null || ruleMapper(ruleId) !== null) {\n            result.directives.push({ type, line: loc.start.line, column: loc.start.column + 1, ruleId });\n        } else {\n            result.directiveProblems.push(createLintingProblem({ ruleId, loc }));\n        }\n    }\n    return result;\n}\n\n/**\n * Remove the ignored part from a given directive comment and trim it.\n * @param {string} value The comment text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripDirectiveComment(value) {\n    return value.split(/\\s-{2,}\\s/u)[0].trim();\n}\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\nfunction getDirectiveComments(filename, ast, ruleMapper, warnInlineConfig) {\n    const configuredRules = {};\n    const enabledGlobals = Object.create(null);\n    const exportedVariables = {};\n    const problems = [];\n    const disableDirectives = [];\n    const validator = new ConfigValidator({\n        builtInRules: Rules\n    });\n\n    ast.comments.filter(token => token.type !== \"Shebang\").forEach(comment => {\n        const trimmedCommentText = stripDirectiveComment(comment.value);\n        const match = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\\s|$)/u.exec(trimmedCommentText);\n\n        if (!match) {\n            return;\n        }\n        const directiveText = match[1];\n        const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\n\n        if (comment.type === \"Line\" && !lineCommentSupported) {\n            return;\n        }\n\n        if (warnInlineConfig) {\n            const kind = comment.type === \"Block\" ? `/*${directiveText}*/` : `//${directiveText}`;\n\n            problems.push(createLintingProblem({\n                ruleId: null,\n                message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,\n                loc: comment.loc,\n                severity: 1\n            }));\n            return;\n        }\n\n        if (lineCommentSupported && comment.loc.start.line !== comment.loc.end.line) {\n            const message = `${directiveText} comment should not span multiple lines.`;\n\n            problems.push(createLintingProblem({\n                ruleId: null,\n                message,\n                loc: comment.loc\n            }));\n            return;\n        }\n\n        const directiveValue = trimmedCommentText.slice(match.index + directiveText.length);\n\n        switch (directiveText) {\n            case \"eslint-disable\":\n            case \"eslint-enable\":\n            case \"eslint-disable-next-line\":\n            case \"eslint-disable-line\": {\n                const directiveType = directiveText.slice(\"eslint-\".length);\n                const options = { type: directiveType, loc: comment.loc, value: directiveValue, ruleMapper };\n                const { directives, directiveProblems } = createDisableDirectives(options);\n\n                disableDirectives.push(...directives);\n                problems.push(...directiveProblems);\n                break;\n            }\n\n            case \"exported\":\n                Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n                break;\n\n            case \"globals\":\n            case \"global\":\n                for (const [id, { value }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\n                    let normalizedValue;\n\n                    try {\n                        normalizedValue = ConfigOps.normalizeConfigGlobal(value);\n                    } catch (err) {\n                        problems.push(createLintingProblem({\n                            ruleId: null,\n                            loc: comment.loc,\n                            message: err.message\n                        }));\n                        continue;\n                    }\n\n                    if (enabledGlobals[id]) {\n                        enabledGlobals[id].comments.push(comment);\n                        enabledGlobals[id].value = normalizedValue;\n                    } else {\n                        enabledGlobals[id] = {\n                            comments: [comment],\n                            value: normalizedValue\n                        };\n                    }\n                }\n                break;\n\n            case \"eslint\": {\n                const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n\n                if (parseResult.success) {\n                    Object.keys(parseResult.config).forEach(name => {\n                        const rule = ruleMapper(name);\n                        const ruleValue = parseResult.config[name];\n\n                        if (rule === null) {\n                            problems.push(createLintingProblem({ ruleId: name, loc: comment.loc }));\n                            return;\n                        }\n\n                        try {\n                            validator.validateRuleOptions(rule, name, ruleValue);\n                        } catch (err) {\n                            problems.push(createLintingProblem({\n                                ruleId: name,\n                                message: err.message,\n                                loc: comment.loc\n                            }));\n\n                            // do not apply the config, if found invalid options.\n                            return;\n                        }\n\n                        configuredRules[name] = ruleValue;\n                    });\n                } else {\n                    problems.push(parseResult.error);\n                }\n\n                break;\n            }\n\n            // no default\n        }\n    });\n\n    return {\n        configuredRules,\n        enabledGlobals,\n        exportedVariables,\n        problems,\n        disableDirectives\n    };\n}\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param {Parser} parser The parser which uses this options.\n * @param {number} ecmaVersion ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersion(parser, ecmaVersion) {\n    if ((parser[parserSymbol] || parser) === espree) {\n        if (ecmaVersion === \"latest\") {\n            return espree.latestEcmaVersion;\n        }\n    }\n\n    /*\n     * Calculate ECMAScript edition number from official year version starting with\n     * ES2015, which corresponds with ES6 (or a difference of 2009).\n     */\n    return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)\\*\\//gsu;\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\nfunction findEslintEnv(text) {\n    let match, retv;\n\n    eslintEnvPattern.lastIndex = 0;\n\n    while ((match = eslintEnvPattern.exec(text)) !== null) {\n        retv = Object.assign(\n            retv || {},\n            commentParser.parseListConfig(stripDirectiveComment(match[1]))\n        );\n    }\n\n    return retv;\n}\n\n/**\n * Convert \"/path/to/<text>\" to \"<text>\".\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\n * was omitted because `configArray.extractConfig()` requires an absolute path.\n * But the linter should pass `<text>` to `RuleContext#getFilename()` in that\n * case.\n * Also, code blocks can have their virtual filename. If the parent filename was\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\n * it's not an absolute path).\n * @param {string} filename The filename to normalize.\n * @returns {string} The normalized filename.\n */\nfunction normalizeFilename(filename) {\n    const parts = filename.split(path.sep);\n    const index = parts.lastIndexOf(\"<text>\");\n\n    return index === -1 ? filename : parts.slice(index).join(path.sep);\n}\n\n/**\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\n * consistent shape.\n * @param {VerifyOptions} providedOptions Options\n * @param {ConfigData} config Config.\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\n */\nfunction normalizeVerifyOptions(providedOptions, config) {\n    const disableInlineConfig = config.noInlineConfig === true;\n    const ignoreInlineConfig = providedOptions.allowInlineConfig === false;\n    const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig\n        ? ` (${config.configNameOfNoInlineConfig})`\n        : \"\";\n\n    let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;\n\n    if (typeof reportUnusedDisableDirectives === \"boolean\") {\n        reportUnusedDisableDirectives = reportUnusedDisableDirectives ? \"error\" : \"off\";\n    }\n    if (typeof reportUnusedDisableDirectives !== \"string\") {\n        reportUnusedDisableDirectives = config.reportUnusedDisableDirectives ? \"warn\" : \"off\";\n    }\n\n    return {\n        filename: normalizeFilename(providedOptions.filename || \"<input>\"),\n        allowInlineConfig: !ignoreInlineConfig,\n        warnInlineConfig: disableInlineConfig && !ignoreInlineConfig\n            ? `your config${configNameOfNoInlineConfig}`\n            : null,\n        reportUnusedDisableDirectives,\n        disableFixes: Boolean(providedOptions.disableFixes)\n    };\n}\n\n/**\n * Combines the provided parserOptions with the options from environments\n * @param {Parser} parser The parser which uses this options.\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {ParserOptions} Resulting parser options after merge\n */\nfunction resolveParserOptions(parser, providedOptions, enabledEnvironments) {\n\n    const parserOptionsFromEnv = enabledEnvironments\n        .filter(env => env.parserOptions)\n        .reduce((parserOptions, env) => merge(parserOptions, env.parserOptions), {});\n    const mergedParserOptions = merge(parserOptionsFromEnv, providedOptions || {});\n    const isModule = mergedParserOptions.sourceType === \"module\";\n\n    if (isModule) {\n\n        /*\n         * can't have global return inside of modules\n         * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\n         */\n        mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, { globalReturn: false });\n    }\n\n    mergedParserOptions.ecmaVersion = normalizeEcmaVersion(parser, mergedParserOptions.ecmaVersion);\n\n    return mergedParserOptions;\n}\n\n/**\n * Combines the provided globals object with the globals from environments\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Record<string, GlobalConf>} The resolved globals object\n */\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\n    return Object.assign(\n        {},\n        ...enabledEnvironments.filter(env => env.globals).map(env => env.globals),\n        providedGlobals\n    );\n}\n\n/**\n * Strips Unicode BOM from a given text.\n * @param {string} text A text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripUnicodeBOM(text) {\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n    if (text.charCodeAt(0) === 0xFEFF) {\n        return text.slice(1);\n    }\n    return text;\n}\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\nfunction getRuleOptions(ruleConfig) {\n    if (Array.isArray(ruleConfig)) {\n        return ruleConfig.slice(1);\n    }\n    return [];\n\n}\n\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {ParserOptions} parserOptions The parser options.\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\nfunction analyzeScope(ast, parserOptions, visitorKeys) {\n    const ecmaFeatures = parserOptions.ecmaFeatures || {};\n    const ecmaVersion = parserOptions.ecmaVersion || DEFAULT_ECMA_VERSION;\n\n    return eslintScope.analyze(ast, {\n        ignoreEval: true,\n        nodejsScope: ecmaFeatures.globalReturn,\n        impliedStrict: ecmaFeatures.impliedStrict,\n        ecmaVersion,\n        sourceType: parserOptions.sourceType || \"script\",\n        childVisitorKeys: visitorKeys || evk.KEYS,\n        fallback: Traverser.getKeys\n    });\n}\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {Parser} parser The parser to parse.\n * @param {ParserOptions} providedParserOptions Options to pass to the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: Problem}|{success: true, sourceCode: SourceCode}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\nfunction parse(text, parser, providedParserOptions, filePath) {\n    const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);\n    const parserOptions = Object.assign({}, providedParserOptions, {\n        loc: true,\n        range: true,\n        raw: true,\n        tokens: true,\n        comment: true,\n        eslintVisitorKeys: true,\n        eslintScopeManager: true,\n        filePath\n    });\n\n    /*\n     * Check for parsing errors first. If there's a parsing error, nothing\n     * else can happen. However, a parsing error does not throw an error\n     * from this method - it's just considered a fatal error message, a\n     * problem that ESLint identified just like any other.\n     */\n    try {\n        const parseResult = (typeof parser.parseForESLint === \"function\")\n            ? parser.parseForESLint(textToParse, parserOptions)\n            : { ast: parser.parse(textToParse, parserOptions) };\n        const ast = parseResult.ast;\n        const parserServices = parseResult.services || {};\n        const visitorKeys = parseResult.visitorKeys || evk.KEYS;\n        const scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);\n\n        return {\n            success: true,\n\n            /*\n             * Save all values that `parseForESLint()` returned.\n             * If a `SourceCode` object is given as the first parameter instead of source code text,\n             * linter skips the parsing process and reuses the source code object.\n             * In that case, linter needs all the values that `parseForESLint()` returned.\n             */\n            sourceCode: new SourceCode({\n                text,\n                ast,\n                parserServices,\n                scopeManager,\n                visitorKeys\n            })\n        };\n    } catch (ex) {\n\n        // If the message includes a leading line number, strip it:\n        const message = `Parsing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n\n        debug(\"%s\\n%s\", message, ex.stack);\n\n        return {\n            success: false,\n            error: {\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                message,\n                line: ex.lineNumber,\n                column: ex.column\n            }\n        };\n    }\n}\n\n/**\n * Gets the scope for the current node\n * @param {ScopeManager} scopeManager The scope manager for this AST\n * @param {ASTNode} currentNode The node to get the scope of\n * @returns {eslint-scope.Scope} The scope information for this node\n */\nfunction getScope(scopeManager, currentNode) {\n\n    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n    const inner = currentNode.type !== \"Program\";\n\n    for (let node = currentNode; node; node = node.parent) {\n        const scope = scopeManager.acquire(node, inner);\n\n        if (scope) {\n            if (scope.type === \"function-expression-name\") {\n                return scope.childScopes[0];\n            }\n            return scope;\n        }\n    }\n\n    return scopeManager.scopes[0];\n}\n\n/**\n * Marks a variable as used in the current scope\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\n * @param {ASTNode} currentNode The node currently being traversed\n * @param {Object} parserOptions The options used to parse this text\n * @param {string} name The name of the variable that should be marked as used.\n * @returns {boolean} True if the variable was found and marked as used, false if not.\n */\nfunction markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {\n    const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;\n    const specialScope = hasGlobalReturn || parserOptions.sourceType === \"module\";\n    const currentScope = getScope(scopeManager, currentNode);\n\n    // Special Node.js scope means we need to start one level deeper\n    const initialScope = currentScope.type === \"global\" && specialScope ? currentScope.childScopes[0] : currentScope;\n\n    for (let scope = initialScope; scope; scope = scope.upper) {\n        const variable = scope.variables.find(scopeVar => scopeVar.name === name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Runs a rule, and gets its listeners\n * @param {Rule} rule A normalized rule with a `create` method\n * @param {Context} ruleContext The context that should be passed to the rule\n * @returns {Object} A map of selector listeners provided by the rule\n */\nfunction createRuleListeners(rule, ruleContext) {\n    try {\n        return rule.create(ruleContext);\n    } catch (ex) {\n        ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\n        throw ex;\n    }\n}\n\n/**\n * Gets all the ancestors of a given node\n * @param {ASTNode} node The node\n * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting\n * from the root node and going inwards to the parent node.\n */\nfunction getAncestors(node) {\n    const ancestorsStartingAtParent = [];\n\n    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n        ancestorsStartingAtParent.push(ancestor);\n    }\n\n    return ancestorsStartingAtParent.reverse();\n}\n\n// methods that exist on SourceCode object\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n    getSource: \"getText\",\n    getSourceLines: \"getLines\",\n    getAllComments: \"getAllComments\",\n    getNodeByRangeIndex: \"getNodeByRangeIndex\",\n    getComments: \"getComments\",\n    getCommentsBefore: \"getCommentsBefore\",\n    getCommentsAfter: \"getCommentsAfter\",\n    getCommentsInside: \"getCommentsInside\",\n    getJSDocComment: \"getJSDocComment\",\n    getFirstToken: \"getFirstToken\",\n    getFirstTokens: \"getFirstTokens\",\n    getLastToken: \"getLastToken\",\n    getLastTokens: \"getLastTokens\",\n    getTokenAfter: \"getTokenAfter\",\n    getTokenBefore: \"getTokenBefore\",\n    getTokenByRangeStart: \"getTokenByRangeStart\",\n    getTokens: \"getTokens\",\n    getTokensAfter: \"getTokensAfter\",\n    getTokensBefore: \"getTokensBefore\",\n    getTokensBetween: \"getTokensBetween\"\n};\n\nconst BASE_TRAVERSAL_CONTEXT = Object.freeze(\n    Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(\n        (contextInfo, methodName) =>\n            Object.assign(contextInfo, {\n                [methodName](...args) {\n                    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);\n                }\n            }),\n        {}\n    )\n);\n\n/**\n * Runs the given rules on the given SourceCode object\n * @param {SourceCode} sourceCode A SourceCode object for the given text\n * @param {Object} configuredRules The rules configuration\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\n * @param {Object} parserOptions The options that were passed to the parser\n * @param {string} parserName The name of the parser in the config\n * @param {Object} settings The settings that were enabled in the config\n * @param {string} filename The reported filename of the code\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\n * @param {string | undefined} cwd cwd of the cli\n * @param {string} physicalFilename The full path of the file on disk without any code block information\n * @returns {Problem[]} An array of reported problems\n */\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename, disableFixes, cwd, physicalFilename) {\n    const emitter = createEmitter();\n    const nodeQueue = [];\n    let currentNode = sourceCode.ast;\n\n    Traverser.traverse(sourceCode.ast, {\n        enter(node, parent) {\n            node.parent = parent;\n            nodeQueue.push({ isEntering: true, node });\n        },\n        leave(node) {\n            nodeQueue.push({ isEntering: false, node });\n        },\n        visitorKeys: sourceCode.visitorKeys\n    });\n\n    /*\n     * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n     * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n     * properties once for each rule.\n     */\n    const sharedTraversalContext = Object.freeze(\n        Object.assign(\n            Object.create(BASE_TRAVERSAL_CONTEXT),\n            {\n                getAncestors: () => getAncestors(currentNode),\n                getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),\n                getCwd: () => cwd,\n                getFilename: () => filename,\n                getPhysicalFilename: () => physicalFilename || filename,\n                getScope: () => getScope(sourceCode.scopeManager, currentNode),\n                getSourceCode: () => sourceCode,\n                markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name),\n                parserOptions,\n                parserPath: parserName,\n                parserServices: sourceCode.parserServices,\n                settings\n            }\n        )\n    );\n\n\n    const lintingProblems = [];\n\n    Object.keys(configuredRules).forEach(ruleId => {\n        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\n\n        // not load disabled rules\n        if (severity === 0) {\n            return;\n        }\n\n        const rule = ruleMapper(ruleId);\n\n        if (rule === null) {\n            lintingProblems.push(createLintingProblem({ ruleId }));\n            return;\n        }\n\n        const messageIds = rule.meta && rule.meta.messages;\n        let reportTranslator = null;\n        const ruleContext = Object.freeze(\n            Object.assign(\n                Object.create(sharedTraversalContext),\n                {\n                    id: ruleId,\n                    options: getRuleOptions(configuredRules[ruleId]),\n                    report(...args) {\n\n                        /*\n                         * Create a report translator lazily.\n                         * In a vast majority of cases, any given rule reports zero errors on a given\n                         * piece of code. Creating a translator lazily avoids the performance cost of\n                         * creating a new translator function for each rule that usually doesn't get\n                         * called.\n                         *\n                         * Using lazy report translators improves end-to-end performance by about 3%\n                         * with Node 8.4.0.\n                         */\n                        if (reportTranslator === null) {\n                            reportTranslator = createReportTranslator({\n                                ruleId,\n                                severity,\n                                sourceCode,\n                                messageIds,\n                                disableFixes\n                            });\n                        }\n                        const problem = reportTranslator(...args);\n\n                        if (problem.fix && rule.meta && !rule.meta.fixable) {\n                            throw new Error(\"Fixable rules should export a `meta.fixable` property.\");\n                        }\n                        lintingProblems.push(problem);\n                    }\n                }\n            )\n        );\n\n        const ruleListeners = createRuleListeners(rule, ruleContext);\n\n        // add all the selectors from the rule as listeners\n        Object.keys(ruleListeners).forEach(selector => {\n            emitter.on(\n                selector,\n                timing.enabled\n                    ? timing.time(ruleId, ruleListeners[selector])\n                    : ruleListeners[selector]\n            );\n        });\n    });\n\n    // only run code path analyzer if the top level node is \"Program\", skip otherwise\n    const eventGenerator = nodeQueue[0].node.type === \"Program\"\n        ? new CodePathAnalyzer(new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys }))\n        : new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys });\n\n    nodeQueue.forEach(traversalInfo => {\n        currentNode = traversalInfo.node;\n\n        try {\n            if (traversalInfo.isEntering) {\n                eventGenerator.enterNode(currentNode);\n            } else {\n                eventGenerator.leaveNode(currentNode);\n            }\n        } catch (err) {\n            err.currentNode = currentNode;\n            throw err;\n        }\n    });\n\n    return lintingProblems;\n}\n\n/**\n * Ensure the source code to be a string.\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\n * @returns {string} The source code text.\n */\nfunction ensureText(textOrSourceCode) {\n    if (typeof textOrSourceCode === \"object\") {\n        const { hasBOM, text } = textOrSourceCode;\n        const bom = hasBOM ? \"\\uFEFF\" : \"\";\n\n        return bom + text;\n    }\n\n    return String(textOrSourceCode);\n}\n\n/**\n * Get an environment.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} envId The environment ID to get.\n * @returns {Environment|null} The environment.\n */\nfunction getEnv(slots, envId) {\n    return (\n        (slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId)) ||\n        BuiltInEnvironments.get(envId) ||\n        null\n    );\n}\n\n/**\n * Get a rule.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} ruleId The rule ID to get.\n * @returns {Rule|null} The rule.\n */\nfunction getRule(slots, ruleId) {\n    return (\n        (slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId)) ||\n        slots.ruleMap.get(ruleId)\n    );\n}\n\n/**\n * Normalize the value of the cwd\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\n * @returns {string | undefined} normalized cwd\n */\nfunction normalizeCwd(cwd) {\n    if (cwd) {\n        return cwd;\n    }\n    if (typeof process === \"object\") {\n        return process.cwd();\n    }\n\n    // It's more explicit to assign the undefined\n    // eslint-disable-next-line no-undefined\n    return undefined;\n}\n\n/**\n * The map to store private data.\n * @type {WeakMap<Linter, LinterInternalSlots>}\n */\nconst internalSlotsMap = new WeakMap();\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\nclass Linter {\n\n    /**\n     * Initialize the Linter.\n     * @param {Object} [config] the config object\n     * @param {string} [config.cwd]  path to a directory that should be considered as the current working directory, can be undefined.\n     */\n    constructor({ cwd } = {}) {\n        internalSlotsMap.set(this, {\n            cwd: normalizeCwd(cwd),\n            lastConfigArray: null,\n            lastSourceCode: null,\n            parserMap: new Map([[\"espree\", espree]]),\n            ruleMap: new Rules()\n        });\n\n        this.version = pkg.version;\n    }\n\n    /**\n     * Getter for package version.\n     * @static\n     * @returns {string} The version from package.json.\n     */\n    static get version() {\n        return pkg.version;\n    }\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n     */\n    _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n        const slots = internalSlotsMap.get(this);\n        const config = providedConfig || {};\n        const options = normalizeVerifyOptions(providedOptions, config);\n        let text;\n\n        // evaluate arguments\n        if (typeof textOrSourceCode === \"string\") {\n            slots.lastSourceCode = null;\n            text = textOrSourceCode;\n        } else {\n            slots.lastSourceCode = textOrSourceCode;\n            text = textOrSourceCode.text;\n        }\n\n        // Resolve parser.\n        let parserName = DEFAULT_PARSER_NAME;\n        let parser = espree;\n\n        if (typeof config.parser === \"object\" && config.parser !== null) {\n            parserName = config.parser.filePath;\n            parser = config.parser.definition;\n        } else if (typeof config.parser === \"string\") {\n            if (!slots.parserMap.has(config.parser)) {\n                return [{\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Configured parser '${config.parser}' was not found.`,\n                    line: 0,\n                    column: 0\n                }];\n            }\n            parserName = config.parser;\n            parser = slots.parserMap.get(config.parser);\n        }\n\n        // search and apply \"eslint-env *\".\n        const envInFile = options.allowInlineConfig && !options.warnInlineConfig\n            ? findEslintEnv(text)\n            : {};\n        const resolvedEnvConfig = Object.assign({ builtin: true }, config.env, envInFile);\n        const enabledEnvs = Object.keys(resolvedEnvConfig)\n            .filter(envName => resolvedEnvConfig[envName])\n            .map(envName => getEnv(slots, envName))\n            .filter(env => env);\n\n        const parserOptions = resolveParserOptions(parser, config.parserOptions || {}, enabledEnvs);\n        const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\n        const settings = config.settings || {};\n\n        if (!slots.lastSourceCode) {\n            const parseResult = parse(\n                text,\n                parser,\n                parserOptions,\n                options.filename\n            );\n\n            if (!parseResult.success) {\n                return [parseResult.error];\n            }\n\n            slots.lastSourceCode = parseResult.sourceCode;\n        } else {\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             */\n            if (!slots.lastSourceCode.scopeManager) {\n                slots.lastSourceCode = new SourceCode({\n                    text: slots.lastSourceCode.text,\n                    ast: slots.lastSourceCode.ast,\n                    parserServices: slots.lastSourceCode.parserServices,\n                    visitorKeys: slots.lastSourceCode.visitorKeys,\n                    scopeManager: analyzeScope(slots.lastSourceCode.ast, parserOptions)\n                });\n            }\n        }\n\n        const sourceCode = slots.lastSourceCode;\n        const commentDirectives = options.allowInlineConfig\n            ? getDirectiveComments(options.filename, sourceCode.ast, ruleId => getRule(slots, ruleId), options.warnInlineConfig)\n            : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };\n\n        // augment global scope with declared global variables\n        addDeclaredGlobals(\n            sourceCode.scopeManager.scopes[0],\n            configuredGlobals,\n            { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }\n        );\n\n        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n\n        let lintingProblems;\n\n        try {\n            lintingProblems = runRules(\n                sourceCode,\n                configuredRules,\n                ruleId => getRule(slots, ruleId),\n                parserOptions,\n                parserName,\n                settings,\n                options.filename,\n                options.disableFixes,\n                slots.cwd,\n                providedOptions.physicalFilename\n            );\n        } catch (err) {\n            err.message += `\\nOccurred while linting ${options.filename}`;\n            debug(\"An error occurred while traversing\");\n            debug(\"Filename:\", options.filename);\n            if (err.currentNode) {\n                const { line } = err.currentNode.loc.start;\n\n                debug(\"Line:\", line);\n                err.message += `:${line}`;\n            }\n            debug(\"Parser Options:\", parserOptions);\n            debug(\"Parser Path:\", parserName);\n            debug(\"Settings:\", settings);\n            throw err;\n        }\n\n        return applyDisableDirectives({\n            directives: commentDirectives.disableDirectives,\n            problems: lintingProblems\n                .concat(commentDirectives.problems)\n                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n        });\n    }\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\n     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n     */\n    verify(textOrSourceCode, config, filenameOrOptions) {\n        debug(\"Verify\");\n        const options = typeof filenameOrOptions === \"string\"\n            ? { filename: filenameOrOptions }\n            : filenameOrOptions || {};\n\n        // CLIEngine passes a `ConfigArray` object.\n        if (config && typeof config.extractConfig === \"function\") {\n            return this._verifyWithConfigArray(textOrSourceCode, config, options);\n        }\n\n        /*\n         * `Linter` doesn't support `overrides` property in configuration.\n         * So we cannot apply multiple processors.\n         */\n        if (options.preprocess || options.postprocess) {\n            return this._verifyWithProcessor(textOrSourceCode, config, options);\n        }\n        return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n    }\n\n    /**\n     * Verify a given code with `ConfigArray`.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigArray} configArray The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @returns {LintMessage[]} The found problems.\n     */\n    _verifyWithConfigArray(textOrSourceCode, configArray, options) {\n        debug(\"With ConfigArray: %s\", options.filename);\n\n        // Store the config array in order to get plugin envs and rules later.\n        internalSlotsMap.get(this).lastConfigArray = configArray;\n\n        // Extract the final config for this file.\n        const config = configArray.extractConfig(options.filename);\n        const processor =\n            config.processor &&\n            configArray.pluginProcessors.get(config.processor);\n\n        // Verify.\n        if (processor) {\n            debug(\"Apply the processor: %o\", config.processor);\n            const { preprocess, postprocess, supportsAutofix } = processor;\n            const disableFixes = options.disableFixes || !supportsAutofix;\n\n            return this._verifyWithProcessor(\n                textOrSourceCode,\n                config,\n                { ...options, disableFixes, postprocess, preprocess },\n                configArray\n            );\n        }\n        return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n    }\n\n    /**\n     * Verify with a processor.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigData|ExtractedConfig} config The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n     * @returns {LintMessage[]} The found problems.\n     */\n    _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {\n        const filename = options.filename || \"<input>\";\n        const filenameToExpose = normalizeFilename(filename);\n        const physicalFilename = options.physicalFilename || filenameToExpose;\n        const text = ensureText(textOrSourceCode);\n        const preprocess = options.preprocess || (rawText => [rawText]);\n\n        // TODO(stephenwade): Replace this with array.flat() when we drop support for Node v10\n        const postprocess = options.postprocess || (array => [].concat(...array));\n        const filterCodeBlock =\n            options.filterCodeBlock ||\n            (blockFilename => blockFilename.endsWith(\".js\"));\n        const originalExtname = path.extname(filename);\n        const messageLists = preprocess(text, filenameToExpose).map((block, i) => {\n            debug(\"A code block was found: %o\", block.filename || \"(unnamed)\");\n\n            // Keep the legacy behavior.\n            if (typeof block === \"string\") {\n                return this._verifyWithoutProcessors(block, config, options);\n            }\n\n            const blockText = block.text;\n            const blockName = path.join(filename, `${i}_${block.filename}`);\n\n            // Skip this block if filtered.\n            if (!filterCodeBlock(blockName, blockText)) {\n                debug(\"This code block was skipped.\");\n                return [];\n            }\n\n            // Resolve configuration again if the file content or extension was changed.\n            if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\n                debug(\"Resolving configuration again because the file content or extension was changed.\");\n                return this._verifyWithConfigArray(\n                    blockText,\n                    configForRecursive,\n                    { ...options, filename: blockName, physicalFilename }\n                );\n            }\n\n            // Does lint.\n            return this._verifyWithoutProcessors(\n                blockText,\n                config,\n                { ...options, filename: blockName, physicalFilename }\n            );\n        });\n\n        return postprocess(messageLists, filenameToExpose);\n    }\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n    getSourceCode() {\n        return internalSlotsMap.get(this).lastSourceCode;\n    }\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n    defineRule(ruleId, ruleModule) {\n        internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);\n    }\n\n    /**\n     * Defines many new linting rules.\n     * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n    defineRules(rulesToDefine) {\n        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n            this.defineRule(ruleId, rulesToDefine[ruleId]);\n        });\n    }\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map<string, Rule>} All loaded rules\n     */\n    getRules() {\n        const { lastConfigArray, ruleMap } = internalSlotsMap.get(this);\n\n        return new Map(function *() {\n            yield* ruleMap;\n\n            if (lastConfigArray) {\n                yield* lastConfigArray.pluginRules;\n            }\n        }());\n    }\n\n    /**\n     * Define a new parser module\n     * @param {string} parserId Name of the parser\n     * @param {Parser} parserModule The parser object\n     * @returns {void}\n     */\n    defineParser(parserId, parserModule) {\n        internalSlotsMap.get(this).parserMap.set(parserId, parserModule);\n    }\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {ConfigData|ConfigArray} config The ESLint config object to use.\n     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\n     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n    verifyAndFix(text, config, options) {\n        let messages = [],\n            fixedResult,\n            fixed = false,\n            passNumber = 0,\n            currentText = text;\n        const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\n        const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n        do {\n            passNumber++;\n\n            debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\n            messages = this.verify(currentText, config, options);\n\n            debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\n            fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);\n\n            /*\n             * stop if there are any syntax errors.\n             * 'fixedResult.output' is a empty string.\n             */\n            if (messages.length === 1 && messages[0].fatal) {\n                break;\n            }\n\n            // keep track if any fixes were ever applied - important for return value\n            fixed = fixed || fixedResult.fixed;\n\n            // update to use the fixed output instead of the original text\n            currentText = fixedResult.output;\n\n        } while (\n            fixedResult.fixed &&\n            passNumber < MAX_AUTOFIX_PASSES\n        );\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n        if (fixedResult.fixed) {\n            fixedResult.messages = this.verify(currentText, config, options);\n        }\n\n        // ensure the last result properly reflects if fixes were done\n        fixedResult.fixed = fixed;\n        fixedResult.output = currentText;\n\n        return fixedResult;\n    }\n}\n\nmodule.exports = {\n    Linter,\n\n    /**\n     * Get the internal slots of a given Linter instance for tests.\n     * @param {Linter} instance The Linter instance to get.\n     * @returns {LinterInternalSlots} The internal slots.\n     */\n    getLinterInternalSlots(instance) {\n        return internalSlotsMap.get(instance);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}