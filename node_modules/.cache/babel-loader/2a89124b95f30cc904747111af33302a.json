{"ast":null,"code":"/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n/**\n * Parses and normalizes an option object.\n * @param {Object} options An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\n\nfunction parseOptions(options) {\n  return {\n    boolean: \"boolean\" in options ? options.boolean : true,\n    number: \"number\" in options ? options.number : true,\n    string: \"string\" in options ? options.string : true,\n    disallowTemplateShorthand: \"disallowTemplateShorthand\" in options ? options.disallowTemplateShorthand : false,\n    allow: options.allow || []\n  };\n}\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\n\n\nfunction isDoubleLogicalNegating(node) {\n  return node.operator === \"!\" && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n}\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\n\n\nfunction isBinaryNegatingOfIndexOf(node) {\n  if (node.operator !== \"~\") {\n    return false;\n  }\n\n  const callNode = astUtils.skipChainExpression(node.argument);\n  return callNode.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN);\n}\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\n\n\nfunction isMultiplyByOne(node) {\n  return node.operator === \"*\" && (node.left.type === \"Literal\" && node.left.value === 1 || node.right.type === \"Literal\" && node.right.value === 1);\n}\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\n\n\nfunction isNumeric(node) {\n  return node.type === \"Literal\" && typeof node.value === \"number\" || node.type === \"CallExpression\" && (node.callee.name === \"Number\" || node.callee.name === \"parseInt\" || node.callee.name === \"parseFloat\");\n}\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\n\n\nfunction getNonNumericOperand(node) {\n  const left = node.left,\n        right = node.right;\n\n  if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n    return right;\n  }\n\n  if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n    return left;\n  }\n\n  return null;\n}\n/**\n * Checks whether an expression evaluates to a string.\n * @param {ASTNode} node node that represents the expression to check.\n * @returns {boolean} Whether or not the expression evaluates to a string.\n */\n\n\nfunction isStringType(node) {\n  return astUtils.isStringLiteral(node) || node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"String\";\n}\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\n\n\nfunction isEmptyString(node) {\n  return astUtils.isStringLiteral(node) && (node.value === \"\" || node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\");\n}\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\n\n\nfunction isConcatWithEmptyString(node) {\n  return node.operator === \"+\" && (isEmptyString(node.left) && !isStringType(node.right) || isEmptyString(node.right) && !isStringType(node.left));\n}\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\n\n\nfunction isAppendEmptyString(node) {\n  return node.operator === \"+=\" && isEmptyString(node.right);\n}\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\n\n\nfunction getNonEmptyOperand(node) {\n  return isEmptyString(node.left) ? node.right : node.left;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow shorthand type conversions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        boolean: {\n          type: \"boolean\",\n          default: true\n        },\n        number: {\n          type: \"boolean\",\n          default: true\n        },\n        string: {\n          type: \"boolean\",\n          default: true\n        },\n        disallowTemplateShorthand: {\n          type: \"boolean\",\n          default: false\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            enum: ALLOWABLE_OPERATORS\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useRecommendation: \"use `{{recommendation}}` instead.\"\n    }\n  },\n\n  create(context) {\n    const options = parseOptions(context.options[0] || {});\n    const sourceCode = context.getSourceCode();\n    /**\n     * Reports an error and autofixes the node\n     * @param {ASTNode} node An ast node to report the error on.\n     * @param {string} recommendation The recommended code for the issue\n     * @param {bool} shouldFix Whether this report should fix the node\n     * @returns {void}\n     */\n\n    function report(node, recommendation, shouldFix) {\n      context.report({\n        node,\n        messageId: \"useRecommendation\",\n        data: {\n          recommendation\n        },\n\n        fix(fixer) {\n          if (!shouldFix) {\n            return null;\n          }\n\n          const tokenBefore = sourceCode.getTokenBefore(node);\n\n          if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {\n            return fixer.replaceText(node, ` ${recommendation}`);\n          }\n\n          return fixer.replaceText(node, recommendation);\n        }\n\n      });\n    }\n\n    return {\n      UnaryExpression(node) {\n        let operatorAllowed; // !!foo\n\n        operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n\n        if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n          const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n          report(node, recommendation, true);\n        } // ~foo.indexOf(bar)\n\n\n        operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n\n        if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n          // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\n          const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n          const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n          report(node, recommendation, false);\n        } // +foo\n\n\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n          const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      // Use `:exit` to prevent double reporting\n      \"BinaryExpression:exit\"(node) {\n        let operatorAllowed; // 1 * foo\n\n        operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n        const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n        if (nonNumericOperand) {\n          const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n          report(node, recommendation, true);\n        } // \"\" + foo\n\n\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n          const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      AssignmentExpression(node) {\n        // foo += \"\"\n        const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n          const code = sourceCode.getText(getNonEmptyOperand(node));\n          const recommendation = `${code} = String(${code})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      TemplateLiteral(node) {\n        if (!options.disallowTemplateShorthand) {\n          return;\n        } // tag`${foo}`\n\n\n        if (node.parent.type === \"TaggedTemplateExpression\") {\n          return;\n        } // `` or `${foo}${bar}`\n\n\n        if (node.expressions.length !== 1) {\n          return;\n        } //  `prefix${foo}`\n\n\n        if (node.quasis[0].value.cooked !== \"\") {\n          return;\n        } //  `${foo}postfix`\n\n\n        if (node.quasis[1].value.cooked !== \"\") {\n          return;\n        } // if the expression is already a string, then this isn't a coercion\n\n\n        if (isStringType(node.expressions[0])) {\n          return;\n        }\n\n        const code = sourceCode.getText(node.expressions[0]);\n        const recommendation = `String(${code})`;\n        report(node, recommendation, true);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","INDEX_OF_PATTERN","ALLOWABLE_OPERATORS","parseOptions","options","boolean","number","string","disallowTemplateShorthand","allow","isDoubleLogicalNegating","node","operator","argument","type","isBinaryNegatingOfIndexOf","callNode","skipChainExpression","isSpecificMemberAccess","callee","isMultiplyByOne","left","value","right","isNumeric","name","getNonNumericOperand","isStringType","isStringLiteral","isEmptyString","quasis","length","cooked","isConcatWithEmptyString","isAppendEmptyString","getNonEmptyOperand","module","exports","meta","docs","description","category","recommended","url","fixable","schema","properties","default","items","enum","uniqueItems","additionalProperties","messages","useRecommendation","create","context","sourceCode","getSourceCode","report","recommendation","shouldFix","messageId","data","fix","fixer","tokenBefore","getTokenBefore","range","canTokensBeAdjacent","replaceText","UnaryExpression","operatorAllowed","indexOf","getText","comparison","nonNumericOperand","AssignmentExpression","code","TemplateLiteral","parent","expressions"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-implicit-coercion.js"],"sourcesContent":["/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    return {\n        boolean: \"boolean\" in options ? options.boolean : true,\n        number: \"number\" in options ? options.number : true,\n        string: \"string\" in options ? options.string : true,\n        disallowTemplateShorthand: \"disallowTemplateShorthand\" in options ? options.disallowTemplateShorthand : false,\n        allow: options.allow || []\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    if (node.operator !== \"~\") {\n        return false;\n    }\n    const callNode = astUtils.skipChainExpression(node.argument);\n\n    return (\n        callNode.type === \"CallExpression\" &&\n        astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    const left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether an expression evaluates to a string.\n * @param {ASTNode} node node that represents the expression to check.\n * @returns {boolean} Whether or not the expression evaluates to a string.\n */\nfunction isStringType(node) {\n    return astUtils.isStringLiteral(node) ||\n        (\n            node.type === \"CallExpression\" &&\n            node.callee.type === \"Identifier\" &&\n            node.callee.name === \"String\"\n        );\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (isEmptyString(node.left) && !isStringType(node.right)) ||\n        (isEmptyString(node.right) && !isStringType(node.left))\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n    return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow shorthand type conversions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\",\n                    default: true\n                },\n                number: {\n                    type: \"boolean\",\n                    default: true\n                },\n                string: {\n                    type: \"boolean\",\n                    default: true\n                },\n                disallowTemplateShorthand: {\n                    type: \"boolean\",\n                    default: false\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useRecommendation: \"use `{{recommendation}}` instead.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0] || {});\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports an error and autofixes the node\n         * @param {ASTNode} node An ast node to report the error on.\n         * @param {string} recommendation The recommended code for the issue\n         * @param {bool} shouldFix Whether this report should fix the node\n         * @returns {void}\n         */\n        function report(node, recommendation, shouldFix) {\n            context.report({\n                node,\n                messageId: \"useRecommendation\",\n                data: {\n                    recommendation\n                },\n                fix(fixer) {\n                    if (!shouldFix) {\n                        return null;\n                    }\n\n                    const tokenBefore = sourceCode.getTokenBefore(node);\n\n                    if (\n                        tokenBefore &&\n                        tokenBefore.range[1] === node.range[0] &&\n                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)\n                    ) {\n                        return fixer.replaceText(node, ` ${recommendation}`);\n                    }\n                    return fixer.replaceText(node, recommendation);\n                }\n            });\n        }\n\n        return {\n            UnaryExpression(node) {\n                let operatorAllowed;\n\n                // !!foo\n                operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n\n                    // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\n                    const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n                    const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n\n                    report(node, recommendation, false);\n                }\n\n                // +foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\"(node) {\n                let operatorAllowed;\n\n                // 1 * foo\n                operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            AssignmentExpression(node) {\n\n                // foo += \"\"\n                const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\n                    const recommendation = `${code} = String(${code})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            TemplateLiteral(node) {\n                if (!options.disallowTemplateShorthand) {\n                    return;\n                }\n\n                // tag`${foo}`\n                if (node.parent.type === \"TaggedTemplateExpression\") {\n                    return;\n                }\n\n                // `` or `${foo}${bar}`\n                if (node.expressions.length !== 1) {\n                    return;\n                }\n\n\n                //  `prefix${foo}`\n                if (node.quasis[0].value.cooked !== \"\") {\n                    return;\n                }\n\n                //  `${foo}postfix`\n                if (node.quasis[1].value.cooked !== \"\") {\n                    return;\n                }\n\n                // if the expression is already a string, then this isn't a coercion\n                if (isStringType(node.expressions[0])) {\n                    return;\n                }\n\n                const code = sourceCode.getText(node.expressions[0]);\n                const recommendation = `String(${code})`;\n\n                report(node, recommendation, true);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}