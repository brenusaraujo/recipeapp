{"ast":null,"code":"/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent brace style for blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/brace-style\"\n    },\n    schema: [{\n      enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n      sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n      blockSameLine: \"Statement inside of curly braces should be on next line.\",\n      nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n      singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n      sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"1tbs\",\n          params = context.options[1] || {},\n          sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Fixes a place where a newline unexpectedly appears\n     * @param {Token} firstToken The token before the unexpected newline\n     * @param {Token} secondToken The token after the unexpected newline\n     * @returns {Function} A fixer function to remove the newlines between the tokens\n     */\n\n    function removeNewlineBetween(firstToken, secondToken) {\n      const textRange = [firstToken.range[1], secondToken.range[0]];\n      const textBetween = sourceCode.text.slice(textRange[0], textRange[1]); // Don't do a fix if there is a comment between the tokens\n\n      if (textBetween.trim()) {\n        return null;\n      }\n\n      return fixer => fixer.replaceTextRange(textRange, \" \");\n    }\n    /**\n     * Validates a pair of curly brackets based on the user's config\n     * @param {Token} openingCurly The opening curly bracket\n     * @param {Token} closingCurly The closing curly bracket\n     * @returns {void}\n     */\n\n\n    function validateCurlyPair(openingCurly, closingCurly) {\n      const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n      const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n      const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n      const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n      if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n        context.report({\n          node: openingCurly,\n          messageId: \"nextLineOpen\",\n          fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n        });\n      }\n\n      if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"sameLineOpen\",\n          fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n        });\n      }\n\n      if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"blockSameLine\",\n          fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n        });\n      }\n\n      if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n        context.report({\n          node: closingCurly,\n          messageId: \"singleLineClose\",\n          fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n        });\n      }\n    }\n    /**\n     * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n     * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n     * @returns {void}\n     */\n\n\n    function validateCurlyBeforeKeyword(curlyToken) {\n      const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n      if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"nextLineClose\",\n          fix: removeNewlineBetween(curlyToken, keywordToken)\n        });\n      }\n\n      if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"sameLineClose\",\n          fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      BlockStatement(node) {\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n          validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n        }\n      },\n\n      ClassBody(node) {\n        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n      },\n\n      SwitchStatement(node) {\n        const closingCurly = sourceCode.getLastToken(node);\n        const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n        validateCurlyPair(openingCurly, closingCurly);\n      },\n\n      IfStatement(node) {\n        if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n          // Handle the keyword after the `if` block (before `else`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n        }\n      },\n\n      TryStatement(node) {\n        // Handle the keyword after the `try` block (before `catch` or `finally`)\n        validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n        if (node.handler && node.finalizer) {\n          // Handle the keyword after the `catch` block (before `finally`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","properties","allowSingleLine","default","additionalProperties","fixable","messages","nextLineOpen","sameLineOpen","blockSameLine","nextLineClose","singleLineClose","sameLineClose","create","context","style","options","params","sourceCode","getSourceCode","removeNewlineBetween","firstToken","secondToken","textRange","range","textBetween","text","slice","trim","fixer","replaceTextRange","validateCurlyPair","openingCurly","closingCurly","tokenBeforeOpeningCurly","getTokenBefore","tokenAfterOpeningCurly","getTokenAfter","tokenBeforeClosingCurly","singleLineException","isTokenOnSameLine","report","node","messageId","fix","insertTextBefore","insertTextAfter","validateCurlyBeforeKeyword","curlyToken","keywordToken","BlockStatement","STATEMENT_LIST_PARENTS","has","parent","getFirstToken","getLastToken","ClassBody","SwitchStatement","cases","length","IfStatement","consequent","alternate","TryStatement","block","handler","finalizer","body"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/brace-style.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent brace style for blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/brace-style\"\n        },\n\n        schema: [\n            {\n                enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\",\n\n        messages: {\n            nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n            sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n            blockSameLine: \"Statement inside of curly braces should be on next line.\",\n            nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n            singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n            sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"1tbs\",\n            params = context.options[1] || {},\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Fixes a place where a newline unexpectedly appears\n         * @param {Token} firstToken The token before the unexpected newline\n         * @param {Token} secondToken The token after the unexpected newline\n         * @returns {Function} A fixer function to remove the newlines between the tokens\n         */\n        function removeNewlineBetween(firstToken, secondToken) {\n            const textRange = [firstToken.range[1], secondToken.range[0]];\n            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n            // Don't do a fix if there is a comment between the tokens\n            if (textBetween.trim()) {\n                return null;\n            }\n            return fixer => fixer.replaceTextRange(textRange, \" \");\n        }\n\n        /**\n         * Validates a pair of curly brackets based on the user's config\n         * @param {Token} openingCurly The opening curly bracket\n         * @param {Token} closingCurly The closing curly bracket\n         * @returns {void}\n         */\n        function validateCurlyPair(openingCurly, closingCurly) {\n            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n            if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"nextLineOpen\",\n                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n                });\n            }\n\n            if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"sameLineOpen\",\n                    fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n                });\n            }\n\n            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"blockSameLine\",\n                    fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n                });\n            }\n\n            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n                context.report({\n                    node: closingCurly,\n                    messageId: \"singleLineClose\",\n                    fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n         * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n         * @returns {void}\n         */\n        function validateCurlyBeforeKeyword(curlyToken) {\n            const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n            if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"nextLineClose\",\n                    fix: removeNewlineBetween(curlyToken, keywordToken)\n                });\n            }\n\n            if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"sameLineClose\",\n                    fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BlockStatement(node) {\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n                }\n            },\n            ClassBody(node) {\n                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n            },\n            SwitchStatement(node) {\n                const closingCurly = sourceCode.getLastToken(node);\n                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n\n                validateCurlyPair(openingCurly, closingCurly);\n            },\n            IfStatement(node) {\n                if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n\n                    // Handle the keyword after the `if` block (before `else`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n                }\n            },\n            TryStatement(node) {\n\n                // Handle the keyword after the `try` block (before `catch` or `finally`)\n                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n                if (node.handler && node.finalizer) {\n\n                    // Handle the keyword after the `catch` block (before `finally`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}