{"ast":null,"code":"/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\n\nfunction createReferenceMap(scope) {\n  let outReferenceMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n\n  for (const reference of scope.references) {\n    if (reference.resolved === null) {\n      continue;\n    }\n\n    outReferenceMap.set(reference.identifier, reference);\n  }\n\n  for (const childScope of scope.childScopes) {\n    if (childScope.type !== \"function\") {\n      createReferenceMap(childScope, outReferenceMap);\n    }\n  }\n\n  return outReferenceMap;\n}\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\n\n\nfunction getWriteExpr(reference) {\n  if (reference.writeExpr) {\n    return reference.writeExpr;\n  }\n\n  let node = reference.identifier;\n\n  while (node) {\n    const t = node.parent.type;\n\n    if (t === \"AssignmentExpression\" && node.parent.left === node) {\n      return node.parent.right;\n    }\n\n    if (t === \"MemberExpression\" && node.parent.object === node) {\n      node = node.parent;\n      continue;\n    }\n\n    break;\n  }\n\n  return null;\n}\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\n\n\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n  if (!variable) {\n    return false; // A global variable which was not defined.\n  } // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n\n\n  if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n    return false;\n  }\n\n  const functionScope = variable.scope.variableScope;\n  return variable.references.every(reference => reference.from.variableScope === functionScope);\n}\n\nclass SegmentInfo {\n  constructor() {\n    this.info = new WeakMap();\n  }\n  /**\n   * Initialize the segment information.\n   * @param {PathSegment} segment The segment to initialize.\n   * @returns {void}\n   */\n\n\n  initialize(segment) {\n    const outdatedReadVariables = new Set();\n    const freshReadVariables = new Set();\n\n    for (const prevSegment of segment.prevSegments) {\n      const info = this.info.get(prevSegment);\n\n      if (info) {\n        info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\n        info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\n      }\n    }\n\n    this.info.set(segment, {\n      outdatedReadVariables,\n      freshReadVariables\n    });\n  }\n  /**\n   * Mark a given variable as read on given segments.\n   * @param {PathSegment[]} segments The segments that it read the variable on.\n   * @param {Variable} variable The variable to be read.\n   * @returns {void}\n   */\n\n\n  markAsRead(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info) {\n        info.freshReadVariables.add(variable); // If a variable is freshly read again, then it's no more out-dated.\n\n        info.outdatedReadVariables.delete(variable);\n      }\n    }\n  }\n  /**\n   * Move `freshReadVariables` to `outdatedReadVariables`.\n   * @param {PathSegment[]} segments The segments to process.\n   * @returns {void}\n   */\n\n\n  makeOutdated(segments) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info) {\n        info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\n        info.freshReadVariables.clear();\n      }\n    }\n  }\n  /**\n   * Check if a given variable is outdated on the current segments.\n   * @param {PathSegment[]} segments The current segments.\n   * @param {Variable} variable The variable to check.\n   * @returns {boolean} `true` if the variable is outdated on the segments.\n   */\n\n\n  isOutdated(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info && info.outdatedReadVariables.has(variable)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const assignmentReferences = new Map();\n    const segmentInfo = new SegmentInfo();\n    let stack = null;\n    return {\n      onCodePathStart(codePath) {\n        const scope = context.getScope();\n        const shouldVerify = scope.type === \"function\" && (scope.block.async || scope.block.generator);\n        stack = {\n          upper: stack,\n          codePath,\n          referenceMap: shouldVerify ? createReferenceMap(scope) : null\n        };\n      },\n\n      onCodePathEnd() {\n        stack = stack.upper;\n      },\n\n      // Initialize the segment information.\n      onCodePathSegmentStart(segment) {\n        segmentInfo.initialize(segment);\n      },\n\n      // Handle references to prepare verification.\n      Identifier(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack;\n        const reference = referenceMap && referenceMap.get(node); // Ignore if this is not a valid variable reference.\n\n        if (!reference) {\n          return;\n        }\n\n        const variable = reference.resolved;\n        const writeExpr = getWriteExpr(reference);\n        const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\"; // Add a fresh read variable.\n\n        if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n          segmentInfo.markAsRead(codePath.currentSegments, variable);\n        }\n        /*\n         * Register the variable to verify after ESLint traversed the `writeExpr` node\n         * if this reference is an assignment to a variable which is referred from other closure.\n         */\n\n\n        if (writeExpr && writeExpr.parent.right === writeExpr && // ‚Üê exclude variable declarations.\n        !isLocalVariableWithoutEscape(variable, isMemberAccess)) {\n          let refs = assignmentReferences.get(writeExpr);\n\n          if (!refs) {\n            refs = [];\n            assignmentReferences.set(writeExpr, refs);\n          }\n\n          refs.push(reference);\n        }\n      },\n\n      /*\n       * Verify assignments.\n       * If the reference exists in `outdatedReadVariables` list, report it.\n       */\n      \":expression:exit\"(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack; // referenceMap exists if this is in a resumable function scope.\n\n        if (!referenceMap) {\n          return;\n        } // Mark the read variables on this code path as outdated.\n\n\n        if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n          segmentInfo.makeOutdated(codePath.currentSegments);\n        } // Verify.\n\n\n        const references = assignmentReferences.get(node);\n\n        if (references) {\n          assignmentReferences.delete(node);\n\n          for (const reference of references) {\n            const variable = reference.resolved;\n\n            if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {\n              context.report({\n                node: node.parent,\n                messageId: \"nonAtomicUpdate\",\n                data: {\n                  value: sourceCode.getText(node.parent.left)\n                }\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["createReferenceMap","scope","outReferenceMap","Map","reference","references","resolved","set","identifier","childScope","childScopes","type","getWriteExpr","writeExpr","node","t","parent","left","right","object","isLocalVariableWithoutEscape","variable","isMemberAccess","defs","some","d","functionScope","variableScope","every","from","SegmentInfo","constructor","info","WeakMap","initialize","segment","outdatedReadVariables","Set","freshReadVariables","prevSegment","prevSegments","get","forEach","prototype","add","markAsRead","segments","delete","makeOutdated","clear","isOutdated","has","module","exports","meta","docs","description","category","recommended","url","fixable","schema","messages","nonAtomicUpdate","create","context","sourceCode","getSourceCode","assignmentReferences","segmentInfo","stack","onCodePathStart","codePath","getScope","shouldVerify","block","async","generator","upper","referenceMap","onCodePathEnd","onCodePathSegmentStart","Identifier","isRead","operator","currentSegments","refs","push","report","messageId","data","value","getText"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/require-atomic-updates.js"],"sourcesContent":["/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n    for (const reference of scope.references) {\n        if (reference.resolved === null) {\n            continue;\n        }\n\n        outReferenceMap.set(reference.identifier, reference);\n    }\n    for (const childScope of scope.childScopes) {\n        if (childScope.type !== \"function\") {\n            createReferenceMap(childScope, outReferenceMap);\n        }\n    }\n\n    return outReferenceMap;\n}\n\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\nfunction getWriteExpr(reference) {\n    if (reference.writeExpr) {\n        return reference.writeExpr;\n    }\n    let node = reference.identifier;\n\n    while (node) {\n        const t = node.parent.type;\n\n        if (t === \"AssignmentExpression\" && node.parent.left === node) {\n            return node.parent.right;\n        }\n        if (t === \"MemberExpression\" && node.parent.object === node) {\n            node = node.parent;\n            continue;\n        }\n\n        break;\n    }\n\n    return null;\n}\n\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n    if (!variable) {\n        return false; // A global variable which was not defined.\n    }\n\n    // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n    if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n        return false;\n    }\n\n    const functionScope = variable.scope.variableScope;\n\n    return variable.references.every(reference =>\n        reference.from.variableScope === functionScope);\n}\n\nclass SegmentInfo {\n    constructor() {\n        this.info = new WeakMap();\n    }\n\n    /**\n     * Initialize the segment information.\n     * @param {PathSegment} segment The segment to initialize.\n     * @returns {void}\n     */\n    initialize(segment) {\n        const outdatedReadVariables = new Set();\n        const freshReadVariables = new Set();\n\n        for (const prevSegment of segment.prevSegments) {\n            const info = this.info.get(prevSegment);\n\n            if (info) {\n                info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\n                info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\n            }\n        }\n\n        this.info.set(segment, { outdatedReadVariables, freshReadVariables });\n    }\n\n    /**\n     * Mark a given variable as read on given segments.\n     * @param {PathSegment[]} segments The segments that it read the variable on.\n     * @param {Variable} variable The variable to be read.\n     * @returns {void}\n     */\n    markAsRead(segments, variable) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariables.add(variable);\n\n                // If a variable is freshly read again, then it's no more out-dated.\n                info.outdatedReadVariables.delete(variable);\n            }\n        }\n    }\n\n    /**\n     * Move `freshReadVariables` to `outdatedReadVariables`.\n     * @param {PathSegment[]} segments The segments to process.\n     * @returns {void}\n     */\n    makeOutdated(segments) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\n                info.freshReadVariables.clear();\n            }\n        }\n    }\n\n    /**\n     * Check if a given variable is outdated on the current segments.\n     * @param {PathSegment[]} segments The current segments.\n     * @param {Variable} variable The variable to check.\n     * @returns {boolean} `true` if the variable is outdated on the segments.\n     */\n    isOutdated(segments, variable) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info && info.outdatedReadVariables.has(variable)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const assignmentReferences = new Map();\n        const segmentInfo = new SegmentInfo();\n        let stack = null;\n\n        return {\n            onCodePathStart(codePath) {\n                const scope = context.getScope();\n                const shouldVerify =\n                    scope.type === \"function\" &&\n                    (scope.block.async || scope.block.generator);\n\n                stack = {\n                    upper: stack,\n                    codePath,\n                    referenceMap: shouldVerify ? createReferenceMap(scope) : null\n                };\n            },\n            onCodePathEnd() {\n                stack = stack.upper;\n            },\n\n            // Initialize the segment information.\n            onCodePathSegmentStart(segment) {\n                segmentInfo.initialize(segment);\n            },\n\n            // Handle references to prepare verification.\n            Identifier(node) {\n                const { codePath, referenceMap } = stack;\n                const reference = referenceMap && referenceMap.get(node);\n\n                // Ignore if this is not a valid variable reference.\n                if (!reference) {\n                    return;\n                }\n                const variable = reference.resolved;\n                const writeExpr = getWriteExpr(reference);\n                const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\n\n                // Add a fresh read variable.\n                if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n                    segmentInfo.markAsRead(codePath.currentSegments, variable);\n                }\n\n                /*\n                 * Register the variable to verify after ESLint traversed the `writeExpr` node\n                 * if this reference is an assignment to a variable which is referred from other closure.\n                 */\n                if (writeExpr &&\n                    writeExpr.parent.right === writeExpr && // ‚Üê exclude variable declarations.\n                    !isLocalVariableWithoutEscape(variable, isMemberAccess)\n                ) {\n                    let refs = assignmentReferences.get(writeExpr);\n\n                    if (!refs) {\n                        refs = [];\n                        assignmentReferences.set(writeExpr, refs);\n                    }\n\n                    refs.push(reference);\n                }\n            },\n\n            /*\n             * Verify assignments.\n             * If the reference exists in `outdatedReadVariables` list, report it.\n             */\n            \":expression:exit\"(node) {\n                const { codePath, referenceMap } = stack;\n\n                // referenceMap exists if this is in a resumable function scope.\n                if (!referenceMap) {\n                    return;\n                }\n\n                // Mark the read variables on this code path as outdated.\n                if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n                    segmentInfo.makeOutdated(codePath.currentSegments);\n                }\n\n                // Verify.\n                const references = assignmentReferences.get(node);\n\n                if (references) {\n                    assignmentReferences.delete(node);\n\n                    for (const reference of references) {\n                        const variable = reference.resolved;\n\n                        if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {\n                            context.report({\n                                node: node.parent,\n                                messageId: \"nonAtomicUpdate\",\n                                data: {\n                                    value: sourceCode.getText(node.parent.left)\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}