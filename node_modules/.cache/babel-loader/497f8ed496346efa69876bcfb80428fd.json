{"ast":null,"code":"/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce camelcase naming convention\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/camelcase\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImports: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreGlobals: {\n          type: \"boolean\",\n          default: false\n        },\n        properties: {\n          enum: [\"always\", \"never\"]\n        },\n        allow: {\n          type: \"array\",\n          items: [{\n            type: \"string\"\n          }],\n          minItems: 0,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      notCamelCase: \"Identifier '{{name}}' is not in camel case.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    let properties = options.properties || \"\";\n    const ignoreDestructuring = options.ignoreDestructuring;\n    const ignoreImports = options.ignoreImports;\n    const ignoreGlobals = options.ignoreGlobals;\n    const allow = options.allow || [];\n    let globalScope;\n\n    if (properties !== \"always\" && properties !== \"never\") {\n      properties = \"always\";\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n\n\n    const reported = [];\n    const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n    /**\n     * Checks if a string contains an underscore and isn't all upper-case\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is underscored\n     * @private\n     */\n\n    function isUnderscored(name) {\n      // if there's an underscore, it might be A_CONSTANT, which is okay\n      return name.includes(\"_\") && name !== name.toUpperCase();\n    }\n    /**\n     * Checks if a string match the ignore list\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is ignored\n     * @private\n     */\n\n\n    function isAllowed(name) {\n      return allow.some(entry => name === entry || name.match(new RegExp(entry, \"u\")));\n    }\n    /**\n     * Checks if a parent of a node is an ObjectPattern.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} if the node is inside an ObjectPattern\n     * @private\n     */\n\n\n    function isInsideObjectPattern(node) {\n      let current = node;\n\n      while (current) {\n        const parent = current.parent;\n\n        if (parent && parent.type === \"Property\" && parent.computed && parent.key === current) {\n          return false;\n        }\n\n        if (current.type === \"ObjectPattern\") {\n          return true;\n        }\n\n        current = parent;\n      }\n\n      return false;\n    }\n    /**\n     * Checks whether the given node represents assignment target property in destructuring.\n     *\n     * For examples:\n     *    ({a: b.foo} = c);  // => true for `foo`\n     *    ([a.foo] = b);     // => true for `foo`\n     *    ([a.foo = 1] = b); // => true for `foo`\n     *    ({...a.foo} = b);  // => true for `foo`\n     * @param {ASTNode} node An Identifier node to check\n     * @returns {boolean} True if the node is an assignment target property in destructuring.\n     */\n\n\n    function isAssignmentTargetPropertyInDestructuring(node) {\n      if (node.parent.type === \"MemberExpression\" && node.parent.property === node && !node.parent.computed) {\n        const effectiveParent = node.parent.parent;\n        return effectiveParent.type === \"Property\" && effectiveParent.value === node.parent && effectiveParent.parent.type === \"ObjectPattern\" || effectiveParent.type === \"ArrayPattern\" || effectiveParent.type === \"RestElement\" || effectiveParent.type === \"AssignmentPattern\" && effectiveParent.left === node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n     * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} `true` if the node is a reference to a global variable.\n     */\n\n\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n    /**\n     * Checks whether the given node represents a reference to a property of an object in an object literal expression.\n     * This allows to differentiate between a global variable that is allowed to be used as a reference, and the key\n     * of the expressed object (which shouldn't be allowed).\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} `true` if the node is a property name of an object literal expression\n     */\n\n\n    function isPropertyNameInObjectLiteral(node) {\n      const parent = node.parent;\n      return parent.type === \"Property\" && parent.parent.type === \"ObjectExpression\" && !parent.computed && parent.key === node;\n    }\n    /**\n     * Reports an AST node as a rule violation.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     * @private\n     */\n\n\n    function report(node) {\n      if (!reported.includes(node)) {\n        reported.push(node);\n        context.report({\n          node,\n          messageId: \"notCamelCase\",\n          data: {\n            name: node.name\n          }\n        });\n      }\n    }\n\n    return {\n      Program() {\n        globalScope = context.getScope();\n      },\n\n      Identifier(node) {\n        /*\n         * Leading and trailing underscores are commonly used to flag\n         * private/protected identifiers, strip them before checking if underscored\n         */\n        const name = node.name,\n              nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, \"\")),\n              effectiveParent = node.parent.type === \"MemberExpression\" ? node.parent.parent : node.parent; // First, we ignore the node if it match the ignore list\n\n        if (isAllowed(name)) {\n          return;\n        } // Check if it's a global variable\n\n\n        if (ignoreGlobals && isReferenceToGlobalVariable(node) && !isPropertyNameInObjectLiteral(node)) {\n          return;\n        } // MemberExpressions get special rules\n\n\n        if (node.parent.type === \"MemberExpression\") {\n          // \"never\" check properties\n          if (properties === \"never\") {\n            return;\n          } // Always report underscored object names\n\n\n          if (node.parent.object.type === \"Identifier\" && node.parent.object.name === node.name && nameIsUnderscored) {\n            report(node); // Report AssignmentExpressions only if they are the left side of the assignment\n          } else if (effectiveParent.type === \"AssignmentExpression\" && nameIsUnderscored && (effectiveParent.right.type !== \"MemberExpression\" || effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name)) {\n            report(node);\n          } else if (isAssignmentTargetPropertyInDestructuring(node) && nameIsUnderscored) {\n            report(node);\n          }\n          /*\n           * Properties have their own rules, and\n           * AssignmentPattern nodes can be treated like Properties:\n           * e.g.: const { no_camelcased = false } = bar;\n           */\n\n        } else if (node.parent.type === \"Property\" || node.parent.type === \"AssignmentPattern\") {\n          if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\") {\n            if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {\n              report(node);\n            }\n\n            const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;\n\n            if (nameIsUnderscored && node.parent.computed) {\n              report(node);\n            } // prevent checking righthand side of destructured object\n\n\n            if (node.parent.key === node && node.parent.value !== node) {\n              return;\n            }\n\n            const valueIsUnderscored = node.parent.value.name && nameIsUnderscored; // ignore destructuring if the option is set, unless a new identifier is created\n\n            if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n              report(node);\n            }\n          } // \"never\" check properties or always ignore destructuring\n\n\n          if (properties === \"never\" || ignoreDestructuring && isInsideObjectPattern(node)) {\n            return;\n          } // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n\n\n          if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {\n            report(node);\n          } // Check if it's an import specifier\n\n        } else if ([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"].includes(node.parent.type)) {\n          if (node.parent.type === \"ImportSpecifier\" && ignoreImports) {\n            return;\n          } // Report only if the local imported identifier is underscored\n\n\n          if (node.parent.local && node.parent.local.name === node.name && nameIsUnderscored) {\n            report(node);\n          } // Report anything that is underscored that isn't a CallExpression\n\n        } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","ignoreDestructuring","default","ignoreImports","ignoreGlobals","enum","allow","items","minItems","uniqueItems","additionalProperties","messages","notCamelCase","create","context","options","globalScope","reported","ALLOWED_PARENT_TYPES","Set","isUnderscored","name","includes","toUpperCase","isAllowed","some","entry","match","RegExp","isInsideObjectPattern","node","current","parent","computed","key","isAssignmentTargetPropertyInDestructuring","property","effectiveParent","value","left","isReferenceToGlobalVariable","variable","set","get","defs","length","references","ref","identifier","isPropertyNameInObjectLiteral","report","push","messageId","data","Program","getScope","Identifier","nameIsUnderscored","replace","object","right","shorthand","assignmentKeyEqualsValue","valueIsUnderscored","has","local"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/camelcase.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce camelcase naming convention\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/camelcase\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreImports: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreGlobals: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    },\n                    allow: {\n                        type: \"array\",\n                        items: [\n                            {\n                                type: \"string\"\n                            }\n                        ],\n                        minItems: 0,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            notCamelCase: \"Identifier '{{name}}' is not in camel case.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {};\n        let properties = options.properties || \"\";\n        const ignoreDestructuring = options.ignoreDestructuring;\n        const ignoreImports = options.ignoreImports;\n        const ignoreGlobals = options.ignoreGlobals;\n        const allow = options.allow || [];\n\n        let globalScope;\n\n        if (properties !== \"always\" && properties !== \"never\") {\n            properties = \"always\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = [];\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return name.includes(\"_\") && name !== name.toUpperCase();\n        }\n\n        /**\n         * Checks if a string match the ignore list\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is ignored\n         * @private\n         */\n        function isAllowed(name) {\n            return allow.some(\n                entry => name === entry || name.match(new RegExp(entry, \"u\"))\n            );\n        }\n\n        /**\n         * Checks if a parent of a node is an ObjectPattern.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} if the node is inside an ObjectPattern\n         * @private\n         */\n        function isInsideObjectPattern(node) {\n            let current = node;\n\n            while (current) {\n                const parent = current.parent;\n\n                if (parent && parent.type === \"Property\" && parent.computed && parent.key === current) {\n                    return false;\n                }\n\n                if (current.type === \"ObjectPattern\") {\n                    return true;\n                }\n\n                current = parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether the given node represents assignment target property in destructuring.\n         *\n         * For examples:\n         *    ({a: b.foo} = c);  // => true for `foo`\n         *    ([a.foo] = b);     // => true for `foo`\n         *    ([a.foo = 1] = b); // => true for `foo`\n         *    ({...a.foo} = b);  // => true for `foo`\n         * @param {ASTNode} node An Identifier node to check\n         * @returns {boolean} True if the node is an assignment target property in destructuring.\n         */\n        function isAssignmentTargetPropertyInDestructuring(node) {\n            if (\n                node.parent.type === \"MemberExpression\" &&\n                node.parent.property === node &&\n                !node.parent.computed\n            ) {\n                const effectiveParent = node.parent.parent;\n\n                return (\n                    effectiveParent.type === \"Property\" &&\n                    effectiveParent.value === node.parent &&\n                    effectiveParent.parent.type === \"ObjectPattern\" ||\n                    effectiveParent.type === \"ArrayPattern\" ||\n                    effectiveParent.type === \"RestElement\" ||\n                    (\n                        effectiveParent.type === \"AssignmentPattern\" &&\n                        effectiveParent.left === node.parent\n                    )\n                );\n            }\n            return false;\n        }\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Checks whether the given node represents a reference to a property of an object in an object literal expression.\n         * This allows to differentiate between a global variable that is allowed to be used as a reference, and the key\n         * of the expressed object (which shouldn't be allowed).\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a property name of an object literal expression\n         */\n        function isPropertyNameInObjectLiteral(node) {\n            const parent = node.parent;\n\n            return (\n                parent.type === \"Property\" &&\n                parent.parent.type === \"ObjectExpression\" &&\n                !parent.computed &&\n                parent.key === node\n            );\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (!reported.includes(node)) {\n                reported.push(node);\n                context.report({ node, messageId: \"notCamelCase\", data: { name: node.name } });\n            }\n        }\n\n        return {\n\n            Program() {\n                globalScope = context.getScope();\n            },\n\n            Identifier(node) {\n\n                /*\n                 * Leading and trailing underscores are commonly used to flag\n                 * private/protected identifiers, strip them before checking if underscored\n                 */\n                const name = node.name,\n                    nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, \"\")),\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // First, we ignore the node if it match the ignore list\n                if (isAllowed(name)) {\n                    return;\n                }\n\n                // Check if it's a global variable\n                if (ignoreGlobals && isReferenceToGlobalVariable(node) && !isPropertyNameInObjectLiteral(node)) {\n                    return;\n                }\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    // Always report underscored object names\n                    if (node.parent.object.type === \"Identifier\" && node.parent.object.name === node.name && nameIsUnderscored) {\n                        report(node);\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && nameIsUnderscored && (effectiveParent.right.type !== \"MemberExpression\" || effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name)) {\n                        report(node);\n\n                    } else if (isAssignmentTargetPropertyInDestructuring(node) && nameIsUnderscored) {\n                        report(node);\n                    }\n\n                /*\n                 * Properties have their own rules, and\n                 * AssignmentPattern nodes can be treated like Properties:\n                 * e.g.: const { no_camelcased = false } = bar;\n                 */\n                } else if (node.parent.type === \"Property\" || node.parent.type === \"AssignmentPattern\") {\n\n                    if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\") {\n                        if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {\n                            report(node);\n                        }\n\n                        const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;\n\n                        if (nameIsUnderscored && node.parent.computed) {\n                            report(node);\n                        }\n\n                        // prevent checking righthand side of destructured object\n                        if (node.parent.key === node && node.parent.value !== node) {\n                            return;\n                        }\n\n                        const valueIsUnderscored = node.parent.value.name && nameIsUnderscored;\n\n                        // ignore destructuring if the option is set, unless a new identifier is created\n                        if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n                            report(node);\n                        }\n                    }\n\n                    // \"never\" check properties or always ignore destructuring\n                    if (properties === \"never\" || (ignoreDestructuring && isInsideObjectPattern(node))) {\n                        return;\n                    }\n\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n                    if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if ([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"].includes(node.parent.type)) {\n\n                    if (node.parent.type === \"ImportSpecifier\" && ignoreImports) {\n                        return;\n                    }\n\n                    // Report only if the local imported identifier is underscored\n                    if (\n                        node.parent.local &&\n                        node.parent.local.name === node.name &&\n                        nameIsUnderscored\n                    ) {\n                        report(node);\n                    }\n\n                // Report anything that is underscored that isn't a CallExpression\n                } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}