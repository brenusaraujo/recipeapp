{"ast":null,"code":"/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is in a statement list.\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if the given node is in a statement list\n */\n\n\nfunction isInStatementList(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce variables to be declared either together or separately in functions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/one-var\"\n    },\n    fixable: \"code\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consecutive\"]\n      }, {\n        type: \"object\",\n        properties: {\n          separateRequires: {\n            type: \"boolean\"\n          },\n          var: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          let: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          const: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          initialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          uninitialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      combineUninitialized: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n      combineInitialized: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n      splitUninitialized: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n      splitInitialized: \"Split initialized '{{type}}' declarations into multiple statements.\",\n      splitRequires: \"Split requires to be separated into a single block.\",\n      combine: \"Combine this with the previous '{{type}}' statement.\",\n      split: \"Split '{{type}}' declarations into multiple statements.\"\n    }\n  },\n\n  create(context) {\n    const MODE_ALWAYS = \"always\";\n    const MODE_NEVER = \"never\";\n    const MODE_CONSECUTIVE = \"consecutive\";\n    const mode = context.options[0] || MODE_ALWAYS;\n    const options = {};\n\n    if (typeof mode === \"string\") {\n      // simple options configuration with just a string\n      options.var = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.let = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.const = {\n        uninitialized: mode,\n        initialized: mode\n      };\n    } else if (typeof mode === \"object\") {\n      // options configuration is an object\n      options.separateRequires = !!mode.separateRequires;\n      options.var = {\n        uninitialized: mode.var,\n        initialized: mode.var\n      };\n      options.let = {\n        uninitialized: mode.let,\n        initialized: mode.let\n      };\n      options.const = {\n        uninitialized: mode.const,\n        initialized: mode.const\n      };\n\n      if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n        options.var.uninitialized = mode.uninitialized;\n        options.let.uninitialized = mode.uninitialized;\n        options.const.uninitialized = mode.uninitialized;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n        options.var.initialized = mode.initialized;\n        options.let.initialized = mode.initialized;\n        options.const.initialized = mode.initialized;\n      }\n    }\n\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const functionStack = [];\n    const blockStack = [];\n    /**\n     * Increments the blockStack counter.\n     * @returns {void}\n     * @private\n     */\n\n    function startBlock() {\n      blockStack.push({\n        let: {\n          initialized: false,\n          uninitialized: false\n        },\n        const: {\n          initialized: false,\n          uninitialized: false\n        }\n      });\n    }\n    /**\n     * Increments the functionStack counter.\n     * @returns {void}\n     * @private\n     */\n\n\n    function startFunction() {\n      functionStack.push({\n        initialized: false,\n        uninitialized: false\n      });\n      startBlock();\n    }\n    /**\n     * Decrements the blockStack counter.\n     * @returns {void}\n     * @private\n     */\n\n\n    function endBlock() {\n      blockStack.pop();\n    }\n    /**\n     * Decrements the functionStack counter.\n     * @returns {void}\n     * @private\n     */\n\n\n    function endFunction() {\n      functionStack.pop();\n      endBlock();\n    }\n    /**\n     * Check if a variable declaration is a require.\n     * @param {ASTNode} decl variable declaration Node\n     * @returns {bool} if decl is a require, return true; else return false.\n     * @private\n     */\n\n\n    function isRequire(decl) {\n      return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n    }\n    /**\n     * Records whether initialized/uninitialized/required variables are defined in current scope.\n     * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n     * @param {ASTNode[]} declarations List of declarations\n     * @param {Object} currentScope The scope being investigated\n     * @returns {void}\n     * @private\n     */\n\n\n    function recordTypes(statementType, declarations, currentScope) {\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n            currentScope.uninitialized = true;\n          }\n        } else {\n          if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n            if (options.separateRequires && isRequire(declarations[i])) {\n              currentScope.required = true;\n            } else {\n              currentScope.initialized = true;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Determines the current scope (function or block)\n     * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n     * @returns {Object} The scope associated with statementType\n     */\n\n\n    function getCurrentScope(statementType) {\n      let currentScope;\n\n      if (statementType === \"var\") {\n        currentScope = functionStack[functionStack.length - 1];\n      } else if (statementType === \"let\") {\n        currentScope = blockStack[blockStack.length - 1].let;\n      } else if (statementType === \"const\") {\n        currentScope = blockStack[blockStack.length - 1].const;\n      }\n\n      return currentScope;\n    }\n    /**\n     * Counts the number of initialized and uninitialized declarations in a list of declarations\n     * @param {ASTNode[]} declarations List of declarations\n     * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n     * @private\n     */\n\n\n    function countDeclarations(declarations) {\n      const counts = {\n        uninitialized: 0,\n        initialized: 0\n      };\n\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          counts.uninitialized++;\n        } else {\n          counts.initialized++;\n        }\n      }\n\n      return counts;\n    }\n    /**\n     * Determines if there is more than one var statement in the current scope.\n     * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n     * @param {ASTNode[]} declarations List of declarations\n     * @returns {boolean} Returns true if it is the first var declaration, false if not.\n     * @private\n     */\n\n\n    function hasOnlyOneStatement(statementType, declarations) {\n      const declarationCounts = countDeclarations(declarations);\n      const currentOptions = options[statementType] || {};\n      const currentScope = getCurrentScope(statementType);\n      const hasRequires = declarations.some(isRequire);\n\n      if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n        if (currentScope.uninitialized || currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n\n      if (declarationCounts.uninitialized > 0) {\n        if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n          return false;\n        }\n      }\n\n      if (declarationCounts.initialized > 0) {\n        if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n\n      if (currentScope.required && hasRequires) {\n        return false;\n      }\n\n      recordTypes(statementType, declarations, currentScope);\n      return true;\n    }\n    /**\n     * Fixer to join VariableDeclaration's into a single declaration\n     * @param {VariableDeclarator[]} declarations The `VariableDeclaration` to join\n     * @returns {Function} The fixer function\n     */\n\n\n    function joinDeclarations(declarations) {\n      const declaration = declarations[0];\n      const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n      const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n      const previousNode = body[currentIndex - 1];\n      return fixer => {\n        const type = sourceCode.getTokenBefore(declaration);\n        const prevSemi = sourceCode.getTokenBefore(type);\n        const res = [];\n\n        if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n          if (prevSemi.value === \";\") {\n            res.push(fixer.replaceText(prevSemi, \",\"));\n          } else {\n            res.push(fixer.insertTextAfter(prevSemi, \",\"));\n          }\n\n          res.push(fixer.replaceText(type, \"\"));\n        }\n\n        return res;\n      };\n    }\n    /**\n     * Fixer to split a VariableDeclaration into individual declarations\n     * @param {VariableDeclaration} declaration The `VariableDeclaration` to split\n     * @returns {Function|null} The fixer function\n     */\n\n\n    function splitDeclarations(declaration) {\n      const {\n        parent\n      } = declaration; // don't autofix code such as: if (foo) var x, y;\n\n      if (!isInStatementList(parent.type === \"ExportNamedDeclaration\" ? parent : declaration)) {\n        return null;\n      }\n\n      return fixer => declaration.declarations.map(declarator => {\n        const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n        if (tokenAfterDeclarator === null) {\n          return null;\n        }\n\n        const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, {\n          includeComments: true\n        });\n\n        if (tokenAfterDeclarator.value !== \",\") {\n          return null;\n        }\n\n        const exportPlacement = declaration.parent.type === \"ExportNamedDeclaration\" ? \"export \" : \"\";\n        /*\n         * `var x,y`\n         * tokenAfterDeclarator ^^ afterComma\n         */\n\n        if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n          return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);\n        }\n        /*\n         * `var x,\n         * tokenAfterDeclarator ^\n         *      y`\n         *      ^ afterComma\n         */\n\n\n        if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === \"Line\" || afterComma.type === \"Block\") {\n          let lastComment = afterComma;\n\n          while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n            lastComment = sourceCode.getTokenAfter(lastComment, {\n              includeComments: true\n            });\n          }\n\n          return fixer.replaceTextRange([tokenAfterDeclarator.range[0], lastComment.range[0]], `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `);\n        }\n\n        return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);\n      }).filter(x => x);\n    }\n    /**\n     * Checks a given VariableDeclaration node for errors.\n     * @param {ASTNode} node The VariableDeclaration node to check\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkVariableDeclaration(node) {\n      const parent = node.parent;\n      const type = node.kind;\n\n      if (!options[type]) {\n        return;\n      }\n\n      const declarations = node.declarations;\n      const declarationCounts = countDeclarations(declarations);\n      const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n      if (options[type].initialized === MODE_ALWAYS) {\n        if (options.separateRequires && mixedRequires) {\n          context.report({\n            node,\n            messageId: \"splitRequires\"\n          });\n        }\n      } // consecutive\n\n\n      const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node) || 0;\n\n      if (nodeIndex > 0) {\n        const previousNode = parent.body[nodeIndex - 1];\n        const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n        const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n        if (isPreviousNodeDeclaration && previousNode.kind === type && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {\n          const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n          if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n            context.report({\n              node,\n              messageId: \"combine\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n            context.report({\n              node,\n              messageId: \"combineInitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          } else if (options[type].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {\n            context.report({\n              node,\n              messageId: \"combineUninitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n        }\n      } // always\n\n\n      if (!hasOnlyOneStatement(type, declarations)) {\n        if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n          context.report({\n            node,\n            messageId: \"combine\",\n            data: {\n              type\n            },\n            fix: joinDeclarations(declarations)\n          });\n        } else {\n          if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n            context.report({\n              node,\n              messageId: \"combineInitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n\n          if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n            if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n              return;\n            }\n\n            context.report({\n              node,\n              messageId: \"combineUninitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n        }\n      } // never\n\n\n      if (parent.type !== \"ForStatement\" || parent.init !== node) {\n        const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n        if (totalDeclarations > 1) {\n          if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n            // both initialized and uninitialized\n            context.report({\n              node,\n              messageId: \"split\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n            // initialized\n            context.report({\n              node,\n              messageId: \"splitInitialized\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n            // uninitialized\n            context.report({\n              node,\n              messageId: \"splitUninitialized\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          }\n        }\n      }\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: startFunction,\n      FunctionDeclaration: startFunction,\n      FunctionExpression: startFunction,\n      ArrowFunctionExpression: startFunction,\n      BlockStatement: startBlock,\n      ForStatement: startBlock,\n      ForInStatement: startBlock,\n      ForOfStatement: startBlock,\n      SwitchStatement: startBlock,\n      VariableDeclaration: checkVariableDeclaration,\n      \"ForStatement:exit\": endBlock,\n      \"ForOfStatement:exit\": endBlock,\n      \"ForInStatement:exit\": endBlock,\n      \"SwitchStatement:exit\": endBlock,\n      \"BlockStatement:exit\": endBlock,\n      \"Program:exit\": endFunction,\n      \"FunctionDeclaration:exit\": endFunction,\n      \"FunctionExpression:exit\": endFunction,\n      \"ArrowFunctionExpression:exit\": endFunction\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isInStatementList","node","STATEMENT_LIST_PARENTS","has","parent","type","module","exports","meta","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","separateRequires","var","let","const","additionalProperties","initialized","uninitialized","messages","combineUninitialized","combineInitialized","splitUninitialized","splitInitialized","splitRequires","combine","split","create","context","MODE_ALWAYS","MODE_NEVER","MODE_CONSECUTIVE","mode","options","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","functionStack","blockStack","startBlock","push","startFunction","endBlock","pop","endFunction","isRequire","decl","init","callee","name","recordTypes","statementType","declarations","currentScope","i","length","required","getCurrentScope","countDeclarations","counts","hasOnlyOneStatement","declarationCounts","currentOptions","hasRequires","some","joinDeclarations","declaration","body","Array","isArray","currentIndex","findIndex","range","previousNode","fixer","getTokenBefore","prevSemi","res","kind","getText","value","replaceText","insertTextAfter","splitDeclarations","map","declarator","tokenAfterDeclarator","getTokenAfter","afterComma","includeComments","exportPlacement","loc","start","line","end","lastComment","replaceTextRange","text","slice","filter","x","checkVariableDeclaration","mixedRequires","every","report","messageId","nodeIndex","indexOf","isPreviousNodeDeclaration","declarationsWithPrevious","concat","previousDeclCounts","data","fix","left","totalDeclarations","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","BlockStatement","ForStatement","ForInStatement","ForOfStatement","SwitchStatement","VariableDeclaration"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/one-var.js"],"sourcesContent":["/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is in a statement list.\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if the given node is in a statement list\n */\nfunction isInStatementList(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce variables to be declared either together or separately in functions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/one-var\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consecutive\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            separateRequires: {\n                                type: \"boolean\"\n                            },\n                            var: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            let: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            const: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            initialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            uninitialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            combineUninitialized: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n            combineInitialized: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n            splitUninitialized: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n            splitInitialized: \"Split initialized '{{type}}' declarations into multiple statements.\",\n            splitRequires: \"Split requires to be separated into a single block.\",\n            combine: \"Combine this with the previous '{{type}}' statement.\",\n            split: \"Split '{{type}}' declarations into multiple statements.\"\n        }\n    },\n\n    create(context) {\n        const MODE_ALWAYS = \"always\";\n        const MODE_NEVER = \"never\";\n        const MODE_CONSECUTIVE = \"consecutive\";\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        const options = {};\n\n        if (typeof mode === \"string\") { // simple options configuration with just a string\n            options.var = { uninitialized: mode, initialized: mode };\n            options.let = { uninitialized: mode, initialized: mode };\n            options.const = { uninitialized: mode, initialized: mode };\n        } else if (typeof mode === \"object\") { // options configuration is an object\n            options.separateRequires = !!mode.separateRequires;\n            options.var = { uninitialized: mode.var, initialized: mode.var };\n            options.let = { uninitialized: mode.let, initialized: mode.let };\n            options.const = { uninitialized: mode.const, initialized: mode.const };\n            if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n                options.var.uninitialized = mode.uninitialized;\n                options.let.uninitialized = mode.uninitialized;\n                options.const.uninitialized = mode.uninitialized;\n            }\n            if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n                options.var.initialized = mode.initialized;\n                options.let.initialized = mode.initialized;\n                options.const.initialized = mode.initialized;\n            }\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [];\n        const blockStack = [];\n\n        /**\n         * Increments the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startBlock() {\n            blockStack.push({\n                let: { initialized: false, uninitialized: false },\n                const: { initialized: false, uninitialized: false }\n            });\n        }\n\n        /**\n         * Increments the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push({ initialized: false, uninitialized: false });\n            startBlock();\n        }\n\n        /**\n         * Decrements the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endBlock() {\n            blockStack.pop();\n        }\n\n        /**\n         * Decrements the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n            endBlock();\n        }\n\n        /**\n         * Check if a variable declaration is a require.\n         * @param {ASTNode} decl variable declaration Node\n         * @returns {bool} if decl is a require, return true; else return false.\n         * @private\n         */\n        function isRequire(decl) {\n            return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n        }\n\n        /**\n         * Records whether initialized/uninitialized/required variables are defined in current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @param {Object} currentScope The scope being investigated\n         * @returns {void}\n         * @private\n         */\n        function recordTypes(statementType, declarations, currentScope) {\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n                        currentScope.uninitialized = true;\n                    }\n                } else {\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n                        if (options.separateRequires && isRequire(declarations[i])) {\n                            currentScope.required = true;\n                        } else {\n                            currentScope.initialized = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines the current scope (function or block)\n         * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @returns {Object} The scope associated with statementType\n         */\n        function getCurrentScope(statementType) {\n            let currentScope;\n\n            if (statementType === \"var\") {\n                currentScope = functionStack[functionStack.length - 1];\n            } else if (statementType === \"let\") {\n                currentScope = blockStack[blockStack.length - 1].let;\n            } else if (statementType === \"const\") {\n                currentScope = blockStack[blockStack.length - 1].const;\n            }\n            return currentScope;\n        }\n\n        /**\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n         * @private\n         */\n        function countDeclarations(declarations) {\n            const counts = { uninitialized: 0, initialized: 0 };\n\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    counts.uninitialized++;\n                } else {\n                    counts.initialized++;\n                }\n            }\n            return counts;\n        }\n\n        /**\n         * Determines if there is more than one var statement in the current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\n         * @private\n         */\n        function hasOnlyOneStatement(statementType, declarations) {\n\n            const declarationCounts = countDeclarations(declarations);\n            const currentOptions = options[statementType] || {};\n            const currentScope = getCurrentScope(statementType);\n            const hasRequires = declarations.some(isRequire);\n\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n                if (currentScope.uninitialized || currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n\n            if (declarationCounts.uninitialized > 0) {\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n                    return false;\n                }\n            }\n            if (declarationCounts.initialized > 0) {\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n            if (currentScope.required && hasRequires) {\n                return false;\n            }\n            recordTypes(statementType, declarations, currentScope);\n            return true;\n        }\n\n        /**\n         * Fixer to join VariableDeclaration's into a single declaration\n         * @param {VariableDeclarator[]} declarations The `VariableDeclaration` to join\n         * @returns {Function} The fixer function\n         */\n        function joinDeclarations(declarations) {\n            const declaration = declarations[0];\n            const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n            const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n            const previousNode = body[currentIndex - 1];\n\n            return fixer => {\n                const type = sourceCode.getTokenBefore(declaration);\n                const prevSemi = sourceCode.getTokenBefore(type);\n                const res = [];\n\n                if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n                    if (prevSemi.value === \";\") {\n                        res.push(fixer.replaceText(prevSemi, \",\"));\n                    } else {\n                        res.push(fixer.insertTextAfter(prevSemi, \",\"));\n                    }\n                    res.push(fixer.replaceText(type, \"\"));\n                }\n\n                return res;\n            };\n        }\n\n        /**\n         * Fixer to split a VariableDeclaration into individual declarations\n         * @param {VariableDeclaration} declaration The `VariableDeclaration` to split\n         * @returns {Function|null} The fixer function\n         */\n        function splitDeclarations(declaration) {\n            const { parent } = declaration;\n\n            // don't autofix code such as: if (foo) var x, y;\n            if (!isInStatementList(parent.type === \"ExportNamedDeclaration\" ? parent : declaration)) {\n                return null;\n            }\n\n            return fixer => declaration.declarations.map(declarator => {\n                const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n                if (tokenAfterDeclarator === null) {\n                    return null;\n                }\n\n                const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, { includeComments: true });\n\n                if (tokenAfterDeclarator.value !== \",\") {\n                    return null;\n                }\n\n                const exportPlacement = declaration.parent.type === \"ExportNamedDeclaration\" ? \"export \" : \"\";\n\n                /*\n                 * `var x,y`\n                 * tokenAfterDeclarator ^^ afterComma\n                 */\n                if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n                    return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);\n                }\n\n                /*\n                 * `var x,\n                 * tokenAfterDeclarator ^\n                 *      y`\n                 *      ^ afterComma\n                 */\n                if (\n                    afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line ||\n                    afterComma.type === \"Line\" ||\n                    afterComma.type === \"Block\"\n                ) {\n                    let lastComment = afterComma;\n\n                    while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n                        lastComment = sourceCode.getTokenAfter(lastComment, { includeComments: true });\n                    }\n\n                    return fixer.replaceTextRange(\n                        [tokenAfterDeclarator.range[0], lastComment.range[0]],\n                        `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `\n                    );\n                }\n\n                return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);\n            }).filter(x => x);\n        }\n\n        /**\n         * Checks a given VariableDeclaration node for errors.\n         * @param {ASTNode} node The VariableDeclaration node to check\n         * @returns {void}\n         * @private\n         */\n        function checkVariableDeclaration(node) {\n            const parent = node.parent;\n            const type = node.kind;\n\n            if (!options[type]) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            const declarationCounts = countDeclarations(declarations);\n            const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n            if (options[type].initialized === MODE_ALWAYS) {\n                if (options.separateRequires && mixedRequires) {\n                    context.report({\n                        node,\n                        messageId: \"splitRequires\"\n                    });\n                }\n            }\n\n            // consecutive\n            const nodeIndex = (parent.body && parent.body.length > 0 && parent.body.indexOf(node)) || 0;\n\n            if (nodeIndex > 0) {\n                const previousNode = parent.body[nodeIndex - 1];\n                const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n                const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n                if (\n                    isPreviousNodeDeclaration &&\n                    previousNode.kind === type &&\n                    !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))\n                ) {\n                    const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n                    if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n                        context.report({\n                            node,\n                            messageId: \"combine\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].uninitialized === MODE_CONSECUTIVE &&\n                            declarationCounts.uninitialized > 0 &&\n                            previousDeclCounts.uninitialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // always\n            if (!hasOnlyOneStatement(type, declarations)) {\n                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n                    context.report({\n                        node,\n                        messageId: \"combine\",\n                        data: {\n                            type\n                        },\n                        fix: joinDeclarations(declarations)\n                    });\n                } else {\n                    if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                    if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n                        if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n                            return;\n                        }\n                        context.report({\n                            node,\n                            messageId: \"combineUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // never\n            if (parent.type !== \"ForStatement\" || parent.init !== node) {\n                const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n                if (totalDeclarations > 1) {\n                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n\n                        // both initialized and uninitialized\n                        context.report({\n                            node,\n                            messageId: \"split\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n\n                        // initialized\n                        context.report({\n                            node,\n                            messageId: \"splitInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n\n                        // uninitialized\n                        context.report({\n                            node,\n                            messageId: \"splitUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            BlockStatement: startBlock,\n            ForStatement: startBlock,\n            ForInStatement: startBlock,\n            ForOfStatement: startBlock,\n            SwitchStatement: startBlock,\n            VariableDeclaration: checkVariableDeclaration,\n            \"ForStatement:exit\": endBlock,\n            \"ForOfStatement:exit\": endBlock,\n            \"ForInStatement:exit\": endBlock,\n            \"SwitchStatement:exit\": endBlock,\n            \"BlockStatement:exit\": endBlock,\n            \"Program:exit\": endFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASC,iBAAT,CAA2BC,IAA3B,EAAiC;EAC7B,OAAOH,QAAQ,CAACI,sBAAT,CAAgCC,GAAhC,CAAoCF,IAAI,CAACG,MAAL,CAAYC,IAAhD,CAAP;AACH,C,CAED;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFH,IAAI,EAAE,YADJ;IAGFI,IAAI,EAAE;MACFC,WAAW,EAAE,6EADX;MAEFC,QAAQ,EAAE,kBAFR;MAGFC,WAAW,EAAE,KAHX;MAIFC,GAAG,EAAE;IAJH,CAHJ;IAUFC,OAAO,EAAE,MAVP;IAYFC,MAAM,EAAE,CACJ;MACIC,KAAK,EAAE,CACH;QACIC,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,aAApB;MADV,CADG,EAIH;QACIZ,IAAI,EAAE,QADV;QAEIa,UAAU,EAAE;UACRC,gBAAgB,EAAE;YACdd,IAAI,EAAE;UADQ,CADV;UAIRe,GAAG,EAAE;YACDH,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,aAApB;UADL,CAJG;UAORI,GAAG,EAAE;YACDJ,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,aAApB;UADL,CAPG;UAURK,KAAK,EAAE;YACHL,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,aAApB;UADH;QAVC,CAFhB;QAgBIM,oBAAoB,EAAE;MAhB1B,CAJG,EAsBH;QACIlB,IAAI,EAAE,QADV;QAEIa,UAAU,EAAE;UACRM,WAAW,EAAE;YACTP,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,aAApB;UADG,CADL;UAIRQ,aAAa,EAAE;YACXR,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,aAApB;UADK;QAJP,CAFhB;QAUIM,oBAAoB,EAAE;MAV1B,CAtBG;IADX,CADI,CAZN;IAoDFG,QAAQ,EAAE;MACNC,oBAAoB,EAAE,mFADhB;MAENC,kBAAkB,EAAE,iFAFd;MAGNC,kBAAkB,EAAE,uEAHd;MAINC,gBAAgB,EAAE,qEAJZ;MAKNC,aAAa,EAAE,qDALT;MAMNC,OAAO,EAAE,sDANH;MAONC,KAAK,EAAE;IAPD;EApDR,CADO;;EAgEbC,MAAM,CAACC,OAAD,EAAU;IACZ,MAAMC,WAAW,GAAG,QAApB;IACA,MAAMC,UAAU,GAAG,OAAnB;IACA,MAAMC,gBAAgB,GAAG,aAAzB;IACA,MAAMC,IAAI,GAAGJ,OAAO,CAACK,OAAR,CAAgB,CAAhB,KAAsBJ,WAAnC;IAEA,MAAMI,OAAO,GAAG,EAAhB;;IAEA,IAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;MAAE;MAC5BC,OAAO,CAACpB,GAAR,GAAc;QAAEK,aAAa,EAAEc,IAAjB;QAAuBf,WAAW,EAAEe;MAApC,CAAd;MACAC,OAAO,CAACnB,GAAR,GAAc;QAAEI,aAAa,EAAEc,IAAjB;QAAuBf,WAAW,EAAEe;MAApC,CAAd;MACAC,OAAO,CAAClB,KAAR,GAAgB;QAAEG,aAAa,EAAEc,IAAjB;QAAuBf,WAAW,EAAEe;MAApC,CAAhB;IACH,CAJD,MAIO,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;MAAE;MACnCC,OAAO,CAACrB,gBAAR,GAA2B,CAAC,CAACoB,IAAI,CAACpB,gBAAlC;MACAqB,OAAO,CAACpB,GAAR,GAAc;QAAEK,aAAa,EAAEc,IAAI,CAACnB,GAAtB;QAA2BI,WAAW,EAAEe,IAAI,CAACnB;MAA7C,CAAd;MACAoB,OAAO,CAACnB,GAAR,GAAc;QAAEI,aAAa,EAAEc,IAAI,CAAClB,GAAtB;QAA2BG,WAAW,EAAEe,IAAI,CAAClB;MAA7C,CAAd;MACAmB,OAAO,CAAClB,KAAR,GAAgB;QAAEG,aAAa,EAAEc,IAAI,CAACjB,KAAtB;QAA6BE,WAAW,EAAEe,IAAI,CAACjB;MAA/C,CAAhB;;MACA,IAAImB,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,IAArC,EAA2C,eAA3C,CAAJ,EAAiE;QAC7DC,OAAO,CAACpB,GAAR,CAAYK,aAAZ,GAA4Bc,IAAI,CAACd,aAAjC;QACAe,OAAO,CAACnB,GAAR,CAAYI,aAAZ,GAA4Bc,IAAI,CAACd,aAAjC;QACAe,OAAO,CAAClB,KAAR,CAAcG,aAAd,GAA8Bc,IAAI,CAACd,aAAnC;MACH;;MACD,IAAIgB,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,IAArC,EAA2C,aAA3C,CAAJ,EAA+D;QAC3DC,OAAO,CAACpB,GAAR,CAAYI,WAAZ,GAA0Be,IAAI,CAACf,WAA/B;QACAgB,OAAO,CAACnB,GAAR,CAAYG,WAAZ,GAA0Be,IAAI,CAACf,WAA/B;QACAgB,OAAO,CAAClB,KAAR,CAAcE,WAAd,GAA4Be,IAAI,CAACf,WAAjC;MACH;IACJ;;IAED,MAAMqB,UAAU,GAAGV,OAAO,CAACW,aAAR,EAAnB,CA7BY,CA+BZ;IACA;IACA;;IAEA,MAAMC,aAAa,GAAG,EAAtB;IACA,MAAMC,UAAU,GAAG,EAAnB;IAEA;AACR;AACA;AACA;AACA;;IACQ,SAASC,UAAT,GAAsB;MAClBD,UAAU,CAACE,IAAX,CAAgB;QACZ7B,GAAG,EAAE;UAAEG,WAAW,EAAE,KAAf;UAAsBC,aAAa,EAAE;QAArC,CADO;QAEZH,KAAK,EAAE;UAAEE,WAAW,EAAE,KAAf;UAAsBC,aAAa,EAAE;QAArC;MAFK,CAAhB;IAIH;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAAS0B,aAAT,GAAyB;MACrBJ,aAAa,CAACG,IAAd,CAAmB;QAAE1B,WAAW,EAAE,KAAf;QAAsBC,aAAa,EAAE;MAArC,CAAnB;MACAwB,UAAU;IACb;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASG,QAAT,GAAoB;MAChBJ,UAAU,CAACK,GAAX;IACH;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASC,WAAT,GAAuB;MACnBP,aAAa,CAACM,GAAd;MACAD,QAAQ;IACX;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASG,SAAT,CAAmBC,IAAnB,EAAyB;MACrB,OAAOA,IAAI,CAACC,IAAL,IAAaD,IAAI,CAACC,IAAL,CAAUpD,IAAV,KAAmB,gBAAhC,IAAoDmD,IAAI,CAACC,IAAL,CAAUC,MAAV,CAAiBC,IAAjB,KAA0B,SAArF;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASC,WAAT,CAAqBC,aAArB,EAAoCC,YAApC,EAAkDC,YAAlD,EAAgE;MAC5D,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,YAAY,CAACG,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;QAC1C,IAAIF,YAAY,CAACE,CAAD,CAAZ,CAAgBP,IAAhB,KAAyB,IAA7B,EAAmC;UAC/B,IAAIjB,OAAO,CAACqB,aAAD,CAAP,IAA0BrB,OAAO,CAACqB,aAAD,CAAP,CAAuBpC,aAAvB,KAAyCW,WAAvE,EAAoF;YAChF2B,YAAY,CAACtC,aAAb,GAA6B,IAA7B;UACH;QACJ,CAJD,MAIO;UACH,IAAIe,OAAO,CAACqB,aAAD,CAAP,IAA0BrB,OAAO,CAACqB,aAAD,CAAP,CAAuBrC,WAAvB,KAAuCY,WAArE,EAAkF;YAC9E,IAAII,OAAO,CAACrB,gBAAR,IAA4BoC,SAAS,CAACO,YAAY,CAACE,CAAD,CAAb,CAAzC,EAA4D;cACxDD,YAAY,CAACG,QAAb,GAAwB,IAAxB;YACH,CAFD,MAEO;cACHH,YAAY,CAACvC,WAAb,GAA2B,IAA3B;YACH;UACJ;QACJ;MACJ;IACJ;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAAS2C,eAAT,CAAyBN,aAAzB,EAAwC;MACpC,IAAIE,YAAJ;;MAEA,IAAIF,aAAa,KAAK,KAAtB,EAA6B;QACzBE,YAAY,GAAGhB,aAAa,CAACA,aAAa,CAACkB,MAAd,GAAuB,CAAxB,CAA5B;MACH,CAFD,MAEO,IAAIJ,aAAa,KAAK,KAAtB,EAA6B;QAChCE,YAAY,GAAGf,UAAU,CAACA,UAAU,CAACiB,MAAX,GAAoB,CAArB,CAAV,CAAkC5C,GAAjD;MACH,CAFM,MAEA,IAAIwC,aAAa,KAAK,OAAtB,EAA+B;QAClCE,YAAY,GAAGf,UAAU,CAACA,UAAU,CAACiB,MAAX,GAAoB,CAArB,CAAV,CAAkC3C,KAAjD;MACH;;MACD,OAAOyC,YAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASK,iBAAT,CAA2BN,YAA3B,EAAyC;MACrC,MAAMO,MAAM,GAAG;QAAE5C,aAAa,EAAE,CAAjB;QAAoBD,WAAW,EAAE;MAAjC,CAAf;;MAEA,KAAK,IAAIwC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,YAAY,CAACG,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;QAC1C,IAAIF,YAAY,CAACE,CAAD,CAAZ,CAAgBP,IAAhB,KAAyB,IAA7B,EAAmC;UAC/BY,MAAM,CAAC5C,aAAP;QACH,CAFD,MAEO;UACH4C,MAAM,CAAC7C,WAAP;QACH;MACJ;;MACD,OAAO6C,MAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASC,mBAAT,CAA6BT,aAA7B,EAA4CC,YAA5C,EAA0D;MAEtD,MAAMS,iBAAiB,GAAGH,iBAAiB,CAACN,YAAD,CAA3C;MACA,MAAMU,cAAc,GAAGhC,OAAO,CAACqB,aAAD,CAAP,IAA0B,EAAjD;MACA,MAAME,YAAY,GAAGI,eAAe,CAACN,aAAD,CAApC;MACA,MAAMY,WAAW,GAAGX,YAAY,CAACY,IAAb,CAAkBnB,SAAlB,CAApB;;MAEA,IAAIiB,cAAc,CAAC/C,aAAf,KAAiCW,WAAjC,IAAgDoC,cAAc,CAAChD,WAAf,KAA+BY,WAAnF,EAAgG;QAC5F,IAAI2B,YAAY,CAACtC,aAAb,IAA8BsC,YAAY,CAACvC,WAA/C,EAA4D;UACxD,IAAI,CAACiD,WAAL,EAAkB;YACd,OAAO,KAAP;UACH;QACJ;MACJ;;MAED,IAAIF,iBAAiB,CAAC9C,aAAlB,GAAkC,CAAtC,EAAyC;QACrC,IAAI+C,cAAc,CAAC/C,aAAf,KAAiCW,WAAjC,IAAgD2B,YAAY,CAACtC,aAAjE,EAAgF;UAC5E,OAAO,KAAP;QACH;MACJ;;MACD,IAAI8C,iBAAiB,CAAC/C,WAAlB,GAAgC,CAApC,EAAuC;QACnC,IAAIgD,cAAc,CAAChD,WAAf,KAA+BY,WAA/B,IAA8C2B,YAAY,CAACvC,WAA/D,EAA4E;UACxE,IAAI,CAACiD,WAAL,EAAkB;YACd,OAAO,KAAP;UACH;QACJ;MACJ;;MACD,IAAIV,YAAY,CAACG,QAAb,IAAyBO,WAA7B,EAA0C;QACtC,OAAO,KAAP;MACH;;MACDb,WAAW,CAACC,aAAD,EAAgBC,YAAhB,EAA8BC,YAA9B,CAAX;MACA,OAAO,IAAP;IACH;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASY,gBAAT,CAA0Bb,YAA1B,EAAwC;MACpC,MAAMc,WAAW,GAAGd,YAAY,CAAC,CAAD,CAAhC;MACA,MAAMe,IAAI,GAAGC,KAAK,CAACC,OAAN,CAAcH,WAAW,CAACxE,MAAZ,CAAmBA,MAAnB,CAA0ByE,IAAxC,IAAgDD,WAAW,CAACxE,MAAZ,CAAmBA,MAAnB,CAA0ByE,IAA1E,GAAiF,EAA9F;MACA,MAAMG,YAAY,GAAGH,IAAI,CAACI,SAAL,CAAehF,IAAI,IAAIA,IAAI,CAACiF,KAAL,CAAW,CAAX,MAAkBN,WAAW,CAACxE,MAAZ,CAAmB8E,KAAnB,CAAyB,CAAzB,CAAzC,CAArB;MACA,MAAMC,YAAY,GAAGN,IAAI,CAACG,YAAY,GAAG,CAAhB,CAAzB;MAEA,OAAOI,KAAK,IAAI;QACZ,MAAM/E,IAAI,GAAGwC,UAAU,CAACwC,cAAX,CAA0BT,WAA1B,CAAb;QACA,MAAMU,QAAQ,GAAGzC,UAAU,CAACwC,cAAX,CAA0BhF,IAA1B,CAAjB;QACA,MAAMkF,GAAG,GAAG,EAAZ;;QAEA,IAAIJ,YAAY,IAAIA,YAAY,CAACK,IAAb,KAAsB3C,UAAU,CAAC4C,OAAX,CAAmBpF,IAAnB,CAA1C,EAAoE;UAChE,IAAIiF,QAAQ,CAACI,KAAT,KAAmB,GAAvB,EAA4B;YACxBH,GAAG,CAACrC,IAAJ,CAASkC,KAAK,CAACO,WAAN,CAAkBL,QAAlB,EAA4B,GAA5B,CAAT;UACH,CAFD,MAEO;YACHC,GAAG,CAACrC,IAAJ,CAASkC,KAAK,CAACQ,eAAN,CAAsBN,QAAtB,EAAgC,GAAhC,CAAT;UACH;;UACDC,GAAG,CAACrC,IAAJ,CAASkC,KAAK,CAACO,WAAN,CAAkBtF,IAAlB,EAAwB,EAAxB,CAAT;QACH;;QAED,OAAOkF,GAAP;MACH,CAfD;IAgBH;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASM,iBAAT,CAA2BjB,WAA3B,EAAwC;MACpC,MAAM;QAAExE;MAAF,IAAawE,WAAnB,CADoC,CAGpC;;MACA,IAAI,CAAC5E,iBAAiB,CAACI,MAAM,CAACC,IAAP,KAAgB,wBAAhB,GAA2CD,MAA3C,GAAoDwE,WAArD,CAAtB,EAAyF;QACrF,OAAO,IAAP;MACH;;MAED,OAAOQ,KAAK,IAAIR,WAAW,CAACd,YAAZ,CAAyBgC,GAAzB,CAA6BC,UAAU,IAAI;QACvD,MAAMC,oBAAoB,GAAGnD,UAAU,CAACoD,aAAX,CAAyBF,UAAzB,CAA7B;;QAEA,IAAIC,oBAAoB,KAAK,IAA7B,EAAmC;UAC/B,OAAO,IAAP;QACH;;QAED,MAAME,UAAU,GAAGrD,UAAU,CAACoD,aAAX,CAAyBD,oBAAzB,EAA+C;UAAEG,eAAe,EAAE;QAAnB,CAA/C,CAAnB;;QAEA,IAAIH,oBAAoB,CAACN,KAArB,KAA+B,GAAnC,EAAwC;UACpC,OAAO,IAAP;QACH;;QAED,MAAMU,eAAe,GAAGxB,WAAW,CAACxE,MAAZ,CAAmBC,IAAnB,KAA4B,wBAA5B,GAAuD,SAAvD,GAAmE,EAA3F;QAEA;AAChB;AACA;AACA;;QACgB,IAAI6F,UAAU,CAAChB,KAAX,CAAiB,CAAjB,MAAwBc,oBAAoB,CAACd,KAArB,CAA2B,CAA3B,CAA5B,EAA2D;UACvD,OAAOE,KAAK,CAACO,WAAN,CAAkBK,oBAAlB,EAAyC,KAAII,eAAgB,GAAExB,WAAW,CAACY,IAAK,GAAhF,CAAP;QACH;QAED;AAChB;AACA;AACA;AACA;AACA;;;QACgB,IACIU,UAAU,CAACG,GAAX,CAAeC,KAAf,CAAqBC,IAArB,GAA4BP,oBAAoB,CAACK,GAArB,CAAyBG,GAAzB,CAA6BD,IAAzD,IACAL,UAAU,CAAC7F,IAAX,KAAoB,MADpB,IAEA6F,UAAU,CAAC7F,IAAX,KAAoB,OAHxB,EAIE;UACE,IAAIoG,WAAW,GAAGP,UAAlB;;UAEA,OAAOO,WAAW,CAACpG,IAAZ,KAAqB,MAArB,IAA+BoG,WAAW,CAACpG,IAAZ,KAAqB,OAA3D,EAAoE;YAChEoG,WAAW,GAAG5D,UAAU,CAACoD,aAAX,CAAyBQ,WAAzB,EAAsC;cAAEN,eAAe,EAAE;YAAnB,CAAtC,CAAd;UACH;;UAED,OAAOf,KAAK,CAACsB,gBAAN,CACH,CAACV,oBAAoB,CAACd,KAArB,CAA2B,CAA3B,CAAD,EAAgCuB,WAAW,CAACvB,KAAZ,CAAkB,CAAlB,CAAhC,CADG,EAEF,IAAGrC,UAAU,CAAC8D,IAAX,CAAgBC,KAAhB,CAAsBZ,oBAAoB,CAACd,KAArB,CAA2B,CAA3B,CAAtB,EAAqDuB,WAAW,CAACvB,KAAZ,CAAkB,CAAlB,CAArD,CAA2E,GAAEkB,eAAgB,GAAExB,WAAW,CAACY,IAAK,GAFjH,CAAP;QAIH;;QAED,OAAOJ,KAAK,CAACO,WAAN,CAAkBK,oBAAlB,EAAyC,KAAII,eAAgB,GAAExB,WAAW,CAACY,IAAK,EAAhF,CAAP;MACH,CA/Ce,EA+CbqB,MA/Ca,CA+CNC,CAAC,IAAIA,CA/CC,CAAhB;IAgDH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASC,wBAAT,CAAkC9G,IAAlC,EAAwC;MACpC,MAAMG,MAAM,GAAGH,IAAI,CAACG,MAApB;MACA,MAAMC,IAAI,GAAGJ,IAAI,CAACuF,IAAlB;;MAEA,IAAI,CAAChD,OAAO,CAACnC,IAAD,CAAZ,EAAoB;QAChB;MACH;;MAED,MAAMyD,YAAY,GAAG7D,IAAI,CAAC6D,YAA1B;MACA,MAAMS,iBAAiB,GAAGH,iBAAiB,CAACN,YAAD,CAA3C;MACA,MAAMkD,aAAa,GAAGlD,YAAY,CAACY,IAAb,CAAkBnB,SAAlB,KAAgC,CAACO,YAAY,CAACmD,KAAb,CAAmB1D,SAAnB,CAAvD;;MAEA,IAAIf,OAAO,CAACnC,IAAD,CAAP,CAAcmB,WAAd,KAA8BY,WAAlC,EAA+C;QAC3C,IAAII,OAAO,CAACrB,gBAAR,IAA4B6F,aAAhC,EAA+C;UAC3C7E,OAAO,CAAC+E,MAAR,CAAe;YACXjH,IADW;YAEXkH,SAAS,EAAE;UAFA,CAAf;QAIH;MACJ,CAnBmC,CAqBpC;;;MACA,MAAMC,SAAS,GAAIhH,MAAM,CAACyE,IAAP,IAAezE,MAAM,CAACyE,IAAP,CAAYZ,MAAZ,GAAqB,CAApC,IAAyC7D,MAAM,CAACyE,IAAP,CAAYwC,OAAZ,CAAoBpH,IAApB,CAA1C,IAAwE,CAA1F;;MAEA,IAAImH,SAAS,GAAG,CAAhB,EAAmB;QACf,MAAMjC,YAAY,GAAG/E,MAAM,CAACyE,IAAP,CAAYuC,SAAS,GAAG,CAAxB,CAArB;QACA,MAAME,yBAAyB,GAAGnC,YAAY,CAAC9E,IAAb,KAAsB,qBAAxD;QACA,MAAMkH,wBAAwB,GAAGzD,YAAY,CAAC0D,MAAb,CAAoBrC,YAAY,CAACrB,YAAb,IAA6B,EAAjD,CAAjC;;QAEA,IACIwD,yBAAyB,IACzBnC,YAAY,CAACK,IAAb,KAAsBnF,IADtB,IAEA,EAAEkH,wBAAwB,CAAC7C,IAAzB,CAA8BnB,SAA9B,KAA4C,CAACgE,wBAAwB,CAACN,KAAzB,CAA+B1D,SAA/B,CAA/C,CAHJ,EAIE;UACE,MAAMkE,kBAAkB,GAAGrD,iBAAiB,CAACe,YAAY,CAACrB,YAAd,CAA5C;;UAEA,IAAItB,OAAO,CAACnC,IAAD,CAAP,CAAcmB,WAAd,KAA8Bc,gBAA9B,IAAkDE,OAAO,CAACnC,IAAD,CAAP,CAAcoB,aAAd,KAAgCa,gBAAtF,EAAwG;YACpGH,OAAO,CAAC+E,MAAR,CAAe;cACXjH,IADW;cAEXkH,SAAS,EAAE,SAFA;cAGXO,IAAI,EAAE;gBACFrH;cADE,CAHK;cAMXsH,GAAG,EAAEhD,gBAAgB,CAACb,YAAD;YANV,CAAf;UAQH,CATD,MASO,IAAItB,OAAO,CAACnC,IAAD,CAAP,CAAcmB,WAAd,KAA8Bc,gBAA9B,IAAkDiC,iBAAiB,CAAC/C,WAAlB,GAAgC,CAAlF,IAAuFiG,kBAAkB,CAACjG,WAAnB,GAAiC,CAA5H,EAA+H;YAClIW,OAAO,CAAC+E,MAAR,CAAe;cACXjH,IADW;cAEXkH,SAAS,EAAE,oBAFA;cAGXO,IAAI,EAAE;gBACFrH;cADE,CAHK;cAMXsH,GAAG,EAAEhD,gBAAgB,CAACb,YAAD;YANV,CAAf;UAQH,CATM,MASA,IAAItB,OAAO,CAACnC,IAAD,CAAP,CAAcoB,aAAd,KAAgCa,gBAAhC,IACHiC,iBAAiB,CAAC9C,aAAlB,GAAkC,CAD/B,IAEHgG,kBAAkB,CAAChG,aAAnB,GAAmC,CAFpC,EAEuC;YAC1CU,OAAO,CAAC+E,MAAR,CAAe;cACXjH,IADW;cAEXkH,SAAS,EAAE,sBAFA;cAGXO,IAAI,EAAE;gBACFrH;cADE,CAHK;cAMXsH,GAAG,EAAEhD,gBAAgB,CAACb,YAAD;YANV,CAAf;UAQH;QACJ;MACJ,CAnEmC,CAqEpC;;;MACA,IAAI,CAACQ,mBAAmB,CAACjE,IAAD,EAAOyD,YAAP,CAAxB,EAA8C;QAC1C,IAAItB,OAAO,CAACnC,IAAD,CAAP,CAAcmB,WAAd,KAA8BY,WAA9B,IAA6CI,OAAO,CAACnC,IAAD,CAAP,CAAcoB,aAAd,KAAgCW,WAAjF,EAA8F;UAC1FD,OAAO,CAAC+E,MAAR,CAAe;YACXjH,IADW;YAEXkH,SAAS,EAAE,SAFA;YAGXO,IAAI,EAAE;cACFrH;YADE,CAHK;YAMXsH,GAAG,EAAEhD,gBAAgB,CAACb,YAAD;UANV,CAAf;QAQH,CATD,MASO;UACH,IAAItB,OAAO,CAACnC,IAAD,CAAP,CAAcmB,WAAd,KAA8BY,WAA9B,IAA6CmC,iBAAiB,CAAC/C,WAAlB,GAAgC,CAAjF,EAAoF;YAChFW,OAAO,CAAC+E,MAAR,CAAe;cACXjH,IADW;cAEXkH,SAAS,EAAE,oBAFA;cAGXO,IAAI,EAAE;gBACFrH;cADE,CAHK;cAMXsH,GAAG,EAAEhD,gBAAgB,CAACb,YAAD;YANV,CAAf;UAQH;;UACD,IAAItB,OAAO,CAACnC,IAAD,CAAP,CAAcoB,aAAd,KAAgCW,WAAhC,IAA+CmC,iBAAiB,CAAC9C,aAAlB,GAAkC,CAArF,EAAwF;YACpF,IAAIxB,IAAI,CAACG,MAAL,CAAYwH,IAAZ,KAAqB3H,IAArB,KAA8BA,IAAI,CAACG,MAAL,CAAYC,IAAZ,KAAqB,gBAArB,IAAyCJ,IAAI,CAACG,MAAL,CAAYC,IAAZ,KAAqB,gBAA5F,CAAJ,EAAmH;cAC/G;YACH;;YACD8B,OAAO,CAAC+E,MAAR,CAAe;cACXjH,IADW;cAEXkH,SAAS,EAAE,sBAFA;cAGXO,IAAI,EAAE;gBACFrH;cADE,CAHK;cAMXsH,GAAG,EAAEhD,gBAAgB,CAACb,YAAD;YANV,CAAf;UAQH;QACJ;MACJ,CAzGmC,CA2GpC;;;MACA,IAAI1D,MAAM,CAACC,IAAP,KAAgB,cAAhB,IAAkCD,MAAM,CAACqD,IAAP,KAAgBxD,IAAtD,EAA4D;QACxD,MAAM4H,iBAAiB,GAAGtD,iBAAiB,CAAC9C,aAAlB,GAAkC8C,iBAAiB,CAAC/C,WAA9E;;QAEA,IAAIqG,iBAAiB,GAAG,CAAxB,EAA2B;UACvB,IAAIrF,OAAO,CAACnC,IAAD,CAAP,CAAcmB,WAAd,KAA8Ba,UAA9B,IAA4CG,OAAO,CAACnC,IAAD,CAAP,CAAcoB,aAAd,KAAgCY,UAAhF,EAA4F;YAExF;YACAF,OAAO,CAAC+E,MAAR,CAAe;cACXjH,IADW;cAEXkH,SAAS,EAAE,OAFA;cAGXO,IAAI,EAAE;gBACFrH;cADE,CAHK;cAMXsH,GAAG,EAAE9B,iBAAiB,CAAC5F,IAAD;YANX,CAAf;UAQH,CAXD,MAWO,IAAIuC,OAAO,CAACnC,IAAD,CAAP,CAAcmB,WAAd,KAA8Ba,UAA9B,IAA4CkC,iBAAiB,CAAC/C,WAAlB,GAAgC,CAAhF,EAAmF;YAEtF;YACAW,OAAO,CAAC+E,MAAR,CAAe;cACXjH,IADW;cAEXkH,SAAS,EAAE,kBAFA;cAGXO,IAAI,EAAE;gBACFrH;cADE,CAHK;cAMXsH,GAAG,EAAE9B,iBAAiB,CAAC5F,IAAD;YANX,CAAf;UAQH,CAXM,MAWA,IAAIuC,OAAO,CAACnC,IAAD,CAAP,CAAcoB,aAAd,KAAgCY,UAAhC,IAA8CkC,iBAAiB,CAAC9C,aAAlB,GAAkC,CAApF,EAAuF;YAE1F;YACAU,OAAO,CAAC+E,MAAR,CAAe;cACXjH,IADW;cAEXkH,SAAS,EAAE,oBAFA;cAGXO,IAAI,EAAE;gBACFrH;cADE,CAHK;cAMXsH,GAAG,EAAE9B,iBAAiB,CAAC5F,IAAD;YANX,CAAf;UAQH;QACJ;MACJ;IACJ,CAvbW,CAybZ;IACA;IACA;;;IAEA,OAAO;MACH6H,OAAO,EAAE3E,aADN;MAEH4E,mBAAmB,EAAE5E,aAFlB;MAGH6E,kBAAkB,EAAE7E,aAHjB;MAIH8E,uBAAuB,EAAE9E,aAJtB;MAKH+E,cAAc,EAAEjF,UALb;MAMHkF,YAAY,EAAElF,UANX;MAOHmF,cAAc,EAAEnF,UAPb;MAQHoF,cAAc,EAAEpF,UARb;MASHqF,eAAe,EAAErF,UATd;MAUHsF,mBAAmB,EAAExB,wBAVlB;MAWH,qBAAqB3D,QAXlB;MAYH,uBAAuBA,QAZpB;MAaH,uBAAuBA,QAbpB;MAcH,wBAAwBA,QAdrB;MAeH,uBAAuBA,QAfpB;MAgBH,gBAAgBE,WAhBb;MAiBH,4BAA4BA,WAjBzB;MAkBH,2BAA2BA,WAlBxB;MAmBH,gCAAgCA;IAnB7B,CAAP;EAsBH;;AAnhBY,CAAjB"},"metadata":{},"sourceType":"script"}