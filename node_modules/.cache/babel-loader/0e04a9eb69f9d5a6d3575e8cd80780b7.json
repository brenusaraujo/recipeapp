{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\n\n\nfunction isComparisonOperator(operator) {\n  return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\n\n\nfunction isEqualityOperator(operator) {\n  return /^(==|===)$/u.test(operator);\n}\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\n\n\nfunction isRangeTestOperator(operator) {\n  return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\n\n\nfunction isNegativeNumericLiteral(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.prefix && astUtils.isNumericLiteral(node.argument);\n}\n/**\n * Determines whether a node is a Template Literal which can be determined statically.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node is a Template Literal without expression.\n */\n\n\nfunction isStaticTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n/**\n * Determines whether a non-Literal node should be treated as a single Literal node.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node should be treated as a single Literal node.\n */\n\n\nfunction looksLikeLiteral(node) {\n  return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);\n}\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. A normalized Literal node with the string as the value if the node is\n *     a Template Literal without expression.\n *  4. Otherwise `null`.\n */\n\n\nfunction getNormalizedLiteral(node) {\n  if (node.type === \"Literal\") {\n    return node;\n  }\n\n  if (isNegativeNumericLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: -node.argument.value,\n      raw: `-${node.argument.value}`\n    };\n  }\n\n  if (isStaticTemplateLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: node.quasis[0].value.cooked,\n      raw: node.quasis[0].value.raw\n    };\n  }\n\n  return null;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: 'require or disallow \"Yoda\" conditions',\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/yoda\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptRange: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyEquality: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      expected: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n    }\n  },\n\n  create(context) {\n    // Default to \"never\" (!always) if no option\n    const always = context.options[0] === \"always\";\n    const exceptRange = context.options[1] && context.options[1].exceptRange;\n    const onlyEquality = context.options[1] && context.options[1].onlyEquality;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Determines whether node represents a range test.\n     * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n     * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n     * both operators must be `<` or `<=`. Finally, the literal on the left side\n     * must be less than or equal to the literal on the right side so that the\n     * test makes any sense.\n     * @param {ASTNode} node LogicalExpression node to test.\n     * @returns {boolean} Whether node is a range test.\n     */\n\n    function isRangeTest(node) {\n      const left = node.left,\n            right = node.right;\n      /**\n       * Determines whether node is of the form `0 <= x && x < 1`.\n       * @returns {boolean} Whether node is a \"between\" range test.\n       */\n\n      function isBetweenTest() {\n        if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n          const leftLiteral = getNormalizedLiteral(left.left);\n          const rightLiteral = getNormalizedLiteral(right.right);\n\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /**\n       * Determines whether node is of the form `x < 0 || 1 <= x`.\n       * @returns {boolean} Whether node is an \"outside\" range test.\n       */\n\n\n      function isOutsideTest() {\n        if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n          const leftLiteral = getNormalizedLiteral(left.right);\n          const rightLiteral = getNormalizedLiteral(right.left);\n\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /**\n       * Determines whether node is wrapped in parentheses.\n       * @returns {boolean} Whether node is preceded immediately by an open\n       *                    paren token and followed immediately by a close\n       *                    paren token.\n       */\n\n\n      function isParenWrapped() {\n        return astUtils.isParenthesised(sourceCode, node);\n      }\n\n      return node.type === \"LogicalExpression\" && left.type === \"BinaryExpression\" && right.type === \"BinaryExpression\" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();\n    }\n\n    const OPERATOR_FLIP_MAP = {\n      \"===\": \"===\",\n      \"!==\": \"!==\",\n      \"==\": \"==\",\n      \"!=\": \"!=\",\n      \"<\": \">\",\n      \">\": \"<\",\n      \"<=\": \">=\",\n      \">=\": \"<=\"\n    };\n    /**\n     * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n     * @param {ASTNode} node The BinaryExpression node\n     * @returns {string} A string representation of the node with the sides and operator flipped\n     */\n\n    function getFlippedString(node) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n      const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n      const source = sourceCode.getText();\n      const leftText = source.slice(node.range[0], lastLeftToken.range[1]);\n      const textBeforeOperator = source.slice(lastLeftToken.range[1], operatorToken.range[0]);\n      const textAfterOperator = source.slice(operatorToken.range[1], firstRightToken.range[0]);\n      const rightText = source.slice(firstRightToken.range[0], node.range[1]);\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      const tokenAfter = sourceCode.getTokenAfter(node);\n      let prefix = \"\";\n      let suffix = \"\";\n\n      if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {\n        prefix = \" \";\n      }\n\n      if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)) {\n        suffix = \" \";\n      }\n\n      return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText + suffix;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      BinaryExpression(node) {\n        const expectedLiteral = always ? node.left : node.right;\n        const expectedNonLiteral = always ? node.right : node.left; // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n\n        if ((expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context.getAncestors().pop()))) {\n          context.report({\n            node,\n            messageId: \"expected\",\n            data: {\n              operator: node.operator,\n              expectedSide: always ? \"left\" : \"right\"\n            },\n            fix: fixer => fixer.replaceText(node, getFlippedString(node))\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isComparisonOperator","operator","test","isEqualityOperator","isRangeTestOperator","indexOf","isNegativeNumericLiteral","node","type","prefix","isNumericLiteral","argument","isStaticTemplateLiteral","expressions","length","looksLikeLiteral","getNormalizedLiteral","value","raw","quasis","cooked","module","exports","meta","docs","description","category","recommended","url","schema","enum","properties","exceptRange","default","onlyEquality","additionalProperties","fixable","messages","expected","create","context","always","options","sourceCode","getSourceCode","isRangeTest","left","right","isBetweenTest","isSameReference","leftLiteral","rightLiteral","isOutsideTest","isParenWrapped","isParenthesised","OPERATOR_FLIP_MAP","getFlippedString","operatorToken","getFirstTokenBetween","token","lastLeftToken","getTokenBefore","firstRightToken","getTokenAfter","source","getText","leftText","slice","range","textBeforeOperator","textAfterOperator","rightText","tokenBefore","tokenAfter","suffix","canTokensBeAdjacent","BinaryExpression","expectedLiteral","expectedNonLiteral","getAncestors","pop","report","messageId","data","expectedSide","fix","fixer","replaceText"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/yoda.js"],"sourcesContent":["/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return /^(==|===)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction isNegativeNumericLiteral(node) {\n    return (\n        node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        astUtils.isNumericLiteral(node.argument)\n    );\n}\n\n/**\n * Determines whether a node is a Template Literal which can be determined statically.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node is a Template Literal without expression.\n */\nfunction isStaticTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\n/**\n * Determines whether a non-Literal node should be treated as a single Literal node.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node should be treated as a single Literal node.\n */\nfunction looksLikeLiteral(node) {\n    return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. A normalized Literal node with the string as the value if the node is\n *     a Template Literal without expression.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (isNegativeNumericLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: `-${node.argument.value}`\n        };\n    }\n\n    if (isStaticTemplateLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: node.quasis[0].value.cooked,\n            raw: node.quasis[0].value.raw\n        };\n    }\n\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: 'require or disallow \"Yoda\" conditions',\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/yoda\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyEquality: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            expected:\n                \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n        }\n    },\n\n    create(context) {\n\n        // Default to \"never\" (!always) if no option\n        const always = context.options[0] === \"always\";\n        const exceptRange =\n            context.options[1] && context.options[1].exceptRange;\n        const onlyEquality =\n            context.options[1] && context.options[1].onlyEquality;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            const left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n                    const leftLiteral = getNormalizedLiteral(left.left);\n                    const rightLiteral = getNormalizedLiteral(right.right);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n                    const leftLiteral = getNormalizedLiteral(left.right);\n                    const rightLiteral = getNormalizedLiteral(right.left);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                return astUtils.isParenthesised(sourceCode, node);\n            }\n\n            return (\n                node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped()\n            );\n        }\n\n        const OPERATOR_FLIP_MAP = {\n            \"===\": \"===\",\n            \"!==\": \"!==\",\n            \"==\": \"==\",\n            \"!=\": \"!=\",\n            \"<\": \">\",\n            \">\": \"<\",\n            \"<=\": \">=\",\n            \">=\": \"<=\"\n        };\n\n        /**\n         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n         * @param {ASTNode} node The BinaryExpression node\n         * @returns {string} A string representation of the node with the sides and operator flipped\n         */\n        function getFlippedString(node) {\n            const operatorToken = sourceCode.getFirstTokenBetween(\n                node.left,\n                node.right,\n                token => token.value === node.operator\n            );\n            const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n            const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n\n            const source = sourceCode.getText();\n\n            const leftText = source.slice(\n                node.range[0],\n                lastLeftToken.range[1]\n            );\n            const textBeforeOperator = source.slice(\n                lastLeftToken.range[1],\n                operatorToken.range[0]\n            );\n            const textAfterOperator = source.slice(\n                operatorToken.range[1],\n                firstRightToken.range[0]\n            );\n            const rightText = source.slice(\n                firstRightToken.range[0],\n                node.range[1]\n            );\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            const tokenAfter = sourceCode.getTokenAfter(node);\n            let prefix = \"\";\n            let suffix = \"\";\n\n            if (\n                tokenBefore &&\n                tokenBefore.range[1] === node.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)\n            ) {\n                prefix = \" \";\n            }\n\n            if (\n                tokenAfter &&\n                node.range[1] === tokenAfter.range[0] &&\n                !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)\n            ) {\n                suffix = \" \";\n            }\n\n            return (\n                prefix +\n                rightText +\n                textBeforeOperator +\n                OPERATOR_FLIP_MAP[operatorToken.value] +\n                textAfterOperator +\n                leftText +\n                suffix\n            );\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression(node) {\n                const expectedLiteral = always ? node.left : node.right;\n                const expectedNonLiteral = always ? node.right : node.left;\n\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n                if (\n                    (expectedNonLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedNonLiteral)) &&\n                    !(\n                        expectedLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedLiteral)\n                    ) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        data: {\n                            operator: node.operator,\n                            expectedSide: always ? \"left\" : \"right\"\n                        },\n                        fix: fixer =>\n                            fixer.replaceText(node, getFlippedString(node))\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}