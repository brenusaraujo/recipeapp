{"ast":null,"code":"/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst ruleFixer = require(\"./rule-fixer\");\n\nconst interpolate = require(\"./interpolate\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\n */\n\n/**\n * Information about the report\n * @typedef {Object} ReportInfo\n * @property {string} ruleId\n * @property {(0|1|2)} severity\n * @property {(string|undefined)} message\n * @property {(string|undefined)} [messageId]\n * @property {number} line\n * @property {number} column\n * @property {(number|undefined)} [endLine]\n * @property {(number|undefined)} [endColumn]\n * @property {(string|null)} nodeType\n * @property {string} source\n * @property {({text: string, range: (number[]|null)}|null)} [fix]\n * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions]\n */\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} args A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\n\n\nfunction normalizeMultiArgReportCall() {\n  // If there is one argument, it is considered to be a new-style call already.\n  if (arguments.length === 1) {\n    // Shallow clone the object to avoid surprises if reusing the descriptor\n    return Object.assign({}, arguments.length <= 0 ? undefined : arguments[0]);\n  } // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n\n\n  if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === \"string\") {\n    return {\n      node: arguments.length <= 0 ? undefined : arguments[0],\n      message: arguments.length <= 1 ? undefined : arguments[1],\n      data: arguments.length <= 2 ? undefined : arguments[2],\n      fix: arguments.length <= 3 ? undefined : arguments[3]\n    };\n  } // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n\n\n  return {\n    node: arguments.length <= 0 ? undefined : arguments[0],\n    loc: arguments.length <= 1 ? undefined : arguments[1],\n    message: arguments.length <= 2 ? undefined : arguments[2],\n    data: arguments.length <= 3 ? undefined : arguments[3],\n    fix: arguments.length <= 4 ? undefined : arguments[4]\n  };\n}\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\n\n\nfunction assertValidNodeInfo(descriptor) {\n  if (descriptor.node) {\n    assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n  } else {\n    assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n  }\n}\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\n\n\nfunction normalizeReportLoc(descriptor) {\n  if (descriptor.loc) {\n    if (descriptor.loc.start) {\n      return descriptor.loc;\n    }\n\n    return {\n      start: descriptor.loc,\n      end: null\n    };\n  }\n\n  return descriptor.node.loc;\n}\n/**\n * Check that a fix has a valid range.\n * @param {Fix|null} fix The fix to validate.\n * @returns {void}\n */\n\n\nfunction assertValidFix(fix) {\n  if (fix) {\n    assert(fix.range && typeof fix.range[0] === \"number\" && typeof fix.range[1] === \"number\", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);\n  }\n}\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\n\n\nfunction compareFixesByRange(a, b) {\n  return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: number[]}} The merged fixes\n */\n\n\nfunction mergeFixes(fixes, sourceCode) {\n  for (const fix of fixes) {\n    assertValidFix(fix);\n  }\n\n  if (fixes.length === 0) {\n    return null;\n  }\n\n  if (fixes.length === 1) {\n    return fixes[0];\n  }\n\n  fixes.sort(compareFixesByRange);\n  const originalText = sourceCode.text;\n  const start = fixes[0].range[0];\n  const end = fixes[fixes.length - 1].range[1];\n  let text = \"\";\n  let lastPos = Number.MIN_SAFE_INTEGER;\n\n  for (const fix of fixes) {\n    assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n    if (fix.range[0] >= 0) {\n      text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n    }\n\n    text += fix.text;\n    lastPos = fix.range[1];\n  }\n\n  text += originalText.slice(Math.max(0, start, lastPos), end);\n  return {\n    range: [start, end],\n    text\n  };\n}\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\n */\n\n\nfunction normalizeFixes(descriptor, sourceCode) {\n  if (typeof descriptor.fix !== \"function\") {\n    return null;\n  } // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n\n\n  const fix = descriptor.fix(ruleFixer); // Merge to one.\n\n  if (fix && Symbol.iterator in fix) {\n    return mergeFixes(Array.from(fix), sourceCode);\n  }\n\n  assertValidFix(fix);\n  return fix;\n}\n/**\n * Gets an array of suggestion objects from the given descriptor.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\n */\n\n\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n  if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n    return [];\n  }\n\n  return descriptor.suggest.map(suggestInfo => {\n    const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n    return { ...suggestInfo,\n      desc: interpolate(computedDesc, suggestInfo.data),\n      fix: normalizeFixes(suggestInfo, sourceCode)\n    };\n  }) // Remove suggestions that didn't provide a fix\n  .filter(_ref => {\n    let {\n      fix\n    } = _ref;\n    return fix;\n  });\n}\n/**\n * Creates information about the report from a descriptor\n * @param {Object} options Information about the problem\n * @param {string} options.ruleId Rule ID\n * @param {(0|1|2)} options.severity Rule severity\n * @param {(ASTNode|null)} options.node Node\n * @param {string} options.message Error message\n * @param {string} [options.messageId] The error message ID.\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\n\nfunction createProblem(options) {\n  const problem = {\n    ruleId: options.ruleId,\n    severity: options.severity,\n    message: options.message,\n    line: options.loc.start.line,\n    column: options.loc.start.column + 1,\n    nodeType: options.node && options.node.type || null\n  };\n  /*\n   * If this isnâ€™t in the conditional, some of the tests fail\n   * because `messageId` is present in the problem object\n   */\n\n  if (options.messageId) {\n    problem.messageId = options.messageId;\n  }\n\n  if (options.loc.end) {\n    problem.endLine = options.loc.end.line;\n    problem.endColumn = options.loc.end.column + 1;\n  }\n\n  if (options.fix) {\n    problem.fix = options.fix;\n  }\n\n  if (options.suggestions && options.suggestions.length > 0) {\n    problem.suggestions = options.suggestions;\n  }\n\n  return problem;\n}\n/**\n * Validates that suggestions are properly defined. Throws if an error is detected.\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {void}\n */\n\n\nfunction validateSuggestions(suggest, messages) {\n  if (suggest && Array.isArray(suggest)) {\n    suggest.forEach(suggestion => {\n      if (suggestion.messageId) {\n        const {\n          messageId\n        } = suggestion;\n\n        if (!messages) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n        }\n\n        if (!messages[messageId]) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n        }\n\n        if (suggestion.desc) {\n          throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n        }\n      } else if (!suggestion.desc) {\n        throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n      }\n\n      if (typeof suggestion.fix !== \"function\") {\n        throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n      }\n    });\n  }\n}\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\n\nmodule.exports = function createReportTranslator(metadata) {\n  /*\n   * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n   * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n   * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n   * majority of rules don't report any problems for a given file).\n   */\n  return function () {\n    const descriptor = normalizeMultiArgReportCall(...arguments);\n    const messages = metadata.messageIds;\n    assertValidNodeInfo(descriptor);\n    let computedMessage;\n\n    if (descriptor.messageId) {\n      if (!messages) {\n        throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n      }\n\n      const id = descriptor.messageId;\n\n      if (descriptor.message) {\n        throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n      }\n\n      if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n        throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n      }\n\n      computedMessage = messages[id];\n    } else if (descriptor.message) {\n      computedMessage = descriptor.message;\n    } else {\n      throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n    }\n\n    validateSuggestions(descriptor.suggest, messages);\n    return createProblem({\n      ruleId: metadata.ruleId,\n      severity: metadata.severity,\n      node: descriptor.node,\n      message: interpolate(computedMessage, descriptor.data),\n      messageId: descriptor.messageId,\n      loc: normalizeReportLoc(descriptor),\n      fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\n      suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\n    });\n  };\n};","map":{"version":3,"names":["assert","require","ruleFixer","interpolate","normalizeMultiArgReportCall","length","Object","assign","node","message","data","fix","loc","assertValidNodeInfo","descriptor","normalizeReportLoc","start","end","assertValidFix","range","JSON","stringify","compareFixesByRange","a","b","mergeFixes","fixes","sourceCode","sort","originalText","text","lastPos","Number","MIN_SAFE_INTEGER","slice","Math","max","normalizeFixes","Symbol","iterator","Array","from","mapSuggestions","messages","suggest","isArray","map","suggestInfo","computedDesc","desc","messageId","filter","createProblem","options","problem","ruleId","severity","line","column","nodeType","type","endLine","endColumn","suggestions","validateSuggestions","forEach","suggestion","TypeError","module","exports","createReportTranslator","metadata","messageIds","computedMessage","id","prototype","hasOwnProperty","call","disableFixes"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/report-translator.js"],"sourcesContent":["/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst ruleFixer = require(\"./rule-fixer\");\nconst interpolate = require(\"./interpolate\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\n */\n\n/**\n * Information about the report\n * @typedef {Object} ReportInfo\n * @property {string} ruleId\n * @property {(0|1|2)} severity\n * @property {(string|undefined)} message\n * @property {(string|undefined)} [messageId]\n * @property {number} line\n * @property {number} column\n * @property {(number|undefined)} [endLine]\n * @property {(number|undefined)} [endColumn]\n * @property {(string|null)} nodeType\n * @property {string} source\n * @property {({text: string, range: (number[]|null)}|null)} [fix]\n * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions]\n */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} args A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\nfunction normalizeMultiArgReportCall(...args) {\n\n    // If there is one argument, it is considered to be a new-style call already.\n    if (args.length === 1) {\n\n        // Shallow clone the object to avoid surprises if reusing the descriptor\n        return Object.assign({}, args[0]);\n    }\n\n    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n    if (typeof args[1] === \"string\") {\n        return {\n            node: args[0],\n            message: args[1],\n            data: args[2],\n            fix: args[3]\n        };\n    }\n\n    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n    return {\n        node: args[0],\n        loc: args[1],\n        message: args[2],\n        data: args[3],\n        fix: args[4]\n    };\n}\n\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\nfunction assertValidNodeInfo(descriptor) {\n    if (descriptor.node) {\n        assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n    } else {\n        assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n    }\n}\n\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\nfunction normalizeReportLoc(descriptor) {\n    if (descriptor.loc) {\n        if (descriptor.loc.start) {\n            return descriptor.loc;\n        }\n        return { start: descriptor.loc, end: null };\n    }\n    return descriptor.node.loc;\n}\n\n/**\n * Check that a fix has a valid range.\n * @param {Fix|null} fix The fix to validate.\n * @returns {void}\n */\nfunction assertValidFix(fix) {\n    if (fix) {\n        assert(fix.range && typeof fix.range[0] === \"number\" && typeof fix.range[1] === \"number\", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);\n    }\n}\n\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareFixesByRange(a, b) {\n    return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: number[]}} The merged fixes\n */\nfunction mergeFixes(fixes, sourceCode) {\n    for (const fix of fixes) {\n        assertValidFix(fix);\n    }\n\n    if (fixes.length === 0) {\n        return null;\n    }\n    if (fixes.length === 1) {\n        return fixes[0];\n    }\n\n    fixes.sort(compareFixesByRange);\n\n    const originalText = sourceCode.text;\n    const start = fixes[0].range[0];\n    const end = fixes[fixes.length - 1].range[1];\n    let text = \"\";\n    let lastPos = Number.MIN_SAFE_INTEGER;\n\n    for (const fix of fixes) {\n        assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n        if (fix.range[0] >= 0) {\n            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n        }\n        text += fix.text;\n        lastPos = fix.range[1];\n    }\n    text += originalText.slice(Math.max(0, start, lastPos), end);\n\n    return { range: [start, end], text };\n}\n\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\n */\nfunction normalizeFixes(descriptor, sourceCode) {\n    if (typeof descriptor.fix !== \"function\") {\n        return null;\n    }\n\n    // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n    const fix = descriptor.fix(ruleFixer);\n\n    // Merge to one.\n    if (fix && Symbol.iterator in fix) {\n        return mergeFixes(Array.from(fix), sourceCode);\n    }\n\n    assertValidFix(fix);\n    return fix;\n}\n\n/**\n * Gets an array of suggestion objects from the given descriptor.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\n */\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n    if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n        return [];\n    }\n\n    return descriptor.suggest\n        .map(suggestInfo => {\n            const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n\n            return {\n                ...suggestInfo,\n                desc: interpolate(computedDesc, suggestInfo.data),\n                fix: normalizeFixes(suggestInfo, sourceCode)\n            };\n        })\n\n        // Remove suggestions that didn't provide a fix\n        .filter(({ fix }) => fix);\n}\n\n/**\n * Creates information about the report from a descriptor\n * @param {Object} options Information about the problem\n * @param {string} options.ruleId Rule ID\n * @param {(0|1|2)} options.severity Rule severity\n * @param {(ASTNode|null)} options.node Node\n * @param {string} options.message Error message\n * @param {string} [options.messageId] The error message ID.\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\nfunction createProblem(options) {\n    const problem = {\n        ruleId: options.ruleId,\n        severity: options.severity,\n        message: options.message,\n        line: options.loc.start.line,\n        column: options.loc.start.column + 1,\n        nodeType: options.node && options.node.type || null\n    };\n\n    /*\n     * If this isnâ€™t in the conditional, some of the tests fail\n     * because `messageId` is present in the problem object\n     */\n    if (options.messageId) {\n        problem.messageId = options.messageId;\n    }\n\n    if (options.loc.end) {\n        problem.endLine = options.loc.end.line;\n        problem.endColumn = options.loc.end.column + 1;\n    }\n\n    if (options.fix) {\n        problem.fix = options.fix;\n    }\n\n    if (options.suggestions && options.suggestions.length > 0) {\n        problem.suggestions = options.suggestions;\n    }\n\n    return problem;\n}\n\n/**\n * Validates that suggestions are properly defined. Throws if an error is detected.\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {void}\n */\nfunction validateSuggestions(suggest, messages) {\n    if (suggest && Array.isArray(suggest)) {\n        suggest.forEach(suggestion => {\n            if (suggestion.messageId) {\n                const { messageId } = suggestion;\n\n                if (!messages) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n                }\n\n                if (!messages[messageId]) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n                }\n\n                if (suggestion.desc) {\n                    throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n                }\n            } else if (!suggestion.desc) {\n                throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n            }\n\n            if (typeof suggestion.fix !== \"function\") {\n                throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n            }\n        });\n    }\n}\n\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\nmodule.exports = function createReportTranslator(metadata) {\n\n    /*\n     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n     * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n     * majority of rules don't report any problems for a given file).\n     */\n    return (...args) => {\n        const descriptor = normalizeMultiArgReportCall(...args);\n        const messages = metadata.messageIds;\n\n        assertValidNodeInfo(descriptor);\n\n        let computedMessage;\n\n        if (descriptor.messageId) {\n            if (!messages) {\n                throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n            }\n            const id = descriptor.messageId;\n\n            if (descriptor.message) {\n                throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n            }\n            if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n                throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n            }\n            computedMessage = messages[id];\n        } else if (descriptor.message) {\n            computedMessage = descriptor.message;\n        } else {\n            throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n        }\n\n        validateSuggestions(descriptor.suggest, messages);\n\n        return createProblem({\n            ruleId: metadata.ruleId,\n            severity: metadata.severity,\n            node: descriptor.node,\n            message: interpolate(computedMessage, descriptor.data),\n            messageId: descriptor.messageId,\n            loc: normalizeReportLoc(descriptor),\n            fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\n            suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\n        });\n    };\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,eAAD,CAA3B,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;;AACA,SAASG,2BAAT,GAA8C;EAE1C;EACA,IAAI,UAAKC,MAAL,KAAgB,CAApB,EAAuB;IAEnB;IACA,OAAOC,MAAM,CAACC,MAAP,CAAc,EAAd,mDAAP;EACH,CAPyC,CAS1C;;;EACA,IAAI,8DAAmB,QAAvB,EAAiC;IAC7B,OAAO;MACHC,IAAI,kDADD;MAEHC,OAAO,kDAFJ;MAGHC,IAAI,kDAHD;MAIHC,GAAG;IAJA,CAAP;EAMH,CAjByC,CAmB1C;;;EACA,OAAO;IACHH,IAAI,kDADD;IAEHI,GAAG,kDAFA;IAGHH,OAAO,kDAHJ;IAIHC,IAAI,kDAJD;IAKHC,GAAG;EALA,CAAP;AAOH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,mBAAT,CAA6BC,UAA7B,EAAyC;EACrC,IAAIA,UAAU,CAACN,IAAf,EAAqB;IACjBR,MAAM,CAAC,OAAOc,UAAU,CAACN,IAAlB,KAA2B,QAA5B,EAAsC,wBAAtC,CAAN;EACH,CAFD,MAEO;IACHR,MAAM,CAACc,UAAU,CAACF,GAAZ,EAAiB,wEAAjB,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,kBAAT,CAA4BD,UAA5B,EAAwC;EACpC,IAAIA,UAAU,CAACF,GAAf,EAAoB;IAChB,IAAIE,UAAU,CAACF,GAAX,CAAeI,KAAnB,EAA0B;MACtB,OAAOF,UAAU,CAACF,GAAlB;IACH;;IACD,OAAO;MAAEI,KAAK,EAAEF,UAAU,CAACF,GAApB;MAAyBK,GAAG,EAAE;IAA9B,CAAP;EACH;;EACD,OAAOH,UAAU,CAACN,IAAX,CAAgBI,GAAvB;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASM,cAAT,CAAwBP,GAAxB,EAA6B;EACzB,IAAIA,GAAJ,EAAS;IACLX,MAAM,CAACW,GAAG,CAACQ,KAAJ,IAAa,OAAOR,GAAG,CAACQ,KAAJ,CAAU,CAAV,CAAP,KAAwB,QAArC,IAAiD,OAAOR,GAAG,CAACQ,KAAJ,CAAU,CAAV,CAAP,KAAwB,QAA1E,EAAqF,0BAAyBC,IAAI,CAACC,SAAL,CAAeV,GAAf,EAAoB,IAApB,EAA0B,CAA1B,CAA6B,EAA3I,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASW,mBAAT,CAA6BC,CAA7B,EAAgCC,CAAhC,EAAmC;EAC/B,OAAOD,CAAC,CAACJ,KAAF,CAAQ,CAAR,IAAaK,CAAC,CAACL,KAAF,CAAQ,CAAR,CAAb,IAA2BI,CAAC,CAACJ,KAAF,CAAQ,CAAR,IAAaK,CAAC,CAACL,KAAF,CAAQ,CAAR,CAA/C;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,UAAT,CAAoBC,KAApB,EAA2BC,UAA3B,EAAuC;EACnC,KAAK,MAAMhB,GAAX,IAAkBe,KAAlB,EAAyB;IACrBR,cAAc,CAACP,GAAD,CAAd;EACH;;EAED,IAAIe,KAAK,CAACrB,MAAN,KAAiB,CAArB,EAAwB;IACpB,OAAO,IAAP;EACH;;EACD,IAAIqB,KAAK,CAACrB,MAAN,KAAiB,CAArB,EAAwB;IACpB,OAAOqB,KAAK,CAAC,CAAD,CAAZ;EACH;;EAEDA,KAAK,CAACE,IAAN,CAAWN,mBAAX;EAEA,MAAMO,YAAY,GAAGF,UAAU,CAACG,IAAhC;EACA,MAAMd,KAAK,GAAGU,KAAK,CAAC,CAAD,CAAL,CAASP,KAAT,CAAe,CAAf,CAAd;EACA,MAAMF,GAAG,GAAGS,KAAK,CAACA,KAAK,CAACrB,MAAN,GAAe,CAAhB,CAAL,CAAwBc,KAAxB,CAA8B,CAA9B,CAAZ;EACA,IAAIW,IAAI,GAAG,EAAX;EACA,IAAIC,OAAO,GAAGC,MAAM,CAACC,gBAArB;;EAEA,KAAK,MAAMtB,GAAX,IAAkBe,KAAlB,EAAyB;IACrB1B,MAAM,CAACW,GAAG,CAACQ,KAAJ,CAAU,CAAV,KAAgBY,OAAjB,EAA0B,iDAA1B,CAAN;;IAEA,IAAIpB,GAAG,CAACQ,KAAJ,CAAU,CAAV,KAAgB,CAApB,EAAuB;MACnBW,IAAI,IAAID,YAAY,CAACK,KAAb,CAAmBC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYpB,KAAZ,EAAmBe,OAAnB,CAAnB,EAAgDpB,GAAG,CAACQ,KAAJ,CAAU,CAAV,CAAhD,CAAR;IACH;;IACDW,IAAI,IAAInB,GAAG,CAACmB,IAAZ;IACAC,OAAO,GAAGpB,GAAG,CAACQ,KAAJ,CAAU,CAAV,CAAV;EACH;;EACDW,IAAI,IAAID,YAAY,CAACK,KAAb,CAAmBC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYpB,KAAZ,EAAmBe,OAAnB,CAAnB,EAAgDd,GAAhD,CAAR;EAEA,OAAO;IAAEE,KAAK,EAAE,CAACH,KAAD,EAAQC,GAAR,CAAT;IAAuBa;EAAvB,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,cAAT,CAAwBvB,UAAxB,EAAoCa,UAApC,EAAgD;EAC5C,IAAI,OAAOb,UAAU,CAACH,GAAlB,KAA0B,UAA9B,EAA0C;IACtC,OAAO,IAAP;EACH,CAH2C,CAK5C;;;EACA,MAAMA,GAAG,GAAGG,UAAU,CAACH,GAAX,CAAeT,SAAf,CAAZ,CAN4C,CAQ5C;;EACA,IAAIS,GAAG,IAAI2B,MAAM,CAACC,QAAP,IAAmB5B,GAA9B,EAAmC;IAC/B,OAAOc,UAAU,CAACe,KAAK,CAACC,IAAN,CAAW9B,GAAX,CAAD,EAAkBgB,UAAlB,CAAjB;EACH;;EAEDT,cAAc,CAACP,GAAD,CAAd;EACA,OAAOA,GAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS+B,cAAT,CAAwB5B,UAAxB,EAAoCa,UAApC,EAAgDgB,QAAhD,EAA0D;EACtD,IAAI,CAAC7B,UAAU,CAAC8B,OAAZ,IAAuB,CAACJ,KAAK,CAACK,OAAN,CAAc/B,UAAU,CAAC8B,OAAzB,CAA5B,EAA+D;IAC3D,OAAO,EAAP;EACH;;EAED,OAAO9B,UAAU,CAAC8B,OAAX,CACFE,GADE,CACEC,WAAW,IAAI;IAChB,MAAMC,YAAY,GAAGD,WAAW,CAACE,IAAZ,IAAoBN,QAAQ,CAACI,WAAW,CAACG,SAAb,CAAjD;IAEA,OAAO,EACH,GAAGH,WADA;MAEHE,IAAI,EAAE9C,WAAW,CAAC6C,YAAD,EAAeD,WAAW,CAACrC,IAA3B,CAFd;MAGHC,GAAG,EAAE0B,cAAc,CAACU,WAAD,EAAcpB,UAAd;IAHhB,CAAP;EAKH,CATE,EAWH;EAXG,CAYFwB,MAZE,CAYK;IAAA,IAAC;MAAExC;IAAF,CAAD;IAAA,OAAaA,GAAb;EAAA,CAZL,CAAP;AAaH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASyC,aAAT,CAAuBC,OAAvB,EAAgC;EAC5B,MAAMC,OAAO,GAAG;IACZC,MAAM,EAAEF,OAAO,CAACE,MADJ;IAEZC,QAAQ,EAAEH,OAAO,CAACG,QAFN;IAGZ/C,OAAO,EAAE4C,OAAO,CAAC5C,OAHL;IAIZgD,IAAI,EAAEJ,OAAO,CAACzC,GAAR,CAAYI,KAAZ,CAAkByC,IAJZ;IAKZC,MAAM,EAAEL,OAAO,CAACzC,GAAR,CAAYI,KAAZ,CAAkB0C,MAAlB,GAA2B,CALvB;IAMZC,QAAQ,EAAEN,OAAO,CAAC7C,IAAR,IAAgB6C,OAAO,CAAC7C,IAAR,CAAaoD,IAA7B,IAAqC;EANnC,CAAhB;EASA;AACJ;AACA;AACA;;EACI,IAAIP,OAAO,CAACH,SAAZ,EAAuB;IACnBI,OAAO,CAACJ,SAAR,GAAoBG,OAAO,CAACH,SAA5B;EACH;;EAED,IAAIG,OAAO,CAACzC,GAAR,CAAYK,GAAhB,EAAqB;IACjBqC,OAAO,CAACO,OAAR,GAAkBR,OAAO,CAACzC,GAAR,CAAYK,GAAZ,CAAgBwC,IAAlC;IACAH,OAAO,CAACQ,SAAR,GAAoBT,OAAO,CAACzC,GAAR,CAAYK,GAAZ,CAAgByC,MAAhB,GAAyB,CAA7C;EACH;;EAED,IAAIL,OAAO,CAAC1C,GAAZ,EAAiB;IACb2C,OAAO,CAAC3C,GAAR,GAAc0C,OAAO,CAAC1C,GAAtB;EACH;;EAED,IAAI0C,OAAO,CAACU,WAAR,IAAuBV,OAAO,CAACU,WAAR,CAAoB1D,MAApB,GAA6B,CAAxD,EAA2D;IACvDiD,OAAO,CAACS,WAAR,GAAsBV,OAAO,CAACU,WAA9B;EACH;;EAED,OAAOT,OAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASU,mBAAT,CAA6BpB,OAA7B,EAAsCD,QAAtC,EAAgD;EAC5C,IAAIC,OAAO,IAAIJ,KAAK,CAACK,OAAN,CAAcD,OAAd,CAAf,EAAuC;IACnCA,OAAO,CAACqB,OAAR,CAAgBC,UAAU,IAAI;MAC1B,IAAIA,UAAU,CAAChB,SAAf,EAA0B;QACtB,MAAM;UAAEA;QAAF,IAAgBgB,UAAtB;;QAEA,IAAI,CAACvB,QAAL,EAAe;UACX,MAAM,IAAIwB,SAAJ,CAAe,mEAAkEjB,SAAU,uDAA3F,CAAN;QACH;;QAED,IAAI,CAACP,QAAQ,CAACO,SAAD,CAAb,EAA0B;UACtB,MAAM,IAAIiB,SAAJ,CAAe,mEAAkEjB,SAAU,oDAAmD9B,IAAI,CAACC,SAAL,CAAesB,QAAf,EAAyB,IAAzB,EAA+B,CAA/B,CAAkC,EAAhL,CAAN;QACH;;QAED,IAAIuB,UAAU,CAACjB,IAAf,EAAqB;UACjB,MAAM,IAAIkB,SAAJ,CAAc,oHAAd,CAAN;QACH;MACJ,CAdD,MAcO,IAAI,CAACD,UAAU,CAACjB,IAAhB,EAAsB;QACzB,MAAM,IAAIkB,SAAJ,CAAc,gGAAd,CAAN;MACH;;MAED,IAAI,OAAOD,UAAU,CAACvD,GAAlB,KAA0B,UAA9B,EAA0C;QACtC,MAAM,IAAIwD,SAAJ,CAAe,8EAA6ED,UAAW,EAAvG,CAAN;MACH;IACJ,CAtBD;EAuBH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB,SAASC,sBAAT,CAAgCC,QAAhC,EAA0C;EAEvD;AACJ;AACA;AACA;AACA;AACA;EACI,OAAO,YAAa;IAChB,MAAMzD,UAAU,GAAGV,2BAA2B,CAAC,YAAD,CAA9C;IACA,MAAMuC,QAAQ,GAAG4B,QAAQ,CAACC,UAA1B;IAEA3D,mBAAmB,CAACC,UAAD,CAAnB;IAEA,IAAI2D,eAAJ;;IAEA,IAAI3D,UAAU,CAACoC,SAAf,EAA0B;MACtB,IAAI,CAACP,QAAL,EAAe;QACX,MAAM,IAAIwB,SAAJ,CAAc,8FAAd,CAAN;MACH;;MACD,MAAMO,EAAE,GAAG5D,UAAU,CAACoC,SAAtB;;MAEA,IAAIpC,UAAU,CAACL,OAAf,EAAwB;QACpB,MAAM,IAAI0D,SAAJ,CAAc,+EAAd,CAAN;MACH;;MACD,IAAI,CAACxB,QAAD,IAAa,CAACrC,MAAM,CAACqE,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqClC,QAArC,EAA+C+B,EAA/C,CAAlB,EAAsE;QAClE,MAAM,IAAIP,SAAJ,CAAe,gDAA+CO,EAAG,oDAAmDtD,IAAI,CAACC,SAAL,CAAesB,QAAf,EAAyB,IAAzB,EAA+B,CAA/B,CAAkC,EAAtJ,CAAN;MACH;;MACD8B,eAAe,GAAG9B,QAAQ,CAAC+B,EAAD,CAA1B;IACH,CAbD,MAaO,IAAI5D,UAAU,CAACL,OAAf,EAAwB;MAC3BgE,eAAe,GAAG3D,UAAU,CAACL,OAA7B;IACH,CAFM,MAEA;MACH,MAAM,IAAI0D,SAAJ,CAAc,gGAAd,CAAN;IACH;;IAEDH,mBAAmB,CAAClD,UAAU,CAAC8B,OAAZ,EAAqBD,QAArB,CAAnB;IAEA,OAAOS,aAAa,CAAC;MACjBG,MAAM,EAAEgB,QAAQ,CAAChB,MADA;MAEjBC,QAAQ,EAAEe,QAAQ,CAACf,QAFF;MAGjBhD,IAAI,EAAEM,UAAU,CAACN,IAHA;MAIjBC,OAAO,EAAEN,WAAW,CAACsE,eAAD,EAAkB3D,UAAU,CAACJ,IAA7B,CAJH;MAKjBwC,SAAS,EAAEpC,UAAU,CAACoC,SALL;MAMjBtC,GAAG,EAAEG,kBAAkB,CAACD,UAAD,CANN;MAOjBH,GAAG,EAAE4D,QAAQ,CAACO,YAAT,GAAwB,IAAxB,GAA+BzC,cAAc,CAACvB,UAAD,EAAayD,QAAQ,CAAC5C,UAAtB,CAPjC;MAQjBoC,WAAW,EAAEQ,QAAQ,CAACO,YAAT,GAAwB,EAAxB,GAA6BpC,cAAc,CAAC5B,UAAD,EAAayD,QAAQ,CAAC5C,UAAtB,EAAkCgB,QAAlC;IARvC,CAAD,CAApB;EAUH,CAvCD;AAwCH,CAhDD"},"metadata":{},"sourceType":"script"}