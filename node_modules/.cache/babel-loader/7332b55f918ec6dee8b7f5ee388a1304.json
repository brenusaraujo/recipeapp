{"ast":null,"code":"/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the use of variables within the scope they are defined\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/block-scoped-var\"\n    },\n    schema: [],\n    messages: {\n      outOfScope: \"'{{name}}' used outside of binding context.\"\n    }\n  },\n\n  create(context) {\n    let stack = [];\n    /**\n     * Makes a block scope.\n     * @param {ASTNode} node A node of a scope.\n     * @returns {void}\n     */\n\n    function enterScope(node) {\n      stack.push(node.range);\n    }\n    /**\n     * Pops the last block scope.\n     * @returns {void}\n     */\n\n\n    function exitScope() {\n      stack.pop();\n    }\n    /**\n     * Reports a given reference.\n     * @param {eslint-scope.Reference} reference A reference to report.\n     * @returns {void}\n     */\n\n\n    function report(reference) {\n      const identifier = reference.identifier;\n      context.report({\n        node: identifier,\n        messageId: \"outOfScope\",\n        data: {\n          name: identifier.name\n        }\n      });\n    }\n    /**\n     * Finds and reports references which are outside of valid scopes.\n     * @param {ASTNode} node A node to get variables.\n     * @returns {void}\n     */\n\n\n    function checkForVariables(node) {\n      if (node.kind !== \"var\") {\n        return;\n      } // Defines a predicate to check whether or not a given reference is outside of valid scope.\n\n\n      const scopeRange = stack[stack.length - 1];\n      /**\n       * Check if a reference is out of scope\n       * @param {ASTNode} reference node to examine\n       * @returns {boolean} True is its outside the scope\n       * @private\n       */\n\n      function isOutsideOfScope(reference) {\n        const idRange = reference.identifier.range;\n        return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n      } // Gets declared variables, and checks its references.\n\n\n      const variables = context.getDeclaredVariables(node);\n\n      for (let i = 0; i < variables.length; ++i) {\n        // Reports.\n        variables[i].references.filter(isOutsideOfScope).forEach(report);\n      }\n    }\n\n    return {\n      Program(node) {\n        stack = [node.range];\n      },\n\n      // Manages scopes.\n      BlockStatement: enterScope,\n      \"BlockStatement:exit\": exitScope,\n      ForStatement: enterScope,\n      \"ForStatement:exit\": exitScope,\n      ForInStatement: enterScope,\n      \"ForInStatement:exit\": exitScope,\n      ForOfStatement: enterScope,\n      \"ForOfStatement:exit\": exitScope,\n      SwitchStatement: enterScope,\n      \"SwitchStatement:exit\": exitScope,\n      CatchClause: enterScope,\n      \"CatchClause:exit\": exitScope,\n      // Finds and reports references which are outside of valid scope.\n      VariableDeclaration: checkForVariables\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","messages","outOfScope","create","context","stack","enterScope","node","push","range","exitScope","pop","report","reference","identifier","messageId","data","name","checkForVariables","kind","scopeRange","length","isOutsideOfScope","idRange","variables","getDeclaredVariables","i","references","filter","forEach","Program","BlockStatement","ForStatement","ForInStatement","ForOfStatement","SwitchStatement","CatchClause","VariableDeclaration"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/block-scoped-var.js"],"sourcesContent":["/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the use of variables within the scope they are defined\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/block-scoped-var\"\n        },\n\n        schema: [],\n\n        messages: {\n            outOfScope: \"'{{name}}' used outside of binding context.\"\n        }\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Makes a block scope.\n         * @param {ASTNode} node A node of a scope.\n         * @returns {void}\n         */\n        function enterScope(node) {\n            stack.push(node.range);\n        }\n\n        /**\n         * Pops the last block scope.\n         * @returns {void}\n         */\n        function exitScope() {\n            stack.pop();\n        }\n\n        /**\n         * Reports a given reference.\n         * @param {eslint-scope.Reference} reference A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const identifier = reference.identifier;\n\n            context.report({ node: identifier, messageId: \"outOfScope\", data: { name: identifier.name } });\n        }\n\n        /**\n         * Finds and reports references which are outside of valid scopes.\n         * @param {ASTNode} node A node to get variables.\n         * @returns {void}\n         */\n        function checkForVariables(node) {\n            if (node.kind !== \"var\") {\n                return;\n            }\n\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\n            const scopeRange = stack[stack.length - 1];\n\n            /**\n             * Check if a reference is out of scope\n             * @param {ASTNode} reference node to examine\n             * @returns {boolean} True is its outside the scope\n             * @private\n             */\n            function isOutsideOfScope(reference) {\n                const idRange = reference.identifier.range;\n\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n            }\n\n            // Gets declared variables, and checks its references.\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n\n                // Reports.\n                variables[i]\n                    .references\n                    .filter(isOutsideOfScope)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            Program(node) {\n                stack = [node.range];\n            },\n\n            // Manages scopes.\n            BlockStatement: enterScope,\n            \"BlockStatement:exit\": exitScope,\n            ForStatement: enterScope,\n            \"ForStatement:exit\": exitScope,\n            ForInStatement: enterScope,\n            \"ForInStatement:exit\": exitScope,\n            ForOfStatement: enterScope,\n            \"ForOfStatement:exit\": exitScope,\n            SwitchStatement: enterScope,\n            \"SwitchStatement:exit\": exitScope,\n            CatchClause: enterScope,\n            \"CatchClause:exit\": exitScope,\n\n            // Finds and reports references which are outside of valid scope.\n            VariableDeclaration: checkForVariables\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,YADJ;IAGFC,IAAI,EAAE;MACFC,WAAW,EAAE,gEADX;MAEFC,QAAQ,EAAE,gBAFR;MAGFC,WAAW,EAAE,KAHX;MAIFC,GAAG,EAAE;IAJH,CAHJ;IAUFC,MAAM,EAAE,EAVN;IAYFC,QAAQ,EAAE;MACNC,UAAU,EAAE;IADN;EAZR,CADO;;EAkBbC,MAAM,CAACC,OAAD,EAAU;IACZ,IAAIC,KAAK,GAAG,EAAZ;IAEA;AACR;AACA;AACA;AACA;;IACQ,SAASC,UAAT,CAAoBC,IAApB,EAA0B;MACtBF,KAAK,CAACG,IAAN,CAAWD,IAAI,CAACE,KAAhB;IACH;IAED;AACR;AACA;AACA;;;IACQ,SAASC,SAAT,GAAqB;MACjBL,KAAK,CAACM,GAAN;IACH;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASC,MAAT,CAAgBC,SAAhB,EAA2B;MACvB,MAAMC,UAAU,GAAGD,SAAS,CAACC,UAA7B;MAEAV,OAAO,CAACQ,MAAR,CAAe;QAAEL,IAAI,EAAEO,UAAR;QAAoBC,SAAS,EAAE,YAA/B;QAA6CC,IAAI,EAAE;UAAEC,IAAI,EAAEH,UAAU,CAACG;QAAnB;MAAnD,CAAf;IACH;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASC,iBAAT,CAA2BX,IAA3B,EAAiC;MAC7B,IAAIA,IAAI,CAACY,IAAL,KAAc,KAAlB,EAAyB;QACrB;MACH,CAH4B,CAK7B;;;MACA,MAAMC,UAAU,GAAGf,KAAK,CAACA,KAAK,CAACgB,MAAN,GAAe,CAAhB,CAAxB;MAEA;AACZ;AACA;AACA;AACA;AACA;;MACY,SAASC,gBAAT,CAA0BT,SAA1B,EAAqC;QACjC,MAAMU,OAAO,GAAGV,SAAS,CAACC,UAAV,CAAqBL,KAArC;QAEA,OAAOc,OAAO,CAAC,CAAD,CAAP,GAAaH,UAAU,CAAC,CAAD,CAAvB,IAA8BG,OAAO,CAAC,CAAD,CAAP,GAAaH,UAAU,CAAC,CAAD,CAA5D;MACH,CAlB4B,CAoB7B;;;MACA,MAAMI,SAAS,GAAGpB,OAAO,CAACqB,oBAAR,CAA6BlB,IAA7B,CAAlB;;MAEA,KAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACH,MAA9B,EAAsC,EAAEK,CAAxC,EAA2C;QAEvC;QACAF,SAAS,CAACE,CAAD,CAAT,CACKC,UADL,CAEKC,MAFL,CAEYN,gBAFZ,EAGKO,OAHL,CAGajB,MAHb;MAIH;IACJ;;IAED,OAAO;MACHkB,OAAO,CAACvB,IAAD,EAAO;QACVF,KAAK,GAAG,CAACE,IAAI,CAACE,KAAN,CAAR;MACH,CAHE;;MAKH;MACAsB,cAAc,EAAEzB,UANb;MAOH,uBAAuBI,SAPpB;MAQHsB,YAAY,EAAE1B,UARX;MASH,qBAAqBI,SATlB;MAUHuB,cAAc,EAAE3B,UAVb;MAWH,uBAAuBI,SAXpB;MAYHwB,cAAc,EAAE5B,UAZb;MAaH,uBAAuBI,SAbpB;MAcHyB,eAAe,EAAE7B,UAdd;MAeH,wBAAwBI,SAfrB;MAgBH0B,WAAW,EAAE9B,UAhBV;MAiBH,oBAAoBI,SAjBjB;MAmBH;MACA2B,mBAAmB,EAAEnB;IApBlB,CAAP;EAuBH;;AA9GY,CAAjB"},"metadata":{},"sourceType":"script"}