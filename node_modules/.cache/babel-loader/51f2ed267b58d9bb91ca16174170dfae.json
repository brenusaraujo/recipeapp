{"ast":null,"code":"/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst keywords = require(\"./utils/keywords\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u; // `null` literal must be handled separately.\n\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce dot notation whenever possible\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/dot-notation\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowKeywords: {\n          type: \"boolean\",\n          default: true\n        },\n        allowPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      useDot: \"[{{key}}] is better written in dot notation.\",\n      useBrackets: \".{{key}} is a syntax error.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n    const sourceCode = context.getSourceCode();\n    let allowPattern;\n\n    if (options.allowPattern) {\n      allowPattern = new RegExp(options.allowPattern, \"u\");\n    }\n    /**\n     * Check if the property is valid dot notation\n     * @param {ASTNode} node The dot notation node\n     * @param {string} value Value which is to be checked\n     * @returns {void}\n     */\n\n\n    function checkComputedProperty(node, value) {\n      if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {\n        const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n        context.report({\n          node: node.property,\n          messageId: \"useDot\",\n          data: {\n            key: formattedValue\n          },\n\n          *fix(fixer) {\n            const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n            const rightBracket = sourceCode.getLastToken(node);\n            const nextToken = sourceCode.getTokenAfter(node); // Don't perform any fixes if there are comments inside the brackets.\n\n            if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {\n              return;\n            } // Replace the brackets by an identifier.\n\n\n            if (!node.optional) {\n              yield fixer.insertTextBefore(leftBracket, astUtils.isDecimalInteger(node.object) ? \" .\" : \".\");\n            }\n\n            yield fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], value); // Insert a space after the property if it will be connected to the next token.\n\n            if (nextToken && rightBracket.range[1] === nextToken.range[0] && !astUtils.canTokensBeAdjacent(String(value), nextToken)) {\n              yield fixer.insertTextAfter(node, \" \");\n            }\n          }\n\n        });\n      }\n    }\n\n    return {\n      MemberExpression(node) {\n        if (node.computed && node.property.type === \"Literal\" && (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))) {\n          checkComputedProperty(node, node.property.value);\n        }\n\n        if (node.computed && node.property.type === \"TemplateLiteral\" && node.property.expressions.length === 0) {\n          checkComputedProperty(node, node.property.quasis[0].value.cooked);\n        }\n\n        if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {\n          context.report({\n            node: node.property,\n            messageId: \"useBrackets\",\n            data: {\n              key: node.property.name\n            },\n\n            *fix(fixer) {\n              const dotToken = sourceCode.getTokenBefore(node.property); // A statement that starts with `let[` is parsed as a destructuring variable declaration, not a MemberExpression.\n\n              if (node.object.type === \"Identifier\" && node.object.name === \"let\" && !node.optional) {\n                return;\n              } // Don't perform any fixes if there are comments between the dot and the property name.\n\n\n              if (sourceCode.commentsExistBetween(dotToken, node.property)) {\n                return;\n              } // Replace the identifier to brackets.\n\n\n              if (!node.optional) {\n                yield fixer.remove(dotToken);\n              }\n\n              yield fixer.replaceText(node.property, `[\"${node.property.name}\"]`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","keywords","validIdentifier","literalTypesToCheck","Set","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowKeywords","default","allowPattern","additionalProperties","fixable","messages","useDot","useBrackets","create","context","options","sourceCode","getSourceCode","RegExp","checkComputedProperty","node","value","test","indexOf","String","formattedValue","property","JSON","stringify","report","messageId","data","key","fix","fixer","leftBracket","getTokenAfter","object","isOpeningBracketToken","rightBracket","getLastToken","nextToken","commentsExistBetween","optional","insertTextBefore","isDecimalInteger","replaceTextRange","range","canTokensBeAdjacent","insertTextAfter","MemberExpression","computed","has","isNullLiteral","expressions","length","quasis","cooked","name","dotToken","getTokenBefore","remove","replaceText"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/dot-notation.js"],"sourcesContent":["/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;\n\n// `null` literal must be handled separately.\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce dot notation whenever possible\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/dot-notation\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowKeywords: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    allowPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            useDot: \"[{{key}}] is better written in dot notation.\",\n            useBrackets: \".{{key}} is a syntax error.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n        const sourceCode = context.getSourceCode();\n\n        let allowPattern;\n\n        if (options.allowPattern) {\n            allowPattern = new RegExp(options.allowPattern, \"u\");\n        }\n\n        /**\n         * Check if the property is valid dot notation\n         * @param {ASTNode} node The dot notation node\n         * @param {string} value Value which is to be checked\n         * @returns {void}\n         */\n        function checkComputedProperty(node, value) {\n            if (\n                validIdentifier.test(value) &&\n                (allowKeywords || keywords.indexOf(String(value)) === -1) &&\n                !(allowPattern && allowPattern.test(value))\n            ) {\n                const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n\n                context.report({\n                    node: node.property,\n                    messageId: \"useDot\",\n                    data: {\n                        key: formattedValue\n                    },\n                    *fix(fixer) {\n                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n                        const rightBracket = sourceCode.getLastToken(node);\n                        const nextToken = sourceCode.getTokenAfter(node);\n\n                        // Don't perform any fixes if there are comments inside the brackets.\n                        if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {\n                            return;\n                        }\n\n                        // Replace the brackets by an identifier.\n                        if (!node.optional) {\n                            yield fixer.insertTextBefore(\n                                leftBracket,\n                                astUtils.isDecimalInteger(node.object) ? \" .\" : \".\"\n                            );\n                        }\n                        yield fixer.replaceTextRange(\n                            [leftBracket.range[0], rightBracket.range[1]],\n                            value\n                        );\n\n                        // Insert a space after the property if it will be connected to the next token.\n                        if (\n                            nextToken &&\n                            rightBracket.range[1] === nextToken.range[0] &&\n                            !astUtils.canTokensBeAdjacent(String(value), nextToken)\n                        ) {\n                            yield fixer.insertTextAfter(node, \" \");\n                        }\n                    }\n                });\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                if (\n                    node.computed &&\n                    node.property.type === \"Literal\" &&\n                    (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))\n                ) {\n                    checkComputedProperty(node, node.property.value);\n                }\n                if (\n                    node.computed &&\n                    node.property.type === \"TemplateLiteral\" &&\n                    node.property.expressions.length === 0\n                ) {\n                    checkComputedProperty(node, node.property.quasis[0].value.cooked);\n                }\n                if (\n                    !allowKeywords &&\n                    !node.computed &&\n                    keywords.indexOf(String(node.property.name)) !== -1\n                ) {\n                    context.report({\n                        node: node.property,\n                        messageId: \"useBrackets\",\n                        data: {\n                            key: node.property.name\n                        },\n                        *fix(fixer) {\n                            const dotToken = sourceCode.getTokenBefore(node.property);\n\n                            // A statement that starts with `let[` is parsed as a destructuring variable declaration, not a MemberExpression.\n                            if (node.object.type === \"Identifier\" && node.object.name === \"let\" && !node.optional) {\n                                return;\n                            }\n\n                            // Don't perform any fixes if there are comments between the dot and the property name.\n                            if (sourceCode.commentsExistBetween(dotToken, node.property)) {\n                                return;\n                            }\n\n                            // Replace the identifier to brackets.\n                            if (!node.optional) {\n                                yield fixer.remove(dotToken);\n                            }\n                            yield fixer.replaceText(node.property, `[\"${node.property.name}\"]`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}