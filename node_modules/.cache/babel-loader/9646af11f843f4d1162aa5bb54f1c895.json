{"ast":null,"code":"/**\n * @fileoverview Enforce newlines between operands of ternary expressions\n * @author Kai Cataldo\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce newlines between operands of ternary expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/multiline-ternary\"\n    },\n    schema: [{\n      enum: [\"always\", \"always-multiline\", \"never\"]\n    }],\n    messages: {\n      expectedTestCons: \"Expected newline between test and consequent of ternary expression.\",\n      expectedConsAlt: \"Expected newline between consequent and alternate of ternary expression.\",\n      unexpectedTestCons: \"Unexpected newline between test and consequent of ternary expression.\",\n      unexpectedConsAlt: \"Unexpected newline between consequent and alternate of ternary expression.\"\n    },\n    fixable: \"whitespace\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0];\n    const multiline = option !== \"never\";\n    const allowSingleLine = option === \"always-multiline\"; //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      ConditionalExpression(node) {\n        const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);\n        const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);\n        const firstTokenOfTest = sourceCode.getFirstToken(node);\n        const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);\n        const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);\n        const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);\n        const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);\n        const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);\n        const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);\n        const hasComments = !!sourceCode.getCommentsInside(node).length;\n\n        if (!multiline) {\n          if (!areTestAndConsequentOnSameLine) {\n            context.report({\n              node: node.test,\n              loc: {\n                start: firstTokenOfTest.loc.start,\n                end: lastTokenOfTest.loc.end\n              },\n              messageId: \"unexpectedTestCons\",\n              fix: fixer => {\n                if (hasComments) {\n                  return null;\n                }\n\n                const fixers = [];\n                const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);\n                const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);\n\n                if (!areTestAndQuestionOnSameLine) {\n                  fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));\n                }\n\n                if (!areQuestionAndConsOnSameLine) {\n                  fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));\n                }\n\n                return fixers;\n              }\n            });\n          }\n\n          if (!areConsequentAndAlternateOnSameLine) {\n            context.report({\n              node: node.consequent,\n              loc: {\n                start: firstTokenOfConsequent.loc.start,\n                end: lastTokenOfConsequent.loc.end\n              },\n              messageId: \"unexpectedConsAlt\",\n              fix: fixer => {\n                if (hasComments) {\n                  return null;\n                }\n\n                const fixers = [];\n                const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);\n                const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);\n\n                if (!areConsAndColonOnSameLine) {\n                  fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));\n                }\n\n                if (!areColonAndAltOnSameLine) {\n                  fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));\n                }\n\n                return fixers;\n              }\n            });\n          }\n        } else {\n          if (allowSingleLine && node.loc.start.line === node.loc.end.line) {\n            return;\n          }\n\n          if (areTestAndConsequentOnSameLine) {\n            context.report({\n              node: node.test,\n              loc: {\n                start: firstTokenOfTest.loc.start,\n                end: lastTokenOfTest.loc.end\n              },\n              messageId: \"expectedTestCons\",\n              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfTest.range[1], questionToken.range[0]], \"\\n\")\n            });\n          }\n\n          if (areConsequentAndAlternateOnSameLine) {\n            context.report({\n              node: node.consequent,\n              loc: {\n                start: firstTokenOfConsequent.loc.start,\n                end: lastTokenOfConsequent.loc.end\n              },\n              messageId: \"expectedConsAlt\",\n              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfConsequent.range[1], colonToken.range[0]], \"\\n\")\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","messages","expectedTestCons","expectedConsAlt","unexpectedTestCons","unexpectedConsAlt","fixable","create","context","sourceCode","getSourceCode","option","options","multiline","allowSingleLine","ConditionalExpression","node","questionToken","getTokenAfter","test","isNotClosingParenToken","colonToken","consequent","firstTokenOfTest","getFirstToken","lastTokenOfTest","getTokenBefore","firstTokenOfConsequent","lastTokenOfConsequent","firstTokenOfAlternate","areTestAndConsequentOnSameLine","isTokenOnSameLine","areConsequentAndAlternateOnSameLine","hasComments","getCommentsInside","length","report","loc","start","end","messageId","fix","fixer","fixers","areTestAndQuestionOnSameLine","areQuestionAndConsOnSameLine","push","removeRange","range","areConsAndColonOnSameLine","areColonAndAltOnSameLine","line","replaceTextRange"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/multiline-ternary.js"],"sourcesContent":["/**\n * @fileoverview Enforce newlines between operands of ternary expressions\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce newlines between operands of ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/multiline-ternary\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"always-multiline\", \"never\"]\n            }\n        ],\n\n        messages: {\n            expectedTestCons: \"Expected newline between test and consequent of ternary expression.\",\n            expectedConsAlt: \"Expected newline between consequent and alternate of ternary expression.\",\n            unexpectedTestCons: \"Unexpected newline between test and consequent of ternary expression.\",\n            unexpectedConsAlt: \"Unexpected newline between consequent and alternate of ternary expression.\"\n        },\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0];\n        const multiline = option !== \"never\";\n        const allowSingleLine = option === \"always-multiline\";\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression(node) {\n                const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);\n                const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);\n\n                const firstTokenOfTest = sourceCode.getFirstToken(node);\n                const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);\n                const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);\n                const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);\n                const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);\n\n                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);\n                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);\n\n                const hasComments = !!sourceCode.getCommentsInside(node).length;\n\n                if (!multiline) {\n                    if (!areTestAndConsequentOnSameLine) {\n                        context.report({\n                            node: node.test,\n                            loc: {\n                                start: firstTokenOfTest.loc.start,\n                                end: lastTokenOfTest.loc.end\n                            },\n                            messageId: \"unexpectedTestCons\",\n                            fix: fixer => {\n                                if (hasComments) {\n                                    return null;\n                                }\n                                const fixers = [];\n                                const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);\n                                const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);\n\n                                if (!areTestAndQuestionOnSameLine) {\n                                    fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));\n                                }\n                                if (!areQuestionAndConsOnSameLine) {\n                                    fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));\n                                }\n\n                                return fixers;\n                            }\n                        });\n                    }\n\n                    if (!areConsequentAndAlternateOnSameLine) {\n                        context.report({\n                            node: node.consequent,\n                            loc: {\n                                start: firstTokenOfConsequent.loc.start,\n                                end: lastTokenOfConsequent.loc.end\n                            },\n                            messageId: \"unexpectedConsAlt\",\n                            fix: fixer => {\n                                if (hasComments) {\n                                    return null;\n                                }\n                                const fixers = [];\n                                const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);\n                                const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);\n\n                                if (!areConsAndColonOnSameLine) {\n                                    fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));\n                                }\n                                if (!areColonAndAltOnSameLine) {\n                                    fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));\n                                }\n\n                                return fixers;\n                            }\n                        });\n                    }\n                } else {\n                    if (allowSingleLine && node.loc.start.line === node.loc.end.line) {\n                        return;\n                    }\n\n                    if (areTestAndConsequentOnSameLine) {\n                        context.report({\n                            node: node.test,\n                            loc: {\n                                start: firstTokenOfTest.loc.start,\n                                end: lastTokenOfTest.loc.end\n                            },\n                            messageId: \"expectedTestCons\",\n                            fix: fixer => (hasComments ? null : (\n                                fixer.replaceTextRange(\n                                    [\n                                        lastTokenOfTest.range[1],\n                                        questionToken.range[0]\n                                    ],\n                                    \"\\n\"\n                                )\n                            ))\n                        });\n                    }\n\n                    if (areConsequentAndAlternateOnSameLine) {\n                        context.report({\n                            node: node.consequent,\n                            loc: {\n                                start: firstTokenOfConsequent.loc.start,\n                                end: lastTokenOfConsequent.loc.end\n                            },\n                            messageId: \"expectedConsAlt\",\n                            fix: (fixer => (hasComments ? null : (\n                                fixer.replaceTextRange(\n                                    [\n                                        lastTokenOfConsequent.range[1],\n                                        colonToken.range[0]\n                                    ],\n                                    \"\\n\"\n                                )\n                            )))\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}