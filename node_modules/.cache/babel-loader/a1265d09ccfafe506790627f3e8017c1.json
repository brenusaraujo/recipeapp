{"ast":null,"code":"/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\n * Checks a given node is a member access which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a member access which has\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\n */\n\n\nfunction isTargetMethod(node) {\n  return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n/**\n * Returns a human-legible description of an array method\n * @param {string} arrayMethodName A method name to fully qualify\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\n *      or else `Array.prototype.` if it is an instance method.\n */\n\n\nfunction fullMethodName(arrayMethodName) {\n  if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n    return \"Array.\".concat(arrayMethodName);\n  }\n\n  return \"Array.prototype.\".concat(arrayMethodName);\n}\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method, returning the method name.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {string} The method name if the node is a callback method,\n *      null otherwise.\n */\n\n\nfunction getArrayMethodName(node) {\n  let currentNode = node;\n\n  while (currentNode) {\n    const parent = currentNode.parent;\n\n    switch (parent.type) {\n      /*\n       * Looks up the destination. e.g.,\n       * foo.every(nativeFoo || function foo() { ... });\n       */\n      case \"LogicalExpression\":\n      case \"ConditionalExpression\":\n      case \"ChainExpression\":\n        currentNode = parent;\n        break;\n\n      /*\n       * If the upper function is IIFE, checks the destination of the return value.\n       * e.g.\n       *   foo.every((function() {\n       *     // setup...\n       *     return function callback() { ... };\n       *   })());\n       */\n\n      case \"ReturnStatement\":\n        {\n          const func = astUtils.getUpperFunction(parent);\n\n          if (func === null || !astUtils.isCallee(func)) {\n            return null;\n          }\n\n          currentNode = func.parent;\n          break;\n        }\n\n      /*\n       * e.g.\n       *   Array.from([], function() {});\n       *   list.every(function() {});\n       */\n\n      case \"CallExpression\":\n        if (astUtils.isArrayFromMethod(parent.callee)) {\n          if (parent.arguments.length >= 2 && parent.arguments[1] === currentNode) {\n            return \"from\";\n          }\n        }\n\n        if (isTargetMethod(parent.callee)) {\n          if (parent.arguments.length >= 1 && parent.arguments[0] === currentNode) {\n            return astUtils.getStaticPropertyName(parent.callee);\n          }\n        }\n\n        return null;\n      // Otherwise this node is not target.\n\n      default:\n        return null;\n    }\n  }\n  /* istanbul ignore next: unreachable */\n\n\n  return null;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in callbacks of array methods\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-callback-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        },\n        checkForEach: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n      expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false,\n      checkForEach: false\n    };\n    const sourceCode = context.getSourceCode();\n    let funcInfo = {\n      arrayMethodName: null,\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n    /**\n     * Checks whether or not the last code path segment is reachable.\n     * Then reports this function if the segment is reachable.\n     *\n     * If the last code path segment is reachable, there are paths which are not\n     * returned or thrown.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n\n    function checkLastSegment(node) {\n      if (!funcInfo.shouldCheck) {\n        return;\n      }\n\n      let messageId = null;\n\n      if (funcInfo.arrayMethodName === \"forEach\") {\n        if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n          messageId = \"expectedNoReturnValue\";\n        }\n      } else {\n        if (node.body.type === \"BlockStatement\" && funcInfo.codePath.currentSegments.some(isReachable)) {\n          messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n        }\n      }\n\n      if (messageId) {\n        const name = astUtils.getFunctionNameWithKind(node);\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId,\n          data: {\n            name,\n            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n          }\n        });\n      }\n    }\n\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        let methodName = null;\n\n        if (TARGET_NODE_TYPE.test(node.type)) {\n          methodName = getArrayMethodName(node);\n        }\n\n        funcInfo = {\n          arrayMethodName: methodName,\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: methodName && !node.async && !node.generator,\n          node\n        };\n      },\n\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (!funcInfo.shouldCheck) {\n          return;\n        }\n\n        funcInfo.hasReturn = true;\n        let messageId = null;\n\n        if (funcInfo.arrayMethodName === \"forEach\") {\n          // if checkForEach: true, returning a value at any path inside a forEach is not allowed\n          if (options.checkForEach && node.argument) {\n            messageId = \"expectedNoReturnValue\";\n          }\n        } else {\n          // if allowImplicit: false, should also check node.argument\n          if (!options.allowImplicit && !node.argument) {\n            messageId = \"expectedReturnValue\";\n          }\n        }\n\n        if (messageId) {\n          context.report({\n            node,\n            messageId,\n            data: {\n              name: astUtils.getFunctionNameWithKind(funcInfo.node),\n              arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n            }\n          });\n        }\n      },\n\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","TARGET_NODE_TYPE","TARGET_METHODS","isReachable","segment","reachable","isTargetMethod","node","isSpecificMemberAccess","fullMethodName","arrayMethodName","includes","concat","getArrayMethodName","currentNode","parent","type","func","getUpperFunction","isCallee","isArrayFromMethod","callee","arguments","length","getStaticPropertyName","module","exports","meta","docs","description","category","recommended","url","schema","properties","allowImplicit","default","checkForEach","additionalProperties","messages","expectedAtEnd","expectedInside","expectedReturnValue","expectedNoReturnValue","create","context","options","sourceCode","getSourceCode","funcInfo","upper","codePath","hasReturn","shouldCheck","checkLastSegment","messageId","expression","body","currentSegments","some","name","getFunctionNameWithKind","report","loc","getFunctionHeadLoc","data","onCodePathStart","methodName","test","async","generator","onCodePathEnd","ReturnStatement","argument"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/array-callback-return.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks a given node is a member access which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a member access which has\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\n */\nfunction isTargetMethod(node) {\n    return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n\n/**\n * Returns a human-legible description of an array method\n * @param {string} arrayMethodName A method name to fully qualify\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\n *      or else `Array.prototype.` if it is an instance method.\n */\nfunction fullMethodName(arrayMethodName) {\n    if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n        return \"Array.\".concat(arrayMethodName);\n    }\n    return \"Array.prototype.\".concat(arrayMethodName);\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method, returning the method name.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {string} The method name if the node is a callback method,\n *      null otherwise.\n */\nfunction getArrayMethodName(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n            case \"ChainExpression\":\n                currentNode = parent;\n                break;\n\n            /*\n             * If the upper function is IIFE, checks the destination of the return value.\n             * e.g.\n             *   foo.every((function() {\n             *     // setup...\n             *     return function callback() { ... };\n             *   })());\n             */\n            case \"ReturnStatement\": {\n                const func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return null;\n                }\n                currentNode = func.parent;\n                break;\n            }\n\n            /*\n             * e.g.\n             *   Array.from([], function() {});\n             *   list.every(function() {});\n             */\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === currentNode\n                    ) {\n                        return \"from\";\n                    }\n                }\n                if (isTargetMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === currentNode\n                    ) {\n                        return astUtils.getStaticPropertyName(parent.callee);\n                    }\n                }\n                return null;\n\n            // Otherwise this node is not target.\n            default:\n                return null;\n        }\n    }\n\n    /* istanbul ignore next: unreachable */\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in callbacks of array methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-callback-return\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    checkForEach: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n            expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false, checkForEach: false };\n        const sourceCode = context.getSourceCode();\n\n        let funcInfo = {\n            arrayMethodName: null,\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n\n            if (!funcInfo.shouldCheck) {\n                return;\n            }\n\n            let messageId = null;\n\n            if (funcInfo.arrayMethodName === \"forEach\") {\n                if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n                    messageId = \"expectedNoReturnValue\";\n                }\n            } else {\n                if (node.body.type === \"BlockStatement\" && funcInfo.codePath.currentSegments.some(isReachable)) {\n                    messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n                }\n            }\n\n            if (messageId) {\n                const name = astUtils.getFunctionNameWithKind(node);\n\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId,\n                    data: { name, arrayMethodName: fullMethodName(funcInfo.arrayMethodName) }\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n\n                let methodName = null;\n\n                if (TARGET_NODE_TYPE.test(node.type)) {\n                    methodName = getArrayMethodName(node);\n                }\n\n                funcInfo = {\n                    arrayMethodName: methodName,\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        methodName &&\n                        !node.async &&\n                        !node.generator,\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n\n                if (!funcInfo.shouldCheck) {\n                    return;\n                }\n\n                funcInfo.hasReturn = true;\n\n                let messageId = null;\n\n                if (funcInfo.arrayMethodName === \"forEach\") {\n\n                    // if checkForEach: true, returning a value at any path inside a forEach is not allowed\n                    if (options.checkForEach && node.argument) {\n                        messageId = \"expectedNoReturnValue\";\n                    }\n                } else {\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        messageId = \"expectedReturnValue\";\n                    }\n                }\n\n                if (messageId) {\n                    context.report({\n                        node,\n                        messageId,\n                        data: {\n                            name: astUtils.getFunctionNameWithKind(funcInfo.node),\n                            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n                        }\n                    });\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}