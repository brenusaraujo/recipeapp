{"ast":null,"code":"/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst eslintUtils = require(\"eslint-utils\");\n\nconst precedence = astUtils.getPrecedence; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary boolean casts\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForLogicalOperands: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpectedCall: \"Redundant Boolean call.\",\n      unexpectedNegation: \"Redundant double negation.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); // Node types which have a test which will coerce values to booleans.\n\n    const BOOLEAN_NODE_TYPES = [\"IfStatement\", \"DoWhileStatement\", \"WhileStatement\", \"ConditionalExpression\", \"ForStatement\"];\n    /**\n     * Check if a node is a Boolean function or constructor.\n     * @param {ASTNode} node the node\n     * @returns {boolean} If the node is Boolean function or constructor\n     */\n\n    function isBooleanFunctionOrConstructorCall(node) {\n      // Boolean(<bool>) and new Boolean(<bool>)\n      return (node.type === \"CallExpression\" || node.type === \"NewExpression\") && node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\";\n    }\n    /**\n     * Checks whether the node is a logical expression and that the option is enabled\n     * @param {ASTNode} node the node\n     * @returns {boolean} if the node is a logical expression and option is enabled\n     */\n\n\n    function isLogicalContext(node) {\n      return node.type === \"LogicalExpression\" && (node.operator === \"||\" || node.operator === \"&&\") && context.options.length && context.options[0].enforceForLogicalOperands === true;\n    }\n    /**\n     * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n     * @param {ASTNode} node The node\n     * @returns {boolean} If it is in a boolean context\n     */\n\n\n    function isInBooleanContext(node) {\n      return isBooleanFunctionOrConstructorCall(node.parent) && node === node.parent.arguments[0] || BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 && node === node.parent.test || // !<bool>\n      node.parent.type === \"UnaryExpression\" && node.parent.operator === \"!\";\n    }\n    /**\n     * Checks whether the node is a context that should report an error\n     * Acts recursively if it is in a logical context\n     * @param {ASTNode} node the node\n     * @returns {boolean} If the node is in one of the flagged contexts\n     */\n\n\n    function isInFlaggedContext(node) {\n      if (node.parent.type === \"ChainExpression\") {\n        return isInFlaggedContext(node.parent);\n      }\n\n      return isInBooleanContext(node) || isLogicalContext(node.parent) && // For nested logical statements\n      isInFlaggedContext(node.parent);\n    }\n    /**\n     * Check if a node has comments inside.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if it has comments inside.\n     */\n\n\n    function hasCommentsInside(node) {\n      return Boolean(sourceCode.getCommentsInside(node).length);\n    }\n    /**\n     * Checks if the given node is wrapped in grouping parentheses. Parentheses for constructs such as if() don't count.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is parenthesized.\n     * @private\n     */\n\n\n    function isParenthesized(node) {\n      return eslintUtils.isParenthesized(1, node, sourceCode);\n    }\n    /**\n     * Determines whether the given node needs to be parenthesized when replacing the previous node.\n     * It assumes that `previousNode` is the node to be reported by this rule, so it has a limited list\n     * of possible parent node types. By the same assumption, the node's role in a particular parent is already known.\n     * For example, if the parent is `ConditionalExpression`, `previousNode` must be its `test` child.\n     * @param {ASTNode} previousNode Previous node.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node needs to be parenthesized.\n     */\n\n\n    function needsParens(previousNode, node) {\n      if (previousNode.parent.type === \"ChainExpression\") {\n        return needsParens(previousNode.parent, node);\n      }\n\n      if (isParenthesized(previousNode)) {\n        // parentheses around the previous node will stay, so there is no need for an additional pair\n        return false;\n      } // parent of the previous node will become parent of the replacement node\n\n\n      const parent = previousNode.parent;\n\n      switch (parent.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return node.type === \"SequenceExpression\";\n\n        case \"IfStatement\":\n        case \"DoWhileStatement\":\n        case \"WhileStatement\":\n        case \"ForStatement\":\n          return false;\n\n        case \"ConditionalExpression\":\n          return precedence(node) <= precedence(parent);\n\n        case \"UnaryExpression\":\n          return precedence(node) < precedence(parent);\n\n        case \"LogicalExpression\":\n          if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {\n            return true;\n          }\n\n          if (previousNode === parent.left) {\n            return precedence(node) < precedence(parent);\n          }\n\n          return precedence(node) <= precedence(parent);\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(`Unexpected parent type: ${parent.type}`);\n      }\n    }\n\n    return {\n      UnaryExpression(node) {\n        const parent = node.parent; // Exit early if it's guaranteed not to match\n\n        if (node.operator !== \"!\" || parent.type !== \"UnaryExpression\" || parent.operator !== \"!\") {\n          return;\n        }\n\n        if (isInFlaggedContext(parent)) {\n          context.report({\n            node: parent,\n            messageId: \"unexpectedNegation\",\n\n            fix(fixer) {\n              if (hasCommentsInside(parent)) {\n                return null;\n              }\n\n              if (needsParens(parent, node.argument)) {\n                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);\n              }\n\n              let prefix = \"\";\n              const tokenBefore = sourceCode.getTokenBefore(parent);\n              const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n\n              if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                prefix = \" \";\n              }\n\n              return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n            }\n\n          });\n        }\n      },\n\n      CallExpression(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n          return;\n        }\n\n        if (isInFlaggedContext(node)) {\n          context.report({\n            node,\n            messageId: \"unexpectedCall\",\n\n            fix(fixer) {\n              const parent = node.parent;\n\n              if (node.arguments.length === 0) {\n                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n                  /*\n                   * !Boolean() -> true\n                   */\n                  if (hasCommentsInside(parent)) {\n                    return null;\n                  }\n\n                  const replacement = \"true\";\n                  let prefix = \"\";\n                  const tokenBefore = sourceCode.getTokenBefore(parent);\n\n                  if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                    prefix = \" \";\n                  }\n\n                  return fixer.replaceText(parent, prefix + replacement);\n                }\n                /*\n                 * Boolean() -> false\n                 */\n\n\n                if (hasCommentsInside(node)) {\n                  return null;\n                }\n\n                return fixer.replaceText(node, \"false\");\n              }\n\n              if (node.arguments.length === 1) {\n                const argument = node.arguments[0];\n\n                if (argument.type === \"SpreadElement\" || hasCommentsInside(node)) {\n                  return null;\n                }\n                /*\n                 * Boolean(expression) -> expression\n                 */\n\n\n                if (needsParens(node, argument)) {\n                  return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                }\n\n                return fixer.replaceText(node, sourceCode.getText(argument));\n              } // two or more arguments\n\n\n              return null;\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","eslintUtils","precedence","getPrecedence","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","enforceForLogicalOperands","default","additionalProperties","fixable","messages","unexpectedCall","unexpectedNegation","create","context","sourceCode","getSourceCode","BOOLEAN_NODE_TYPES","isBooleanFunctionOrConstructorCall","node","callee","name","isLogicalContext","operator","options","length","isInBooleanContext","parent","arguments","indexOf","test","isInFlaggedContext","hasCommentsInside","Boolean","getCommentsInside","isParenthesized","needsParens","previousNode","isMixedLogicalAndCoalesceExpressions","left","Error","UnaryExpression","report","messageId","fix","fixer","argument","replaceText","getText","prefix","tokenBefore","getTokenBefore","firstReplacementToken","getFirstToken","range","canTokensBeAdjacent","CallExpression","replacement"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-extra-boolean-cast.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"eslint-utils\");\n\nconst precedence = astUtils.getPrecedence;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary boolean casts\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForLogicalOperands: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedCall: \"Redundant Boolean call.\",\n            unexpectedNegation: \"Redundant double negation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Node types which have a test which will coerce values to booleans.\n        const BOOLEAN_NODE_TYPES = [\n            \"IfStatement\",\n            \"DoWhileStatement\",\n            \"WhileStatement\",\n            \"ConditionalExpression\",\n            \"ForStatement\"\n        ];\n\n        /**\n         * Check if a node is a Boolean function or constructor.\n         * @param {ASTNode} node the node\n         * @returns {boolean} If the node is Boolean function or constructor\n         */\n        function isBooleanFunctionOrConstructorCall(node) {\n\n            // Boolean(<bool>) and new Boolean(<bool>)\n            return (node.type === \"CallExpression\" || node.type === \"NewExpression\") &&\n                    node.callee.type === \"Identifier\" &&\n                        node.callee.name === \"Boolean\";\n        }\n\n        /**\n         * Checks whether the node is a logical expression and that the option is enabled\n         * @param {ASTNode} node the node\n         * @returns {boolean} if the node is a logical expression and option is enabled\n         */\n        function isLogicalContext(node) {\n            return node.type === \"LogicalExpression\" &&\n            (node.operator === \"||\" || node.operator === \"&&\") &&\n            (context.options.length && context.options[0].enforceForLogicalOperands === true);\n\n        }\n\n\n        /**\n         * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n         * @param {ASTNode} node The node\n         * @returns {boolean} If it is in a boolean context\n         */\n        function isInBooleanContext(node) {\n            return (\n                (isBooleanFunctionOrConstructorCall(node.parent) &&\n                node === node.parent.arguments[0]) ||\n\n                (BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 &&\n                    node === node.parent.test) ||\n\n                // !<bool>\n                (node.parent.type === \"UnaryExpression\" &&\n                    node.parent.operator === \"!\")\n            );\n        }\n\n        /**\n         * Checks whether the node is a context that should report an error\n         * Acts recursively if it is in a logical context\n         * @param {ASTNode} node the node\n         * @returns {boolean} If the node is in one of the flagged contexts\n         */\n        function isInFlaggedContext(node) {\n            if (node.parent.type === \"ChainExpression\") {\n                return isInFlaggedContext(node.parent);\n            }\n\n            return isInBooleanContext(node) ||\n            (isLogicalContext(node.parent) &&\n\n            // For nested logical statements\n            isInFlaggedContext(node.parent)\n            );\n        }\n\n\n        /**\n         * Check if a node has comments inside.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if it has comments inside.\n         */\n        function hasCommentsInside(node) {\n            return Boolean(sourceCode.getCommentsInside(node).length);\n        }\n\n        /**\n         * Checks if the given node is wrapped in grouping parentheses. Parentheses for constructs such as if() don't count.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is parenthesized.\n         * @private\n         */\n        function isParenthesized(node) {\n            return eslintUtils.isParenthesized(1, node, sourceCode);\n        }\n\n        /**\n         * Determines whether the given node needs to be parenthesized when replacing the previous node.\n         * It assumes that `previousNode` is the node to be reported by this rule, so it has a limited list\n         * of possible parent node types. By the same assumption, the node's role in a particular parent is already known.\n         * For example, if the parent is `ConditionalExpression`, `previousNode` must be its `test` child.\n         * @param {ASTNode} previousNode Previous node.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node needs to be parenthesized.\n         */\n        function needsParens(previousNode, node) {\n            if (previousNode.parent.type === \"ChainExpression\") {\n                return needsParens(previousNode.parent, node);\n            }\n            if (isParenthesized(previousNode)) {\n\n                // parentheses around the previous node will stay, so there is no need for an additional pair\n                return false;\n            }\n\n            // parent of the previous node will become parent of the replacement node\n            const parent = previousNode.parent;\n\n            switch (parent.type) {\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return node.type === \"SequenceExpression\";\n                case \"IfStatement\":\n                case \"DoWhileStatement\":\n                case \"WhileStatement\":\n                case \"ForStatement\":\n                    return false;\n                case \"ConditionalExpression\":\n                    return precedence(node) <= precedence(parent);\n                case \"UnaryExpression\":\n                    return precedence(node) < precedence(parent);\n                case \"LogicalExpression\":\n                    if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {\n                        return true;\n                    }\n                    if (previousNode === parent.left) {\n                        return precedence(node) < precedence(parent);\n                    }\n                    return precedence(node) <= precedence(parent);\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(`Unexpected parent type: ${parent.type}`);\n            }\n        }\n\n        return {\n            UnaryExpression(node) {\n                const parent = node.parent;\n\n\n                // Exit early if it's guaranteed not to match\n                if (node.operator !== \"!\" ||\n                          parent.type !== \"UnaryExpression\" ||\n                          parent.operator !== \"!\") {\n                    return;\n                }\n\n\n                if (isInFlaggedContext(parent)) {\n                    context.report({\n                        node: parent,\n                        messageId: \"unexpectedNegation\",\n                        fix(fixer) {\n                            if (hasCommentsInside(parent)) {\n                                return null;\n                            }\n\n                            if (needsParens(parent, node.argument)) {\n                                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);\n                            }\n\n                            let prefix = \"\";\n                            const tokenBefore = sourceCode.getTokenBefore(parent);\n                            const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === parent.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\n                            ) {\n                                prefix = \" \";\n                            }\n\n                            return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n                        }\n                    });\n                }\n            },\n\n            CallExpression(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n                    return;\n                }\n\n                if (isInFlaggedContext(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedCall\",\n                        fix(fixer) {\n                            const parent = node.parent;\n\n                            if (node.arguments.length === 0) {\n                                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n\n                                    /*\n                                     * !Boolean() -> true\n                                     */\n\n                                    if (hasCommentsInside(parent)) {\n                                        return null;\n                                    }\n\n                                    const replacement = \"true\";\n                                    let prefix = \"\";\n                                    const tokenBefore = sourceCode.getTokenBefore(parent);\n\n                                    if (\n                                        tokenBefore &&\n                                        tokenBefore.range[1] === parent.range[0] &&\n                                        !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\n                                    ) {\n                                        prefix = \" \";\n                                    }\n\n                                    return fixer.replaceText(parent, prefix + replacement);\n                                }\n\n                                /*\n                                 * Boolean() -> false\n                                 */\n\n                                if (hasCommentsInside(node)) {\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, \"false\");\n                            }\n\n                            if (node.arguments.length === 1) {\n                                const argument = node.arguments[0];\n\n                                if (argument.type === \"SpreadElement\" || hasCommentsInside(node)) {\n                                    return null;\n                                }\n\n                                /*\n                                 * Boolean(expression) -> expression\n                                 */\n\n                                if (needsParens(node, argument)) {\n                                    return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                                }\n\n                                return fixer.replaceText(node, sourceCode.getText(argument));\n                            }\n\n                            // two or more arguments\n                            return null;\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}