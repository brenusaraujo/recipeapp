{"ast":null,"code":"/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Computes the union of one or more arrays\n * @param {...any[]} arrays One or more arrays to union\n * @returns {any[]} The union of the input arrays\n */\n\n\nfunction union() {\n  // TODO(stephenwade): Replace this with arrays.flat() when we drop support for Node v10\n  return [...new Set([].concat(...arguments))];\n}\n/**\n * Computes the intersection of one or more arrays\n * @param {...any[]} arrays One or more arrays to intersect\n * @returns {any[]} The intersection of the input arrays\n */\n\n\nfunction intersection() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  let result = [...new Set(arrays[0])];\n\n  for (const array of arrays.slice(1)) {\n    result = result.filter(x => array.includes(x));\n  }\n\n  return result;\n}\n/**\n * Gets the possible types of a selector\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n */\n\n\nfunction getPossibleTypes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"identifier\":\n      return [parsedSelector.value];\n\n    case \"matches\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n        if (typesForComponents.every(Boolean)) {\n          return union(...typesForComponents);\n        }\n\n        return null;\n      }\n\n    case \"compound\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent); // If all of the components could match any type, then the compound could also match any type.\n\n        if (!typesForComponents.length) {\n          return null;\n        }\n        /*\n         * If at least one of the components could only match a particular type, the compound could only match\n         * the intersection of those types.\n         */\n\n\n        return intersection(...typesForComponents);\n      }\n\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return getPossibleTypes(parsedSelector.right);\n\n    default:\n      return null;\n  }\n}\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\n\n\nfunction countClassAttributes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n    case \"attribute\":\n    case \"field\":\n    case \"nth-child\":\n    case \"nth-last-child\":\n      return 1;\n\n    default:\n      return 0;\n  }\n}\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\n\n\nfunction countIdentifiers(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n    case \"identifier\":\n      return 1;\n\n    default:\n      return 0;\n  }\n}\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\n\n\nfunction compareSpecificity(selectorA, selectorB) {\n  return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\n\n\nfunction tryParseSelector(rawSelector) {\n  try {\n    return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\n  } catch (err) {\n    if (err.location && err.location.start && typeof err.location.start.offset === \"number\") {\n      throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.location.start.offset}: ${err.message}`);\n    }\n\n    throw err;\n  }\n}\n\nconst selectorCache = new Map();\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\n\nfunction parseSelector(rawSelector) {\n  if (selectorCache.has(rawSelector)) {\n    return selectorCache.get(rawSelector);\n  }\n\n  const parsedSelector = tryParseSelector(rawSelector);\n  const result = {\n    rawSelector,\n    isExit: rawSelector.endsWith(\":exit\"),\n    parsedSelector,\n    listenerTypes: getPossibleTypes(parsedSelector),\n    attributeCount: countClassAttributes(parsedSelector),\n    identifierCount: countIdentifiers(parsedSelector)\n  };\n  selectorCache.set(rawSelector, result);\n  return result;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: SafeEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\n\n\nclass NodeEventGenerator {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {SafeEmitter} emitter\n   * An SafeEmitter which is the destination of events. This emitter must already\n   * have registered listeners for all of the events that it needs to listen for.\n   * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)\n   * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.\n   * @returns {NodeEventGenerator} new instance\n   */\n  constructor(emitter, esqueryOptions) {\n    this.emitter = emitter;\n    this.esqueryOptions = esqueryOptions;\n    this.currentAncestry = [];\n    this.enterSelectorsByNodeType = new Map();\n    this.exitSelectorsByNodeType = new Map();\n    this.anyTypeEnterSelectors = [];\n    this.anyTypeExitSelectors = [];\n    emitter.eventNames().forEach(rawSelector => {\n      const selector = parseSelector(rawSelector);\n\n      if (selector.listenerTypes) {\n        const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n        selector.listenerTypes.forEach(nodeType => {\n          if (!typeMap.has(nodeType)) {\n            typeMap.set(nodeType, []);\n          }\n\n          typeMap.get(nodeType).push(selector);\n        });\n        return;\n      }\n\n      const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n      selectors.push(selector);\n    });\n    this.anyTypeEnterSelectors.sort(compareSpecificity);\n    this.anyTypeExitSelectors.sort(compareSpecificity);\n    this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n  }\n  /**\n   * Checks a selector against a node, and emits it if it matches\n   * @param {ASTNode} node The node to check\n   * @param {ASTSelector} selector An AST selector descriptor\n   * @returns {void}\n   */\n\n\n  applySelector(node, selector) {\n    if (esquery.matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {\n      this.emitter.emit(selector.rawSelector, node);\n    }\n  }\n  /**\n   * Applies all appropriate selectors to a node, in specificity order\n   * @param {ASTNode} node The node to check\n   * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n   * @returns {void}\n   */\n\n\n  applySelectors(node, isExit) {\n    const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n    const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n    /*\n     * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n     * Iterate through each of them, applying selectors in the right order.\n     */\n\n    let selectorsByTypeIndex = 0;\n    let anyTypeSelectorsIndex = 0;\n\n    while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n      if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {\n        this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n      } else {\n        this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n      }\n    }\n  }\n  /**\n   * Emits an event of entering AST node.\n   * @param {ASTNode} node A node which was entered.\n   * @returns {void}\n   */\n\n\n  enterNode(node) {\n    if (node.parent) {\n      this.currentAncestry.unshift(node.parent);\n    }\n\n    this.applySelectors(node, false);\n  }\n  /**\n   * Emits an event of leaving AST node.\n   * @param {ASTNode} node A node which was left.\n   * @returns {void}\n   */\n\n\n  leaveNode(node) {\n    this.applySelectors(node, true);\n    this.currentAncestry.shift();\n  }\n\n}\n\nmodule.exports = NodeEventGenerator;","map":{"version":3,"names":["esquery","require","union","Set","concat","intersection","arrays","length","result","array","slice","filter","x","includes","getPossibleTypes","parsedSelector","type","value","typesForComponents","selectors","map","every","Boolean","typesForComponent","right","countClassAttributes","left","reduce","sum","childSelector","countIdentifiers","compareSpecificity","selectorA","selectorB","attributeCount","identifierCount","rawSelector","tryParseSelector","parse","replace","err","location","start","offset","SyntaxError","message","selectorCache","Map","parseSelector","has","get","isExit","endsWith","listenerTypes","set","NodeEventGenerator","constructor","emitter","esqueryOptions","currentAncestry","enterSelectorsByNodeType","exitSelectorsByNodeType","anyTypeEnterSelectors","anyTypeExitSelectors","eventNames","forEach","selector","typeMap","nodeType","push","sort","selectorList","applySelector","node","matches","emit","applySelectors","selectorsByNodeType","anyTypeSelectors","selectorsByTypeIndex","anyTypeSelectorsIndex","enterNode","parent","unshift","leaveNode","shift","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/node-event-generator.js"],"sourcesContent":["/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Computes the union of one or more arrays\n * @param {...any[]} arrays One or more arrays to union\n * @returns {any[]} The union of the input arrays\n */\nfunction union(...arrays) {\n\n    // TODO(stephenwade): Replace this with arrays.flat() when we drop support for Node v10\n    return [...new Set([].concat(...arrays))];\n}\n\n/**\n * Computes the intersection of one or more arrays\n * @param {...any[]} arrays One or more arrays to intersect\n * @returns {any[]} The intersection of the input arrays\n */\nfunction intersection(...arrays) {\n    if (arrays.length === 0) {\n        return [];\n    }\n\n    let result = [...new Set(arrays[0])];\n\n    for (const array of arrays.slice(1)) {\n        result = result.filter(x => array.includes(x));\n    }\n    return result;\n}\n\n/**\n * Gets the possible types of a selector\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n */\nfunction getPossibleTypes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"identifier\":\n            return [parsedSelector.value];\n\n        case \"matches\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n            if (typesForComponents.every(Boolean)) {\n                return union(...typesForComponents);\n            }\n            return null;\n        }\n\n        case \"compound\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\n\n            // If all of the components could match any type, then the compound could also match any type.\n            if (!typesForComponents.length) {\n                return null;\n            }\n\n            /*\n             * If at least one of the components could only match a particular type, the compound could only match\n             * the intersection of those types.\n             */\n            return intersection(...typesForComponents);\n        }\n\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return getPossibleTypes(parsedSelector.right);\n\n        default:\n            return null;\n\n    }\n}\n\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\nfunction countClassAttributes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n        case \"attribute\":\n        case \"field\":\n        case \"nth-child\":\n        case \"nth-last-child\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\nfunction countIdentifiers(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n        case \"identifier\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\nfunction compareSpecificity(selectorA, selectorB) {\n    return selectorA.attributeCount - selectorB.attributeCount ||\n        selectorA.identifierCount - selectorB.identifierCount ||\n        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\nfunction tryParseSelector(rawSelector) {\n    try {\n        return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\n    } catch (err) {\n        if (err.location && err.location.start && typeof err.location.start.offset === \"number\") {\n            throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.location.start.offset}: ${err.message}`);\n        }\n        throw err;\n    }\n}\n\nconst selectorCache = new Map();\n\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\nfunction parseSelector(rawSelector) {\n    if (selectorCache.has(rawSelector)) {\n        return selectorCache.get(rawSelector);\n    }\n\n    const parsedSelector = tryParseSelector(rawSelector);\n\n    const result = {\n        rawSelector,\n        isExit: rawSelector.endsWith(\":exit\"),\n        parsedSelector,\n        listenerTypes: getPossibleTypes(parsedSelector),\n        attributeCount: countClassAttributes(parsedSelector),\n        identifierCount: countIdentifiers(parsedSelector)\n    };\n\n    selectorCache.set(rawSelector, result);\n    return result;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: SafeEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\nclass NodeEventGenerator {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {SafeEmitter} emitter\n     * An SafeEmitter which is the destination of events. This emitter must already\n     * have registered listeners for all of the events that it needs to listen for.\n     * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)\n     * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.\n     * @returns {NodeEventGenerator} new instance\n     */\n    constructor(emitter, esqueryOptions) {\n        this.emitter = emitter;\n        this.esqueryOptions = esqueryOptions;\n        this.currentAncestry = [];\n        this.enterSelectorsByNodeType = new Map();\n        this.exitSelectorsByNodeType = new Map();\n        this.anyTypeEnterSelectors = [];\n        this.anyTypeExitSelectors = [];\n\n        emitter.eventNames().forEach(rawSelector => {\n            const selector = parseSelector(rawSelector);\n\n            if (selector.listenerTypes) {\n                const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n\n                selector.listenerTypes.forEach(nodeType => {\n                    if (!typeMap.has(nodeType)) {\n                        typeMap.set(nodeType, []);\n                    }\n                    typeMap.get(nodeType).push(selector);\n                });\n                return;\n            }\n            const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n            selectors.push(selector);\n        });\n\n        this.anyTypeEnterSelectors.sort(compareSpecificity);\n        this.anyTypeExitSelectors.sort(compareSpecificity);\n        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    }\n\n    /**\n     * Checks a selector against a node, and emits it if it matches\n     * @param {ASTNode} node The node to check\n     * @param {ASTSelector} selector An AST selector descriptor\n     * @returns {void}\n     */\n    applySelector(node, selector) {\n        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {\n            this.emitter.emit(selector.rawSelector, node);\n        }\n    }\n\n    /**\n     * Applies all appropriate selectors to a node, in specificity order\n     * @param {ASTNode} node The node to check\n     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n     * @returns {void}\n     */\n    applySelectors(node, isExit) {\n        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n        /*\n         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n         * Iterate through each of them, applying selectors in the right order.\n         */\n        let selectorsByTypeIndex = 0;\n        let anyTypeSelectorsIndex = 0;\n\n        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n            if (\n                selectorsByTypeIndex >= selectorsByNodeType.length ||\n                anyTypeSelectorsIndex < anyTypeSelectors.length &&\n                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0\n            ) {\n                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n            } else {\n                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n            }\n        }\n    }\n\n    /**\n     * Emits an event of entering AST node.\n     * @param {ASTNode} node A node which was entered.\n     * @returns {void}\n     */\n    enterNode(node) {\n        if (node.parent) {\n            this.currentAncestry.unshift(node.parent);\n        }\n        this.applySelectors(node, false);\n    }\n\n    /**\n     * Emits an event of leaving AST node.\n     * @param {ASTNode} node A node which was left.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.applySelectors(node, true);\n        this.currentAncestry.shift();\n    }\n}\n\nmodule.exports = NodeEventGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}