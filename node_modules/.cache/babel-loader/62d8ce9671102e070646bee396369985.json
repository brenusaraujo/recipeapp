{"ast":null,"code":"/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {string} Id of the segment.\n */\n\n/* istanbul ignore next */\n\n\nfunction getId(segment) {\n  // eslint-disable-line jsdoc/require-jsdoc\n  return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n/**\n * Get string for the given node and operation.\n * @param {ASTNode} node The node to convert.\n * @param {\"enter\" | \"exit\" | undefined} label The operation label.\n * @returns {string} The string representation.\n */\n\n\nfunction nodeToString(node, label) {\n  const suffix = label ? `:${label}` : \"\";\n\n  switch (node.type) {\n    case \"Identifier\":\n      return `${node.type}${suffix} (${node.name})`;\n\n    case \"Literal\":\n      return `${node.type}${suffix} (${node.value})`;\n\n    default:\n      return `${node.type}${suffix}`;\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  /**\n   * A flag that debug dumping is enabled or not.\n   * @type {boolean}\n   */\n  enabled: debug.enabled,\n\n  /**\n   * Dumps given objects.\n   * @param {...any} args objects to dump.\n   * @returns {void}\n   */\n  dump: debug,\n\n  /**\n   * Dumps the current analyzing state.\n   * @param {ASTNode} node A node to dump.\n   * @param {CodePathState} state A state to dump.\n   * @param {boolean} leaving A flag whether or not it's leaving\n   * @returns {void}\n   */\n  dumpState: !debug.enabled ? debug :\n  /* istanbul ignore next */\n  function (node, state, leaving) {\n    for (let i = 0; i < state.currentSegments.length; ++i) {\n      const segInternal = state.currentSegments[i].internal;\n\n      if (leaving) {\n        const last = segInternal.nodes.length - 1;\n\n        if (last >= 0 && segInternal.nodes[last] === nodeToString(node, \"enter\")) {\n          segInternal.nodes[last] = nodeToString(node, void 0);\n        } else {\n          segInternal.nodes.push(nodeToString(node, \"exit\"));\n        }\n      } else {\n        segInternal.nodes.push(nodeToString(node, \"enter\"));\n      }\n    }\n\n    debug([`${state.currentSegments.map(getId).join(\",\")})`, `${node.type}${leaving ? \":exit\" : \"\"}`].join(\" \"));\n  },\n\n  /**\n   * Dumps a DOT code of a given code path.\n   * The DOT code can be visualized with Graphvis.\n   * @param {CodePath} codePath A code path to dump.\n   * @returns {void}\n   * @see http://www.graphviz.org\n   * @see http://www.webgraphviz.com\n   */\n  dumpDot: !debug.enabled ? debug :\n  /* istanbul ignore next */\n  function (codePath) {\n    let text = \"\\n\" + \"digraph {\\n\" + \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" + \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n    if (codePath.returnedSegments.length > 0) {\n      text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n    }\n\n    if (codePath.thrownSegments.length > 0) {\n      text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n    }\n\n    const traceMap = Object.create(null);\n    const arrows = this.makeDotArrows(codePath, traceMap);\n\n    for (const id in traceMap) {\n      // eslint-disable-line guard-for-in\n      const segment = traceMap[id];\n      text += `${id}[`;\n\n      if (segment.reachable) {\n        text += \"label=\\\"\";\n      } else {\n        text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n      }\n\n      if (segment.internal.nodes.length > 0) {\n        text += segment.internal.nodes.join(\"\\\\n\");\n      } else {\n        text += \"????\";\n      }\n\n      text += \"\\\"];\\n\";\n    }\n\n    text += `${arrows}\\n`;\n    text += \"}\";\n    debug(\"DOT\", text);\n  },\n\n  /**\n   * Makes a DOT code of a given code path.\n   * The DOT code can be visualized with Graphvis.\n   * @param {CodePath} codePath A code path to make DOT.\n   * @param {Object} traceMap Optional. A map to check whether or not segments had been done.\n   * @returns {string} A DOT code of the code path.\n   */\n  makeDotArrows(codePath, traceMap) {\n    const stack = [[codePath.initialSegment, 0]];\n    const done = traceMap || Object.create(null);\n    let lastId = codePath.initialSegment.id;\n    let text = `initial->${codePath.initialSegment.id}`;\n\n    while (stack.length > 0) {\n      const item = stack.pop();\n      const segment = item[0];\n      const index = item[1];\n\n      if (done[segment.id] && index === 0) {\n        continue;\n      }\n\n      done[segment.id] = segment;\n      const nextSegment = segment.allNextSegments[index];\n\n      if (!nextSegment) {\n        continue;\n      }\n\n      if (lastId === segment.id) {\n        text += `->${nextSegment.id}`;\n      } else {\n        text += `;\\n${segment.id}->${nextSegment.id}`;\n      }\n\n      lastId = nextSegment.id;\n      stack.unshift([segment, 1 + index]);\n      stack.push([nextSegment, 0]);\n    }\n\n    codePath.returnedSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->final\";\n      } else {\n        text += `;\\n${finalSegment.id}->final`;\n      }\n\n      lastId = null;\n    });\n    codePath.thrownSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->thrown\";\n      } else {\n        text += `;\\n${finalSegment.id}->thrown`;\n      }\n\n      lastId = null;\n    });\n    return `${text};`;\n  }\n\n};","map":{"version":3,"names":["debug","require","getId","segment","id","reachable","nodeToString","node","label","suffix","type","name","value","module","exports","enabled","dump","dumpState","state","leaving","i","currentSegments","length","segInternal","internal","last","nodes","push","map","join","dumpDot","codePath","text","returnedSegments","thrownSegments","traceMap","Object","create","arrows","makeDotArrows","stack","initialSegment","done","lastId","item","pop","index","nextSegment","allNextSegments","unshift","forEach","finalSegment"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/code-path-analysis/debug-helpers.js"],"sourcesContent":["/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {string} Id of the segment.\n */\n/* istanbul ignore next */\nfunction getId(segment) { // eslint-disable-line jsdoc/require-jsdoc\n    return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n\n/**\n * Get string for the given node and operation.\n * @param {ASTNode} node The node to convert.\n * @param {\"enter\" | \"exit\" | undefined} label The operation label.\n * @returns {string} The string representation.\n */\nfunction nodeToString(node, label) {\n    const suffix = label ? `:${label}` : \"\";\n\n    switch (node.type) {\n        case \"Identifier\": return `${node.type}${suffix} (${node.name})`;\n        case \"Literal\": return `${node.type}${suffix} (${node.value})`;\n        default: return `${node.type}${suffix}`;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * A flag that debug dumping is enabled or not.\n     * @type {boolean}\n     */\n    enabled: debug.enabled,\n\n    /**\n     * Dumps given objects.\n     * @param {...any} args objects to dump.\n     * @returns {void}\n     */\n    dump: debug,\n\n    /**\n     * Dumps the current analyzing state.\n     * @param {ASTNode} node A node to dump.\n     * @param {CodePathState} state A state to dump.\n     * @param {boolean} leaving A flag whether or not it's leaving\n     * @returns {void}\n     */\n    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {\n        for (let i = 0; i < state.currentSegments.length; ++i) {\n            const segInternal = state.currentSegments[i].internal;\n\n            if (leaving) {\n                const last = segInternal.nodes.length - 1;\n\n                if (last >= 0 && segInternal.nodes[last] === nodeToString(node, \"enter\")) {\n                    segInternal.nodes[last] = nodeToString(node, void 0);\n                } else {\n                    segInternal.nodes.push(nodeToString(node, \"exit\"));\n                }\n            } else {\n                segInternal.nodes.push(nodeToString(node, \"enter\"));\n            }\n        }\n\n        debug([\n            `${state.currentSegments.map(getId).join(\",\")})`,\n            `${node.type}${leaving ? \":exit\" : \"\"}`\n        ].join(\" \"));\n    },\n\n    /**\n     * Dumps a DOT code of a given code path.\n     * The DOT code can be visualized with Graphvis.\n     * @param {CodePath} codePath A code path to dump.\n     * @returns {void}\n     * @see http://www.graphviz.org\n     * @see http://www.webgraphviz.com\n     */\n    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {\n        let text =\n            \"\\n\" +\n            \"digraph {\\n\" +\n            \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" +\n            \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n        if (codePath.returnedSegments.length > 0) {\n            text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n        }\n        if (codePath.thrownSegments.length > 0) {\n            text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n        }\n\n        const traceMap = Object.create(null);\n        const arrows = this.makeDotArrows(codePath, traceMap);\n\n        for (const id in traceMap) { // eslint-disable-line guard-for-in\n            const segment = traceMap[id];\n\n            text += `${id}[`;\n\n            if (segment.reachable) {\n                text += \"label=\\\"\";\n            } else {\n                text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n            }\n\n            if (segment.internal.nodes.length > 0) {\n                text += segment.internal.nodes.join(\"\\\\n\");\n            } else {\n                text += \"????\";\n            }\n\n            text += \"\\\"];\\n\";\n        }\n\n        text += `${arrows}\\n`;\n        text += \"}\";\n        debug(\"DOT\", text);\n    },\n\n    /**\n     * Makes a DOT code of a given code path.\n     * The DOT code can be visualized with Graphvis.\n     * @param {CodePath} codePath A code path to make DOT.\n     * @param {Object} traceMap Optional. A map to check whether or not segments had been done.\n     * @returns {string} A DOT code of the code path.\n     */\n    makeDotArrows(codePath, traceMap) {\n        const stack = [[codePath.initialSegment, 0]];\n        const done = traceMap || Object.create(null);\n        let lastId = codePath.initialSegment.id;\n        let text = `initial->${codePath.initialSegment.id}`;\n\n        while (stack.length > 0) {\n            const item = stack.pop();\n            const segment = item[0];\n            const index = item[1];\n\n            if (done[segment.id] && index === 0) {\n                continue;\n            }\n            done[segment.id] = segment;\n\n            const nextSegment = segment.allNextSegments[index];\n\n            if (!nextSegment) {\n                continue;\n            }\n\n            if (lastId === segment.id) {\n                text += `->${nextSegment.id}`;\n            } else {\n                text += `;\\n${segment.id}->${nextSegment.id}`;\n            }\n            lastId = nextSegment.id;\n\n            stack.unshift([segment, 1 + index]);\n            stack.push([nextSegment, 0]);\n        }\n\n        codePath.returnedSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->final\";\n            } else {\n                text += `;\\n${finalSegment.id}->final`;\n            }\n            lastId = null;\n        });\n\n        codePath.thrownSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->thrown\";\n            } else {\n                text += `;\\n${finalSegment.id}->thrown`;\n            }\n            lastId = null;\n        });\n\n        return `${text};`;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}