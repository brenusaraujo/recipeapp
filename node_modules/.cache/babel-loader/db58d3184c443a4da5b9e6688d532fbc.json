{"ast":null,"code":"/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst FixTracker = require(\"./utils/fix-tracker\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `else` blocks after `return` statements in `if` statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-else-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowElseIf: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Unnecessary 'else' after 'return'.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks whether the given names can be safely used to declare block-scoped variables\n     * in the given scope. Name collisions can produce redeclaration syntax errors,\n     * or silently change references and modify behavior of the original code.\n     *\n     * This is not a generic function. In particular, it is assumed that the scope is a function scope or\n     * a function's inner scope, and that the names can be valid identifiers in the given scope.\n     * @param {string[]} names Array of variable names.\n     * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\n     * @returns {boolean} True if all names can be safely declared, false otherwise.\n     */\n    function isSafeToDeclare(names, scope) {\n      if (names.length === 0) {\n        return true;\n      }\n\n      const functionScope = scope.variableScope;\n      /*\n       * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\n       * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\n       * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\n       *\n       * Redeclaring any of these would cause a syntax error, except for the implicit variables.\n       */\n\n      const declaredVariables = scope.variables.filter(_ref => {\n        let {\n          defs\n        } = _ref;\n        return defs.length > 0;\n      });\n\n      if (declaredVariables.some(_ref2 => {\n        let {\n          name\n        } = _ref2;\n        return names.includes(name);\n      })) {\n        return false;\n      } // Redeclaring a catch variable would also cause a syntax error.\n\n\n      if (scope !== functionScope && scope.upper.type === \"catch\") {\n        if (scope.upper.variables.some(_ref3 => {\n          let {\n            name\n          } = _ref3;\n          return names.includes(name);\n        })) {\n          return false;\n        }\n      }\n      /*\n       * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\n       * However, if the variable was used, declaring a new one with the same name would change references\n       * and modify behavior.\n       */\n\n\n      const usedImplicitVariables = scope.variables.filter(_ref4 => {\n        let {\n          defs,\n          references\n        } = _ref4;\n        return defs.length === 0 && references.length > 0;\n      });\n\n      if (usedImplicitVariables.some(_ref5 => {\n        let {\n          name\n        } = _ref5;\n        return names.includes(name);\n      })) {\n        return false;\n      }\n      /*\n       * Declaring a variable with a name that was already used to reference a variable from an upper scope\n       * would change references and modify behavior.\n       */\n\n\n      if (scope.through.some(t => names.includes(t.identifier.name))) {\n        return false;\n      }\n      /*\n       * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\n       * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\n       *\n       * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\n       * function foo() { if (bar) { let a; if (baz) { var a; } } }\n       */\n\n\n      if (scope !== functionScope) {\n        const scopeNodeRange = scope.block.range;\n        const variablesToCheck = functionScope.variables.filter(_ref6 => {\n          let {\n            name\n          } = _ref6;\n          return names.includes(name);\n        });\n\n        if (variablesToCheck.some(v => v.defs.some(_ref7 => {\n          let {\n            node: {\n              range\n            }\n          } = _ref7;\n          return scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1];\n        }))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Checks whether the removal of `else` and its braces is safe from variable name collisions.\n     * @param {Node} node The 'else' node.\n     * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\n     * @returns {boolean} True if it is safe, false otherwise.\n     */\n\n\n    function isSafeFromNameCollisions(node, scope) {\n      if (node.type === \"FunctionDeclaration\") {\n        // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\n        return false;\n      }\n\n      if (node.type !== \"BlockStatement\") {\n        return true;\n      }\n\n      const elseBlockScope = scope.childScopes.find(_ref8 => {\n        let {\n          block\n        } = _ref8;\n        return block === node;\n      });\n\n      if (!elseBlockScope) {\n        // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\n        return true;\n      }\n      /*\n       * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\n       * only block-scoped variables (such as let and const variables or class and function declarations)\n       * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\n       */\n\n\n      const namesToCheck = elseBlockScope.variables.map(_ref9 => {\n        let {\n          name\n        } = _ref9;\n        return name;\n      });\n      return isSafeToDeclare(namesToCheck, scope);\n    }\n    /**\n     * Display the context report if rule is violated\n     * @param {Node} node The 'else' node\n     * @returns {void}\n     */\n\n\n    function displayReport(node) {\n      const currentScope = context.getScope();\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        fix: fixer => {\n          if (!isSafeFromNameCollisions(node, currentScope)) {\n            return null;\n          }\n\n          const sourceCode = context.getSourceCode();\n          const startToken = sourceCode.getFirstToken(node);\n          const elseToken = sourceCode.getTokenBefore(startToken);\n          const source = sourceCode.getText(node);\n          const lastIfToken = sourceCode.getTokenBefore(elseToken);\n          let fixedSource, firstTokenOfElseBlock;\n\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n          } else {\n            firstTokenOfElseBlock = startToken;\n          }\n          /*\n           * If the if block does not have curly braces and does not end in a semicolon\n           * and the else block starts with (, [, /, +, ` or -, then it is not\n           * safe to remove the else keyword, because ASI will not add a semicolon\n           * after the if block\n           */\n\n\n          const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n          const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n          if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n            return null;\n          }\n\n          const endToken = sourceCode.getLastToken(node);\n          const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n          if (lastTokenOfElseBlock.value !== \";\") {\n            const nextToken = sourceCode.getTokenAfter(endToken);\n            const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n            const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n            /*\n             * If the else block contents does not end in a semicolon,\n             * and the else block starts with (, [, /, +, ` or -, then it is not\n             * safe to remove the else block, because ASI will not add a semicolon\n             * after the remaining else block contents\n             */\n\n            if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== \"}\") {\n              return null;\n            }\n          }\n\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            fixedSource = source.slice(1, -1);\n          } else {\n            fixedSource = source;\n          }\n          /*\n           * Extend the replacement range to include the entire\n           * function to avoid conflicting with no-useless-return.\n           * https://github.com/eslint/eslint/issues/8026\n           *\n           * Also, to avoid name collisions between two else blocks.\n           */\n\n\n          return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n        }\n      });\n    }\n    /**\n     * Check to see if the node is a ReturnStatement\n     * @param {Node} node The node being evaluated\n     * @returns {boolean} True if node is a return\n     */\n\n\n    function checkForReturn(node) {\n      return node.type === \"ReturnStatement\";\n    }\n    /**\n     * Naive return checking, does not iterate through the whole\n     * BlockStatement because we make the assumption that the ReturnStatement\n     * will be the last node in the body of the BlockStatement.\n     * @param {Node} node The consequent/alternate node\n     * @returns {boolean} True if it has a return\n     */\n\n\n    function naiveHasReturn(node) {\n      if (node.type === \"BlockStatement\") {\n        const body = node.body,\n              lastChildNode = body[body.length - 1];\n        return lastChildNode && checkForReturn(lastChildNode);\n      }\n\n      return checkForReturn(node);\n    }\n    /**\n     * Check to see if the node is valid for evaluation,\n     * meaning it has an else.\n     * @param {Node} node The node being evaluated\n     * @returns {boolean} True if the node is valid\n     */\n\n\n    function hasElse(node) {\n      return node.alternate && node.consequent;\n    }\n    /**\n     * If the consequent is an IfStatement, check to see if it has an else\n     * and both its consequent and alternate path return, meaning this is\n     * a nested case of rule violation.  If-Else not considered currently.\n     * @param {Node} node The consequent node\n     * @returns {boolean} True if this is a nested rule violation\n     */\n\n\n    function checkForIf(node) {\n      return node.type === \"IfStatement\" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n    }\n    /**\n     * Check the consequent/body node to make sure it is not\n     * a ReturnStatement or an IfStatement that returns on both\n     * code paths.\n     * @param {Node} node The consequent or body node\n     * @returns {boolean} `true` if it is a Return/If node that always returns.\n     */\n\n\n    function checkForReturnOrIf(node) {\n      return checkForReturn(node) || checkForIf(node);\n    }\n    /**\n     * Check whether a node returns in every codepath.\n     * @param {Node} node The node to be checked\n     * @returns {boolean} `true` if it returns on every codepath.\n     */\n\n\n    function alwaysReturns(node) {\n      if (node.type === \"BlockStatement\") {\n        // If we have a BlockStatement, check each consequent body node.\n        return node.body.some(checkForReturnOrIf);\n      }\n      /*\n       * If not a block statement, make sure the consequent isn't a\n       * ReturnStatement or an IfStatement with returns on both paths.\n       */\n\n\n      return checkForReturnOrIf(node);\n    }\n    /**\n     * Check the if statement, but don't catch else-if blocks.\n     * @returns {void}\n     * @param {Node} node The node for the if statement to check\n     * @private\n     */\n\n\n    function checkIfWithoutElse(node) {\n      const parent = node.parent;\n      /*\n       * Fixing this would require splitting one statement into two, so no error should\n       * be reported if this node is in a position where only one statement is allowed.\n       */\n\n      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n        return;\n      }\n\n      const consequents = [];\n      let alternate;\n\n      for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n        if (!currentNode.alternate) {\n          return;\n        }\n\n        consequents.push(currentNode.consequent);\n        alternate = currentNode.alternate;\n      }\n\n      if (consequents.every(alwaysReturns)) {\n        displayReport(alternate);\n      }\n    }\n    /**\n     * Check the if statement\n     * @returns {void}\n     * @param {Node} node The node for the if statement to check\n     * @private\n     */\n\n\n    function checkIfWithElse(node) {\n      const parent = node.parent;\n      /*\n       * Fixing this would require splitting one statement into two, so no error should\n       * be reported if this node is in a position where only one statement is allowed.\n       */\n\n      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n        return;\n      }\n\n      const alternate = node.alternate;\n\n      if (alternate && alwaysReturns(node.consequent)) {\n        displayReport(alternate);\n      }\n    }\n\n    const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false); //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","FixTracker","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowElseIf","default","additionalProperties","fixable","messages","unexpected","create","context","isSafeToDeclare","names","scope","length","functionScope","variableScope","declaredVariables","variables","filter","defs","some","name","includes","upper","usedImplicitVariables","references","through","t","identifier","scopeNodeRange","block","range","variablesToCheck","v","node","isSafeFromNameCollisions","elseBlockScope","childScopes","find","namesToCheck","map","displayReport","currentScope","getScope","report","messageId","fix","fixer","sourceCode","getSourceCode","startToken","getFirstToken","elseToken","getTokenBefore","source","getText","lastIfToken","fixedSource","firstTokenOfElseBlock","value","getTokenAfter","ifBlockMaybeUnsafe","parent","consequent","elseBlockUnsafe","test","endToken","getLastToken","lastTokenOfElseBlock","nextToken","nextTokenUnsafe","nextTokenOnSameLine","loc","start","line","slice","retainEnclosingFunction","replaceTextRange","checkForReturn","naiveHasReturn","body","lastChildNode","hasElse","alternate","checkForIf","checkForReturnOrIf","alwaysReturns","checkIfWithoutElse","STATEMENT_LIST_PARENTS","has","consequents","currentNode","push","every","checkIfWithElse","options"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-else-return.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `else` blocks after `return` statements in `if` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-else-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowElseIf: {\n                    type: \"boolean\",\n                    default: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Unnecessary 'else' after 'return'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whether the given names can be safely used to declare block-scoped variables\n         * in the given scope. Name collisions can produce redeclaration syntax errors,\n         * or silently change references and modify behavior of the original code.\n         *\n         * This is not a generic function. In particular, it is assumed that the scope is a function scope or\n         * a function's inner scope, and that the names can be valid identifiers in the given scope.\n         * @param {string[]} names Array of variable names.\n         * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\n         * @returns {boolean} True if all names can be safely declared, false otherwise.\n         */\n        function isSafeToDeclare(names, scope) {\n\n            if (names.length === 0) {\n                return true;\n            }\n\n            const functionScope = scope.variableScope;\n\n            /*\n             * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\n             * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\n             * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\n             *\n             * Redeclaring any of these would cause a syntax error, except for the implicit variables.\n             */\n            const declaredVariables = scope.variables.filter(({ defs }) => defs.length > 0);\n\n            if (declaredVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            // Redeclaring a catch variable would also cause a syntax error.\n            if (scope !== functionScope && scope.upper.type === \"catch\") {\n                if (scope.upper.variables.some(({ name }) => names.includes(name))) {\n                    return false;\n                }\n            }\n\n            /*\n             * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\n             * However, if the variable was used, declaring a new one with the same name would change references\n             * and modify behavior.\n             */\n            const usedImplicitVariables = scope.variables.filter(({ defs, references }) =>\n                defs.length === 0 && references.length > 0);\n\n            if (usedImplicitVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            /*\n             * Declaring a variable with a name that was already used to reference a variable from an upper scope\n             * would change references and modify behavior.\n             */\n            if (scope.through.some(t => names.includes(t.identifier.name))) {\n                return false;\n            }\n\n            /*\n             * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\n             * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\n             *\n             * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\n             * function foo() { if (bar) { let a; if (baz) { var a; } } }\n             */\n            if (scope !== functionScope) {\n                const scopeNodeRange = scope.block.range;\n                const variablesToCheck = functionScope.variables.filter(({ name }) => names.includes(name));\n\n                if (variablesToCheck.some(v => v.defs.some(({ node: { range } }) =>\n                    scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n\n        /**\n         * Checks whether the removal of `else` and its braces is safe from variable name collisions.\n         * @param {Node} node The 'else' node.\n         * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\n         * @returns {boolean} True if it is safe, false otherwise.\n         */\n        function isSafeFromNameCollisions(node, scope) {\n\n            if (node.type === \"FunctionDeclaration\") {\n\n                // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\n                return false;\n            }\n\n            if (node.type !== \"BlockStatement\") {\n                return true;\n            }\n\n            const elseBlockScope = scope.childScopes.find(({ block }) => block === node);\n\n            if (!elseBlockScope) {\n\n                // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\n                return true;\n            }\n\n            /*\n             * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\n             * only block-scoped variables (such as let and const variables or class and function declarations)\n             * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\n             */\n            const namesToCheck = elseBlockScope.variables.map(({ name }) => name);\n\n            return isSafeToDeclare(namesToCheck, scope);\n        }\n\n        /**\n         * Display the context report if rule is violated\n         * @param {Node} node The 'else' node\n         * @returns {void}\n         */\n        function displayReport(node) {\n            const currentScope = context.getScope();\n\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                fix: fixer => {\n\n                    if (!isSafeFromNameCollisions(node, currentScope)) {\n                        return null;\n                    }\n\n                    const sourceCode = context.getSourceCode();\n                    const startToken = sourceCode.getFirstToken(node);\n                    const elseToken = sourceCode.getTokenBefore(startToken);\n                    const source = sourceCode.getText(node);\n                    const lastIfToken = sourceCode.getTokenBefore(elseToken);\n                    let fixedSource, firstTokenOfElseBlock;\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n                    } else {\n                        firstTokenOfElseBlock = startToken;\n                    }\n\n                    /*\n                     * If the if block does not have curly braces and does not end in a semicolon\n                     * and the else block starts with (, [, /, +, ` or -, then it is not\n                     * safe to remove the else keyword, because ASI will not add a semicolon\n                     * after the if block\n                     */\n                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n                    const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n                        return null;\n                    }\n\n                    const endToken = sourceCode.getLastToken(node);\n                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n                    if (lastTokenOfElseBlock.value !== \";\") {\n                        const nextToken = sourceCode.getTokenAfter(endToken);\n\n                        const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n                        /*\n                         * If the else block contents does not end in a semicolon,\n                         * and the else block starts with (, [, /, +, ` or -, then it is not\n                         * safe to remove the else block, because ASI will not add a semicolon\n                         * after the remaining else block contents\n                         */\n                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== \"}\")) {\n                            return null;\n                        }\n                    }\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        fixedSource = source.slice(1, -1);\n                    } else {\n                        fixedSource = source;\n                    }\n\n                    /*\n                     * Extend the replacement range to include the entire\n                     * function to avoid conflicting with no-useless-return.\n                     * https://github.com/eslint/eslint/issues/8026\n                     *\n                     * Also, to avoid name collisions between two else blocks.\n                     */\n                    return new FixTracker(fixer, sourceCode)\n                        .retainEnclosingFunction(node)\n                        .replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n                }\n            });\n        }\n\n        /**\n         * Check to see if the node is a ReturnStatement\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if node is a return\n         */\n        function checkForReturn(node) {\n            return node.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Naive return checking, does not iterate through the whole\n         * BlockStatement because we make the assumption that the ReturnStatement\n         * will be the last node in the body of the BlockStatement.\n         * @param {Node} node The consequent/alternate node\n         * @returns {boolean} True if it has a return\n         */\n        function naiveHasReturn(node) {\n            if (node.type === \"BlockStatement\") {\n                const body = node.body,\n                    lastChildNode = body[body.length - 1];\n\n                return lastChildNode && checkForReturn(lastChildNode);\n            }\n            return checkForReturn(node);\n        }\n\n        /**\n         * Check to see if the node is valid for evaluation,\n         * meaning it has an else.\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if the node is valid\n         */\n        function hasElse(node) {\n            return node.alternate && node.consequent;\n        }\n\n        /**\n         * If the consequent is an IfStatement, check to see if it has an else\n         * and both its consequent and alternate path return, meaning this is\n         * a nested case of rule violation.  If-Else not considered currently.\n         * @param {Node} node The consequent node\n         * @returns {boolean} True if this is a nested rule violation\n         */\n        function checkForIf(node) {\n            return node.type === \"IfStatement\" && hasElse(node) &&\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n        }\n\n        /**\n         * Check the consequent/body node to make sure it is not\n         * a ReturnStatement or an IfStatement that returns on both\n         * code paths.\n         * @param {Node} node The consequent or body node\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\n         */\n        function checkForReturnOrIf(node) {\n            return checkForReturn(node) || checkForIf(node);\n        }\n\n\n        /**\n         * Check whether a node returns in every codepath.\n         * @param {Node} node The node to be checked\n         * @returns {boolean} `true` if it returns on every codepath.\n         */\n        function alwaysReturns(node) {\n            if (node.type === \"BlockStatement\") {\n\n                // If we have a BlockStatement, check each consequent body node.\n                return node.body.some(checkForReturnOrIf);\n            }\n\n            /*\n             * If not a block statement, make sure the consequent isn't a\n             * ReturnStatement or an IfStatement with returns on both paths.\n             */\n            return checkForReturnOrIf(node);\n        }\n\n\n        /**\n         * Check the if statement, but don't catch else-if blocks.\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithoutElse(node) {\n            const parent = node.parent;\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const consequents = [];\n            let alternate;\n\n            for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n                if (!currentNode.alternate) {\n                    return;\n                }\n                consequents.push(currentNode.consequent);\n                alternate = currentNode.alternate;\n            }\n\n            if (consequents.every(alwaysReturns)) {\n                displayReport(alternate);\n            }\n        }\n\n        /**\n         * Check the if statement\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithElse(node) {\n            const parent = node.parent;\n\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const alternate = node.alternate;\n\n            if (alternate && alwaysReturns(node.consequent)) {\n                displayReport(alternate);\n            }\n        }\n\n        const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}