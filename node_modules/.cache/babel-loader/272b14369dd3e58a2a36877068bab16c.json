{"ast":null,"code":"/**\n * @fileoverview Helper class to aid in constructing fix commands.\n * @author Alan Pierce\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./ast-utils\"); //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A helper class to combine fix options into a fix command. Currently, it\n * exposes some \"retain\" methods that extend the range of the text being\n * replaced so that other fixes won't touch that region in the same pass.\n */\n\n\nclass FixTracker {\n  /**\n   * Create a new FixTracker.\n   * @param {ruleFixer} fixer A ruleFixer instance.\n   * @param {SourceCode} sourceCode A SourceCode object for the current code.\n   */\n  constructor(fixer, sourceCode) {\n    this.fixer = fixer;\n    this.sourceCode = sourceCode;\n    this.retainedRange = null;\n  }\n  /**\n   * Mark the given range as \"retained\", meaning that other fixes may not\n   * may not modify this region in the same pass.\n   * @param {int[]} range The range to retain.\n   * @returns {FixTracker} The same RuleFixer, for chained calls.\n   */\n\n\n  retainRange(range) {\n    this.retainedRange = range;\n    return this;\n  }\n  /**\n   * Given a node, find the function containing it (or the entire program) and\n   * mark it as retained, meaning that other fixes may not modify it in this\n   * pass. This is useful for avoiding conflicts in fixes that modify control\n   * flow.\n   * @param {ASTNode} node The node to use as a starting point.\n   * @returns {FixTracker} The same RuleFixer, for chained calls.\n   */\n\n\n  retainEnclosingFunction(node) {\n    const functionNode = astUtils.getUpperFunction(node);\n    return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\n  }\n  /**\n   * Given a node or token, find the token before and afterward, and mark that\n   * range as retained, meaning that other fixes may not modify it in this\n   * pass. This is useful for avoiding conflicts in fixes that make a small\n   * change to the code where the AST should not be changed.\n   * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\n   *      point. The token to the left and right are use in the range.\n   * @returns {FixTracker} The same RuleFixer, for chained calls.\n   */\n\n\n  retainSurroundingTokens(nodeOrToken) {\n    const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n    const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n    return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n  }\n  /**\n   * Create a fix command that replaces the given range with the given text,\n   * accounting for any retained ranges.\n   * @param {int[]} range The range to remove in the fix.\n   * @param {string} text The text to insert in place of the range.\n   * @returns {Object} The fix command.\n   */\n\n\n  replaceTextRange(range, text) {\n    let actualRange;\n\n    if (this.retainedRange) {\n      actualRange = [Math.min(this.retainedRange[0], range[0]), Math.max(this.retainedRange[1], range[1])];\n    } else {\n      actualRange = range;\n    }\n\n    return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));\n  }\n  /**\n   * Create a fix command that removes the given node or token, accounting for\n   * any retained ranges.\n   * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n   * @returns {Object} The fix command.\n   */\n\n\n  remove(nodeOrToken) {\n    return this.replaceTextRange(nodeOrToken.range, \"\");\n  }\n\n}\n\nmodule.exports = FixTracker;","map":{"version":3,"names":["astUtils","require","FixTracker","constructor","fixer","sourceCode","retainedRange","retainRange","range","retainEnclosingFunction","node","functionNode","getUpperFunction","ast","retainSurroundingTokens","nodeOrToken","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","replaceTextRange","text","actualRange","Math","min","max","slice","remove","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/utils/fix-tracker.js"],"sourcesContent":["/**\n * @fileoverview Helper class to aid in constructing fix commands.\n * @author Alan Pierce\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./ast-utils\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A helper class to combine fix options into a fix command. Currently, it\n * exposes some \"retain\" methods that extend the range of the text being\n * replaced so that other fixes won't touch that region in the same pass.\n */\nclass FixTracker {\n\n    /**\n     * Create a new FixTracker.\n     * @param {ruleFixer} fixer A ruleFixer instance.\n     * @param {SourceCode} sourceCode A SourceCode object for the current code.\n     */\n    constructor(fixer, sourceCode) {\n        this.fixer = fixer;\n        this.sourceCode = sourceCode;\n        this.retainedRange = null;\n    }\n\n    /**\n     * Mark the given range as \"retained\", meaning that other fixes may not\n     * may not modify this region in the same pass.\n     * @param {int[]} range The range to retain.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainRange(range) {\n        this.retainedRange = range;\n        return this;\n    }\n\n    /**\n     * Given a node, find the function containing it (or the entire program) and\n     * mark it as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that modify control\n     * flow.\n     * @param {ASTNode} node The node to use as a starting point.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainEnclosingFunction(node) {\n        const functionNode = astUtils.getUpperFunction(node);\n\n        return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\n    }\n\n    /**\n     * Given a node or token, find the token before and afterward, and mark that\n     * range as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that make a small\n     * change to the code where the AST should not be changed.\n     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\n     *      point. The token to the left and right are use in the range.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainSurroundingTokens(nodeOrToken) {\n        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n\n        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n    }\n\n    /**\n     * Create a fix command that replaces the given range with the given text,\n     * accounting for any retained ranges.\n     * @param {int[]} range The range to remove in the fix.\n     * @param {string} text The text to insert in place of the range.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        let actualRange;\n\n        if (this.retainedRange) {\n            actualRange = [\n                Math.min(this.retainedRange[0], range[0]),\n                Math.max(this.retainedRange[1], range[1])\n            ];\n        } else {\n            actualRange = range;\n        }\n\n        return this.fixer.replaceTextRange(\n            actualRange,\n            this.sourceCode.text.slice(actualRange[0], range[0]) +\n                text +\n                this.sourceCode.text.slice(range[1], actualRange[1])\n        );\n    }\n\n    /**\n     * Create a fix command that removes the given node or token, accounting for\n     * any retained ranges.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.replaceTextRange(nodeOrToken.range, \"\");\n    }\n}\n\nmodule.exports = FixTracker;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,aAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,UAAN,CAAiB;EAEb;AACJ;AACA;AACA;AACA;EACIC,WAAW,CAACC,KAAD,EAAQC,UAAR,EAAoB;IAC3B,KAAKD,KAAL,GAAaA,KAAb;IACA,KAAKC,UAAL,GAAkBA,UAAlB;IACA,KAAKC,aAAL,GAAqB,IAArB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIC,WAAW,CAACC,KAAD,EAAQ;IACf,KAAKF,aAAL,GAAqBE,KAArB;IACA,OAAO,IAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,uBAAuB,CAACC,IAAD,EAAO;IAC1B,MAAMC,YAAY,GAAGX,QAAQ,CAACY,gBAAT,CAA0BF,IAA1B,CAArB;IAEA,OAAO,KAAKH,WAAL,CAAiBI,YAAY,GAAGA,YAAY,CAACH,KAAhB,GAAwB,KAAKH,UAAL,CAAgBQ,GAAhB,CAAoBL,KAAzE,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIM,uBAAuB,CAACC,WAAD,EAAc;IACjC,MAAMC,WAAW,GAAG,KAAKX,UAAL,CAAgBY,cAAhB,CAA+BF,WAA/B,KAA+CA,WAAnE;IACA,MAAMG,UAAU,GAAG,KAAKb,UAAL,CAAgBc,aAAhB,CAA8BJ,WAA9B,KAA8CA,WAAjE;IAEA,OAAO,KAAKR,WAAL,CAAiB,CAACS,WAAW,CAACR,KAAZ,CAAkB,CAAlB,CAAD,EAAuBU,UAAU,CAACV,KAAX,CAAiB,CAAjB,CAAvB,CAAjB,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIY,gBAAgB,CAACZ,KAAD,EAAQa,IAAR,EAAc;IAC1B,IAAIC,WAAJ;;IAEA,IAAI,KAAKhB,aAAT,EAAwB;MACpBgB,WAAW,GAAG,CACVC,IAAI,CAACC,GAAL,CAAS,KAAKlB,aAAL,CAAmB,CAAnB,CAAT,EAAgCE,KAAK,CAAC,CAAD,CAArC,CADU,EAEVe,IAAI,CAACE,GAAL,CAAS,KAAKnB,aAAL,CAAmB,CAAnB,CAAT,EAAgCE,KAAK,CAAC,CAAD,CAArC,CAFU,CAAd;IAIH,CALD,MAKO;MACHc,WAAW,GAAGd,KAAd;IACH;;IAED,OAAO,KAAKJ,KAAL,CAAWgB,gBAAX,CACHE,WADG,EAEH,KAAKjB,UAAL,CAAgBgB,IAAhB,CAAqBK,KAArB,CAA2BJ,WAAW,CAAC,CAAD,CAAtC,EAA2Cd,KAAK,CAAC,CAAD,CAAhD,IACIa,IADJ,GAEI,KAAKhB,UAAL,CAAgBgB,IAAhB,CAAqBK,KAArB,CAA2BlB,KAAK,CAAC,CAAD,CAAhC,EAAqCc,WAAW,CAAC,CAAD,CAAhD,CAJD,CAAP;EAMH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIK,MAAM,CAACZ,WAAD,EAAc;IAChB,OAAO,KAAKK,gBAAL,CAAsBL,WAAW,CAACP,KAAlC,EAAyC,EAAzC,CAAP;EACH;;AAzFY;;AA4FjBoB,MAAM,CAACC,OAAP,GAAiB3B,UAAjB"},"metadata":{},"sourceType":"script"}