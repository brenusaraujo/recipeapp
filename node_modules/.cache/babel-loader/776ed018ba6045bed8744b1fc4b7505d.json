{"ast":null,"code":"/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      {\n  breakableTypePattern\n} = require(\"../../shared/ast-utils\"),\n      CodePath = require(\"./code-path\"),\n      CodePathSegment = require(\"./code-path-segment\"),\n      IdGenerator = require(\"./id-generator\"),\n      debug = require(\"./debug-helpers\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\n\n\nfunction isCaseNode(node) {\n  return Boolean(node.test);\n}\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\n\n\nfunction isHandledLogicalOperator(operator) {\n  return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\n\n\nfunction isLogicalAssignmentOperator(operator) {\n  return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\n\n\nfunction getLabel(node) {\n  if (node.parent.type === \"LabeledStatement\") {\n    return node.parent.label.name;\n  }\n\n  return null;\n}\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\n\n\nfunction isForkingByTrueOrFalse(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n      return parent.test === node;\n\n    case \"LogicalExpression\":\n      return isHandledLogicalOperator(parent.operator);\n\n    case \"AssignmentExpression\":\n      return isLogicalAssignmentOperator(parent.operator);\n\n    default:\n      return false;\n  }\n}\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\n\n\nfunction getBooleanValueIfSimpleConstant(node) {\n  if (node.type === \"Literal\") {\n    return Boolean(node.value);\n  }\n\n  return void 0;\n}\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\n\n\nfunction isIdentifierReference(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"LabeledStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n    case \"ImportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"CatchClause\":\n      return false;\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    case \"Property\":\n    case \"MethodDefinition\":\n      return parent.key !== node || parent.computed || parent.shorthand;\n\n    case \"AssignmentPattern\":\n      return parent.key !== node;\n\n    default:\n      return true;\n  }\n}\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction forwardCurrentToHead(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const currentSegments = state.currentSegments;\n  const headSegments = state.headSegments;\n  const end = Math.max(currentSegments.length, headSegments.length);\n  let i, currentSegment, headSegment; // Fires leaving events.\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && currentSegment) {\n      debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n      if (currentSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n      }\n    }\n  } // Update state.\n\n\n  state.currentSegments = headSegments; // Fires entering events.\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && headSegment) {\n      debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n      CodePathSegment.markUsed(headSegment);\n\n      if (headSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentStart\", headSegment, node);\n      }\n    }\n  }\n}\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction leaveFromCurrentSegment(analyzer, node) {\n  const state = CodePath.getState(analyzer.codePath);\n  const currentSegments = state.currentSegments;\n\n  for (let i = 0; i < currentSegments.length; ++i) {\n    const currentSegment = currentSegments[i];\n    debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n    if (currentSegment.reachable) {\n      analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n    }\n  }\n\n  state.currentSegments = [];\n}\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction preprocess(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const parent = node.parent;\n\n  switch (parent.type) {\n    // The `arguments.length == 0` case is in `postprocess` function.\n    case \"CallExpression\":\n      if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n        state.makeOptionalRight();\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (parent.optional === true && parent.property === node) {\n        state.makeOptionalRight();\n      }\n\n      break;\n\n    case \"LogicalExpression\":\n      if (parent.right === node && isHandledLogicalOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      /*\n       * Fork if this node is at `consequent`/`alternate`.\n       * `popForkContext()` exists at `IfStatement:exit` and\n       * `ConditionalExpression:exit`.\n       */\n      if (parent.consequent === node) {\n        state.makeIfConsequent();\n      } else if (parent.alternate === node) {\n        state.makeIfAlternate();\n      }\n\n      break;\n\n    case \"SwitchCase\":\n      if (parent.consequent[0] === node) {\n        state.makeSwitchCaseBody(false, !parent.test);\n      }\n\n      break;\n\n    case \"TryStatement\":\n      if (parent.handler === node) {\n        state.makeCatchBlock();\n      } else if (parent.finalizer === node) {\n        state.makeFinallyBlock();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n      if (parent.test === node) {\n        state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n      } else {\n        assert(parent.body === node);\n        state.makeWhileBody();\n      }\n\n      break;\n\n    case \"DoWhileStatement\":\n      if (parent.body === node) {\n        state.makeDoWhileBody();\n      } else {\n        assert(parent.test === node);\n        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n      }\n\n      break;\n\n    case \"ForStatement\":\n      if (parent.test === node) {\n        state.makeForTest(getBooleanValueIfSimpleConstant(node));\n      } else if (parent.update === node) {\n        state.makeForUpdate();\n      } else if (parent.body === node) {\n        state.makeForBody();\n      }\n\n      break;\n\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      if (parent.left === node) {\n        state.makeForInOfLeft();\n      } else if (parent.right === node) {\n        state.makeForInOfRight();\n      } else {\n        assert(parent.body === node);\n        state.makeForInOfBody();\n      }\n\n      break;\n\n    case \"AssignmentPattern\":\n      /*\n       * Fork if this node is at `right`.\n       * `left` is executed always, so it uses the current path.\n       * `popForkContext()` exists at `AssignmentPattern:exit`.\n       */\n      if (parent.right === node) {\n        state.pushForkContext();\n        state.forkBypassPath();\n        state.forkPath();\n      }\n\n      break;\n\n    default:\n      break;\n  }\n}\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction processCodePathToEnter(analyzer, node) {\n  let codePath = analyzer.codePath;\n  let state = codePath && CodePath.getState(codePath);\n  const parent = node.parent;\n\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      if (codePath) {\n        // Emits onCodePathSegmentStart events if updated.\n        forwardCurrentToHead(analyzer, node);\n        debug.dumpState(node, state, false);\n      } // Create the code path of this scope.\n\n\n      codePath = analyzer.codePath = new CodePath(analyzer.idGenerator.next(), codePath, analyzer.onLooped);\n      state = CodePath.getState(codePath); // Emits onCodePathStart events.\n\n      debug.dump(`onCodePathStart ${codePath.id}`);\n      analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n      break;\n\n    case \"ChainExpression\":\n      state.pushChainContext();\n      break;\n\n    case \"CallExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.pushChoiceContext(node.operator.slice(0, -1), // removes `=` from the end\n        isForkingByTrueOrFalse(node));\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      state.pushChoiceContext(\"test\", false);\n      break;\n\n    case \"SwitchStatement\":\n      state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));\n      break;\n\n    case \"TryStatement\":\n      state.pushTryContext(Boolean(node.finalizer));\n      break;\n\n    case \"SwitchCase\":\n      /*\n       * Fork if this node is after the 2st node in `cases`.\n       * It's similar to `else` blocks.\n       * The next `test` node is processed in this path.\n       */\n      if (parent.discriminant !== node && parent.cases[0] !== node) {\n        state.forkPath();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.pushLoopContext(node.type, getLabel(node));\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.pushBreakContext(false, node.label.name);\n      }\n\n      break;\n\n    default:\n      break;\n  } // Emits onCodePathSegmentStart events if updated.\n\n\n  forwardCurrentToHead(analyzer, node);\n  debug.dumpState(node, state, false);\n}\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction processCodePathToExit(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  let dontForward = false;\n\n  switch (node.type) {\n    case \"ChainExpression\":\n      state.popChainContext();\n      break;\n\n    case \"IfStatement\":\n    case \"ConditionalExpression\":\n      state.popChoiceContext();\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n\n      break;\n\n    case \"SwitchStatement\":\n      state.popSwitchContext();\n      break;\n\n    case \"SwitchCase\":\n      /*\n       * This is the same as the process at the 1st `consequent` node in\n       * `preprocess` function.\n       * Must do if this `consequent` is empty.\n       */\n      if (node.consequent.length === 0) {\n        state.makeSwitchCaseBody(true, !node.test);\n      }\n\n      if (state.forkContext.reachable) {\n        dontForward = true;\n      }\n\n      break;\n\n    case \"TryStatement\":\n      state.popTryContext();\n      break;\n\n    case \"BreakStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeBreak(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ContinueStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeContinue(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ReturnStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeReturn();\n      dontForward = true;\n      break;\n\n    case \"ThrowStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeThrow();\n      dontForward = true;\n      break;\n\n    case \"Identifier\":\n      if (isIdentifierReference(node)) {\n        state.makeFirstThrowablePathInTryBlock();\n        dontForward = true;\n      }\n\n      break;\n\n    case \"CallExpression\":\n    case \"ImportExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"YieldExpression\":\n      state.makeFirstThrowablePathInTryBlock();\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.popLoopContext();\n      break;\n\n    case \"AssignmentPattern\":\n      state.popForkContext();\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.popBreakContext();\n      }\n\n      break;\n\n    default:\n      break;\n  } // Emits onCodePathSegmentStart events if updated.\n\n\n  if (!dontForward) {\n    forwardCurrentToHead(analyzer, node);\n  }\n\n  debug.dumpState(node, state, true);\n}\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction postprocess(analyzer, node) {\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      {\n        let codePath = analyzer.codePath; // Mark the current path as the final node.\n\n        CodePath.getState(codePath).makeFinal(); // Emits onCodePathSegmentEnd event of the current segments.\n\n        leaveFromCurrentSegment(analyzer, node); // Emits onCodePathEnd event of this code path.\n\n        debug.dump(`onCodePathEnd ${codePath.id}`);\n        analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n        debug.dumpDot(codePath);\n        codePath = analyzer.codePath = analyzer.codePath.upper;\n\n        if (codePath) {\n          debug.dumpState(node, CodePath.getState(codePath), true);\n        }\n\n        break;\n      }\n    // The `arguments.length >= 1` case is in `preprocess` function.\n\n    case \"CallExpression\":\n      if (node.optional === true && node.arguments.length === 0) {\n        CodePath.getState(analyzer.codePath).makeOptionalRight();\n      }\n\n      break;\n\n    default:\n      break;\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\n\n\nclass CodePathAnalyzer {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {EventGenerator} eventGenerator An event generator to wrap.\n   */\n  constructor(eventGenerator) {\n    this.original = eventGenerator;\n    this.emitter = eventGenerator.emitter;\n    this.codePath = null;\n    this.idGenerator = new IdGenerator(\"s\");\n    this.currentNode = null;\n    this.onLooped = this.onLooped.bind(this);\n  }\n  /**\n   * Does the process to enter a given AST node.\n   * This updates state of analysis and calls `enterNode` of the wrapped.\n   * @param {ASTNode} node A node which is entering.\n   * @returns {void}\n   */\n\n\n  enterNode(node) {\n    this.currentNode = node; // Updates the code path due to node's position in its parent node.\n\n    if (node.parent) {\n      preprocess(this, node);\n    }\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n\n\n    processCodePathToEnter(this, node); // Emits node events.\n\n    this.original.enterNode(node);\n    this.currentNode = null;\n  }\n  /**\n   * Does the process to leave a given AST node.\n   * This updates state of analysis and calls `leaveNode` of the wrapped.\n   * @param {ASTNode} node A node which is leaving.\n   * @returns {void}\n   */\n\n\n  leaveNode(node) {\n    this.currentNode = node;\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n\n    processCodePathToExit(this, node); // Emits node events.\n\n    this.original.leaveNode(node); // Emits the last onCodePathStart/onCodePathSegmentStart events.\n\n    postprocess(this, node);\n    this.currentNode = null;\n  }\n  /**\n   * This is called on a code path looped.\n   * Then this raises a looped event.\n   * @param {CodePathSegment} fromSegment A segment of prev.\n   * @param {CodePathSegment} toSegment A segment of next.\n   * @returns {void}\n   */\n\n\n  onLooped(fromSegment, toSegment) {\n    if (fromSegment.reachable && toSegment.reachable) {\n      debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n      this.emitter.emit(\"onCodePathSegmentLoop\", fromSegment, toSegment, this.currentNode);\n    }\n  }\n\n}\n\nmodule.exports = CodePathAnalyzer;","map":{"version":3,"names":["assert","require","breakableTypePattern","CodePath","CodePathSegment","IdGenerator","debug","isCaseNode","node","Boolean","test","isHandledLogicalOperator","operator","isLogicalAssignmentOperator","getLabel","parent","type","label","name","isForkingByTrueOrFalse","getBooleanValueIfSimpleConstant","value","isIdentifierReference","id","key","computed","shorthand","forwardCurrentToHead","analyzer","codePath","state","getState","currentSegments","headSegments","end","Math","max","length","i","currentSegment","headSegment","dump","reachable","emitter","emit","markUsed","leaveFromCurrentSegment","preprocess","optional","arguments","makeOptionalRight","property","right","makeLogicalRight","consequent","makeIfConsequent","alternate","makeIfAlternate","makeSwitchCaseBody","handler","makeCatchBlock","finalizer","makeFinallyBlock","makeWhileTest","body","makeWhileBody","makeDoWhileBody","makeDoWhileTest","makeForTest","update","makeForUpdate","makeForBody","left","makeForInOfLeft","makeForInOfRight","makeForInOfBody","pushForkContext","forkBypassPath","forkPath","processCodePathToEnter","dumpState","idGenerator","next","onLooped","pushChainContext","makeOptionalNode","pushChoiceContext","slice","pushSwitchContext","cases","some","pushTryContext","discriminant","pushLoopContext","pushBreakContext","processCodePathToExit","dontForward","popChainContext","popChoiceContext","popSwitchContext","forkContext","popTryContext","makeBreak","makeContinue","makeReturn","makeThrow","makeFirstThrowablePathInTryBlock","popLoopContext","popForkContext","popBreakContext","postprocess","makeFinal","dumpDot","upper","CodePathAnalyzer","constructor","eventGenerator","original","currentNode","bind","enterNode","leaveNode","fromSegment","toSegment","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js"],"sourcesContent":["/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    { breakableTypePattern } = require(\"../../shared/ast-utils\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\nfunction isHandledLogicalOperator(operator) {\n    return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\nfunction isLogicalAssignmentOperator(operator) {\n    return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\nfunction getLabel(node) {\n    if (node.parent.type === \"LabeledStatement\") {\n        return node.parent.label.name;\n    }\n    return null;\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return isHandledLogicalOperator(parent.operator);\n\n        case \"AssignmentExpression\":\n            return isLogicalAssignmentOperator(parent.operator);\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const currentSegments = state.currentSegments;\n    const headSegments = state.headSegments;\n    const end = Math.max(currentSegments.length, headSegments.length);\n    let i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node\n                );\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n\n            CodePathSegment.markUsed(headSegment);\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node\n                );\n            }\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    const state = CodePath.getState(analyzer.codePath);\n    const currentSegments = state.currentSegments;\n\n    for (let i = 0; i < currentSegments.length; ++i) {\n        const currentSegment = currentSegments[i];\n\n        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n        if (currentSegment.reachable) {\n            analyzer.emitter.emit(\n                \"onCodePathSegmentEnd\",\n                currentSegment,\n                node\n            );\n        }\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (parent.type) {\n\n        // The `arguments.length == 0` case is in `postprocess` function.\n        case \"CallExpression\":\n            if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n                state.makeOptionalRight();\n            }\n            break;\n        case \"MemberExpression\":\n            if (parent.optional === true && parent.property === node) {\n                state.makeOptionalRight();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (\n                parent.right === node &&\n                isHandledLogicalOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (\n                parent.right === node &&\n                isLogicalAssignmentOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    let codePath = analyzer.codePath;\n    let state = codePath && CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            if (codePath) {\n\n                // Emits onCodePathSegmentStart events if updated.\n                forwardCurrentToHead(analyzer, node);\n                debug.dumpState(node, state, false);\n            }\n\n            // Create the code path of this scope.\n            codePath = analyzer.codePath = new CodePath(\n                analyzer.idGenerator.next(),\n                codePath,\n                analyzer.onLooped\n            );\n            state = CodePath.getState(codePath);\n\n            // Emits onCodePathStart events.\n            debug.dump(`onCodePathStart ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n            break;\n\n        case \"ChainExpression\":\n            state.pushChainContext();\n            break;\n        case \"CallExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n        case \"MemberExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator,\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator.slice(0, -1), // removes `=` from the end\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                getLabel(node)\n            );\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    let dontForward = false;\n\n    switch (node.type) {\n        case \"ChainExpression\":\n            state.popChainContext();\n            break;\n\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"ImportExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    if (!dontForward) {\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\": {\n            let codePath = analyzer.codePath;\n\n            // Mark the current path as the final node.\n            CodePath.getState(codePath).makeFinal();\n\n            // Emits onCodePathSegmentEnd event of the current segments.\n            leaveFromCurrentSegment(analyzer, node);\n\n            // Emits onCodePathEnd event of this code path.\n            debug.dump(`onCodePathEnd ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n            debug.dumpDot(codePath);\n\n            codePath = analyzer.codePath = analyzer.codePath.upper;\n            if (codePath) {\n                debug.dumpState(node, CodePath.getState(codePath), true);\n            }\n            break;\n        }\n\n        // The `arguments.length >= 1` case is in `preprocess` function.\n        case \"CallExpression\":\n            if (node.optional === true && node.arguments.length === 0) {\n                CodePath.getState(analyzer.codePath).makeOptionalRight();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {EventGenerator} eventGenerator An event generator to wrap.\n     */\n    constructor(eventGenerator) {\n        this.original = eventGenerator;\n        this.emitter = eventGenerator.emitter;\n        this.codePath = null;\n        this.idGenerator = new IdGenerator(\"s\");\n        this.currentNode = null;\n        this.onLooped = this.onLooped.bind(this);\n    }\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     * @param {ASTNode} node A node which is entering.\n     * @returns {void}\n     */\n    enterNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     * @param {ASTNode} node A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.currentNode = node;\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     * @param {CodePathSegment} fromSegment A segment of prev.\n     * @param {CodePathSegment} toSegment A segment of next.\n     * @returns {void}\n     */\n    onLooped(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n}\n\nmodule.exports = CodePathAnalyzer;\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;AAAA,MACI;EAAEC;AAAF,IAA2BD,OAAO,CAAC,wBAAD,CADtC;AAAA,MAEIE,QAAQ,GAAGF,OAAO,CAAC,aAAD,CAFtB;AAAA,MAGIG,eAAe,GAAGH,OAAO,CAAC,qBAAD,CAH7B;AAAA,MAIII,WAAW,GAAGJ,OAAO,CAAC,gBAAD,CAJzB;AAAA,MAKIK,KAAK,GAAGL,OAAO,CAAC,iBAAD,CALnB,C,CAOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASM,UAAT,CAAoBC,IAApB,EAA0B;EACtB,OAAOC,OAAO,CAACD,IAAI,CAACE,IAAN,CAAd;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,wBAAT,CAAkCC,QAAlC,EAA4C;EACxC,OAAOA,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,IAAlC,IAA0CA,QAAQ,KAAK,IAA9D;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,2BAAT,CAAqCD,QAArC,EAA+C;EAC3C,OAAOA,QAAQ,KAAK,KAAb,IAAsBA,QAAQ,KAAK,KAAnC,IAA4CA,QAAQ,KAAK,KAAhE;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASE,QAAT,CAAkBN,IAAlB,EAAwB;EACpB,IAAIA,IAAI,CAACO,MAAL,CAAYC,IAAZ,KAAqB,kBAAzB,EAA6C;IACzC,OAAOR,IAAI,CAACO,MAAL,CAAYE,KAAZ,CAAkBC,IAAzB;EACH;;EACD,OAAO,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCX,IAAhC,EAAsC;EAClC,MAAMO,MAAM,GAAGP,IAAI,CAACO,MAApB;;EAEA,QAAQA,MAAM,CAACC,IAAf;IACI,KAAK,uBAAL;IACA,KAAK,aAAL;IACA,KAAK,gBAAL;IACA,KAAK,kBAAL;IACA,KAAK,cAAL;MACI,OAAOD,MAAM,CAACL,IAAP,KAAgBF,IAAvB;;IAEJ,KAAK,mBAAL;MACI,OAAOG,wBAAwB,CAACI,MAAM,CAACH,QAAR,CAA/B;;IAEJ,KAAK,sBAAL;MACI,OAAOC,2BAA2B,CAACE,MAAM,CAACH,QAAR,CAAlC;;IAEJ;MACI,OAAO,KAAP;EAfR;AAiBH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,+BAAT,CAAyCZ,IAAzC,EAA+C;EAC3C,IAAIA,IAAI,CAACQ,IAAL,KAAc,SAAlB,EAA6B;IACzB,OAAOP,OAAO,CAACD,IAAI,CAACa,KAAN,CAAd;EACH;;EACD,OAAO,KAAK,CAAZ;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,qBAAT,CAA+Bd,IAA/B,EAAqC;EACjC,MAAMO,MAAM,GAAGP,IAAI,CAACO,MAApB;;EAEA,QAAQA,MAAM,CAACC,IAAf;IACI,KAAK,kBAAL;IACA,KAAK,gBAAL;IACA,KAAK,mBAAL;IACA,KAAK,cAAL;IACA,KAAK,aAAL;IACA,KAAK,iBAAL;IACA,KAAK,wBAAL;IACA,KAAK,0BAAL;IACA,KAAK,aAAL;MACI,OAAO,KAAP;;IAEJ,KAAK,qBAAL;IACA,KAAK,oBAAL;IACA,KAAK,yBAAL;IACA,KAAK,kBAAL;IACA,KAAK,iBAAL;IACA,KAAK,oBAAL;MACI,OAAOD,MAAM,CAACQ,EAAP,KAAcf,IAArB;;IAEJ,KAAK,UAAL;IACA,KAAK,kBAAL;MACI,OACIO,MAAM,CAACS,GAAP,KAAehB,IAAf,IACAO,MAAM,CAACU,QADP,IAEAV,MAAM,CAACW,SAHX;;IAMJ,KAAK,mBAAL;MACI,OAAOX,MAAM,CAACS,GAAP,KAAehB,IAAtB;;IAEJ;MACI,OAAO,IAAP;EAhCR;AAkCH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmB,oBAAT,CAA8BC,QAA9B,EAAwCpB,IAAxC,EAA8C;EAC1C,MAAMqB,QAAQ,GAAGD,QAAQ,CAACC,QAA1B;EACA,MAAMC,KAAK,GAAG3B,QAAQ,CAAC4B,QAAT,CAAkBF,QAAlB,CAAd;EACA,MAAMG,eAAe,GAAGF,KAAK,CAACE,eAA9B;EACA,MAAMC,YAAY,GAAGH,KAAK,CAACG,YAA3B;EACA,MAAMC,GAAG,GAAGC,IAAI,CAACC,GAAL,CAASJ,eAAe,CAACK,MAAzB,EAAiCJ,YAAY,CAACI,MAA9C,CAAZ;EACA,IAAIC,CAAJ,EAAOC,cAAP,EAAuBC,WAAvB,CAN0C,CAQ1C;;EACA,KAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,GAAhB,EAAqB,EAAEI,CAAvB,EAA0B;IACtBC,cAAc,GAAGP,eAAe,CAACM,CAAD,CAAhC;IACAE,WAAW,GAAGP,YAAY,CAACK,CAAD,CAA1B;;IAEA,IAAIC,cAAc,KAAKC,WAAnB,IAAkCD,cAAtC,EAAsD;MAClDjC,KAAK,CAACmC,IAAN,CAAY,wBAAuBF,cAAc,CAAChB,EAAG,EAArD;;MAEA,IAAIgB,cAAc,CAACG,SAAnB,EAA8B;QAC1Bd,QAAQ,CAACe,OAAT,CAAiBC,IAAjB,CACI,sBADJ,EAEIL,cAFJ,EAGI/B,IAHJ;MAKH;IACJ;EACJ,CAxByC,CA0B1C;;;EACAsB,KAAK,CAACE,eAAN,GAAwBC,YAAxB,CA3B0C,CA6B1C;;EACA,KAAKK,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,GAAhB,EAAqB,EAAEI,CAAvB,EAA0B;IACtBC,cAAc,GAAGP,eAAe,CAACM,CAAD,CAAhC;IACAE,WAAW,GAAGP,YAAY,CAACK,CAAD,CAA1B;;IAEA,IAAIC,cAAc,KAAKC,WAAnB,IAAkCA,WAAtC,EAAmD;MAC/ClC,KAAK,CAACmC,IAAN,CAAY,0BAAyBD,WAAW,CAACjB,EAAG,EAApD;MAEAnB,eAAe,CAACyC,QAAhB,CAAyBL,WAAzB;;MACA,IAAIA,WAAW,CAACE,SAAhB,EAA2B;QACvBd,QAAQ,CAACe,OAAT,CAAiBC,IAAjB,CACI,wBADJ,EAEIJ,WAFJ,EAGIhC,IAHJ;MAKH;IACJ;EACJ;AAEJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsC,uBAAT,CAAiClB,QAAjC,EAA2CpB,IAA3C,EAAiD;EAC7C,MAAMsB,KAAK,GAAG3B,QAAQ,CAAC4B,QAAT,CAAkBH,QAAQ,CAACC,QAA3B,CAAd;EACA,MAAMG,eAAe,GAAGF,KAAK,CAACE,eAA9B;;EAEA,KAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,eAAe,CAACK,MAApC,EAA4C,EAAEC,CAA9C,EAAiD;IAC7C,MAAMC,cAAc,GAAGP,eAAe,CAACM,CAAD,CAAtC;IAEAhC,KAAK,CAACmC,IAAN,CAAY,wBAAuBF,cAAc,CAAChB,EAAG,EAArD;;IACA,IAAIgB,cAAc,CAACG,SAAnB,EAA8B;MAC1Bd,QAAQ,CAACe,OAAT,CAAiBC,IAAjB,CACI,sBADJ,EAEIL,cAFJ,EAGI/B,IAHJ;IAKH;EACJ;;EAEDsB,KAAK,CAACE,eAAN,GAAwB,EAAxB;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASe,UAAT,CAAoBnB,QAApB,EAA8BpB,IAA9B,EAAoC;EAChC,MAAMqB,QAAQ,GAAGD,QAAQ,CAACC,QAA1B;EACA,MAAMC,KAAK,GAAG3B,QAAQ,CAAC4B,QAAT,CAAkBF,QAAlB,CAAd;EACA,MAAMd,MAAM,GAAGP,IAAI,CAACO,MAApB;;EAEA,QAAQA,MAAM,CAACC,IAAf;IAEI;IACA,KAAK,gBAAL;MACI,IAAID,MAAM,CAACiC,QAAP,KAAoB,IAApB,IAA4BjC,MAAM,CAACkC,SAAP,CAAiBZ,MAAjB,IAA2B,CAAvD,IAA4DtB,MAAM,CAACkC,SAAP,CAAiB,CAAjB,MAAwBzC,IAAxF,EAA8F;QAC1FsB,KAAK,CAACoB,iBAAN;MACH;;MACD;;IACJ,KAAK,kBAAL;MACI,IAAInC,MAAM,CAACiC,QAAP,KAAoB,IAApB,IAA4BjC,MAAM,CAACoC,QAAP,KAAoB3C,IAApD,EAA0D;QACtDsB,KAAK,CAACoB,iBAAN;MACH;;MACD;;IAEJ,KAAK,mBAAL;MACI,IACInC,MAAM,CAACqC,KAAP,KAAiB5C,IAAjB,IACAG,wBAAwB,CAACI,MAAM,CAACH,QAAR,CAF5B,EAGE;QACEkB,KAAK,CAACuB,gBAAN;MACH;;MACD;;IAEJ,KAAK,sBAAL;MACI,IACItC,MAAM,CAACqC,KAAP,KAAiB5C,IAAjB,IACAK,2BAA2B,CAACE,MAAM,CAACH,QAAR,CAF/B,EAGE;QACEkB,KAAK,CAACuB,gBAAN;MACH;;MACD;;IAEJ,KAAK,uBAAL;IACA,KAAK,aAAL;MAEI;AACZ;AACA;AACA;AACA;MACY,IAAItC,MAAM,CAACuC,UAAP,KAAsB9C,IAA1B,EAAgC;QAC5BsB,KAAK,CAACyB,gBAAN;MACH,CAFD,MAEO,IAAIxC,MAAM,CAACyC,SAAP,KAAqBhD,IAAzB,EAA+B;QAClCsB,KAAK,CAAC2B,eAAN;MACH;;MACD;;IAEJ,KAAK,YAAL;MACI,IAAI1C,MAAM,CAACuC,UAAP,CAAkB,CAAlB,MAAyB9C,IAA7B,EAAmC;QAC/BsB,KAAK,CAAC4B,kBAAN,CAAyB,KAAzB,EAAgC,CAAC3C,MAAM,CAACL,IAAxC;MACH;;MACD;;IAEJ,KAAK,cAAL;MACI,IAAIK,MAAM,CAAC4C,OAAP,KAAmBnD,IAAvB,EAA6B;QACzBsB,KAAK,CAAC8B,cAAN;MACH,CAFD,MAEO,IAAI7C,MAAM,CAAC8C,SAAP,KAAqBrD,IAAzB,EAA+B;QAClCsB,KAAK,CAACgC,gBAAN;MACH;;MACD;;IAEJ,KAAK,gBAAL;MACI,IAAI/C,MAAM,CAACL,IAAP,KAAgBF,IAApB,EAA0B;QACtBsB,KAAK,CAACiC,aAAN,CAAoB3C,+BAA+B,CAACZ,IAAD,CAAnD;MACH,CAFD,MAEO;QACHR,MAAM,CAACe,MAAM,CAACiD,IAAP,KAAgBxD,IAAjB,CAAN;QACAsB,KAAK,CAACmC,aAAN;MACH;;MACD;;IAEJ,KAAK,kBAAL;MACI,IAAIlD,MAAM,CAACiD,IAAP,KAAgBxD,IAApB,EAA0B;QACtBsB,KAAK,CAACoC,eAAN;MACH,CAFD,MAEO;QACHlE,MAAM,CAACe,MAAM,CAACL,IAAP,KAAgBF,IAAjB,CAAN;QACAsB,KAAK,CAACqC,eAAN,CAAsB/C,+BAA+B,CAACZ,IAAD,CAArD;MACH;;MACD;;IAEJ,KAAK,cAAL;MACI,IAAIO,MAAM,CAACL,IAAP,KAAgBF,IAApB,EAA0B;QACtBsB,KAAK,CAACsC,WAAN,CAAkBhD,+BAA+B,CAACZ,IAAD,CAAjD;MACH,CAFD,MAEO,IAAIO,MAAM,CAACsD,MAAP,KAAkB7D,IAAtB,EAA4B;QAC/BsB,KAAK,CAACwC,aAAN;MACH,CAFM,MAEA,IAAIvD,MAAM,CAACiD,IAAP,KAAgBxD,IAApB,EAA0B;QAC7BsB,KAAK,CAACyC,WAAN;MACH;;MACD;;IAEJ,KAAK,gBAAL;IACA,KAAK,gBAAL;MACI,IAAIxD,MAAM,CAACyD,IAAP,KAAgBhE,IAApB,EAA0B;QACtBsB,KAAK,CAAC2C,eAAN;MACH,CAFD,MAEO,IAAI1D,MAAM,CAACqC,KAAP,KAAiB5C,IAArB,EAA2B;QAC9BsB,KAAK,CAAC4C,gBAAN;MACH,CAFM,MAEA;QACH1E,MAAM,CAACe,MAAM,CAACiD,IAAP,KAAgBxD,IAAjB,CAAN;QACAsB,KAAK,CAAC6C,eAAN;MACH;;MACD;;IAEJ,KAAK,mBAAL;MAEI;AACZ;AACA;AACA;AACA;MACY,IAAI5D,MAAM,CAACqC,KAAP,KAAiB5C,IAArB,EAA2B;QACvBsB,KAAK,CAAC8C,eAAN;QACA9C,KAAK,CAAC+C,cAAN;QACA/C,KAAK,CAACgD,QAAN;MACH;;MACD;;IAEJ;MACI;EApHR;AAsHH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCnD,QAAhC,EAA0CpB,IAA1C,EAAgD;EAC5C,IAAIqB,QAAQ,GAAGD,QAAQ,CAACC,QAAxB;EACA,IAAIC,KAAK,GAAGD,QAAQ,IAAI1B,QAAQ,CAAC4B,QAAT,CAAkBF,QAAlB,CAAxB;EACA,MAAMd,MAAM,GAAGP,IAAI,CAACO,MAApB;;EAEA,QAAQP,IAAI,CAACQ,IAAb;IACI,KAAK,SAAL;IACA,KAAK,qBAAL;IACA,KAAK,oBAAL;IACA,KAAK,yBAAL;MACI,IAAIa,QAAJ,EAAc;QAEV;QACAF,oBAAoB,CAACC,QAAD,EAAWpB,IAAX,CAApB;QACAF,KAAK,CAAC0E,SAAN,CAAgBxE,IAAhB,EAAsBsB,KAAtB,EAA6B,KAA7B;MACH,CANL,CAQI;;;MACAD,QAAQ,GAAGD,QAAQ,CAACC,QAAT,GAAoB,IAAI1B,QAAJ,CAC3ByB,QAAQ,CAACqD,WAAT,CAAqBC,IAArB,EAD2B,EAE3BrD,QAF2B,EAG3BD,QAAQ,CAACuD,QAHkB,CAA/B;MAKArD,KAAK,GAAG3B,QAAQ,CAAC4B,QAAT,CAAkBF,QAAlB,CAAR,CAdJ,CAgBI;;MACAvB,KAAK,CAACmC,IAAN,CAAY,mBAAkBZ,QAAQ,CAACN,EAAG,EAA1C;MACAK,QAAQ,CAACe,OAAT,CAAiBC,IAAjB,CAAsB,iBAAtB,EAAyCf,QAAzC,EAAmDrB,IAAnD;MACA;;IAEJ,KAAK,iBAAL;MACIsB,KAAK,CAACsD,gBAAN;MACA;;IACJ,KAAK,gBAAL;MACI,IAAI5E,IAAI,CAACwC,QAAL,KAAkB,IAAtB,EAA4B;QACxBlB,KAAK,CAACuD,gBAAN;MACH;;MACD;;IACJ,KAAK,kBAAL;MACI,IAAI7E,IAAI,CAACwC,QAAL,KAAkB,IAAtB,EAA4B;QACxBlB,KAAK,CAACuD,gBAAN;MACH;;MACD;;IAEJ,KAAK,mBAAL;MACI,IAAI1E,wBAAwB,CAACH,IAAI,CAACI,QAAN,CAA5B,EAA6C;QACzCkB,KAAK,CAACwD,iBAAN,CACI9E,IAAI,CAACI,QADT,EAEIO,sBAAsB,CAACX,IAAD,CAF1B;MAIH;;MACD;;IAEJ,KAAK,sBAAL;MACI,IAAIK,2BAA2B,CAACL,IAAI,CAACI,QAAN,CAA/B,EAAgD;QAC5CkB,KAAK,CAACwD,iBAAN,CACI9E,IAAI,CAACI,QAAL,CAAc2E,KAAd,CAAoB,CAApB,EAAuB,CAAC,CAAxB,CADJ,EACgC;QAC5BpE,sBAAsB,CAACX,IAAD,CAF1B;MAIH;;MACD;;IAEJ,KAAK,uBAAL;IACA,KAAK,aAAL;MACIsB,KAAK,CAACwD,iBAAN,CAAwB,MAAxB,EAAgC,KAAhC;MACA;;IAEJ,KAAK,iBAAL;MACIxD,KAAK,CAAC0D,iBAAN,CACIhF,IAAI,CAACiF,KAAL,CAAWC,IAAX,CAAgBnF,UAAhB,CADJ,EAEIO,QAAQ,CAACN,IAAD,CAFZ;MAIA;;IAEJ,KAAK,cAAL;MACIsB,KAAK,CAAC6D,cAAN,CAAqBlF,OAAO,CAACD,IAAI,CAACqD,SAAN,CAA5B;MACA;;IAEJ,KAAK,YAAL;MAEI;AACZ;AACA;AACA;AACA;MACY,IAAI9C,MAAM,CAAC6E,YAAP,KAAwBpF,IAAxB,IAAgCO,MAAM,CAAC0E,KAAP,CAAa,CAAb,MAAoBjF,IAAxD,EAA8D;QAC1DsB,KAAK,CAACgD,QAAN;MACH;;MACD;;IAEJ,KAAK,gBAAL;IACA,KAAK,kBAAL;IACA,KAAK,cAAL;IACA,KAAK,gBAAL;IACA,KAAK,gBAAL;MACIhD,KAAK,CAAC+D,eAAN,CAAsBrF,IAAI,CAACQ,IAA3B,EAAiCF,QAAQ,CAACN,IAAD,CAAzC;MACA;;IAEJ,KAAK,kBAAL;MACI,IAAI,CAACN,oBAAoB,CAACQ,IAArB,CAA0BF,IAAI,CAACwD,IAAL,CAAUhD,IAApC,CAAL,EAAgD;QAC5Cc,KAAK,CAACgE,gBAAN,CAAuB,KAAvB,EAA8BtF,IAAI,CAACS,KAAL,CAAWC,IAAzC;MACH;;MACD;;IAEJ;MACI;EApGR,CAL4C,CA4G5C;;;EACAS,oBAAoB,CAACC,QAAD,EAAWpB,IAAX,CAApB;EACAF,KAAK,CAAC0E,SAAN,CAAgBxE,IAAhB,EAAsBsB,KAAtB,EAA6B,KAA7B;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiE,qBAAT,CAA+BnE,QAA/B,EAAyCpB,IAAzC,EAA+C;EAC3C,MAAMqB,QAAQ,GAAGD,QAAQ,CAACC,QAA1B;EACA,MAAMC,KAAK,GAAG3B,QAAQ,CAAC4B,QAAT,CAAkBF,QAAlB,CAAd;EACA,IAAImE,WAAW,GAAG,KAAlB;;EAEA,QAAQxF,IAAI,CAACQ,IAAb;IACI,KAAK,iBAAL;MACIc,KAAK,CAACmE,eAAN;MACA;;IAEJ,KAAK,aAAL;IACA,KAAK,uBAAL;MACInE,KAAK,CAACoE,gBAAN;MACA;;IAEJ,KAAK,mBAAL;MACI,IAAIvF,wBAAwB,CAACH,IAAI,CAACI,QAAN,CAA5B,EAA6C;QACzCkB,KAAK,CAACoE,gBAAN;MACH;;MACD;;IAEJ,KAAK,sBAAL;MACI,IAAIrF,2BAA2B,CAACL,IAAI,CAACI,QAAN,CAA/B,EAAgD;QAC5CkB,KAAK,CAACoE,gBAAN;MACH;;MACD;;IAEJ,KAAK,iBAAL;MACIpE,KAAK,CAACqE,gBAAN;MACA;;IAEJ,KAAK,YAAL;MAEI;AACZ;AACA;AACA;AACA;MACY,IAAI3F,IAAI,CAAC8C,UAAL,CAAgBjB,MAAhB,KAA2B,CAA/B,EAAkC;QAC9BP,KAAK,CAAC4B,kBAAN,CAAyB,IAAzB,EAA+B,CAAClD,IAAI,CAACE,IAArC;MACH;;MACD,IAAIoB,KAAK,CAACsE,WAAN,CAAkB1D,SAAtB,EAAiC;QAC7BsD,WAAW,GAAG,IAAd;MACH;;MACD;;IAEJ,KAAK,cAAL;MACIlE,KAAK,CAACuE,aAAN;MACA;;IAEJ,KAAK,gBAAL;MACI1E,oBAAoB,CAACC,QAAD,EAAWpB,IAAX,CAApB;MACAsB,KAAK,CAACwE,SAAN,CAAgB9F,IAAI,CAACS,KAAL,IAAcT,IAAI,CAACS,KAAL,CAAWC,IAAzC;MACA8E,WAAW,GAAG,IAAd;MACA;;IAEJ,KAAK,mBAAL;MACIrE,oBAAoB,CAACC,QAAD,EAAWpB,IAAX,CAApB;MACAsB,KAAK,CAACyE,YAAN,CAAmB/F,IAAI,CAACS,KAAL,IAAcT,IAAI,CAACS,KAAL,CAAWC,IAA5C;MACA8E,WAAW,GAAG,IAAd;MACA;;IAEJ,KAAK,iBAAL;MACIrE,oBAAoB,CAACC,QAAD,EAAWpB,IAAX,CAApB;MACAsB,KAAK,CAAC0E,UAAN;MACAR,WAAW,GAAG,IAAd;MACA;;IAEJ,KAAK,gBAAL;MACIrE,oBAAoB,CAACC,QAAD,EAAWpB,IAAX,CAApB;MACAsB,KAAK,CAAC2E,SAAN;MACAT,WAAW,GAAG,IAAd;MACA;;IAEJ,KAAK,YAAL;MACI,IAAI1E,qBAAqB,CAACd,IAAD,CAAzB,EAAiC;QAC7BsB,KAAK,CAAC4E,gCAAN;QACAV,WAAW,GAAG,IAAd;MACH;;MACD;;IAEJ,KAAK,gBAAL;IACA,KAAK,kBAAL;IACA,KAAK,kBAAL;IACA,KAAK,eAAL;IACA,KAAK,iBAAL;MACIlE,KAAK,CAAC4E,gCAAN;MACA;;IAEJ,KAAK,gBAAL;IACA,KAAK,kBAAL;IACA,KAAK,cAAL;IACA,KAAK,gBAAL;IACA,KAAK,gBAAL;MACI5E,KAAK,CAAC6E,cAAN;MACA;;IAEJ,KAAK,mBAAL;MACI7E,KAAK,CAAC8E,cAAN;MACA;;IAEJ,KAAK,kBAAL;MACI,IAAI,CAAC1G,oBAAoB,CAACQ,IAArB,CAA0BF,IAAI,CAACwD,IAAL,CAAUhD,IAApC,CAAL,EAAgD;QAC5Cc,KAAK,CAAC+E,eAAN;MACH;;MACD;;IAEJ;MACI;EAvGR,CAL2C,CA+G3C;;;EACA,IAAI,CAACb,WAAL,EAAkB;IACdrE,oBAAoB,CAACC,QAAD,EAAWpB,IAAX,CAApB;EACH;;EACDF,KAAK,CAAC0E,SAAN,CAAgBxE,IAAhB,EAAsBsB,KAAtB,EAA6B,IAA7B;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgF,WAAT,CAAqBlF,QAArB,EAA+BpB,IAA/B,EAAqC;EACjC,QAAQA,IAAI,CAACQ,IAAb;IACI,KAAK,SAAL;IACA,KAAK,qBAAL;IACA,KAAK,oBAAL;IACA,KAAK,yBAAL;MAAgC;QAC5B,IAAIa,QAAQ,GAAGD,QAAQ,CAACC,QAAxB,CAD4B,CAG5B;;QACA1B,QAAQ,CAAC4B,QAAT,CAAkBF,QAAlB,EAA4BkF,SAA5B,GAJ4B,CAM5B;;QACAjE,uBAAuB,CAAClB,QAAD,EAAWpB,IAAX,CAAvB,CAP4B,CAS5B;;QACAF,KAAK,CAACmC,IAAN,CAAY,iBAAgBZ,QAAQ,CAACN,EAAG,EAAxC;QACAK,QAAQ,CAACe,OAAT,CAAiBC,IAAjB,CAAsB,eAAtB,EAAuCf,QAAvC,EAAiDrB,IAAjD;QACAF,KAAK,CAAC0G,OAAN,CAAcnF,QAAd;QAEAA,QAAQ,GAAGD,QAAQ,CAACC,QAAT,GAAoBD,QAAQ,CAACC,QAAT,CAAkBoF,KAAjD;;QACA,IAAIpF,QAAJ,EAAc;UACVvB,KAAK,CAAC0E,SAAN,CAAgBxE,IAAhB,EAAsBL,QAAQ,CAAC4B,QAAT,CAAkBF,QAAlB,CAAtB,EAAmD,IAAnD;QACH;;QACD;MACH;IAED;;IACA,KAAK,gBAAL;MACI,IAAIrB,IAAI,CAACwC,QAAL,KAAkB,IAAlB,IAA0BxC,IAAI,CAACyC,SAAL,CAAeZ,MAAf,KAA0B,CAAxD,EAA2D;QACvDlC,QAAQ,CAAC4B,QAAT,CAAkBH,QAAQ,CAACC,QAA3B,EAAqCqB,iBAArC;MACH;;MACD;;IAEJ;MACI;EAjCR;AAmCH,C,CAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACA,MAAMgE,gBAAN,CAAuB;EAEnB;;EACA;AACJ;AACA;EACIC,WAAW,CAACC,cAAD,EAAiB;IACxB,KAAKC,QAAL,GAAgBD,cAAhB;IACA,KAAKzE,OAAL,GAAeyE,cAAc,CAACzE,OAA9B;IACA,KAAKd,QAAL,GAAgB,IAAhB;IACA,KAAKoD,WAAL,GAAmB,IAAI5E,WAAJ,CAAgB,GAAhB,CAAnB;IACA,KAAKiH,WAAL,GAAmB,IAAnB;IACA,KAAKnC,QAAL,GAAgB,KAAKA,QAAL,CAAcoC,IAAd,CAAmB,IAAnB,CAAhB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIC,SAAS,CAAChH,IAAD,EAAO;IACZ,KAAK8G,WAAL,GAAmB9G,IAAnB,CADY,CAGZ;;IACA,IAAIA,IAAI,CAACO,MAAT,EAAiB;MACbgC,UAAU,CAAC,IAAD,EAAOvC,IAAP,CAAV;IACH;IAED;AACR;AACA;AACA;;;IACQuE,sBAAsB,CAAC,IAAD,EAAOvE,IAAP,CAAtB,CAZY,CAcZ;;IACA,KAAK6G,QAAL,CAAcG,SAAd,CAAwBhH,IAAxB;IAEA,KAAK8G,WAAL,GAAmB,IAAnB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIG,SAAS,CAACjH,IAAD,EAAO;IACZ,KAAK8G,WAAL,GAAmB9G,IAAnB;IAEA;AACR;AACA;AACA;;IACQuF,qBAAqB,CAAC,IAAD,EAAOvF,IAAP,CAArB,CAPY,CASZ;;IACA,KAAK6G,QAAL,CAAcI,SAAd,CAAwBjH,IAAxB,EAVY,CAYZ;;IACAsG,WAAW,CAAC,IAAD,EAAOtG,IAAP,CAAX;IAEA,KAAK8G,WAAL,GAAmB,IAAnB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACInC,QAAQ,CAACuC,WAAD,EAAcC,SAAd,EAAyB;IAC7B,IAAID,WAAW,CAAChF,SAAZ,IAAyBiF,SAAS,CAACjF,SAAvC,EAAkD;MAC9CpC,KAAK,CAACmC,IAAN,CAAY,yBAAwBiF,WAAW,CAACnG,EAAG,OAAMoG,SAAS,CAACpG,EAAG,EAAtE;MACA,KAAKoB,OAAL,CAAaC,IAAb,CACI,uBADJ,EAEI8E,WAFJ,EAGIC,SAHJ,EAII,KAAKL,WAJT;IAMH;EACJ;;AAlFkB;;AAqFvBM,MAAM,CAACC,OAAP,GAAiBX,gBAAjB"},"metadata":{},"sourceType":"script"}