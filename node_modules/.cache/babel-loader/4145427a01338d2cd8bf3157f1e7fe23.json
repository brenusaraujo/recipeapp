{"ast":null,"code":"/**\n * @fileoverview `IgnorePattern` class.\n *\n * `IgnorePattern` class has the set of glob patterns and the base path.\n *\n * It provides two static methods.\n *\n * - `IgnorePattern.createDefaultIgnore(cwd)`\n *      Create the default predicate function.\n * - `IgnorePattern.createIgnore(ignorePatterns)`\n *      Create the predicate function from multiple `IgnorePattern` objects.\n *\n * It provides two properties and a method.\n *\n * - `patterns`\n *      The glob patterns that ignore to lint.\n * - `basePath`\n *      The base path of the glob patterns. If absolute paths existed in the\n *      glob patterns, those are handled as relative paths to the base path.\n * - `getPatternsRelativeTo(basePath)`\n *      Get `patterns` as modified for a given base path. It modifies the\n *      absolute paths in the patterns as prepending the difference of two base\n *      paths.\n *\n * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes\n * `ignorePatterns` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst path = require(\"path\");\n\nconst ignore = require(\"ignore\");\n\nconst debug = require(\"debug\")(\"eslintrc:ignore-pattern\");\n/** @typedef {ReturnType<import(\"ignore\").default>} Ignore */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the path to the common ancestor directory of given paths.\n * @param {string[]} sourcePaths The paths to calculate the common ancestor.\n * @returns {string} The path to the common ancestor directory.\n */\n\n\nfunction getCommonAncestorPath(sourcePaths) {\n  let result = sourcePaths[0];\n\n  for (let i = 1; i < sourcePaths.length; ++i) {\n    const a = result;\n    const b = sourcePaths[i]; // Set the shorter one (it's the common ancestor if one includes the other).\n\n    result = a.length < b.length ? a : b; // Set the common ancestor.\n\n    for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {\n      if (a[j] !== b[j]) {\n        result = a.slice(0, lastSepPos);\n        break;\n      }\n\n      if (a[j] === path.sep) {\n        lastSepPos = j;\n      }\n    }\n  }\n\n  let resolvedResult = result || path.sep; // if Windows common ancestor is root of drive must have trailing slash to be absolute.\n\n  if (resolvedResult && resolvedResult.endsWith(\":\") && process.platform === \"win32\") {\n    resolvedResult += path.sep;\n  }\n\n  return resolvedResult;\n}\n/**\n * Make relative path.\n * @param {string} from The source path to get relative path.\n * @param {string} to The destination path to get relative path.\n * @returns {string} The relative path.\n */\n\n\nfunction relative(from, to) {\n  const relPath = path.relative(from, to);\n\n  if (path.sep === \"/\") {\n    return relPath;\n  }\n\n  return relPath.split(path.sep).join(\"/\");\n}\n/**\n * Get the trailing slash if existed.\n * @param {string} filePath The path to check.\n * @returns {string} The trailing slash if existed.\n */\n\n\nfunction dirSuffix(filePath) {\n  const isDir = filePath.endsWith(path.sep) || process.platform === \"win32\" && filePath.endsWith(\"/\");\n  return isDir ? \"/\" : \"\";\n}\n\nconst DefaultPatterns = Object.freeze([\"/**/node_modules/*\"]);\nconst DotPatterns = Object.freeze([\".*\", \"!.eslintrc.*\", \"!../\"]); //------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nclass IgnorePattern {\n  /**\n   * The default patterns.\n   * @type {string[]}\n   */\n  static get DefaultPatterns() {\n    return DefaultPatterns;\n  }\n  /**\n   * Create the default predicate function.\n   * @param {string} cwd The current working directory.\n   * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}\n   * The preficate function.\n   * The first argument is an absolute path that is checked.\n   * The second argument is the flag to not ignore dotfiles.\n   * If the predicate function returned `true`, it means the path should be ignored.\n   */\n\n\n  static createDefaultIgnore(cwd) {\n    return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);\n  }\n  /**\n   * Create the predicate function from multiple `IgnorePattern` objects.\n   * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.\n   * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}\n   * The preficate function.\n   * The first argument is an absolute path that is checked.\n   * The second argument is the flag to not ignore dotfiles.\n   * If the predicate function returned `true`, it means the path should be ignored.\n   */\n\n\n  static createIgnore(ignorePatterns) {\n    debug(\"Create with: %o\", ignorePatterns);\n    const basePath = getCommonAncestorPath(ignorePatterns.map(p => p.basePath));\n    const patterns = [].concat(...ignorePatterns.map(p => p.getPatternsRelativeTo(basePath)));\n    const ig = ignore().add([...DotPatterns, ...patterns]);\n    const dotIg = ignore().add(patterns);\n    debug(\"  processed: %o\", {\n      basePath,\n      patterns\n    });\n    return Object.assign(function (filePath) {\n      let dot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      assert(path.isAbsolute(filePath), \"'filePath' should be an absolute path.\");\n      const relPathRaw = relative(basePath, filePath);\n      const relPath = relPathRaw && relPathRaw + dirSuffix(filePath);\n      const adoptedIg = dot ? dotIg : ig;\n      const result = relPath !== \"\" && adoptedIg.ignores(relPath);\n      debug(\"Check\", {\n        filePath,\n        dot,\n        relativePath: relPath,\n        result\n      });\n      return result;\n    }, {\n      basePath,\n      patterns\n    });\n  }\n  /**\n   * Initialize a new `IgnorePattern` instance.\n   * @param {string[]} patterns The glob patterns that ignore to lint.\n   * @param {string} basePath The base path of `patterns`.\n   */\n\n\n  constructor(patterns, basePath) {\n    assert(path.isAbsolute(basePath), \"'basePath' should be an absolute path.\");\n    /**\n     * The glob patterns that ignore to lint.\n     * @type {string[]}\n     */\n\n    this.patterns = patterns;\n    /**\n     * The base path of `patterns`.\n     * @type {string}\n     */\n\n    this.basePath = basePath;\n    /**\n     * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.\n     *\n     * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.\n     * It's `false` as-is for `ignorePatterns` property in config files.\n     * @type {boolean}\n     */\n\n    this.loose = false;\n  }\n  /**\n   * Get `patterns` as modified for a given base path. It modifies the\n   * absolute paths in the patterns as prepending the difference of two base\n   * paths.\n   * @param {string} newBasePath The base path.\n   * @returns {string[]} Modifired patterns.\n   */\n\n\n  getPatternsRelativeTo(newBasePath) {\n    assert(path.isAbsolute(newBasePath), \"'newBasePath' should be an absolute path.\");\n    const {\n      basePath,\n      loose,\n      patterns\n    } = this;\n\n    if (newBasePath === basePath) {\n      return patterns;\n    }\n\n    const prefix = `/${relative(newBasePath, basePath)}`;\n    return patterns.map(pattern => {\n      const negative = pattern.startsWith(\"!\");\n      const head = negative ? \"!\" : \"\";\n      const body = negative ? pattern.slice(1) : pattern;\n\n      if (body.startsWith(\"/\") || body.startsWith(\"../\")) {\n        return `${head}${prefix}${body}`;\n      }\n\n      return loose ? pattern : `${head}${prefix}/**/${body}`;\n    });\n  }\n\n}\n\nmodule.exports = {\n  IgnorePattern\n};","map":{"version":3,"names":["assert","require","path","ignore","debug","getCommonAncestorPath","sourcePaths","result","i","length","a","b","j","lastSepPos","slice","sep","resolvedResult","endsWith","process","platform","relative","from","to","relPath","split","join","dirSuffix","filePath","isDir","DefaultPatterns","Object","freeze","DotPatterns","IgnorePattern","createDefaultIgnore","cwd","createIgnore","ignorePatterns","basePath","map","p","patterns","concat","getPatternsRelativeTo","ig","add","dotIg","assign","dot","isAbsolute","relPathRaw","adoptedIg","ignores","relativePath","constructor","loose","newBasePath","prefix","pattern","negative","startsWith","head","body","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/@eslint/eslintrc/lib/config-array/ignore-pattern.js"],"sourcesContent":["/**\n * @fileoverview `IgnorePattern` class.\n *\n * `IgnorePattern` class has the set of glob patterns and the base path.\n *\n * It provides two static methods.\n *\n * - `IgnorePattern.createDefaultIgnore(cwd)`\n *      Create the default predicate function.\n * - `IgnorePattern.createIgnore(ignorePatterns)`\n *      Create the predicate function from multiple `IgnorePattern` objects.\n *\n * It provides two properties and a method.\n *\n * - `patterns`\n *      The glob patterns that ignore to lint.\n * - `basePath`\n *      The base path of the glob patterns. If absolute paths existed in the\n *      glob patterns, those are handled as relative paths to the base path.\n * - `getPatternsRelativeTo(basePath)`\n *      Get `patterns` as modified for a given base path. It modifies the\n *      absolute paths in the patterns as prepending the difference of two base\n *      paths.\n *\n * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes\n * `ignorePatterns` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst path = require(\"path\");\nconst ignore = require(\"ignore\");\nconst debug = require(\"debug\")(\"eslintrc:ignore-pattern\");\n\n/** @typedef {ReturnType<import(\"ignore\").default>} Ignore */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the path to the common ancestor directory of given paths.\n * @param {string[]} sourcePaths The paths to calculate the common ancestor.\n * @returns {string} The path to the common ancestor directory.\n */\nfunction getCommonAncestorPath(sourcePaths) {\n    let result = sourcePaths[0];\n\n    for (let i = 1; i < sourcePaths.length; ++i) {\n        const a = result;\n        const b = sourcePaths[i];\n\n        // Set the shorter one (it's the common ancestor if one includes the other).\n        result = a.length < b.length ? a : b;\n\n        // Set the common ancestor.\n        for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {\n            if (a[j] !== b[j]) {\n                result = a.slice(0, lastSepPos);\n                break;\n            }\n            if (a[j] === path.sep) {\n                lastSepPos = j;\n            }\n        }\n    }\n\n    let resolvedResult = result || path.sep;\n\n    // if Windows common ancestor is root of drive must have trailing slash to be absolute.\n    if (resolvedResult && resolvedResult.endsWith(\":\") && process.platform === \"win32\") {\n        resolvedResult += path.sep;\n    }\n    return resolvedResult;\n}\n\n/**\n * Make relative path.\n * @param {string} from The source path to get relative path.\n * @param {string} to The destination path to get relative path.\n * @returns {string} The relative path.\n */\nfunction relative(from, to) {\n    const relPath = path.relative(from, to);\n\n    if (path.sep === \"/\") {\n        return relPath;\n    }\n    return relPath.split(path.sep).join(\"/\");\n}\n\n/**\n * Get the trailing slash if existed.\n * @param {string} filePath The path to check.\n * @returns {string} The trailing slash if existed.\n */\nfunction dirSuffix(filePath) {\n    const isDir = (\n        filePath.endsWith(path.sep) ||\n        (process.platform === \"win32\" && filePath.endsWith(\"/\"))\n    );\n\n    return isDir ? \"/\" : \"\";\n}\n\nconst DefaultPatterns = Object.freeze([\"/**/node_modules/*\"]);\nconst DotPatterns = Object.freeze([\".*\", \"!.eslintrc.*\", \"!../\"]);\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nclass IgnorePattern {\n\n    /**\n     * The default patterns.\n     * @type {string[]}\n     */\n    static get DefaultPatterns() {\n        return DefaultPatterns;\n    }\n\n    /**\n     * Create the default predicate function.\n     * @param {string} cwd The current working directory.\n     * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createDefaultIgnore(cwd) {\n        return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);\n    }\n\n    /**\n     * Create the predicate function from multiple `IgnorePattern` objects.\n     * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.\n     * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createIgnore(ignorePatterns) {\n        debug(\"Create with: %o\", ignorePatterns);\n\n        const basePath = getCommonAncestorPath(ignorePatterns.map(p => p.basePath));\n        const patterns = [].concat(\n            ...ignorePatterns.map(p => p.getPatternsRelativeTo(basePath))\n        );\n        const ig = ignore().add([...DotPatterns, ...patterns]);\n        const dotIg = ignore().add(patterns);\n\n        debug(\"  processed: %o\", { basePath, patterns });\n\n        return Object.assign(\n            (filePath, dot = false) => {\n                assert(path.isAbsolute(filePath), \"'filePath' should be an absolute path.\");\n                const relPathRaw = relative(basePath, filePath);\n                const relPath = relPathRaw && (relPathRaw + dirSuffix(filePath));\n                const adoptedIg = dot ? dotIg : ig;\n                const result = relPath !== \"\" && adoptedIg.ignores(relPath);\n\n                debug(\"Check\", { filePath, dot, relativePath: relPath, result });\n                return result;\n            },\n            { basePath, patterns }\n        );\n    }\n\n    /**\n     * Initialize a new `IgnorePattern` instance.\n     * @param {string[]} patterns The glob patterns that ignore to lint.\n     * @param {string} basePath The base path of `patterns`.\n     */\n    constructor(patterns, basePath) {\n        assert(path.isAbsolute(basePath), \"'basePath' should be an absolute path.\");\n\n        /**\n         * The glob patterns that ignore to lint.\n         * @type {string[]}\n         */\n        this.patterns = patterns;\n\n        /**\n         * The base path of `patterns`.\n         * @type {string}\n         */\n        this.basePath = basePath;\n\n        /**\n         * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.\n         *\n         * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.\n         * It's `false` as-is for `ignorePatterns` property in config files.\n         * @type {boolean}\n         */\n        this.loose = false;\n    }\n\n    /**\n     * Get `patterns` as modified for a given base path. It modifies the\n     * absolute paths in the patterns as prepending the difference of two base\n     * paths.\n     * @param {string} newBasePath The base path.\n     * @returns {string[]} Modifired patterns.\n     */\n    getPatternsRelativeTo(newBasePath) {\n        assert(path.isAbsolute(newBasePath), \"'newBasePath' should be an absolute path.\");\n        const { basePath, loose, patterns } = this;\n\n        if (newBasePath === basePath) {\n            return patterns;\n        }\n        const prefix = `/${relative(newBasePath, basePath)}`;\n\n        return patterns.map(pattern => {\n            const negative = pattern.startsWith(\"!\");\n            const head = negative ? \"!\" : \"\";\n            const body = negative ? pattern.slice(1) : pattern;\n\n            if (body.startsWith(\"/\") || body.startsWith(\"../\")) {\n                return `${head}${prefix}${body}`;\n            }\n            return loose ? pattern : `${head}${prefix}/**/${body}`;\n        });\n    }\n}\n\nmodule.exports = { IgnorePattern };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}