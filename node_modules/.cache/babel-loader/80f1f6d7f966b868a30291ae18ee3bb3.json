{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useStateWithRef = void 0;\n\nconst react_1 = require(\"react\");\n/**\n * Like useState, but also returns a ref that's always instantly updated.\n *\n * This is useful in two cases:\n *\n * 1. You need to both force a re-render when a variable changes, and\n *    also avoid re-running side effects (for example, a network call), even\n *    before the state fully updates for the component.\n * 2. Multiple callbacks need to modify the same object or array before the\n *    state updates. For example, if one callback tries to append 4 to\n *    `[1, 2, 3]` and another tries to append 5, we may end up with only\n *    `[1, 2, 3, 5]` instead of `[1, 2, 3, 4, 5]`\n */\n\n\nconst useStateWithRef = initialState => {\n  const [value, setValue] = (0, react_1.useState)(initialState); // Need to explicitly type this out, or the overloads can confuse the\n  // compiler to think that this might be a React Component ref\n\n  const valueRef = (0, react_1.useRef)(initialState);\n  const setValueAndRef = (0, react_1.useCallback)(newValue => {\n    valueRef.current = newValue;\n    setValue(newValue);\n  }, []);\n  return [value, setValueAndRef, valueRef];\n};\n\nexports.useStateWithRef = useStateWithRef;","map":{"version":3,"sources":["../../src/hooks/use-state-with-ref.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,OAAA,CAAA;AAEA;;;;;;;;;;;;AAYG;;;AACI,MAAM,eAAe,GAC1B,YAD6B,IAEsB;EACnD,MAAM,CAAC,KAAD,EAAQ,QAAR,IAAoB,CAAA,GAAA,OAAA,CAAA,QAAA,EAAS,YAAT,CAA1B,CADmD,CAEnD;EACA;;EACA,MAAM,QAAQ,GAAG,CAAA,GAAA,OAAA,CAAA,MAAA,EAAU,YAAV,CAAjB;EAEA,MAAM,cAAc,GAAG,CAAA,GAAA,OAAA,CAAA,WAAA,EAAa,QAAD,IAAgB;IACjD,QAAQ,CAAC,OAAT,GAAmB,QAAnB;IACA,QAAQ,CAAC,QAAD,CAAR;EACD,CAHsB,EAGpB,EAHoB,CAAvB;EAKA,OAAO,CAAC,KAAD,EAAQ,cAAR,EAAwB,QAAxB,CAAP;AACD,CAdM;;AAAM,OAAA,CAAA,eAAA,GAAe,eAAf","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useStateWithRef = void 0;\nconst react_1 = require(\"react\");\n/**\n * Like useState, but also returns a ref that's always instantly updated.\n *\n * This is useful in two cases:\n *\n * 1. You need to both force a re-render when a variable changes, and\n *    also avoid re-running side effects (for example, a network call), even\n *    before the state fully updates for the component.\n * 2. Multiple callbacks need to modify the same object or array before the\n *    state updates. For example, if one callback tries to append 4 to\n *    `[1, 2, 3]` and another tries to append 5, we may end up with only\n *    `[1, 2, 3, 5]` instead of `[1, 2, 3, 4, 5]`\n */\nconst useStateWithRef = (initialState) => {\n    const [value, setValue] = (0, react_1.useState)(initialState);\n    // Need to explicitly type this out, or the overloads can confuse the\n    // compiler to think that this might be a React Component ref\n    const valueRef = (0, react_1.useRef)(initialState);\n    const setValueAndRef = (0, react_1.useCallback)((newValue) => {\n        valueRef.current = newValue;\n        setValue(newValue);\n    }, []);\n    return [value, setValueAndRef, valueRef];\n};\nexports.useStateWithRef = useStateWithRef;\n"]},"metadata":{},"sourceType":"script"}