{"ast":null,"code":"/**\n * @fileoverview A variant of EventEmitter which does not give listeners information about each other\n * @author Teddy Katz\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An event emitter\n * @typedef {Object} SafeEmitter\n * @property {function(eventName: string, listenerFunc: Function): void} on Adds a listener for a given event name\n * @property {function(eventName: string, arg1?: any, arg2?: any, arg3?: any)} emit Emits an event with a given name.\n * This calls all the listeners that were listening for that name, with `arg1`, `arg2`, and `arg3` as arguments.\n * @property {function(): string[]} eventNames Gets the list of event names that have registered listeners.\n */\n\n/**\n * Creates an object which can listen for and emit events.\n * This is similar to the EventEmitter API in Node's standard library, but it has a few differences.\n * The goal is to allow multiple modules to attach arbitrary listeners to the same emitter, without\n * letting the modules know about each other at all.\n * 1. It has no special keys like `error` and `newListener`, which would allow modules to detect when\n * another module throws an error or registers a listener.\n * 2. It calls listener functions without any `this` value. (`EventEmitter` calls listeners with a\n * `this` value of the emitter instance, which would give listeners access to other listeners.)\n * @returns {SafeEmitter} An emitter\n */\n\nmodule.exports = () => {\n  const listeners = Object.create(null);\n  return Object.freeze({\n    on(eventName, listener) {\n      if (eventName in listeners) {\n        listeners[eventName].push(listener);\n      } else {\n        listeners[eventName] = [listener];\n      }\n    },\n\n    emit(eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (eventName in listeners) {\n        listeners[eventName].forEach(listener => listener(...args));\n      }\n    },\n\n    eventNames() {\n      return Object.keys(listeners);\n    }\n\n  });\n};","map":{"version":3,"names":["module","exports","listeners","Object","create","freeze","on","eventName","listener","push","emit","args","forEach","eventNames","keys"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/safe-emitter.js"],"sourcesContent":["/**\n * @fileoverview A variant of EventEmitter which does not give listeners information about each other\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An event emitter\n * @typedef {Object} SafeEmitter\n * @property {function(eventName: string, listenerFunc: Function): void} on Adds a listener for a given event name\n * @property {function(eventName: string, arg1?: any, arg2?: any, arg3?: any)} emit Emits an event with a given name.\n * This calls all the listeners that were listening for that name, with `arg1`, `arg2`, and `arg3` as arguments.\n * @property {function(): string[]} eventNames Gets the list of event names that have registered listeners.\n */\n\n/**\n * Creates an object which can listen for and emit events.\n * This is similar to the EventEmitter API in Node's standard library, but it has a few differences.\n * The goal is to allow multiple modules to attach arbitrary listeners to the same emitter, without\n * letting the modules know about each other at all.\n * 1. It has no special keys like `error` and `newListener`, which would allow modules to detect when\n * another module throws an error or registers a listener.\n * 2. It calls listener functions without any `this` value. (`EventEmitter` calls listeners with a\n * `this` value of the emitter instance, which would give listeners access to other listeners.)\n * @returns {SafeEmitter} An emitter\n */\nmodule.exports = () => {\n    const listeners = Object.create(null);\n\n    return Object.freeze({\n        on(eventName, listener) {\n            if (eventName in listeners) {\n                listeners[eventName].push(listener);\n            } else {\n                listeners[eventName] = [listener];\n            }\n        },\n        emit(eventName, ...args) {\n            if (eventName in listeners) {\n                listeners[eventName].forEach(listener => listener(...args));\n            }\n        },\n        eventNames() {\n            return Object.keys(listeners);\n        }\n    });\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,OAAP,GAAiB,MAAM;EACnB,MAAMC,SAAS,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAlB;EAEA,OAAOD,MAAM,CAACE,MAAP,CAAc;IACjBC,EAAE,CAACC,SAAD,EAAYC,QAAZ,EAAsB;MACpB,IAAID,SAAS,IAAIL,SAAjB,EAA4B;QACxBA,SAAS,CAACK,SAAD,CAAT,CAAqBE,IAArB,CAA0BD,QAA1B;MACH,CAFD,MAEO;QACHN,SAAS,CAACK,SAAD,CAAT,GAAuB,CAACC,QAAD,CAAvB;MACH;IACJ,CAPgB;;IAQjBE,IAAI,CAACH,SAAD,EAAqB;MAAA,kCAANI,IAAM;QAANA,IAAM;MAAA;;MACrB,IAAIJ,SAAS,IAAIL,SAAjB,EAA4B;QACxBA,SAAS,CAACK,SAAD,CAAT,CAAqBK,OAArB,CAA6BJ,QAAQ,IAAIA,QAAQ,CAAC,GAAGG,IAAJ,CAAjD;MACH;IACJ,CAZgB;;IAajBE,UAAU,GAAG;MACT,OAAOV,MAAM,CAACW,IAAP,CAAYZ,SAAZ,CAAP;IACH;;EAfgB,CAAd,CAAP;AAiBH,CApBD"},"metadata":{},"sourceType":"script"}