{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  getStaticValue\n} = require(\"eslint-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`-like methods\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implied-eval\"\n    },\n    schema: [],\n    messages: {\n      impliedEval: \"Implied eval. Consider passing a function instead of a string.\"\n    }\n  },\n\n  create(context) {\n    const GLOBAL_CANDIDATES = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n    const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;\n    /**\n     * Checks whether a node is evaluated as a string or not.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node is evaluated as a string.\n     */\n\n    function isEvaluatedString(node) {\n      if (node.type === \"Literal\" && typeof node.value === \"string\" || node.type === \"TemplateLiteral\") {\n        return true;\n      }\n\n      if (node.type === \"BinaryExpression\" && node.operator === \"+\") {\n        return isEvaluatedString(node.left) || isEvaluatedString(node.right);\n      }\n\n      return false;\n    }\n    /**\n     * Reports if the `CallExpression` node has evaluated argument.\n     * @param {ASTNode} node A CallExpression to check.\n     * @returns {void}\n     */\n\n\n    function reportImpliedEvalCallExpression(node) {\n      const [firstArgument] = node.arguments;\n\n      if (firstArgument) {\n        const staticValue = getStaticValue(firstArgument, context.getScope());\n        const isStaticString = staticValue && typeof staticValue.value === \"string\";\n        const isString = isStaticString || isEvaluatedString(firstArgument);\n\n        if (isString) {\n          context.report({\n            node,\n            messageId: \"impliedEval\"\n          });\n        }\n      }\n    }\n    /**\n     * Reports calls of `implied eval` via the global references.\n     * @param {Variable} globalVar A global variable to check.\n     * @returns {void}\n     */\n\n\n    function reportImpliedEvalViaGlobal(globalVar) {\n      const {\n        references,\n        name\n      } = globalVar;\n      references.forEach(ref => {\n        const identifier = ref.identifier;\n        let node = identifier.parent;\n\n        while (astUtils.isSpecificMemberAccess(node, null, name)) {\n          node = node.parent;\n        }\n\n        if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {\n          const calleeNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n          const parent = calleeNode.parent;\n\n          if (parent.type === \"CallExpression\" && parent.callee === calleeNode) {\n            reportImpliedEvalCallExpression(parent);\n          }\n        }\n      });\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      CallExpression(node) {\n        if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {\n          reportImpliedEvalCallExpression(node);\n        }\n      },\n\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        GLOBAL_CANDIDATES.map(candidate => astUtils.getVariableByName(globalScope, candidate)).filter(globalVar => !!globalVar && globalVar.defs.length === 0).forEach(reportImpliedEvalViaGlobal);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","getStaticValue","module","exports","meta","type","docs","description","category","recommended","url","schema","messages","impliedEval","create","context","GLOBAL_CANDIDATES","Object","freeze","EVAL_LIKE_FUNC_PATTERN","isEvaluatedString","node","value","operator","left","right","reportImpliedEvalCallExpression","firstArgument","arguments","staticValue","getScope","isStaticString","isString","report","messageId","reportImpliedEvalViaGlobal","globalVar","references","name","forEach","ref","identifier","parent","isSpecificMemberAccess","calleeNode","callee","CallExpression","isSpecificId","globalScope","map","candidate","getVariableByName","filter","defs","length"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-implied-eval.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { getStaticValue } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`-like methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implied-eval\"\n        },\n\n        schema: [],\n\n        messages: {\n            impliedEval: \"Implied eval. Consider passing a function instead of a string.\"\n        }\n    },\n\n    create(context) {\n        const GLOBAL_CANDIDATES = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n        const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;\n\n        /**\n         * Checks whether a node is evaluated as a string or not.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is evaluated as a string.\n         */\n        function isEvaluatedString(node) {\n            if (\n                (node.type === \"Literal\" && typeof node.value === \"string\") ||\n                node.type === \"TemplateLiteral\"\n            ) {\n                return true;\n            }\n            if (node.type === \"BinaryExpression\" && node.operator === \"+\") {\n                return isEvaluatedString(node.left) || isEvaluatedString(node.right);\n            }\n            return false;\n        }\n\n        /**\n         * Reports if the `CallExpression` node has evaluated argument.\n         * @param {ASTNode} node A CallExpression to check.\n         * @returns {void}\n         */\n        function reportImpliedEvalCallExpression(node) {\n            const [firstArgument] = node.arguments;\n\n            if (firstArgument) {\n\n                const staticValue = getStaticValue(firstArgument, context.getScope());\n                const isStaticString = staticValue && typeof staticValue.value === \"string\";\n                const isString = isStaticString || isEvaluatedString(firstArgument);\n\n                if (isString) {\n                    context.report({\n                        node,\n                        messageId: \"impliedEval\"\n                    });\n                }\n            }\n\n        }\n\n        /**\n         * Reports calls of `implied eval` via the global references.\n         * @param {Variable} globalVar A global variable to check.\n         * @returns {void}\n         */\n        function reportImpliedEvalViaGlobal(globalVar) {\n            const { references, name } = globalVar;\n\n            references.forEach(ref => {\n                const identifier = ref.identifier;\n                let node = identifier.parent;\n\n                while (astUtils.isSpecificMemberAccess(node, null, name)) {\n                    node = node.parent;\n                }\n\n                if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {\n                    const calleeNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n                    const parent = calleeNode.parent;\n\n                    if (parent.type === \"CallExpression\" && parent.callee === calleeNode) {\n                        reportImpliedEvalCallExpression(parent);\n                    }\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n                if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {\n                    reportImpliedEvalCallExpression(node);\n                }\n            },\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                GLOBAL_CANDIDATES\n                    .map(candidate => astUtils.getVariableByName(globalScope, candidate))\n                    .filter(globalVar => !!globalVar && globalVar.defs.length === 0)\n                    .forEach(reportImpliedEvalViaGlobal);\n            }\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB;;AACA,MAAM;EAAEC;AAAF,IAAqBD,OAAO,CAAC,cAAD,CAAlC,C,CAEA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,YADJ;IAGFC,IAAI,EAAE;MACFC,WAAW,EAAE,2CADX;MAEFC,QAAQ,EAAE,gBAFR;MAGFC,WAAW,EAAE,KAHX;MAIFC,GAAG,EAAE;IAJH,CAHJ;IAUFC,MAAM,EAAE,EAVN;IAYFC,QAAQ,EAAE;MACNC,WAAW,EAAE;IADP;EAZR,CADO;;EAkBbC,MAAM,CAACC,OAAD,EAAU;IACZ,MAAMC,iBAAiB,GAAGC,MAAM,CAACC,MAAP,CAAc,CAAC,QAAD,EAAW,QAAX,EAAqB,YAArB,CAAd,CAA1B;IACA,MAAMC,sBAAsB,GAAG,2CAA/B;IAEA;AACR;AACA;AACA;AACA;;IACQ,SAASC,iBAAT,CAA2BC,IAA3B,EAAiC;MAC7B,IACKA,IAAI,CAAChB,IAAL,KAAc,SAAd,IAA2B,OAAOgB,IAAI,CAACC,KAAZ,KAAsB,QAAlD,IACAD,IAAI,CAAChB,IAAL,KAAc,iBAFlB,EAGE;QACE,OAAO,IAAP;MACH;;MACD,IAAIgB,IAAI,CAAChB,IAAL,KAAc,kBAAd,IAAoCgB,IAAI,CAACE,QAAL,KAAkB,GAA1D,EAA+D;QAC3D,OAAOH,iBAAiB,CAACC,IAAI,CAACG,IAAN,CAAjB,IAAgCJ,iBAAiB,CAACC,IAAI,CAACI,KAAN,CAAxD;MACH;;MACD,OAAO,KAAP;IACH;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASC,+BAAT,CAAyCL,IAAzC,EAA+C;MAC3C,MAAM,CAACM,aAAD,IAAkBN,IAAI,CAACO,SAA7B;;MAEA,IAAID,aAAJ,EAAmB;QAEf,MAAME,WAAW,GAAG5B,cAAc,CAAC0B,aAAD,EAAgBZ,OAAO,CAACe,QAAR,EAAhB,CAAlC;QACA,MAAMC,cAAc,GAAGF,WAAW,IAAI,OAAOA,WAAW,CAACP,KAAnB,KAA6B,QAAnE;QACA,MAAMU,QAAQ,GAAGD,cAAc,IAAIX,iBAAiB,CAACO,aAAD,CAApD;;QAEA,IAAIK,QAAJ,EAAc;UACVjB,OAAO,CAACkB,MAAR,CAAe;YACXZ,IADW;YAEXa,SAAS,EAAE;UAFA,CAAf;QAIH;MACJ;IAEJ;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASC,0BAAT,CAAoCC,SAApC,EAA+C;MAC3C,MAAM;QAAEC,UAAF;QAAcC;MAAd,IAAuBF,SAA7B;MAEAC,UAAU,CAACE,OAAX,CAAmBC,GAAG,IAAI;QACtB,MAAMC,UAAU,GAAGD,GAAG,CAACC,UAAvB;QACA,IAAIpB,IAAI,GAAGoB,UAAU,CAACC,MAAtB;;QAEA,OAAO3C,QAAQ,CAAC4C,sBAAT,CAAgCtB,IAAhC,EAAsC,IAAtC,EAA4CiB,IAA5C,CAAP,EAA0D;UACtDjB,IAAI,GAAGA,IAAI,CAACqB,MAAZ;QACH;;QAED,IAAI3C,QAAQ,CAAC4C,sBAAT,CAAgCtB,IAAhC,EAAsC,IAAtC,EAA4CF,sBAA5C,CAAJ,EAAyE;UACrE,MAAMyB,UAAU,GAAGvB,IAAI,CAACqB,MAAL,CAAYrC,IAAZ,KAAqB,iBAArB,GAAyCgB,IAAI,CAACqB,MAA9C,GAAuDrB,IAA1E;UACA,MAAMqB,MAAM,GAAGE,UAAU,CAACF,MAA1B;;UAEA,IAAIA,MAAM,CAACrC,IAAP,KAAgB,gBAAhB,IAAoCqC,MAAM,CAACG,MAAP,KAAkBD,UAA1D,EAAsE;YAClElB,+BAA+B,CAACgB,MAAD,CAA/B;UACH;QACJ;MACJ,CAhBD;IAiBH,CAvEW,CAyEZ;IACA;IACA;;;IAEA,OAAO;MACHI,cAAc,CAACzB,IAAD,EAAO;QACjB,IAAItB,QAAQ,CAACgD,YAAT,CAAsB1B,IAAI,CAACwB,MAA3B,EAAmC1B,sBAAnC,CAAJ,EAAgE;UAC5DO,+BAA+B,CAACL,IAAD,CAA/B;QACH;MACJ,CALE;;MAMH,iBAAiB;QACb,MAAM2B,WAAW,GAAGjC,OAAO,CAACe,QAAR,EAApB;QAEAd,iBAAiB,CACZiC,GADL,CACSC,SAAS,IAAInD,QAAQ,CAACoD,iBAAT,CAA2BH,WAA3B,EAAwCE,SAAxC,CADtB,EAEKE,MAFL,CAEYhB,SAAS,IAAI,CAAC,CAACA,SAAF,IAAeA,SAAS,CAACiB,IAAV,CAAeC,MAAf,KAA0B,CAFlE,EAGKf,OAHL,CAGaJ,0BAHb;MAIH;;IAbE,CAAP;EAgBH;;AA/GY,CAAjB"},"metadata":{},"sourceType":"script"}