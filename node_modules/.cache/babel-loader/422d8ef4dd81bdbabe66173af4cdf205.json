{"ast":null,"code":"/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n// \"typed\", the Type Expression Parser for doctrine.\n(function () {\n  'use strict';\n\n  var Syntax, Token, source, length, index, previous, token, value, esutils, utility, rangeOffset, addRange;\n  esutils = require('esutils');\n  utility = require('./utility');\n  Syntax = {\n    NullableLiteral: 'NullableLiteral',\n    AllLiteral: 'AllLiteral',\n    NullLiteral: 'NullLiteral',\n    UndefinedLiteral: 'UndefinedLiteral',\n    VoidLiteral: 'VoidLiteral',\n    UnionType: 'UnionType',\n    ArrayType: 'ArrayType',\n    RecordType: 'RecordType',\n    FieldType: 'FieldType',\n    FunctionType: 'FunctionType',\n    ParameterType: 'ParameterType',\n    RestType: 'RestType',\n    NonNullableType: 'NonNullableType',\n    OptionalType: 'OptionalType',\n    NullableType: 'NullableType',\n    NameExpression: 'NameExpression',\n    TypeApplication: 'TypeApplication',\n    StringLiteralType: 'StringLiteralType',\n    NumericLiteralType: 'NumericLiteralType',\n    BooleanLiteralType: 'BooleanLiteralType'\n  };\n  Token = {\n    ILLEGAL: 0,\n    // ILLEGAL\n    DOT_LT: 1,\n    // .<\n    REST: 2,\n    // ...\n    LT: 3,\n    // <\n    GT: 4,\n    // >\n    LPAREN: 5,\n    // (\n    RPAREN: 6,\n    // )\n    LBRACE: 7,\n    // {\n    RBRACE: 8,\n    // }\n    LBRACK: 9,\n    // [\n    RBRACK: 10,\n    // ]\n    COMMA: 11,\n    // ,\n    COLON: 12,\n    // :\n    STAR: 13,\n    // *\n    PIPE: 14,\n    // |\n    QUESTION: 15,\n    // ?\n    BANG: 16,\n    // !\n    EQUAL: 17,\n    // =\n    NAME: 18,\n    // name token\n    STRING: 19,\n    // string\n    NUMBER: 20,\n    // number\n    EOF: 21\n  };\n\n  function isTypeName(ch) {\n    return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n  }\n\n  function Context(previous, index, token, value) {\n    this._previous = previous;\n    this._index = index;\n    this._token = token;\n    this._value = value;\n  }\n\n  Context.prototype.restore = function () {\n    previous = this._previous;\n    index = this._index;\n    token = this._token;\n    value = this._value;\n  };\n\n  Context.save = function () {\n    return new Context(previous, index, token, value);\n  };\n\n  function maybeAddRange(node, range) {\n    if (addRange) {\n      node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\n    }\n\n    return node;\n  }\n\n  function advance() {\n    var ch = source.charAt(index);\n    index += 1;\n    return ch;\n  }\n\n  function scanHexEscape(prefix) {\n    var i,\n        len,\n        ch,\n        code = 0;\n    len = prefix === 'u' ? 4 : 2;\n\n    for (i = 0; i < len; ++i) {\n      if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n        ch = advance();\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n\n    return String.fromCharCode(code);\n  }\n\n  function scanString() {\n    var str = '',\n        quote,\n        ch,\n        code,\n        unescaped,\n        restore; //TODO review removal octal = false\n\n    quote = source.charAt(index);\n    ++index;\n\n    while (index < length) {\n      ch = advance();\n\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = advance();\n\n        if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'u':\n            case 'x':\n              restore = index;\n              unescaped = scanHexEscape(ch);\n\n              if (unescaped) {\n                str += unescaped;\n              } else {\n                index = restore;\n                str += ch;\n              }\n\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\v';\n              break;\n\n            default:\n              if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                code = '01234567'.indexOf(ch); // \\0 is not octal escape sequence\n                // Deprecating unused code. TODO review removal\n                //if (code !== 0) {\n                //    octal = true;\n                //}\n\n                if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                  //TODO Review Removal octal = true;\n                  code = code * 8 + '01234567'.indexOf(advance()); // 3 digits are only allowed when string starts\n                  // with 0, 1, 2, 3\n\n                  if ('0123'.indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                    code = code * 8 + '01234567'.indexOf(advance());\n                  }\n                }\n\n                str += String.fromCharCode(code);\n              } else {\n                str += ch;\n              }\n\n              break;\n          }\n        } else {\n          if (ch === '\\r' && source.charCodeAt(index) === 0x0A\n          /* '\\n' */\n          ) {\n            ++index;\n          }\n        }\n      } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (quote !== '') {\n      utility.throwError('unexpected quote');\n    }\n\n    value = str;\n    return Token.STRING;\n  }\n\n  function scanNumber() {\n    var number, ch;\n    number = '';\n    ch = source.charCodeAt(index);\n\n    if (ch !== 0x2E\n    /* '.' */\n    ) {\n      number = advance();\n      ch = source.charCodeAt(index);\n\n      if (number === '0') {\n        if (ch === 0x78\n        /* 'x' */\n        || ch === 0x58\n        /* 'X' */\n        ) {\n          number += advance();\n\n          while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (!esutils.code.isHexDigit(ch)) {\n              break;\n            }\n\n            number += advance();\n          }\n\n          if (number.length <= 2) {\n            // only 0x\n            utility.throwError('unexpected token');\n          }\n\n          if (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (esutils.code.isIdentifierStartES5(ch)) {\n              utility.throwError('unexpected token');\n            }\n          }\n\n          value = parseInt(number, 16);\n          return Token.NUMBER;\n        }\n\n        if (esutils.code.isOctalDigit(ch)) {\n          number += advance();\n\n          while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (!esutils.code.isOctalDigit(ch)) {\n              break;\n            }\n\n            number += advance();\n          }\n\n          if (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n              utility.throwError('unexpected token');\n            }\n          }\n\n          value = parseInt(number, 8);\n          return Token.NUMBER;\n        }\n\n        if (esutils.code.isDecimalDigit(ch)) {\n          utility.throwError('unexpected token');\n        }\n      }\n\n      while (index < length) {\n        ch = source.charCodeAt(index);\n\n        if (!esutils.code.isDecimalDigit(ch)) {\n          break;\n        }\n\n        number += advance();\n      }\n    }\n\n    if (ch === 0x2E\n    /* '.' */\n    ) {\n      number += advance();\n\n      while (index < length) {\n        ch = source.charCodeAt(index);\n\n        if (!esutils.code.isDecimalDigit(ch)) {\n          break;\n        }\n\n        number += advance();\n      }\n    }\n\n    if (ch === 0x65\n    /* 'e' */\n    || ch === 0x45\n    /* 'E' */\n    ) {\n      number += advance();\n      ch = source.charCodeAt(index);\n\n      if (ch === 0x2B\n      /* '+' */\n      || ch === 0x2D\n      /* '-' */\n      ) {\n        number += advance();\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (esutils.code.isDecimalDigit(ch)) {\n        number += advance();\n\n        while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (!esutils.code.isDecimalDigit(ch)) {\n            break;\n          }\n\n          number += advance();\n        }\n      } else {\n        utility.throwError('unexpected token');\n      }\n    }\n\n    if (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (esutils.code.isIdentifierStartES5(ch)) {\n        utility.throwError('unexpected token');\n      }\n    }\n\n    value = parseFloat(number);\n    return Token.NUMBER;\n  }\n\n  function scanTypeName() {\n    var ch, ch2;\n    value = advance();\n\n    while (index < length && isTypeName(source.charCodeAt(index))) {\n      ch = source.charCodeAt(index);\n\n      if (ch === 0x2E\n      /* '.' */\n      ) {\n        if (index + 1 >= length) {\n          return Token.ILLEGAL;\n        }\n\n        ch2 = source.charCodeAt(index + 1);\n\n        if (ch2 === 0x3C\n        /* '<' */\n        ) {\n          break;\n        }\n      }\n\n      value += advance();\n    }\n\n    return Token.NAME;\n  }\n\n  function next() {\n    var ch;\n    previous = index;\n\n    while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\n      advance();\n    }\n\n    if (index >= length) {\n      token = Token.EOF;\n      return token;\n    }\n\n    ch = source.charCodeAt(index);\n\n    switch (ch) {\n      case 0x27:\n      /* ''' */\n\n      case 0x22:\n        /* '\"' */\n        token = scanString();\n        return token;\n\n      case 0x3A:\n        /* ':' */\n        advance();\n        token = Token.COLON;\n        return token;\n\n      case 0x2C:\n        /* ',' */\n        advance();\n        token = Token.COMMA;\n        return token;\n\n      case 0x28:\n        /* '(' */\n        advance();\n        token = Token.LPAREN;\n        return token;\n\n      case 0x29:\n        /* ')' */\n        advance();\n        token = Token.RPAREN;\n        return token;\n\n      case 0x5B:\n        /* '[' */\n        advance();\n        token = Token.LBRACK;\n        return token;\n\n      case 0x5D:\n        /* ']' */\n        advance();\n        token = Token.RBRACK;\n        return token;\n\n      case 0x7B:\n        /* '{' */\n        advance();\n        token = Token.LBRACE;\n        return token;\n\n      case 0x7D:\n        /* '}' */\n        advance();\n        token = Token.RBRACE;\n        return token;\n\n      case 0x2E:\n        /* '.' */\n        if (index + 1 < length) {\n          ch = source.charCodeAt(index + 1);\n\n          if (ch === 0x3C\n          /* '<' */\n          ) {\n            advance(); // '.'\n\n            advance(); // '<'\n\n            token = Token.DOT_LT;\n            return token;\n          }\n\n          if (ch === 0x2E\n          /* '.' */\n          && index + 2 < length && source.charCodeAt(index + 2) === 0x2E\n          /* '.' */\n          ) {\n            advance(); // '.'\n\n            advance(); // '.'\n\n            advance(); // '.'\n\n            token = Token.REST;\n            return token;\n          }\n\n          if (esutils.code.isDecimalDigit(ch)) {\n            token = scanNumber();\n            return token;\n          }\n        }\n\n        token = Token.ILLEGAL;\n        return token;\n\n      case 0x3C:\n        /* '<' */\n        advance();\n        token = Token.LT;\n        return token;\n\n      case 0x3E:\n        /* '>' */\n        advance();\n        token = Token.GT;\n        return token;\n\n      case 0x2A:\n        /* '*' */\n        advance();\n        token = Token.STAR;\n        return token;\n\n      case 0x7C:\n        /* '|' */\n        advance();\n        token = Token.PIPE;\n        return token;\n\n      case 0x3F:\n        /* '?' */\n        advance();\n        token = Token.QUESTION;\n        return token;\n\n      case 0x21:\n        /* '!' */\n        advance();\n        token = Token.BANG;\n        return token;\n\n      case 0x3D:\n        /* '=' */\n        advance();\n        token = Token.EQUAL;\n        return token;\n\n      case 0x2D:\n        /* '-' */\n        token = scanNumber();\n        return token;\n\n      default:\n        if (esutils.code.isDecimalDigit(ch)) {\n          token = scanNumber();\n          return token;\n        } // type string permits following case,\n        //\n        // namespace.module.MyClass\n        //\n        // this reduced 1 token TK_NAME\n\n\n        utility.assert(isTypeName(ch));\n        token = scanTypeName();\n        return token;\n    }\n  }\n\n  function consume(target, text) {\n    utility.assert(token === target, text || 'consumed token not matched');\n    next();\n  }\n\n  function expect(target, message) {\n    if (token !== target) {\n      utility.throwError(message || 'unexpected token');\n    }\n\n    next();\n  } // UnionType := '(' TypeUnionList ')'\n  //\n  // TypeUnionList :=\n  //     <<empty>>\n  //   | NonemptyTypeUnionList\n  //\n  // NonemptyTypeUnionList :=\n  //     TypeExpression\n  //   | TypeExpression '|' NonemptyTypeUnionList\n\n\n  function parseUnionType() {\n    var elements,\n        startIndex = index - 1;\n    consume(Token.LPAREN, 'UnionType should start with (');\n    elements = [];\n\n    if (token !== Token.RPAREN) {\n      while (true) {\n        elements.push(parseTypeExpression());\n\n        if (token === Token.RPAREN) {\n          break;\n        }\n\n        expect(Token.PIPE);\n      }\n    }\n\n    consume(Token.RPAREN, 'UnionType should end with )');\n    return maybeAddRange({\n      type: Syntax.UnionType,\n      elements: elements\n    }, [startIndex, previous]);\n  } // ArrayType := '[' ElementTypeList ']'\n  //\n  // ElementTypeList :=\n  //     <<empty>>\n  //  | TypeExpression\n  //  | '...' TypeExpression\n  //  | TypeExpression ',' ElementTypeList\n\n\n  function parseArrayType() {\n    var elements,\n        startIndex = index - 1,\n        restStartIndex;\n    consume(Token.LBRACK, 'ArrayType should start with [');\n    elements = [];\n\n    while (token !== Token.RBRACK) {\n      if (token === Token.REST) {\n        restStartIndex = index - 3;\n        consume(Token.REST);\n        elements.push(maybeAddRange({\n          type: Syntax.RestType,\n          expression: parseTypeExpression()\n        }, [restStartIndex, previous]));\n        break;\n      } else {\n        elements.push(parseTypeExpression());\n      }\n\n      if (token !== Token.RBRACK) {\n        expect(Token.COMMA);\n      }\n    }\n\n    expect(Token.RBRACK);\n    return maybeAddRange({\n      type: Syntax.ArrayType,\n      elements: elements\n    }, [startIndex, previous]);\n  }\n\n  function parseFieldName() {\n    var v = value;\n\n    if (token === Token.NAME || token === Token.STRING) {\n      next();\n      return v;\n    }\n\n    if (token === Token.NUMBER) {\n      consume(Token.NUMBER);\n      return String(v);\n    }\n\n    utility.throwError('unexpected token');\n  } // FieldType :=\n  //     FieldName\n  //   | FieldName ':' TypeExpression\n  //\n  // FieldName :=\n  //     NameExpression\n  //   | StringLiteral\n  //   | NumberLiteral\n  //   | ReservedIdentifier\n\n\n  function parseFieldType() {\n    var key,\n        rangeStart = previous;\n    key = parseFieldName();\n\n    if (token === Token.COLON) {\n      consume(Token.COLON);\n      return maybeAddRange({\n        type: Syntax.FieldType,\n        key: key,\n        value: parseTypeExpression()\n      }, [rangeStart, previous]);\n    }\n\n    return maybeAddRange({\n      type: Syntax.FieldType,\n      key: key,\n      value: null\n    }, [rangeStart, previous]);\n  } // RecordType := '{' FieldTypeList '}'\n  //\n  // FieldTypeList :=\n  //     <<empty>>\n  //   | FieldType\n  //   | FieldType ',' FieldTypeList\n\n\n  function parseRecordType() {\n    var fields,\n        rangeStart = index - 1,\n        rangeEnd;\n    consume(Token.LBRACE, 'RecordType should start with {');\n    fields = [];\n\n    if (token === Token.COMMA) {\n      consume(Token.COMMA);\n    } else {\n      while (token !== Token.RBRACE) {\n        fields.push(parseFieldType());\n\n        if (token !== Token.RBRACE) {\n          expect(Token.COMMA);\n        }\n      }\n    }\n\n    rangeEnd = index;\n    expect(Token.RBRACE);\n    return maybeAddRange({\n      type: Syntax.RecordType,\n      fields: fields\n    }, [rangeStart, rangeEnd]);\n  } // NameExpression :=\n  //    Identifier\n  //  | TagIdentifier ':' Identifier\n  //\n  // Tag identifier is one of \"module\", \"external\" or \"event\"\n  // Identifier is the same as Token.NAME, including any dots, something like\n  // namespace.module.MyClass\n\n\n  function parseNameExpression() {\n    var name = value,\n        rangeStart = index - name.length;\n    expect(Token.NAME);\n\n    if (token === Token.COLON && (name === 'module' || name === 'external' || name === 'event')) {\n      consume(Token.COLON);\n      name += ':' + value;\n      expect(Token.NAME);\n    }\n\n    return maybeAddRange({\n      type: Syntax.NameExpression,\n      name: name\n    }, [rangeStart, previous]);\n  } // TypeExpressionList :=\n  //     TopLevelTypeExpression\n  //   | TopLevelTypeExpression ',' TypeExpressionList\n\n\n  function parseTypeExpressionList() {\n    var elements = [];\n    elements.push(parseTop());\n\n    while (token === Token.COMMA) {\n      consume(Token.COMMA);\n      elements.push(parseTop());\n    }\n\n    return elements;\n  } // TypeName :=\n  //     NameExpression\n  //   | NameExpression TypeApplication\n  //\n  // TypeApplication :=\n  //     '.<' TypeExpressionList '>'\n  //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n\n\n  function parseTypeName() {\n    var expr,\n        applications,\n        startIndex = index - value.length;\n    expr = parseNameExpression();\n\n    if (token === Token.DOT_LT || token === Token.LT) {\n      next();\n      applications = parseTypeExpressionList();\n      expect(Token.GT);\n      return maybeAddRange({\n        type: Syntax.TypeApplication,\n        expression: expr,\n        applications: applications\n      }, [startIndex, previous]);\n    }\n\n    return expr;\n  } // ResultType :=\n  //     <<empty>>\n  //   | ':' void\n  //   | ':' TypeExpression\n  //\n  // BNF is above\n  // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n\n\n  function parseResultType() {\n    consume(Token.COLON, 'ResultType should start with :');\n\n    if (token === Token.NAME && value === 'void') {\n      consume(Token.NAME);\n      return {\n        type: Syntax.VoidLiteral\n      };\n    }\n\n    return parseTypeExpression();\n  } // ParametersType :=\n  //     RestParameterType\n  //   | NonRestParametersType\n  //   | NonRestParametersType ',' RestParameterType\n  //\n  // RestParameterType :=\n  //     '...'\n  //     '...' Identifier\n  //\n  // NonRestParametersType :=\n  //     ParameterType ',' NonRestParametersType\n  //   | ParameterType\n  //   | OptionalParametersType\n  //\n  // OptionalParametersType :=\n  //     OptionalParameterType\n  //   | OptionalParameterType, OptionalParametersType\n  //\n  // OptionalParameterType := ParameterType=\n  //\n  // ParameterType := TypeExpression | Identifier ':' TypeExpression\n  //\n  // Identifier is \"new\" or \"this\"\n\n\n  function parseParametersType() {\n    var params = [],\n        optionalSequence = false,\n        expr,\n        rest = false,\n        startIndex,\n        restStartIndex = index - 3,\n        nameStartIndex;\n\n    while (token !== Token.RPAREN) {\n      if (token === Token.REST) {\n        // RestParameterType\n        consume(Token.REST);\n        rest = true;\n      }\n\n      startIndex = previous;\n      expr = parseTypeExpression();\n\n      if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n        nameStartIndex = previous - expr.name.length; // Identifier ':' TypeExpression\n\n        consume(Token.COLON);\n        expr = maybeAddRange({\n          type: Syntax.ParameterType,\n          name: expr.name,\n          expression: parseTypeExpression()\n        }, [nameStartIndex, previous]);\n      }\n\n      if (token === Token.EQUAL) {\n        consume(Token.EQUAL);\n        expr = maybeAddRange({\n          type: Syntax.OptionalType,\n          expression: expr\n        }, [startIndex, previous]);\n        optionalSequence = true;\n      } else {\n        if (optionalSequence) {\n          utility.throwError('unexpected token');\n        }\n      }\n\n      if (rest) {\n        expr = maybeAddRange({\n          type: Syntax.RestType,\n          expression: expr\n        }, [restStartIndex, previous]);\n      }\n\n      params.push(expr);\n\n      if (token !== Token.RPAREN) {\n        expect(Token.COMMA);\n      }\n    }\n\n    return params;\n  } // FunctionType := 'function' FunctionSignatureType\n  //\n  // FunctionSignatureType :=\n  //   | TypeParameters '(' ')' ResultType\n  //   | TypeParameters '(' ParametersType ')' ResultType\n  //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n  //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n\n\n  function parseFunctionType() {\n    var isNew,\n        thisBinding,\n        params,\n        result,\n        fnType,\n        startIndex = index - value.length;\n    utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\n    consume(Token.NAME); // Google Closure Compiler is not implementing TypeParameters.\n    // So we do not. if we don't get '(', we see it as error.\n\n    expect(Token.LPAREN);\n    isNew = false;\n    params = [];\n    thisBinding = null;\n\n    if (token !== Token.RPAREN) {\n      // ParametersType or 'this'\n      if (token === Token.NAME && (value === 'this' || value === 'new')) {\n        // 'this' or 'new'\n        // 'new' is Closure Compiler extension\n        isNew = value === 'new';\n        consume(Token.NAME);\n        expect(Token.COLON);\n        thisBinding = parseTypeName();\n\n        if (token === Token.COMMA) {\n          consume(Token.COMMA);\n          params = parseParametersType();\n        }\n      } else {\n        params = parseParametersType();\n      }\n    }\n\n    expect(Token.RPAREN);\n    result = null;\n\n    if (token === Token.COLON) {\n      result = parseResultType();\n    }\n\n    fnType = maybeAddRange({\n      type: Syntax.FunctionType,\n      params: params,\n      result: result\n    }, [startIndex, previous]);\n\n    if (thisBinding) {\n      // avoid adding null 'new' and 'this' properties\n      fnType['this'] = thisBinding;\n\n      if (isNew) {\n        fnType['new'] = true;\n      }\n    }\n\n    return fnType;\n  } // BasicTypeExpression :=\n  //     '*'\n  //   | 'null'\n  //   | 'undefined'\n  //   | TypeName\n  //   | FunctionType\n  //   | UnionType\n  //   | RecordType\n  //   | ArrayType\n\n\n  function parseBasicTypeExpression() {\n    var context, startIndex;\n\n    switch (token) {\n      case Token.STAR:\n        consume(Token.STAR);\n        return maybeAddRange({\n          type: Syntax.AllLiteral\n        }, [previous - 1, previous]);\n\n      case Token.LPAREN:\n        return parseUnionType();\n\n      case Token.LBRACK:\n        return parseArrayType();\n\n      case Token.LBRACE:\n        return parseRecordType();\n\n      case Token.NAME:\n        startIndex = index - value.length;\n\n        if (value === 'null') {\n          consume(Token.NAME);\n          return maybeAddRange({\n            type: Syntax.NullLiteral\n          }, [startIndex, previous]);\n        }\n\n        if (value === 'undefined') {\n          consume(Token.NAME);\n          return maybeAddRange({\n            type: Syntax.UndefinedLiteral\n          }, [startIndex, previous]);\n        }\n\n        if (value === 'true' || value === 'false') {\n          consume(Token.NAME);\n          return maybeAddRange({\n            type: Syntax.BooleanLiteralType,\n            value: value === 'true'\n          }, [startIndex, previous]);\n        }\n\n        context = Context.save();\n\n        if (value === 'function') {\n          try {\n            return parseFunctionType();\n          } catch (e) {\n            context.restore();\n          }\n        }\n\n        return parseTypeName();\n\n      case Token.STRING:\n        next();\n        return maybeAddRange({\n          type: Syntax.StringLiteralType,\n          value: value\n        }, [previous - value.length - 2, previous]);\n\n      case Token.NUMBER:\n        next();\n        return maybeAddRange({\n          type: Syntax.NumericLiteralType,\n          value: value\n        }, [previous - String(value).length, previous]);\n\n      default:\n        utility.throwError('unexpected token');\n    }\n  } // TypeExpression :=\n  //     BasicTypeExpression\n  //   | '?' BasicTypeExpression\n  //   | '!' BasicTypeExpression\n  //   | BasicTypeExpression '?'\n  //   | BasicTypeExpression '!'\n  //   | '?'\n  //   | BasicTypeExpression '[]'\n\n\n  function parseTypeExpression() {\n    var expr, rangeStart;\n\n    if (token === Token.QUESTION) {\n      rangeStart = index - 1;\n      consume(Token.QUESTION);\n\n      if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {\n        return maybeAddRange({\n          type: Syntax.NullableLiteral\n        }, [rangeStart, previous]);\n      }\n\n      return maybeAddRange({\n        type: Syntax.NullableType,\n        expression: parseBasicTypeExpression(),\n        prefix: true\n      }, [rangeStart, previous]);\n    } else if (token === Token.BANG) {\n      rangeStart = index - 1;\n      consume(Token.BANG);\n      return maybeAddRange({\n        type: Syntax.NonNullableType,\n        expression: parseBasicTypeExpression(),\n        prefix: true\n      }, [rangeStart, previous]);\n    } else {\n      rangeStart = previous;\n    }\n\n    expr = parseBasicTypeExpression();\n\n    if (token === Token.BANG) {\n      consume(Token.BANG);\n      return maybeAddRange({\n        type: Syntax.NonNullableType,\n        expression: expr,\n        prefix: false\n      }, [rangeStart, previous]);\n    }\n\n    if (token === Token.QUESTION) {\n      consume(Token.QUESTION);\n      return maybeAddRange({\n        type: Syntax.NullableType,\n        expression: expr,\n        prefix: false\n      }, [rangeStart, previous]);\n    }\n\n    if (token === Token.LBRACK) {\n      consume(Token.LBRACK);\n      expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\n      return maybeAddRange({\n        type: Syntax.TypeApplication,\n        expression: maybeAddRange({\n          type: Syntax.NameExpression,\n          name: 'Array'\n        }, [rangeStart, previous]),\n        applications: [expr]\n      }, [rangeStart, previous]);\n    }\n\n    return expr;\n  } // TopLevelTypeExpression :=\n  //      TypeExpression\n  //    | TypeUnionList\n  //\n  // This rule is Google Closure Compiler extension, not ES4\n  // like,\n  //   { number | string }\n  // If strict to ES4, we should write it as\n  //   { (number|string) }\n\n\n  function parseTop() {\n    var expr, elements;\n    expr = parseTypeExpression();\n\n    if (token !== Token.PIPE) {\n      return expr;\n    }\n\n    elements = [expr];\n    consume(Token.PIPE);\n\n    while (true) {\n      elements.push(parseTypeExpression());\n\n      if (token !== Token.PIPE) {\n        break;\n      }\n\n      consume(Token.PIPE);\n    }\n\n    return maybeAddRange({\n      type: Syntax.UnionType,\n      elements: elements\n    }, [0, index]);\n  }\n\n  function parseTopParamType() {\n    var expr;\n\n    if (token === Token.REST) {\n      consume(Token.REST);\n      return maybeAddRange({\n        type: Syntax.RestType,\n        expression: parseTop()\n      }, [0, index]);\n    }\n\n    expr = parseTop();\n\n    if (token === Token.EQUAL) {\n      consume(Token.EQUAL);\n      return maybeAddRange({\n        type: Syntax.OptionalType,\n        expression: expr\n      }, [0, index]);\n    }\n\n    return expr;\n  }\n\n  function parseType(src, opt) {\n    var expr;\n    source = src;\n    length = source.length;\n    index = 0;\n    previous = 0;\n    addRange = opt && opt.range;\n    rangeOffset = opt && opt.startIndex || 0;\n    next();\n    expr = parseTop();\n\n    if (opt && opt.midstream) {\n      return {\n        expression: expr,\n        index: previous\n      };\n    }\n\n    if (token !== Token.EOF) {\n      utility.throwError('not reach to EOF');\n    }\n\n    return expr;\n  }\n\n  function parseParamType(src, opt) {\n    var expr;\n    source = src;\n    length = source.length;\n    index = 0;\n    previous = 0;\n    addRange = opt && opt.range;\n    rangeOffset = opt && opt.startIndex || 0;\n    next();\n    expr = parseTopParamType();\n\n    if (opt && opt.midstream) {\n      return {\n        expression: expr,\n        index: previous\n      };\n    }\n\n    if (token !== Token.EOF) {\n      utility.throwError('not reach to EOF');\n    }\n\n    return expr;\n  }\n\n  function stringifyImpl(node, compact, topLevel) {\n    var result, i, iz;\n\n    switch (node.type) {\n      case Syntax.NullableLiteral:\n        result = '?';\n        break;\n\n      case Syntax.AllLiteral:\n        result = '*';\n        break;\n\n      case Syntax.NullLiteral:\n        result = 'null';\n        break;\n\n      case Syntax.UndefinedLiteral:\n        result = 'undefined';\n        break;\n\n      case Syntax.VoidLiteral:\n        result = 'void';\n        break;\n\n      case Syntax.UnionType:\n        if (!topLevel) {\n          result = '(';\n        } else {\n          result = '';\n        }\n\n        for (i = 0, iz = node.elements.length; i < iz; ++i) {\n          result += stringifyImpl(node.elements[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? '|' : ' | ';\n          }\n        }\n\n        if (!topLevel) {\n          result += ')';\n        }\n\n        break;\n\n      case Syntax.ArrayType:\n        result = '[';\n\n        for (i = 0, iz = node.elements.length; i < iz; ++i) {\n          result += stringifyImpl(node.elements[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        result += ']';\n        break;\n\n      case Syntax.RecordType:\n        result = '{';\n\n        for (i = 0, iz = node.fields.length; i < iz; ++i) {\n          result += stringifyImpl(node.fields[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        result += '}';\n        break;\n\n      case Syntax.FieldType:\n        if (node.value) {\n          result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\n        } else {\n          result = node.key;\n        }\n\n        break;\n\n      case Syntax.FunctionType:\n        result = compact ? 'function(' : 'function (';\n\n        if (node['this']) {\n          if (node['new']) {\n            result += compact ? 'new:' : 'new: ';\n          } else {\n            result += compact ? 'this:' : 'this: ';\n          }\n\n          result += stringifyImpl(node['this'], compact);\n\n          if (node.params.length !== 0) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        for (i = 0, iz = node.params.length; i < iz; ++i) {\n          result += stringifyImpl(node.params[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        result += ')';\n\n        if (node.result) {\n          result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\n        }\n\n        break;\n\n      case Syntax.ParameterType:\n        result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\n        break;\n\n      case Syntax.RestType:\n        result = '...';\n\n        if (node.expression) {\n          result += stringifyImpl(node.expression, compact);\n        }\n\n        break;\n\n      case Syntax.NonNullableType:\n        if (node.prefix) {\n          result = '!' + stringifyImpl(node.expression, compact);\n        } else {\n          result = stringifyImpl(node.expression, compact) + '!';\n        }\n\n        break;\n\n      case Syntax.OptionalType:\n        result = stringifyImpl(node.expression, compact) + '=';\n        break;\n\n      case Syntax.NullableType:\n        if (node.prefix) {\n          result = '?' + stringifyImpl(node.expression, compact);\n        } else {\n          result = stringifyImpl(node.expression, compact) + '?';\n        }\n\n        break;\n\n      case Syntax.NameExpression:\n        result = node.name;\n        break;\n\n      case Syntax.TypeApplication:\n        result = stringifyImpl(node.expression, compact) + '.<';\n\n        for (i = 0, iz = node.applications.length; i < iz; ++i) {\n          result += stringifyImpl(node.applications[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        result += '>';\n        break;\n\n      case Syntax.StringLiteralType:\n        result = '\"' + node.value + '\"';\n        break;\n\n      case Syntax.NumericLiteralType:\n        result = String(node.value);\n        break;\n\n      case Syntax.BooleanLiteralType:\n        result = String(node.value);\n        break;\n\n      default:\n        utility.throwError('Unknown type ' + node.type);\n    }\n\n    return result;\n  }\n\n  function stringify(node, options) {\n    if (options == null) {\n      options = {};\n    }\n\n    return stringifyImpl(node, options.compact, options.topLevel);\n  }\n\n  exports.parseType = parseType;\n  exports.parseParamType = parseParamType;\n  exports.stringify = stringify;\n  exports.Syntax = Syntax;\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["Syntax","Token","source","length","index","previous","token","value","esutils","utility","rangeOffset","addRange","require","NullableLiteral","AllLiteral","NullLiteral","UndefinedLiteral","VoidLiteral","UnionType","ArrayType","RecordType","FieldType","FunctionType","ParameterType","RestType","NonNullableType","OptionalType","NullableType","NameExpression","TypeApplication","StringLiteralType","NumericLiteralType","BooleanLiteralType","ILLEGAL","DOT_LT","REST","LT","GT","LPAREN","RPAREN","LBRACE","RBRACE","LBRACK","RBRACK","COMMA","COLON","STAR","PIPE","QUESTION","BANG","EQUAL","NAME","STRING","NUMBER","EOF","isTypeName","ch","indexOf","String","fromCharCode","code","isWhiteSpace","isLineTerminator","Context","_previous","_index","_token","_value","prototype","restore","save","maybeAddRange","node","range","advance","charAt","scanHexEscape","prefix","i","len","isHexDigit","charCodeAt","toLowerCase","scanString","str","quote","unescaped","isOctalDigit","throwError","scanNumber","number","isIdentifierStartES5","parseInt","isDecimalDigit","parseFloat","scanTypeName","ch2","next","assert","consume","target","text","expect","message","parseUnionType","elements","startIndex","push","parseTypeExpression","type","parseArrayType","restStartIndex","expression","parseFieldName","v","parseFieldType","key","rangeStart","parseRecordType","fields","rangeEnd","parseNameExpression","name","parseTypeExpressionList","parseTop","parseTypeName","expr","applications","parseResultType","parseParametersType","params","optionalSequence","rest","nameStartIndex","parseFunctionType","isNew","thisBinding","result","fnType","parseBasicTypeExpression","context","e","parseTopParamType","parseType","src","opt","midstream","parseParamType","stringifyImpl","compact","topLevel","iz","stringify","options","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/doctrine/lib/typed.js"],"sourcesContent":["/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n// \"typed\", the Type Expression Parser for doctrine.\n\n(function () {\n    'use strict';\n\n    var Syntax,\n        Token,\n        source,\n        length,\n        index,\n        previous,\n        token,\n        value,\n        esutils,\n        utility,\n        rangeOffset,\n        addRange;\n\n    esutils = require('esutils');\n    utility = require('./utility');\n\n    Syntax = {\n        NullableLiteral: 'NullableLiteral',\n        AllLiteral: 'AllLiteral',\n        NullLiteral: 'NullLiteral',\n        UndefinedLiteral: 'UndefinedLiteral',\n        VoidLiteral: 'VoidLiteral',\n        UnionType: 'UnionType',\n        ArrayType: 'ArrayType',\n        RecordType: 'RecordType',\n        FieldType: 'FieldType',\n        FunctionType: 'FunctionType',\n        ParameterType: 'ParameterType',\n        RestType: 'RestType',\n        NonNullableType: 'NonNullableType',\n        OptionalType: 'OptionalType',\n        NullableType: 'NullableType',\n        NameExpression: 'NameExpression',\n        TypeApplication: 'TypeApplication',\n        StringLiteralType: 'StringLiteralType',\n        NumericLiteralType: 'NumericLiteralType',\n        BooleanLiteralType: 'BooleanLiteralType'\n    };\n\n    Token = {\n        ILLEGAL: 0,    // ILLEGAL\n        DOT_LT: 1,     // .<\n        REST: 2,       // ...\n        LT: 3,         // <\n        GT: 4,         // >\n        LPAREN: 5,     // (\n        RPAREN: 6,     // )\n        LBRACE: 7,     // {\n        RBRACE: 8,     // }\n        LBRACK: 9,    // [\n        RBRACK: 10,    // ]\n        COMMA: 11,     // ,\n        COLON: 12,     // :\n        STAR: 13,      // *\n        PIPE: 14,      // |\n        QUESTION: 15,  // ?\n        BANG: 16,      // !\n        EQUAL: 17,     // =\n        NAME: 18,      // name token\n        STRING: 19,    // string\n        NUMBER: 20,    // number\n        EOF: 21\n    };\n\n    function isTypeName(ch) {\n        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n    }\n\n    function Context(previous, index, token, value) {\n        this._previous = previous;\n        this._index = index;\n        this._token = token;\n        this._value = value;\n    }\n\n    Context.prototype.restore = function () {\n        previous = this._previous;\n        index = this._index;\n        token = this._token;\n        value = this._value;\n    };\n\n    Context.save = function () {\n        return new Context(previous, index, token, value);\n    };\n\n    function maybeAddRange(node, range) {\n        if (addRange) {\n            node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\n        }\n        return node;\n    }\n\n    function advance() {\n        var ch = source.charAt(index);\n        index += 1;\n        return ch;\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n                ch = advance();\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanString() {\n        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false\n        quote = source.charAt(index);\n        ++index;\n\n        while (index < length) {\n            ch = advance();\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = advance();\n                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\v';\n                        break;\n\n                    default:\n                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            // Deprecating unused code. TODO review removal\n                            //if (code !== 0) {\n                            //    octal = true;\n                            //}\n\n                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                //TODO Review Removal octal = true;\n                                code = code * 8 + '01234567'.indexOf(advance());\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                    code = code * 8 + '01234567'.indexOf(advance());\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    if (ch ===  '\\r' && source.charCodeAt(index) === 0x0A  /* '\\n' */) {\n                        ++index;\n                    }\n                }\n            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            utility.throwError('unexpected quote');\n        }\n\n        value = str;\n        return Token.STRING;\n    }\n\n    function scanNumber() {\n        var number, ch;\n\n        number = '';\n        ch = source.charCodeAt(index);\n\n        if (ch !== 0x2E  /* '.' */) {\n            number = advance();\n            ch = source.charCodeAt(index);\n\n            if (number === '0') {\n                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isHexDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        utility.throwError('unexpected token');\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 16);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isOctalDigit(ch)) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 8);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    utility.throwError('unexpected token');\n                }\n            }\n\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x2E  /* '.' */) {\n            number += advance();\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {\n            number += advance();\n\n            ch = source.charCodeAt(index);\n            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {\n                number += advance();\n            }\n\n            ch = source.charCodeAt(index);\n            if (esutils.code.isDecimalDigit(ch)) {\n                number += advance();\n                while (index < length) {\n                    ch = source.charCodeAt(index);\n                    if (!esutils.code.isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += advance();\n                }\n            } else {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isIdentifierStartES5(ch)) {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        value = parseFloat(number);\n        return Token.NUMBER;\n    }\n\n\n    function scanTypeName() {\n        var ch, ch2;\n\n        value = advance();\n        while (index < length && isTypeName(source.charCodeAt(index))) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x2E  /* '.' */) {\n                if ((index + 1) >= length) {\n                    return Token.ILLEGAL;\n                }\n                ch2 = source.charCodeAt(index + 1);\n                if (ch2 === 0x3C  /* '<' */) {\n                    break;\n                }\n            }\n            value += advance();\n        }\n        return Token.NAME;\n    }\n\n    function next() {\n        var ch;\n\n        previous = index;\n\n        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\n            advance();\n        }\n        if (index >= length) {\n            token = Token.EOF;\n            return token;\n        }\n\n        ch = source.charCodeAt(index);\n        switch (ch) {\n        case 0x27:  /* ''' */\n        case 0x22:  /* '\"' */\n            token = scanString();\n            return token;\n\n        case 0x3A:  /* ':' */\n            advance();\n            token = Token.COLON;\n            return token;\n\n        case 0x2C:  /* ',' */\n            advance();\n            token = Token.COMMA;\n            return token;\n\n        case 0x28:  /* '(' */\n            advance();\n            token = Token.LPAREN;\n            return token;\n\n        case 0x29:  /* ')' */\n            advance();\n            token = Token.RPAREN;\n            return token;\n\n        case 0x5B:  /* '[' */\n            advance();\n            token = Token.LBRACK;\n            return token;\n\n        case 0x5D:  /* ']' */\n            advance();\n            token = Token.RBRACK;\n            return token;\n\n        case 0x7B:  /* '{' */\n            advance();\n            token = Token.LBRACE;\n            return token;\n\n        case 0x7D:  /* '}' */\n            advance();\n            token = Token.RBRACE;\n            return token;\n\n        case 0x2E:  /* '.' */\n            if (index + 1 < length) {\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x3C  /* '<' */) {\n                    advance();  // '.'\n                    advance();  // '<'\n                    token = Token.DOT_LT;\n                    return token;\n                }\n\n                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {\n                    advance();  // '.'\n                    advance();  // '.'\n                    advance();  // '.'\n                    token = Token.REST;\n                    return token;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    token = scanNumber();\n                    return token;\n                }\n            }\n            token = Token.ILLEGAL;\n            return token;\n\n        case 0x3C:  /* '<' */\n            advance();\n            token = Token.LT;\n            return token;\n\n        case 0x3E:  /* '>' */\n            advance();\n            token = Token.GT;\n            return token;\n\n        case 0x2A:  /* '*' */\n            advance();\n            token = Token.STAR;\n            return token;\n\n        case 0x7C:  /* '|' */\n            advance();\n            token = Token.PIPE;\n            return token;\n\n        case 0x3F:  /* '?' */\n            advance();\n            token = Token.QUESTION;\n            return token;\n\n        case 0x21:  /* '!' */\n            advance();\n            token = Token.BANG;\n            return token;\n\n        case 0x3D:  /* '=' */\n            advance();\n            token = Token.EQUAL;\n            return token;\n\n        case 0x2D: /* '-' */\n            token = scanNumber();\n            return token;\n\n        default:\n            if (esutils.code.isDecimalDigit(ch)) {\n                token = scanNumber();\n                return token;\n            }\n\n            // type string permits following case,\n            //\n            // namespace.module.MyClass\n            //\n            // this reduced 1 token TK_NAME\n            utility.assert(isTypeName(ch));\n            token = scanTypeName();\n            return token;\n        }\n    }\n\n    function consume(target, text) {\n        utility.assert(token === target, text || 'consumed token not matched');\n        next();\n    }\n\n    function expect(target, message) {\n        if (token !== target) {\n            utility.throwError(message || 'unexpected token');\n        }\n        next();\n    }\n\n    // UnionType := '(' TypeUnionList ')'\n    //\n    // TypeUnionList :=\n    //     <<empty>>\n    //   | NonemptyTypeUnionList\n    //\n    // NonemptyTypeUnionList :=\n    //     TypeExpression\n    //   | TypeExpression '|' NonemptyTypeUnionList\n    function parseUnionType() {\n        var elements, startIndex = index - 1;\n        consume(Token.LPAREN, 'UnionType should start with (');\n        elements = [];\n        if (token !== Token.RPAREN) {\n            while (true) {\n                elements.push(parseTypeExpression());\n                if (token === Token.RPAREN) {\n                    break;\n                }\n                expect(Token.PIPE);\n            }\n        }\n        consume(Token.RPAREN, 'UnionType should end with )');\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    // ArrayType := '[' ElementTypeList ']'\n    //\n    // ElementTypeList :=\n    //     <<empty>>\n    //  | TypeExpression\n    //  | '...' TypeExpression\n    //  | TypeExpression ',' ElementTypeList\n    function parseArrayType() {\n        var elements, startIndex = index - 1, restStartIndex;\n        consume(Token.LBRACK, 'ArrayType should start with [');\n        elements = [];\n        while (token !== Token.RBRACK) {\n            if (token === Token.REST) {\n                restStartIndex = index - 3;\n                consume(Token.REST);\n                elements.push(maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: parseTypeExpression()\n                }, [restStartIndex, previous]));\n                break;\n            } else {\n                elements.push(parseTypeExpression());\n            }\n            if (token !== Token.RBRACK) {\n                expect(Token.COMMA);\n            }\n        }\n        expect(Token.RBRACK);\n        return maybeAddRange({\n            type: Syntax.ArrayType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    function parseFieldName() {\n        var v = value;\n        if (token === Token.NAME || token === Token.STRING) {\n            next();\n            return v;\n        }\n\n        if (token === Token.NUMBER) {\n            consume(Token.NUMBER);\n            return String(v);\n        }\n\n        utility.throwError('unexpected token');\n    }\n\n    // FieldType :=\n    //     FieldName\n    //   | FieldName ':' TypeExpression\n    //\n    // FieldName :=\n    //     NameExpression\n    //   | StringLiteral\n    //   | NumberLiteral\n    //   | ReservedIdentifier\n    function parseFieldType() {\n        var key, rangeStart = previous;\n\n        key = parseFieldName();\n        if (token === Token.COLON) {\n            consume(Token.COLON);\n            return maybeAddRange({\n                type: Syntax.FieldType,\n                key: key,\n                value: parseTypeExpression()\n            }, [rangeStart, previous]);\n        }\n        return maybeAddRange({\n            type: Syntax.FieldType,\n            key: key,\n            value: null\n        }, [rangeStart, previous]);\n    }\n\n    // RecordType := '{' FieldTypeList '}'\n    //\n    // FieldTypeList :=\n    //     <<empty>>\n    //   | FieldType\n    //   | FieldType ',' FieldTypeList\n    function parseRecordType() {\n        var fields, rangeStart = index - 1, rangeEnd;\n\n        consume(Token.LBRACE, 'RecordType should start with {');\n        fields = [];\n        if (token === Token.COMMA) {\n            consume(Token.COMMA);\n        } else {\n            while (token !== Token.RBRACE) {\n                fields.push(parseFieldType());\n                if (token !== Token.RBRACE) {\n                    expect(Token.COMMA);\n                }\n            }\n        }\n        rangeEnd = index;\n        expect(Token.RBRACE);\n        return maybeAddRange({\n            type: Syntax.RecordType,\n            fields: fields\n        }, [rangeStart, rangeEnd]);\n    }\n\n    // NameExpression :=\n    //    Identifier\n    //  | TagIdentifier ':' Identifier\n    //\n    // Tag identifier is one of \"module\", \"external\" or \"event\"\n    // Identifier is the same as Token.NAME, including any dots, something like\n    // namespace.module.MyClass\n    function parseNameExpression() {\n        var name = value, rangeStart = index - name.length;\n        expect(Token.NAME);\n\n        if (token === Token.COLON && (\n                name === 'module' ||\n                name === 'external' ||\n                name === 'event')) {\n            consume(Token.COLON);\n            name += ':' + value;\n            expect(Token.NAME);\n        }\n\n        return maybeAddRange({\n            type: Syntax.NameExpression,\n            name: name\n        }, [rangeStart, previous]);\n    }\n\n    // TypeExpressionList :=\n    //     TopLevelTypeExpression\n    //   | TopLevelTypeExpression ',' TypeExpressionList\n    function parseTypeExpressionList() {\n        var elements = [];\n\n        elements.push(parseTop());\n        while (token === Token.COMMA) {\n            consume(Token.COMMA);\n            elements.push(parseTop());\n        }\n        return elements;\n    }\n\n    // TypeName :=\n    //     NameExpression\n    //   | NameExpression TypeApplication\n    //\n    // TypeApplication :=\n    //     '.<' TypeExpressionList '>'\n    //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n    function parseTypeName() {\n        var expr, applications, startIndex = index - value.length;\n\n        expr = parseNameExpression();\n        if (token === Token.DOT_LT || token === Token.LT) {\n            next();\n            applications = parseTypeExpressionList();\n            expect(Token.GT);\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: expr,\n                applications: applications\n            }, [startIndex, previous]);\n        }\n        return expr;\n    }\n\n    // ResultType :=\n    //     <<empty>>\n    //   | ':' void\n    //   | ':' TypeExpression\n    //\n    // BNF is above\n    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n    function parseResultType() {\n        consume(Token.COLON, 'ResultType should start with :');\n        if (token === Token.NAME && value === 'void') {\n            consume(Token.NAME);\n            return {\n                type: Syntax.VoidLiteral\n            };\n        }\n        return parseTypeExpression();\n    }\n\n    // ParametersType :=\n    //     RestParameterType\n    //   | NonRestParametersType\n    //   | NonRestParametersType ',' RestParameterType\n    //\n    // RestParameterType :=\n    //     '...'\n    //     '...' Identifier\n    //\n    // NonRestParametersType :=\n    //     ParameterType ',' NonRestParametersType\n    //   | ParameterType\n    //   | OptionalParametersType\n    //\n    // OptionalParametersType :=\n    //     OptionalParameterType\n    //   | OptionalParameterType, OptionalParametersType\n    //\n    // OptionalParameterType := ParameterType=\n    //\n    // ParameterType := TypeExpression | Identifier ':' TypeExpression\n    //\n    // Identifier is \"new\" or \"this\"\n    function parseParametersType() {\n        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;\n\n        while (token !== Token.RPAREN) {\n            if (token === Token.REST) {\n                // RestParameterType\n                consume(Token.REST);\n                rest = true;\n            }\n\n            startIndex = previous;\n\n            expr = parseTypeExpression();\n            if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n                nameStartIndex = previous - expr.name.length;\n                // Identifier ':' TypeExpression\n                consume(Token.COLON);\n                expr = maybeAddRange({\n                    type: Syntax.ParameterType,\n                    name: expr.name,\n                    expression: parseTypeExpression()\n                }, [nameStartIndex, previous]);\n            }\n            if (token === Token.EQUAL) {\n                consume(Token.EQUAL);\n                expr = maybeAddRange({\n                    type: Syntax.OptionalType,\n                    expression: expr\n                }, [startIndex, previous]);\n                optionalSequence = true;\n            } else {\n                if (optionalSequence) {\n                    utility.throwError('unexpected token');\n                }\n            }\n            if (rest) {\n                expr = maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: expr\n                }, [restStartIndex, previous]);\n            }\n            params.push(expr);\n            if (token !== Token.RPAREN) {\n                expect(Token.COMMA);\n            }\n        }\n        return params;\n    }\n\n    // FunctionType := 'function' FunctionSignatureType\n    //\n    // FunctionSignatureType :=\n    //   | TypeParameters '(' ')' ResultType\n    //   | TypeParameters '(' ParametersType ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n    function parseFunctionType() {\n        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;\n        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\n        consume(Token.NAME);\n\n        // Google Closure Compiler is not implementing TypeParameters.\n        // So we do not. if we don't get '(', we see it as error.\n        expect(Token.LPAREN);\n\n        isNew = false;\n        params = [];\n        thisBinding = null;\n        if (token !== Token.RPAREN) {\n            // ParametersType or 'this'\n            if (token === Token.NAME &&\n                    (value === 'this' || value === 'new')) {\n                // 'this' or 'new'\n                // 'new' is Closure Compiler extension\n                isNew = value === 'new';\n                consume(Token.NAME);\n                expect(Token.COLON);\n                thisBinding = parseTypeName();\n                if (token === Token.COMMA) {\n                    consume(Token.COMMA);\n                    params = parseParametersType();\n                }\n            } else {\n                params = parseParametersType();\n            }\n        }\n\n        expect(Token.RPAREN);\n\n        result = null;\n        if (token === Token.COLON) {\n            result = parseResultType();\n        }\n\n        fnType = maybeAddRange({\n            type: Syntax.FunctionType,\n            params: params,\n            result: result\n        }, [startIndex, previous]);\n        if (thisBinding) {\n            // avoid adding null 'new' and 'this' properties\n            fnType['this'] = thisBinding;\n            if (isNew) {\n                fnType['new'] = true;\n            }\n        }\n        return fnType;\n    }\n\n    // BasicTypeExpression :=\n    //     '*'\n    //   | 'null'\n    //   | 'undefined'\n    //   | TypeName\n    //   | FunctionType\n    //   | UnionType\n    //   | RecordType\n    //   | ArrayType\n    function parseBasicTypeExpression() {\n        var context, startIndex;\n        switch (token) {\n        case Token.STAR:\n            consume(Token.STAR);\n            return maybeAddRange({\n                type: Syntax.AllLiteral\n            }, [previous - 1, previous]);\n\n        case Token.LPAREN:\n            return parseUnionType();\n\n        case Token.LBRACK:\n            return parseArrayType();\n\n        case Token.LBRACE:\n            return parseRecordType();\n\n        case Token.NAME:\n            startIndex = index - value.length;\n\n            if (value === 'null') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.NullLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'undefined') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.UndefinedLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'true' || value === 'false') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.BooleanLiteralType,\n                    value: value === 'true'\n                }, [startIndex, previous]);\n            }\n\n            context = Context.save();\n            if (value === 'function') {\n                try {\n                    return parseFunctionType();\n                } catch (e) {\n                    context.restore();\n                }\n            }\n\n            return parseTypeName();\n\n        case Token.STRING:\n            next();\n            return maybeAddRange({\n                type: Syntax.StringLiteralType,\n                value: value\n            }, [previous - value.length - 2, previous]);\n\n        case Token.NUMBER:\n            next();\n            return maybeAddRange({\n                type: Syntax.NumericLiteralType,\n                value: value\n            }, [previous - String(value).length, previous]);\n\n        default:\n            utility.throwError('unexpected token');\n        }\n    }\n\n    // TypeExpression :=\n    //     BasicTypeExpression\n    //   | '?' BasicTypeExpression\n    //   | '!' BasicTypeExpression\n    //   | BasicTypeExpression '?'\n    //   | BasicTypeExpression '!'\n    //   | '?'\n    //   | BasicTypeExpression '[]'\n    function parseTypeExpression() {\n        var expr, rangeStart;\n\n        if (token === Token.QUESTION) {\n            rangeStart = index - 1;\n            consume(Token.QUESTION);\n            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||\n                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||\n                    token === Token.RBRACK || token === Token.GT) {\n                return maybeAddRange({\n                    type: Syntax.NullableLiteral\n                }, [rangeStart, previous]);\n            }\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else if (token === Token.BANG) {\n            rangeStart = index - 1;\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else {\n            rangeStart = previous;\n        }\n\n        expr = parseBasicTypeExpression();\n        if (token === Token.BANG) {\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.QUESTION) {\n            consume(Token.QUESTION);\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.LBRACK) {\n            consume(Token.LBRACK);\n            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: maybeAddRange({\n                    type: Syntax.NameExpression,\n                    name: 'Array'\n                }, [rangeStart, previous]),\n                applications: [expr]\n            }, [rangeStart, previous]);\n        }\n\n        return expr;\n    }\n\n    // TopLevelTypeExpression :=\n    //      TypeExpression\n    //    | TypeUnionList\n    //\n    // This rule is Google Closure Compiler extension, not ES4\n    // like,\n    //   { number | string }\n    // If strict to ES4, we should write it as\n    //   { (number|string) }\n    function parseTop() {\n        var expr, elements;\n\n        expr = parseTypeExpression();\n        if (token !== Token.PIPE) {\n            return expr;\n        }\n\n        elements = [expr];\n        consume(Token.PIPE);\n        while (true) {\n            elements.push(parseTypeExpression());\n            if (token !== Token.PIPE) {\n                break;\n            }\n            consume(Token.PIPE);\n        }\n\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [0, index]);\n    }\n\n    function parseTopParamType() {\n        var expr;\n\n        if (token === Token.REST) {\n            consume(Token.REST);\n            return maybeAddRange({\n                type: Syntax.RestType,\n                expression: parseTop()\n            }, [0, index]);\n        }\n\n        expr = parseTop();\n        if (token === Token.EQUAL) {\n            consume(Token.EQUAL);\n            return maybeAddRange({\n                type: Syntax.OptionalType,\n                expression: expr\n            }, [0, index]);\n        }\n\n        return expr;\n    }\n\n    function parseType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTop();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function parseParamType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTopParamType();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function stringifyImpl(node, compact, topLevel) {\n        var result, i, iz;\n\n        switch (node.type) {\n        case Syntax.NullableLiteral:\n            result = '?';\n            break;\n\n        case Syntax.AllLiteral:\n            result = '*';\n            break;\n\n        case Syntax.NullLiteral:\n            result = 'null';\n            break;\n\n        case Syntax.UndefinedLiteral:\n            result = 'undefined';\n            break;\n\n        case Syntax.VoidLiteral:\n            result = 'void';\n            break;\n\n        case Syntax.UnionType:\n            if (!topLevel) {\n                result = '(';\n            } else {\n                result = '';\n            }\n\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? '|' : ' | ';\n                }\n            }\n\n            if (!topLevel) {\n                result += ')';\n            }\n            break;\n\n        case Syntax.ArrayType:\n            result = '[';\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += ']';\n            break;\n\n        case Syntax.RecordType:\n            result = '{';\n            for (i = 0, iz = node.fields.length; i < iz; ++i) {\n                result += stringifyImpl(node.fields[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '}';\n            break;\n\n        case Syntax.FieldType:\n            if (node.value) {\n                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\n            } else {\n                result = node.key;\n            }\n            break;\n\n        case Syntax.FunctionType:\n            result = compact ? 'function(' : 'function (';\n\n            if (node['this']) {\n                if (node['new']) {\n                    result += (compact ? 'new:' : 'new: ');\n                } else {\n                    result += (compact ? 'this:' : 'this: ');\n                }\n\n                result += stringifyImpl(node['this'], compact);\n\n                if (node.params.length !== 0) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\n                result += stringifyImpl(node.params[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            result += ')';\n\n            if (node.result) {\n                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\n            }\n            break;\n\n        case Syntax.ParameterType:\n            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\n            break;\n\n        case Syntax.RestType:\n            result = '...';\n            if (node.expression) {\n                result += stringifyImpl(node.expression, compact);\n            }\n            break;\n\n        case Syntax.NonNullableType:\n            if (node.prefix) {\n                result = '!' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '!';\n            }\n            break;\n\n        case Syntax.OptionalType:\n            result = stringifyImpl(node.expression, compact) + '=';\n            break;\n\n        case Syntax.NullableType:\n            if (node.prefix) {\n                result = '?' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '?';\n            }\n            break;\n\n        case Syntax.NameExpression:\n            result = node.name;\n            break;\n\n        case Syntax.TypeApplication:\n            result = stringifyImpl(node.expression, compact) + '.<';\n            for (i = 0, iz = node.applications.length; i < iz; ++i) {\n                result += stringifyImpl(node.applications[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '>';\n            break;\n\n        case Syntax.StringLiteralType:\n            result = '\"' + node.value + '\"';\n            break;\n\n        case Syntax.NumericLiteralType:\n            result = String(node.value);\n            break;\n\n        case Syntax.BooleanLiteralType:\n            result = String(node.value);\n            break;\n\n        default:\n            utility.throwError('Unknown type ' + node.type);\n        }\n\n        return result;\n    }\n\n    function stringify(node, options) {\n        if (options == null) {\n            options = {};\n        }\n        return stringifyImpl(node, options.compact, options.topLevel);\n    }\n\n    exports.parseType = parseType;\n    exports.parseParamType = parseParamType;\n    exports.stringify = stringify;\n    exports.Syntax = Syntax;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}