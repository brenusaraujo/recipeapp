{"ast":null,"code":"/**\n * @fileoverview Define 2 token factories; forward and backward.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst BackwardTokenCommentCursor = require(\"./backward-token-comment-cursor\");\n\nconst BackwardTokenCursor = require(\"./backward-token-cursor\");\n\nconst FilterCursor = require(\"./filter-cursor\");\n\nconst ForwardTokenCommentCursor = require(\"./forward-token-comment-cursor\");\n\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\n\nconst LimitCursor = require(\"./limit-cursor\");\n\nconst SkipCursor = require(\"./skip-cursor\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The cursor factory.\n * @private\n */\n\n\nclass CursorFactory {\n  /**\n   * Initializes this cursor.\n   * @param {Function} TokenCursor The class of the cursor which iterates tokens only.\n   * @param {Function} TokenCommentCursor The class of the cursor which iterates the mix of tokens and comments.\n   */\n  constructor(TokenCursor, TokenCommentCursor) {\n    this.TokenCursor = TokenCursor;\n    this.TokenCommentCursor = TokenCommentCursor;\n  }\n  /**\n   * Creates a base cursor instance that can be decorated by createCursor.\n   * @param {Token[]} tokens The array of tokens.\n   * @param {Comment[]} comments The array of comments.\n   * @param {Object} indexMap The map from locations to indices in `tokens`.\n   * @param {number} startLoc The start location of the iteration range.\n   * @param {number} endLoc The end location of the iteration range.\n   * @param {boolean} includeComments The flag to iterate comments as well.\n   * @returns {Cursor} The created base cursor.\n   */\n\n\n  createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {\n    const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;\n    return new Cursor(tokens, comments, indexMap, startLoc, endLoc);\n  }\n  /**\n   * Creates a cursor that iterates tokens with normalized options.\n   * @param {Token[]} tokens The array of tokens.\n   * @param {Comment[]} comments The array of comments.\n   * @param {Object} indexMap The map from locations to indices in `tokens`.\n   * @param {number} startLoc The start location of the iteration range.\n   * @param {number} endLoc The end location of the iteration range.\n   * @param {boolean} includeComments The flag to iterate comments as well.\n   * @param {Function|null} filter The predicate function to choose tokens.\n   * @param {number} skip The count of tokens the cursor skips.\n   * @param {number} count The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n   * @returns {Cursor} The created cursor.\n   */\n\n\n  createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {\n    let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);\n\n    if (filter) {\n      cursor = new FilterCursor(cursor, filter);\n    }\n\n    if (skip >= 1) {\n      cursor = new SkipCursor(cursor, skip);\n    }\n\n    if (count >= 0) {\n      cursor = new LimitCursor(cursor, count);\n    }\n\n    return cursor;\n  }\n\n} //------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n\nexports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);\nexports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);","map":{"version":3,"names":["BackwardTokenCommentCursor","require","BackwardTokenCursor","FilterCursor","ForwardTokenCommentCursor","ForwardTokenCursor","LimitCursor","SkipCursor","CursorFactory","constructor","TokenCursor","TokenCommentCursor","createBaseCursor","tokens","comments","indexMap","startLoc","endLoc","includeComments","Cursor","createCursor","filter","skip","count","cursor","exports","forward","backward"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/source-code/token-store/cursors.js"],"sourcesContent":["/**\n * @fileoverview Define 2 token factories; forward and backward.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst BackwardTokenCommentCursor = require(\"./backward-token-comment-cursor\");\nconst BackwardTokenCursor = require(\"./backward-token-cursor\");\nconst FilterCursor = require(\"./filter-cursor\");\nconst ForwardTokenCommentCursor = require(\"./forward-token-comment-cursor\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst LimitCursor = require(\"./limit-cursor\");\nconst SkipCursor = require(\"./skip-cursor\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The cursor factory.\n * @private\n */\nclass CursorFactory {\n\n    /**\n     * Initializes this cursor.\n     * @param {Function} TokenCursor The class of the cursor which iterates tokens only.\n     * @param {Function} TokenCommentCursor The class of the cursor which iterates the mix of tokens and comments.\n     */\n    constructor(TokenCursor, TokenCommentCursor) {\n        this.TokenCursor = TokenCursor;\n        this.TokenCommentCursor = TokenCommentCursor;\n    }\n\n    /**\n     * Creates a base cursor instance that can be decorated by createCursor.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     * @param {boolean} includeComments The flag to iterate comments as well.\n     * @returns {Cursor} The created base cursor.\n     */\n    createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {\n        const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;\n\n        return new Cursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n\n    /**\n     * Creates a cursor that iterates tokens with normalized options.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     * @param {boolean} includeComments The flag to iterate comments as well.\n     * @param {Function|null} filter The predicate function to choose tokens.\n     * @param {number} skip The count of tokens the cursor skips.\n     * @param {number} count The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n     * @returns {Cursor} The created cursor.\n     */\n    createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {\n        let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);\n\n        if (filter) {\n            cursor = new FilterCursor(cursor, filter);\n        }\n        if (skip >= 1) {\n            cursor = new SkipCursor(cursor, skip);\n        }\n        if (count >= 0) {\n            cursor = new LimitCursor(cursor, count);\n        }\n\n        return cursor;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\nexports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);\nexports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,0BAA0B,GAAGC,OAAO,CAAC,iCAAD,CAA1C;;AACA,MAAMC,mBAAmB,GAAGD,OAAO,CAAC,yBAAD,CAAnC;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAMG,yBAAyB,GAAGH,OAAO,CAAC,gCAAD,CAAzC;;AACA,MAAMI,kBAAkB,GAAGJ,OAAO,CAAC,wBAAD,CAAlC;;AACA,MAAMK,WAAW,GAAGL,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMM,UAAU,GAAGN,OAAO,CAAC,eAAD,CAA1B,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACA,MAAMO,aAAN,CAAoB;EAEhB;AACJ;AACA;AACA;AACA;EACIC,WAAW,CAACC,WAAD,EAAcC,kBAAd,EAAkC;IACzC,KAAKD,WAAL,GAAmBA,WAAnB;IACA,KAAKC,kBAAL,GAA0BA,kBAA1B;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,gBAAgB,CAACC,MAAD,EAASC,QAAT,EAAmBC,QAAnB,EAA6BC,QAA7B,EAAuCC,MAAvC,EAA+CC,eAA/C,EAAgE;IAC5E,MAAMC,MAAM,GAAGD,eAAe,GAAG,KAAKP,kBAAR,GAA6B,KAAKD,WAAhE;IAEA,OAAO,IAAIS,MAAJ,CAAWN,MAAX,EAAmBC,QAAnB,EAA6BC,QAA7B,EAAuCC,QAAvC,EAAiDC,MAAjD,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIG,YAAY,CAACP,MAAD,EAASC,QAAT,EAAmBC,QAAnB,EAA6BC,QAA7B,EAAuCC,MAAvC,EAA+CC,eAA/C,EAAgEG,MAAhE,EAAwEC,IAAxE,EAA8EC,KAA9E,EAAqF;IAC7F,IAAIC,MAAM,GAAG,KAAKZ,gBAAL,CAAsBC,MAAtB,EAA8BC,QAA9B,EAAwCC,QAAxC,EAAkDC,QAAlD,EAA4DC,MAA5D,EAAoEC,eAApE,CAAb;;IAEA,IAAIG,MAAJ,EAAY;MACRG,MAAM,GAAG,IAAIrB,YAAJ,CAAiBqB,MAAjB,EAAyBH,MAAzB,CAAT;IACH;;IACD,IAAIC,IAAI,IAAI,CAAZ,EAAe;MACXE,MAAM,GAAG,IAAIjB,UAAJ,CAAeiB,MAAf,EAAuBF,IAAvB,CAAT;IACH;;IACD,IAAIC,KAAK,IAAI,CAAb,EAAgB;MACZC,MAAM,GAAG,IAAIlB,WAAJ,CAAgBkB,MAAhB,EAAwBD,KAAxB,CAAT;IACH;;IAED,OAAOC,MAAP;EACH;;AAvDe,C,CA0DpB;AACA;AACA;;;AAEAC,OAAO,CAACC,OAAR,GAAkB,IAAIlB,aAAJ,CAAkBH,kBAAlB,EAAsCD,yBAAtC,CAAlB;AACAqB,OAAO,CAACE,QAAR,GAAmB,IAAInB,aAAJ,CAAkBN,mBAAlB,EAAuCF,0BAAvC,CAAnB"},"metadata":{},"sourceType":"script"}