{"ast":null,"code":"'use strict';\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type = require('../type'); // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n\n\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n  var code,\n      idx,\n      bitlen = 0,\n      max = data.length,\n      map = BASE64_MAP; // Convert one by one.\n\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx)); // Skip CR/LF\n\n    if (code > 64) continue; // Fail on illegal characters\n\n    if (code < 0) return false;\n    bitlen += 6;\n  } // If there are any bits left, source was corrupted\n\n\n  return bitlen % 8 === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx,\n      tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''),\n      // remove CR/LF & padding to simplify scan\n  max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = []; // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 4 === 0 && idx) {\n      result.push(bits >> 16 & 0xFF);\n      result.push(bits >> 8 & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = bits << 6 | map.indexOf(input.charAt(idx));\n  } // Dump tail\n\n\n  tailbits = max % 4 * 6;\n\n  if (tailbits === 0) {\n    result.push(bits >> 16 & 0xFF);\n    result.push(bits >> 8 & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push(bits >> 10 & 0xFF);\n    result.push(bits >> 2 & 0xFF);\n  } else if (tailbits === 12) {\n    result.push(bits >> 4 & 0xFF);\n  } // Wrap into Buffer for NodeJS and leave Array for browser\n\n\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object\n/*, style*/\n) {\n  var result = '',\n      bits = 0,\n      idx,\n      tail,\n      max = object.length,\n      map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 3 === 0 && idx) {\n      result += map[bits >> 18 & 0x3F];\n      result += map[bits >> 12 & 0x3F];\n      result += map[bits >> 6 & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  } // Dump tail\n\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[bits >> 18 & 0x3F];\n    result += map[bits >> 12 & 0x3F];\n    result += map[bits >> 6 & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[bits >> 10 & 0x3F];\n    result += map[bits >> 4 & 0x3F];\n    result += map[bits << 2 & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[bits >> 2 & 0x3F];\n    result += map[bits << 4 & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});","map":{"version":3,"names":["NodeBuffer","_require","require","Buffer","__","Type","BASE64_MAP","resolveYamlBinary","data","code","idx","bitlen","max","length","map","indexOf","charAt","constructYamlBinary","tailbits","input","replace","bits","result","push","from","representYamlBinary","object","tail","isBinary","isBuffer","module","exports","kind","resolve","construct","predicate","represent"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/js-yaml/lib/js-yaml/type/binary.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}