{"ast":null,"code":"// Generated by LiveScript 1.6.0\n(function () {\n  var identifierRegex, tokenRegex;\n  identifierRegex = /[\\$\\w]+/;\n\n  function peek(tokens) {\n    var token;\n    token = tokens[0];\n\n    if (token == null) {\n      throw new Error('Unexpected end of input.');\n    }\n\n    return token;\n  }\n\n  function consumeIdent(tokens) {\n    var token;\n    token = peek(tokens);\n\n    if (!identifierRegex.test(token)) {\n      throw new Error(\"Expected text, got '\" + token + \"' instead.\");\n    }\n\n    return tokens.shift();\n  }\n\n  function consumeOp(tokens, op) {\n    var token;\n    token = peek(tokens);\n\n    if (token !== op) {\n      throw new Error(\"Expected '\" + op + \"', got '\" + token + \"' instead.\");\n    }\n\n    return tokens.shift();\n  }\n\n  function maybeConsumeOp(tokens, op) {\n    var token;\n    token = tokens[0];\n\n    if (token === op) {\n      return tokens.shift();\n    } else {\n      return null;\n    }\n  }\n\n  function consumeArray(tokens) {\n    var types;\n    consumeOp(tokens, '[');\n\n    if (peek(tokens) === ']') {\n      throw new Error(\"Must specify type of Array - eg. [Type], got [] instead.\");\n    }\n\n    types = consumeTypes(tokens);\n    consumeOp(tokens, ']');\n    return {\n      structure: 'array',\n      of: types\n    };\n  }\n\n  function consumeTuple(tokens) {\n    var components;\n    components = [];\n    consumeOp(tokens, '(');\n\n    if (peek(tokens) === ')') {\n      throw new Error(\"Tuple must be of at least length 1 - eg. (Type), got () instead.\");\n    }\n\n    for (;;) {\n      components.push(consumeTypes(tokens));\n      maybeConsumeOp(tokens, ',');\n\n      if (')' === peek(tokens)) {\n        break;\n      }\n    }\n\n    consumeOp(tokens, ')');\n    return {\n      structure: 'tuple',\n      of: components\n    };\n  }\n\n  function consumeFields(tokens) {\n    var fields, subset, ref$, key, types;\n    fields = {};\n    consumeOp(tokens, '{');\n    subset = false;\n\n    for (;;) {\n      if (maybeConsumeOp(tokens, '...')) {\n        subset = true;\n        break;\n      }\n\n      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];\n      fields[key] = types;\n      maybeConsumeOp(tokens, ',');\n\n      if ('}' === peek(tokens)) {\n        break;\n      }\n    }\n\n    consumeOp(tokens, '}');\n    return {\n      structure: 'fields',\n      of: fields,\n      subset: subset\n    };\n  }\n\n  function consumeField(tokens) {\n    var key, types;\n    key = consumeIdent(tokens);\n    consumeOp(tokens, ':');\n    types = consumeTypes(tokens);\n    return [key, types];\n  }\n\n  function maybeConsumeStructure(tokens) {\n    switch (tokens[0]) {\n      case '[':\n        return consumeArray(tokens);\n\n      case '(':\n        return consumeTuple(tokens);\n\n      case '{':\n        return consumeFields(tokens);\n    }\n  }\n\n  function consumeType(tokens) {\n    var token, wildcard, type, structure;\n    token = peek(tokens);\n    wildcard = token === '*';\n\n    if (wildcard || identifierRegex.test(token)) {\n      type = wildcard ? consumeOp(tokens, '*') : consumeIdent(tokens);\n      structure = maybeConsumeStructure(tokens);\n\n      if (structure) {\n        return structure.type = type, structure;\n      } else {\n        return {\n          type: type\n        };\n      }\n    } else {\n      structure = maybeConsumeStructure(tokens);\n\n      if (!structure) {\n        throw new Error(\"Unexpected character: \" + token);\n      }\n\n      return structure;\n    }\n  }\n\n  function consumeTypes(tokens) {\n    var lookahead, types, typesSoFar, typeObj, type, structure;\n\n    if ('::' === peek(tokens)) {\n      throw new Error(\"No comment before comment separator '::' found.\");\n    }\n\n    lookahead = tokens[1];\n\n    if (lookahead != null && lookahead === '::') {\n      tokens.shift();\n      tokens.shift();\n    }\n\n    types = [];\n    typesSoFar = {};\n\n    if ('Maybe' === peek(tokens)) {\n      tokens.shift();\n      types = [{\n        type: 'Undefined'\n      }, {\n        type: 'Null'\n      }];\n      typesSoFar = {\n        Undefined: true,\n        Null: true\n      };\n    }\n\n    for (;;) {\n      typeObj = consumeType(tokens), type = typeObj.type, structure = typeObj.structure;\n\n      if (!typesSoFar[type]) {\n        types.push(typeObj);\n      }\n\n      if (structure == null) {\n        typesSoFar[type] = true;\n      }\n\n      if (!maybeConsumeOp(tokens, '|')) {\n        break;\n      }\n    }\n\n    return types;\n  }\n\n  tokenRegex = RegExp('\\\\.\\\\.\\\\.|::|->|' + identifierRegex.source + '|\\\\S', 'g');\n\n  module.exports = function (input) {\n    var tokens, e;\n\n    if (!input.length) {\n      throw new Error('No type specified.');\n    }\n\n    tokens = input.match(tokenRegex) || [];\n\n    if (in$('->', tokens)) {\n      throw new Error(\"Function types are not supported.\\ To validate that something is a function, you may use 'Function'.\");\n    }\n\n    try {\n      return consumeTypes(tokens);\n    } catch (e$) {\n      e = e$;\n      throw new Error(e.message + \" - Remaining tokens: \" + JSON.stringify(tokens) + \" - Initial input: '\" + input + \"'\");\n    }\n  };\n\n  function in$(x, xs) {\n    var i = -1,\n        l = xs.length >>> 0;\n\n    while (++i < l) if (x === xs[i]) return true;\n\n    return false;\n  }\n}).call(this);","map":{"version":3,"names":["identifierRegex","tokenRegex","peek","tokens","token","Error","consumeIdent","test","shift","consumeOp","op","maybeConsumeOp","consumeArray","types","consumeTypes","structure","of","consumeTuple","components","push","consumeFields","fields","subset","ref$","key","consumeField","maybeConsumeStructure","consumeType","wildcard","type","lookahead","typesSoFar","typeObj","Undefined","Null","RegExp","source","module","exports","input","e","length","match","in$","e$","message","JSON","stringify","x","xs","i","l","call"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/type-check/lib/parse-type.js"],"sourcesContent":["// Generated by LiveScript 1.6.0\n(function(){\n  var identifierRegex, tokenRegex;\n  identifierRegex = /[\\$\\w]+/;\n  function peek(tokens){\n    var token;\n    token = tokens[0];\n    if (token == null) {\n      throw new Error('Unexpected end of input.');\n    }\n    return token;\n  }\n  function consumeIdent(tokens){\n    var token;\n    token = peek(tokens);\n    if (!identifierRegex.test(token)) {\n      throw new Error(\"Expected text, got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function consumeOp(tokens, op){\n    var token;\n    token = peek(tokens);\n    if (token !== op) {\n      throw new Error(\"Expected '\" + op + \"', got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function maybeConsumeOp(tokens, op){\n    var token;\n    token = tokens[0];\n    if (token === op) {\n      return tokens.shift();\n    } else {\n      return null;\n    }\n  }\n  function consumeArray(tokens){\n    var types;\n    consumeOp(tokens, '[');\n    if (peek(tokens) === ']') {\n      throw new Error(\"Must specify type of Array - eg. [Type], got [] instead.\");\n    }\n    types = consumeTypes(tokens);\n    consumeOp(tokens, ']');\n    return {\n      structure: 'array',\n      of: types\n    };\n  }\n  function consumeTuple(tokens){\n    var components;\n    components = [];\n    consumeOp(tokens, '(');\n    if (peek(tokens) === ')') {\n      throw new Error(\"Tuple must be of at least length 1 - eg. (Type), got () instead.\");\n    }\n    for (;;) {\n      components.push(consumeTypes(tokens));\n      maybeConsumeOp(tokens, ',');\n      if (')' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, ')');\n    return {\n      structure: 'tuple',\n      of: components\n    };\n  }\n  function consumeFields(tokens){\n    var fields, subset, ref$, key, types;\n    fields = {};\n    consumeOp(tokens, '{');\n    subset = false;\n    for (;;) {\n      if (maybeConsumeOp(tokens, '...')) {\n        subset = true;\n        break;\n      }\n      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];\n      fields[key] = types;\n      maybeConsumeOp(tokens, ',');\n      if ('}' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, '}');\n    return {\n      structure: 'fields',\n      of: fields,\n      subset: subset\n    };\n  }\n  function consumeField(tokens){\n    var key, types;\n    key = consumeIdent(tokens);\n    consumeOp(tokens, ':');\n    types = consumeTypes(tokens);\n    return [key, types];\n  }\n  function maybeConsumeStructure(tokens){\n    switch (tokens[0]) {\n    case '[':\n      return consumeArray(tokens);\n    case '(':\n      return consumeTuple(tokens);\n    case '{':\n      return consumeFields(tokens);\n    }\n  }\n  function consumeType(tokens){\n    var token, wildcard, type, structure;\n    token = peek(tokens);\n    wildcard = token === '*';\n    if (wildcard || identifierRegex.test(token)) {\n      type = wildcard\n        ? consumeOp(tokens, '*')\n        : consumeIdent(tokens);\n      structure = maybeConsumeStructure(tokens);\n      if (structure) {\n        return structure.type = type, structure;\n      } else {\n        return {\n          type: type\n        };\n      }\n    } else {\n      structure = maybeConsumeStructure(tokens);\n      if (!structure) {\n        throw new Error(\"Unexpected character: \" + token);\n      }\n      return structure;\n    }\n  }\n  function consumeTypes(tokens){\n    var lookahead, types, typesSoFar, typeObj, type, structure;\n    if ('::' === peek(tokens)) {\n      throw new Error(\"No comment before comment separator '::' found.\");\n    }\n    lookahead = tokens[1];\n    if (lookahead != null && lookahead === '::') {\n      tokens.shift();\n      tokens.shift();\n    }\n    types = [];\n    typesSoFar = {};\n    if ('Maybe' === peek(tokens)) {\n      tokens.shift();\n      types = [\n        {\n          type: 'Undefined'\n        }, {\n          type: 'Null'\n        }\n      ];\n      typesSoFar = {\n        Undefined: true,\n        Null: true\n      };\n    }\n    for (;;) {\n      typeObj = consumeType(tokens), type = typeObj.type, structure = typeObj.structure;\n      if (!typesSoFar[type]) {\n        types.push(typeObj);\n      }\n      if (structure == null) {\n        typesSoFar[type] = true;\n      }\n      if (!maybeConsumeOp(tokens, '|')) {\n        break;\n      }\n    }\n    return types;\n  }\n  tokenRegex = RegExp('\\\\.\\\\.\\\\.|::|->|' + identifierRegex.source + '|\\\\S', 'g');\n  module.exports = function(input){\n    var tokens, e;\n    if (!input.length) {\n      throw new Error('No type specified.');\n    }\n    tokens = input.match(tokenRegex) || [];\n    if (in$('->', tokens)) {\n      throw new Error(\"Function types are not supported.\\ To validate that something is a function, you may use 'Function'.\");\n    }\n    try {\n      return consumeTypes(tokens);\n    } catch (e$) {\n      e = e$;\n      throw new Error(e.message + \" - Remaining tokens: \" + JSON.stringify(tokens) + \" - Initial input: '\" + input + \"'\");\n    }\n  };\n  function in$(x, xs){\n    var i = -1, l = xs.length >>> 0;\n    while (++i < l) if (x === xs[i]) return true;\n    return false;\n  }\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}