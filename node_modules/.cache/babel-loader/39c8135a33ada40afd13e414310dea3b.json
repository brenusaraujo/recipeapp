{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBoundedIndex = exports.getDefaultSlideIndex = exports.getPrevMoveIndex = exports.getNextMoveIndex = exports.isSlideVisible = void 0;\n\nconst default_controls_1 = require(\"./default-controls\");\n\nconst types_1 = require(\"./types\");\n\nconst isSlideVisible = (currentSlide, indexToCheck, slidesToShow, cellAlign) => {\n  // The addition or subtraction of constants (1 , 0.5) in the following\n  // calculations are accounting for the fact that a slide will be visible even\n  // after the position associated with its index is off-screen. For example,\n  // with cellAlign=\"left\", slidesToShow=1 and indexToCheck=0,\n  // if the currentSlide is set to 0.99, both (a sliver of) slide 0 and slide 1\n  // will be visible at the same time, even though the position we associate\n  // with index 0, its leftmost edge, is off-screen.\n  if (cellAlign === 'left') {\n    return indexToCheck < currentSlide + slidesToShow && indexToCheck > currentSlide - 1;\n  }\n\n  if (cellAlign === 'center') {\n    return indexToCheck > currentSlide - slidesToShow / 2 - 0.5 && indexToCheck <= currentSlide || indexToCheck > currentSlide && indexToCheck < currentSlide + slidesToShow / 2 + 0.5;\n  }\n\n  if (cellAlign === 'right') {\n    return indexToCheck < currentSlide + 1 && indexToCheck > currentSlide - slidesToShow;\n  }\n\n  return false;\n};\n\nexports.isSlideVisible = isSlideVisible;\n\nconst getNextMoveIndex = (scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign) => {\n  if (wrapAround) {\n    return currentSlide + slidesToScroll;\n  } // Quit early if we're already as far right as we can go\n\n\n  if (currentSlide >= slideCount - 1 || cellAlign === 'left' && currentSlide >= slideCount - slidesToShow) {\n    return currentSlide;\n  }\n\n  if (scrollMode === types_1.ScrollMode.remainder && cellAlign === 'left') {\n    return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);\n  }\n\n  return Math.min(currentSlide + slidesToScroll, slideCount - 1);\n};\n\nexports.getNextMoveIndex = getNextMoveIndex;\n\nconst getPrevMoveIndex = (scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign) => {\n  if (wrapAround) {\n    return currentSlide - slidesToScroll;\n  } // Quit early if we're already as far left as we can go\n\n\n  if (currentSlide <= 0 || cellAlign === 'right' && currentSlide <= slidesToShow - 1) {\n    return currentSlide;\n  }\n\n  if (scrollMode === types_1.ScrollMode.remainder && cellAlign === 'right') {\n    return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);\n  }\n\n  return Math.max(currentSlide - slidesToScroll, 0);\n};\n\nexports.getPrevMoveIndex = getPrevMoveIndex;\n\nconst getDefaultSlideIndex = (slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode) => {\n  if (slideIndex !== undefined) {\n    return slideIndex;\n  }\n\n  const dotIndexes = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, false, cellAlign);\n  return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];\n};\n\nexports.getDefaultSlideIndex = getDefaultSlideIndex;\n/**\n * Boils down an unbounded index (-Infinity < index < Infinity) to a bounded one\n * (0 ≤ index < slideCount)\n */\n\nconst getBoundedIndex = (rawIndex, slideCount) => {\n  return (rawIndex % slideCount + slideCount) % slideCount;\n};\n\nexports.getBoundedIndex = getBoundedIndex;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBoundedIndex = exports.getDefaultSlideIndex = exports.getPrevMoveIndex = exports.getNextMoveIndex = exports.isSlideVisible = void 0;\nconst default_controls_1 = require(\"./default-controls\");\nconst types_1 = require(\"./types\");\nconst isSlideVisible = (currentSlide, indexToCheck, slidesToShow, cellAlign) => {\n    // The addition or subtraction of constants (1 , 0.5) in the following\n    // calculations are accounting for the fact that a slide will be visible even\n    // after the position associated with its index is off-screen. For example,\n    // with cellAlign=\"left\", slidesToShow=1 and indexToCheck=0,\n    // if the currentSlide is set to 0.99, both (a sliver of) slide 0 and slide 1\n    // will be visible at the same time, even though the position we associate\n    // with index 0, its leftmost edge, is off-screen.\n    if (cellAlign === 'left') {\n        return (indexToCheck < currentSlide + slidesToShow &&\n            indexToCheck > currentSlide - 1);\n    }\n    if (cellAlign === 'center') {\n        return ((indexToCheck > currentSlide - slidesToShow / 2 - 0.5 &&\n            indexToCheck <= currentSlide) ||\n            (indexToCheck > currentSlide &&\n                indexToCheck < currentSlide + slidesToShow / 2 + 0.5));\n    }\n    if (cellAlign === 'right') {\n        return (indexToCheck < currentSlide + 1 &&\n            indexToCheck > currentSlide - slidesToShow);\n    }\n    return false;\n};\nexports.isSlideVisible = isSlideVisible;\nconst getNextMoveIndex = (scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign) => {\n    if (wrapAround) {\n        return currentSlide + slidesToScroll;\n    }\n    // Quit early if we're already as far right as we can go\n    if (currentSlide >= slideCount - 1 ||\n        (cellAlign === 'left' && currentSlide >= slideCount - slidesToShow)) {\n        return currentSlide;\n    }\n    if (scrollMode === types_1.ScrollMode.remainder && cellAlign === 'left') {\n        return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);\n    }\n    return Math.min(currentSlide + slidesToScroll, slideCount - 1);\n};\nexports.getNextMoveIndex = getNextMoveIndex;\nconst getPrevMoveIndex = (scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign) => {\n    if (wrapAround) {\n        return currentSlide - slidesToScroll;\n    }\n    // Quit early if we're already as far left as we can go\n    if (currentSlide <= 0 ||\n        (cellAlign === 'right' && currentSlide <= slidesToShow - 1)) {\n        return currentSlide;\n    }\n    if (scrollMode === types_1.ScrollMode.remainder && cellAlign === 'right') {\n        return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);\n    }\n    return Math.max(currentSlide - slidesToScroll, 0);\n};\nexports.getPrevMoveIndex = getPrevMoveIndex;\nconst getDefaultSlideIndex = (slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode) => {\n    if (slideIndex !== undefined) {\n        return slideIndex;\n    }\n    const dotIndexes = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, false, cellAlign);\n    return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];\n};\nexports.getDefaultSlideIndex = getDefaultSlideIndex;\n/**\n * Boils down an unbounded index (-Infinity < index < Infinity) to a bounded one\n * (0 ≤ index < slideCount)\n */\nconst getBoundedIndex = (rawIndex, slideCount) => {\n    return ((rawIndex % slideCount) + slideCount) % slideCount;\n};\nexports.getBoundedIndex = getBoundedIndex;\n"]},"metadata":{},"sourceType":"script"}