{"ast":null,"code":"/*\n * @fileoverview Main Doctrine object\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n(function () {\n  'use strict';\n\n  var typed, utility, jsdoc, esutils, hasOwnProperty;\n  esutils = require('esutils');\n  typed = require('./typed');\n  utility = require('./utility');\n\n  function sliceSource(source, index, last) {\n    return source.slice(index, last);\n  }\n\n  hasOwnProperty = function () {\n    var func = Object.prototype.hasOwnProperty;\n    return function hasOwnProperty(obj, name) {\n      return func.call(obj, name);\n    };\n  }();\n\n  function shallowCopy(obj) {\n    var ret = {},\n        key;\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        ret[key] = obj[key];\n      }\n    }\n\n    return ret;\n  }\n\n  function isASCIIAlphanumeric(ch) {\n    return ch >= 0x61\n    /* 'a' */\n    && ch <= 0x7A\n    /* 'z' */\n    || ch >= 0x41\n    /* 'A' */\n    && ch <= 0x5A\n    /* 'Z' */\n    || ch >= 0x30\n    /* '0' */\n    && ch <= 0x39\n    /* '9' */\n    ;\n  }\n\n  function isParamTitle(title) {\n    return title === 'param' || title === 'argument' || title === 'arg';\n  }\n\n  function isReturnTitle(title) {\n    return title === 'return' || title === 'returns';\n  }\n\n  function isProperty(title) {\n    return title === 'property' || title === 'prop';\n  }\n\n  function isNameParameterRequired(title) {\n    return isParamTitle(title) || isProperty(title) || title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\n  }\n\n  function isAllowedName(title) {\n    return isNameParameterRequired(title) || title === 'const' || title === 'constant';\n  }\n\n  function isAllowedNested(title) {\n    return isProperty(title) || isParamTitle(title);\n  }\n\n  function isAllowedOptional(title) {\n    return isProperty(title) || isParamTitle(title);\n  }\n\n  function isTypeParameterRequired(title) {\n    return isParamTitle(title) || isReturnTitle(title) || title === 'define' || title === 'enum' || title === 'implements' || title === 'this' || title === 'type' || title === 'typedef' || isProperty(title);\n  } // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\n  // This would require changes to 'parseType'\n\n\n  function isAllowedType(title) {\n    return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' || title === 'namespace' || title === 'member' || title === 'var' || title === 'module' || title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' || title === 'public' || title === 'private' || title === 'protected';\n  } // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\n\n\n  var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\n  var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\n\n  function unwrapComment(doc) {\n    // JSDoc comment is following form\n    //   /**\n    //    * .......\n    //    */\n    return doc. // remove /**\n    replace(/^\\/\\*\\*?/, ''). // remove */\n    replace(/\\*\\/$/, ''). // remove ' * ' at the beginning of a line\n    replace(new RegExp(STAR_MATCHER, 'g'), '$2'). // remove trailing whitespace\n    replace(/\\s*$/, '');\n  }\n  /**\n   * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\n   * @param {string} originalSource The original wrapped comment\n   * @param {number} unwrappedIndex The index of a character in the unwrapped string\n   * @returns {number} The index of the corresponding character in the original wrapped string\n   */\n\n\n  function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\n    var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\n    var numSkippedChars = 0;\n    var matcher = new RegExp(STAR_MATCHER, 'g');\n    var match;\n\n    while (match = matcher.exec(replacedSource)) {\n      numSkippedChars += match[1].length;\n\n      if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\n        return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\n      }\n    }\n\n    return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\n  } // JSDoc Tag Parser\n\n\n  (function (exports) {\n    var Rules, index, lineNumber, length, source, originalSource, recoverable, sloppy, strict;\n\n    function advance() {\n      var ch = source.charCodeAt(index);\n      index += 1;\n\n      if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D\n      /* '\\r' */\n      && source.charCodeAt(index) === 0x0A\n      /* '\\n' */\n      )) {\n        lineNumber += 1;\n      }\n\n      return String.fromCharCode(ch);\n    }\n\n    function scanTitle() {\n      var title = ''; // waste '@'\n\n      advance();\n\n      while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\n        title += advance();\n      }\n\n      return title;\n    }\n\n    function seekContent() {\n      var ch,\n          waiting,\n          last = index;\n      waiting = false;\n\n      while (last < length) {\n        ch = source.charCodeAt(last);\n\n        if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D\n        /* '\\r' */\n        && source.charCodeAt(last + 1) === 0x0A\n        /* '\\n' */\n        )) {\n          waiting = true;\n        } else if (waiting) {\n          if (ch === 0x40\n          /* '@' */\n          ) {\n            break;\n          }\n\n          if (!esutils.code.isWhiteSpace(ch)) {\n            waiting = false;\n          }\n        }\n\n        last += 1;\n      }\n\n      return last;\n    } // type expression may have nest brace, such as,\n    // { { ok: string } }\n    //\n    // therefore, scanning type expression with balancing braces.\n\n\n    function parseType(title, last, addRange) {\n      var ch,\n          brace,\n          type,\n          startIndex,\n          direct = false; // search '{'\n\n      while (index < last) {\n        ch = source.charCodeAt(index);\n\n        if (esutils.code.isWhiteSpace(ch)) {\n          advance();\n        } else if (ch === 0x7B\n        /* '{' */\n        ) {\n          advance();\n          break;\n        } else {\n          // this is direct pattern\n          direct = true;\n          break;\n        }\n      }\n\n      if (direct) {\n        return null;\n      } // type expression { is found\n\n\n      brace = 1;\n      type = '';\n\n      while (index < last) {\n        ch = source.charCodeAt(index);\n\n        if (esutils.code.isLineTerminator(ch)) {\n          advance();\n        } else {\n          if (ch === 0x7D\n          /* '}' */\n          ) {\n            brace -= 1;\n\n            if (brace === 0) {\n              advance();\n              break;\n            }\n          } else if (ch === 0x7B\n          /* '{' */\n          ) {\n            brace += 1;\n          }\n\n          if (type === '') {\n            startIndex = index;\n          }\n\n          type += advance();\n        }\n      }\n\n      if (brace !== 0) {\n        // braces is not balanced\n        return utility.throwError('Braces are not balanced');\n      }\n\n      if (isAllowedOptional(title)) {\n        return typed.parseParamType(type, {\n          startIndex: convertIndex(startIndex),\n          range: addRange\n        });\n      }\n\n      return typed.parseType(type, {\n        startIndex: convertIndex(startIndex),\n        range: addRange\n      });\n    }\n\n    function scanIdentifier(last) {\n      var identifier;\n\n      if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\n        return null;\n      }\n\n      identifier = advance();\n\n      while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\n        identifier += advance();\n      }\n\n      return identifier;\n    }\n\n    function skipWhiteSpace(last) {\n      while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\n        advance();\n      }\n    }\n\n    function parseName(last, allowBrackets, allowNestedParams) {\n      var name = '',\n          useBrackets,\n          insideString;\n      skipWhiteSpace(last);\n\n      if (index >= last) {\n        return null;\n      }\n\n      if (source.charCodeAt(index) === 0x5B\n      /* '[' */\n      ) {\n        if (allowBrackets) {\n          useBrackets = true;\n          name = advance();\n        } else {\n          return null;\n        }\n      }\n\n      name += scanIdentifier(last);\n\n      if (allowNestedParams) {\n        if (source.charCodeAt(index) === 0x3A\n        /* ':' */\n        && (name === 'module' || name === 'external' || name === 'event')) {\n          name += advance();\n          name += scanIdentifier(last);\n        }\n\n        if (source.charCodeAt(index) === 0x5B\n        /* '[' */\n        && source.charCodeAt(index + 1) === 0x5D\n        /* ']' */\n        ) {\n          name += advance();\n          name += advance();\n        }\n\n        while (source.charCodeAt(index) === 0x2E\n        /* '.' */\n        || source.charCodeAt(index) === 0x2F\n        /* '/' */\n        || source.charCodeAt(index) === 0x23\n        /* '#' */\n        || source.charCodeAt(index) === 0x2D\n        /* '-' */\n        || source.charCodeAt(index) === 0x7E\n        /* '~' */\n        ) {\n          name += advance();\n          name += scanIdentifier(last);\n        }\n      }\n\n      if (useBrackets) {\n        skipWhiteSpace(last); // do we have a default value for this?\n\n        if (source.charCodeAt(index) === 0x3D\n        /* '=' */\n        ) {\n          // consume the '='' symbol\n          name += advance();\n          skipWhiteSpace(last);\n          var ch;\n          var bracketDepth = 1; // scan in the default value\n\n          while (index < last) {\n            ch = source.charCodeAt(index);\n\n            if (esutils.code.isWhiteSpace(ch)) {\n              if (!insideString) {\n                skipWhiteSpace(last);\n                ch = source.charCodeAt(index);\n              }\n            }\n\n            if (ch === 0x27\n            /* ''' */\n            ) {\n              if (!insideString) {\n                insideString = '\\'';\n              } else {\n                if (insideString === '\\'') {\n                  insideString = '';\n                }\n              }\n            }\n\n            if (ch === 0x22\n            /* '\"' */\n            ) {\n              if (!insideString) {\n                insideString = '\"';\n              } else {\n                if (insideString === '\"') {\n                  insideString = '';\n                }\n              }\n            }\n\n            if (ch === 0x5B\n            /* '[' */\n            ) {\n              bracketDepth++;\n            } else if (ch === 0x5D\n            /* ']' */\n            && --bracketDepth === 0) {\n              break;\n            }\n\n            name += advance();\n          }\n        }\n\n        skipWhiteSpace(last);\n\n        if (index >= last || source.charCodeAt(index) !== 0x5D\n        /* ']' */\n        ) {\n          // we never found a closing ']'\n          return null;\n        } // collect the last ']'\n\n\n        name += advance();\n      }\n\n      return name;\n    }\n\n    function skipToTag() {\n      while (index < length && source.charCodeAt(index) !== 0x40\n      /* '@' */\n      ) {\n        advance();\n      }\n\n      if (index >= length) {\n        return false;\n      }\n\n      utility.assert(source.charCodeAt(index) === 0x40\n      /* '@' */\n      );\n      return true;\n    }\n\n    function convertIndex(rangeIndex) {\n      if (source === originalSource) {\n        return rangeIndex;\n      }\n\n      return convertUnwrappedCommentIndex(originalSource, rangeIndex);\n    }\n\n    function TagParser(options, title) {\n      this._options = options;\n      this._title = title.toLowerCase();\n      this._tag = {\n        title: title,\n        description: null\n      };\n\n      if (this._options.lineNumbers) {\n        this._tag.lineNumber = lineNumber;\n      }\n\n      this._first = index - title.length - 1;\n      this._last = 0; // space to save special information for title parsers.\n\n      this._extra = {};\n    } // addError(err, ...)\n\n\n    TagParser.prototype.addError = function addError(errorText) {\n      var args = Array.prototype.slice.call(arguments, 1),\n          msg = errorText.replace(/%(\\d)/g, function (whole, index) {\n        utility.assert(index < args.length, 'Message reference must be in range');\n        return args[index];\n      });\n\n      if (!this._tag.errors) {\n        this._tag.errors = [];\n      }\n\n      if (strict) {\n        utility.throwError(msg);\n      }\n\n      this._tag.errors.push(msg);\n\n      return recoverable;\n    };\n\n    TagParser.prototype.parseType = function () {\n      // type required titles\n      if (isTypeParameterRequired(this._title)) {\n        try {\n          this._tag.type = parseType(this._title, this._last, this._options.range);\n\n          if (!this._tag.type) {\n            if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\n              if (!this.addError('Missing or invalid tag type')) {\n                return false;\n              }\n            }\n          }\n        } catch (error) {\n          this._tag.type = null;\n\n          if (!this.addError(error.message)) {\n            return false;\n          }\n        }\n      } else if (isAllowedType(this._title)) {\n        // optional types\n        try {\n          this._tag.type = parseType(this._title, this._last, this._options.range);\n        } catch (e) {//For optional types, lets drop the thrown error when we hit the end of the file\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype._parseNamePath = function (optional) {\n      var name;\n      name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\n\n      if (!name) {\n        if (!optional) {\n          if (!this.addError('Missing or invalid tag name')) {\n            return false;\n          }\n        }\n      }\n\n      this._tag.name = name;\n      return true;\n    };\n\n    TagParser.prototype.parseNamePath = function () {\n      return this._parseNamePath(false);\n    };\n\n    TagParser.prototype.parseNamePathOptional = function () {\n      return this._parseNamePath(true);\n    };\n\n    TagParser.prototype.parseName = function () {\n      var assign, name; // param, property requires name\n\n      if (isAllowedName(this._title)) {\n        this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\n\n        if (!this._tag.name) {\n          if (!isNameParameterRequired(this._title)) {\n            return true;\n          } // it's possible the name has already been parsed but interpreted as a type\n          // it's also possible this is a sloppy declaration, in which case it will be\n          // fixed at the end\n\n\n          if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\n            this._extra.name = this._tag.type;\n            this._tag.name = this._tag.type.name;\n            this._tag.type = null;\n          } else {\n            if (!this.addError('Missing or invalid tag name')) {\n              return false;\n            }\n          }\n        } else {\n          name = this._tag.name;\n\n          if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\n            // extract the default value if there is one\n            // example: @param {string} [somebody=John Doe] description\n            assign = name.substring(1, name.length - 1).split('=');\n\n            if (assign.length > 1) {\n              this._tag['default'] = assign.slice(1).join('=');\n            }\n\n            this._tag.name = assign[0]; // convert to an optional type\n\n            if (this._tag.type && this._tag.type.type !== 'OptionalType') {\n              this._tag.type = {\n                type: 'OptionalType',\n                expression: this._tag.type\n              };\n            }\n          }\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseDescription = function parseDescription() {\n      var description = sliceSource(source, index, this._last).trim();\n\n      if (description) {\n        if (/^-\\s+/.test(description)) {\n          description = description.substring(2);\n        }\n\n        this._tag.description = description;\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseCaption = function parseDescription() {\n      var description = sliceSource(source, index, this._last).trim();\n      var captionStartTag = '<caption>';\n      var captionEndTag = '</caption>';\n      var captionStart = description.indexOf(captionStartTag);\n      var captionEnd = description.indexOf(captionEndTag);\n\n      if (captionStart >= 0 && captionEnd >= 0) {\n        this._tag.caption = description.substring(captionStart + captionStartTag.length, captionEnd).trim();\n        this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\n      } else {\n        this._tag.description = description;\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseKind = function parseKind() {\n      var kind, kinds;\n      kinds = {\n        'class': true,\n        'constant': true,\n        'event': true,\n        'external': true,\n        'file': true,\n        'function': true,\n        'member': true,\n        'mixin': true,\n        'module': true,\n        'namespace': true,\n        'typedef': true\n      };\n      kind = sliceSource(source, index, this._last).trim();\n      this._tag.kind = kind;\n\n      if (!hasOwnProperty(kinds, kind)) {\n        if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseAccess = function parseAccess() {\n      var access;\n      access = sliceSource(source, index, this._last).trim();\n      this._tag.access = access;\n\n      if (access !== 'private' && access !== 'protected' && access !== 'public') {\n        if (!this.addError('Invalid access name \\'%0\\'', access)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseThis = function parseThis() {\n      // this name may be a name expression (e.g. {foo.bar}),\n      // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\n      var value = sliceSource(source, index, this._last).trim();\n\n      if (value && value.charAt(0) === '{') {\n        var gotType = this.parseType();\n\n        if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\n          this._tag.name = this._tag.type.name;\n          return true;\n        } else {\n          return this.addError('Invalid name for this');\n        }\n      } else {\n        return this.parseNamePath();\n      }\n    };\n\n    TagParser.prototype.parseVariation = function parseVariation() {\n      var variation, text;\n      text = sliceSource(source, index, this._last).trim();\n      variation = parseFloat(text, 10);\n      this._tag.variation = variation;\n\n      if (isNaN(variation)) {\n        if (!this.addError('Invalid variation \\'%0\\'', text)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.ensureEnd = function () {\n      var shouldBeEmpty = sliceSource(source, index, this._last).trim();\n\n      if (shouldBeEmpty) {\n        if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.epilogue = function epilogue() {\n      var description;\n      description = this._tag.description; // un-fix potentially sloppy declaration\n\n      if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\n        this._tag.type = this._extra.name;\n\n        if (!this._tag.name) {\n          this._tag.name = undefined;\n        }\n\n        if (!sloppy) {\n          if (!this.addError('Missing or invalid tag name')) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    };\n\n    Rules = {\n      // http://usejsdoc.org/tags-access.html\n      'access': ['parseAccess'],\n      // http://usejsdoc.org/tags-alias.html\n      'alias': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-augments.html\n      'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-constructor.html\n      'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-constructor.html\n      'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-extends.html\n      'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-example.html\n      'example': ['parseCaption'],\n      // http://usejsdoc.org/tags-deprecated.html\n      'deprecated': ['parseDescription'],\n      // http://usejsdoc.org/tags-global.html\n      'global': ['ensureEnd'],\n      // http://usejsdoc.org/tags-inner.html\n      'inner': ['ensureEnd'],\n      // http://usejsdoc.org/tags-instance.html\n      'instance': ['ensureEnd'],\n      // http://usejsdoc.org/tags-kind.html\n      'kind': ['parseKind'],\n      // http://usejsdoc.org/tags-mixes.html\n      'mixes': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-mixin.html\n      'mixin': ['parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-member.html\n      'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-method.html\n      'method': ['parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-module.html\n      'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-method.html\n      'func': ['parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-method.html\n      'function': ['parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-member.html\n      'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-name.html\n      'name': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-namespace.html\n      'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-private.html\n      'private': ['parseType', 'parseDescription'],\n      // http://usejsdoc.org/tags-protected.html\n      'protected': ['parseType', 'parseDescription'],\n      // http://usejsdoc.org/tags-public.html\n      'public': ['parseType', 'parseDescription'],\n      // http://usejsdoc.org/tags-readonly.html\n      'readonly': ['ensureEnd'],\n      // http://usejsdoc.org/tags-requires.html\n      'requires': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-since.html\n      'since': ['parseDescription'],\n      // http://usejsdoc.org/tags-static.html\n      'static': ['ensureEnd'],\n      // http://usejsdoc.org/tags-summary.html\n      'summary': ['parseDescription'],\n      // http://usejsdoc.org/tags-this.html\n      'this': ['parseThis', 'ensureEnd'],\n      // http://usejsdoc.org/tags-todo.html\n      'todo': ['parseDescription'],\n      // http://usejsdoc.org/tags-typedef.html\n      'typedef': ['parseType', 'parseNamePathOptional'],\n      // http://usejsdoc.org/tags-variation.html\n      'variation': ['parseVariation'],\n      // http://usejsdoc.org/tags-version.html\n      'version': ['parseDescription']\n    };\n\n    TagParser.prototype.parse = function parse() {\n      var i, iz, sequences, method; // empty title\n\n      if (!this._title) {\n        if (!this.addError('Missing or invalid title')) {\n          return null;\n        }\n      } // Seek to content last index.\n\n\n      this._last = seekContent(this._title);\n\n      if (this._options.range) {\n        this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\n      }\n\n      if (hasOwnProperty(Rules, this._title)) {\n        sequences = Rules[this._title];\n      } else {\n        // default sequences\n        sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\n      }\n\n      for (i = 0, iz = sequences.length; i < iz; ++i) {\n        method = sequences[i];\n\n        if (!this[method]()) {\n          return null;\n        }\n      }\n\n      return this._tag;\n    };\n\n    function parseTag(options) {\n      var title, parser, tag; // skip to tag\n\n      if (!skipToTag()) {\n        return null;\n      } // scan title\n\n\n      title = scanTitle(); // construct tag parser\n\n      parser = new TagParser(options, title);\n      tag = parser.parse(); // Seek global index to end of this tag.\n\n      while (index < parser._last) {\n        advance();\n      }\n\n      return tag;\n    } //\n    // Parse JSDoc\n    //\n\n\n    function scanJSDocDescription(preserveWhitespace) {\n      var description = '',\n          ch,\n          atAllowed;\n      atAllowed = true;\n\n      while (index < length) {\n        ch = source.charCodeAt(index);\n\n        if (atAllowed && ch === 0x40\n        /* '@' */\n        ) {\n          break;\n        }\n\n        if (esutils.code.isLineTerminator(ch)) {\n          atAllowed = true;\n        } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\n          atAllowed = false;\n        }\n\n        description += advance();\n      }\n\n      return preserveWhitespace ? description : description.trim();\n    }\n\n    function parse(comment, options) {\n      var tags = [],\n          tag,\n          description,\n          interestingTags,\n          i,\n          iz;\n\n      if (options === undefined) {\n        options = {};\n      }\n\n      if (typeof options.unwrap === 'boolean' && options.unwrap) {\n        source = unwrapComment(comment);\n      } else {\n        source = comment;\n      }\n\n      originalSource = comment; // array of relevant tags\n\n      if (options.tags) {\n        if (Array.isArray(options.tags)) {\n          interestingTags = {};\n\n          for (i = 0, iz = options.tags.length; i < iz; i++) {\n            if (typeof options.tags[i] === 'string') {\n              interestingTags[options.tags[i]] = true;\n            } else {\n              utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n            }\n          }\n        } else {\n          utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n        }\n      }\n\n      length = source.length;\n      index = 0;\n      lineNumber = 0;\n      recoverable = options.recoverable;\n      sloppy = options.sloppy;\n      strict = options.strict;\n      description = scanJSDocDescription(options.preserveWhitespace);\n\n      while (true) {\n        tag = parseTag(options);\n\n        if (!tag) {\n          break;\n        }\n\n        if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\n          tags.push(tag);\n        }\n      }\n\n      return {\n        description: description,\n        tags: tags\n      };\n    }\n\n    exports.parse = parse;\n  })(jsdoc = {});\n\n  exports.version = utility.VERSION;\n  exports.parse = jsdoc.parse;\n  exports.parseType = typed.parseType;\n  exports.parseParamType = typed.parseParamType;\n  exports.unwrapComment = unwrapComment;\n  exports.Syntax = shallowCopy(typed.Syntax);\n  exports.Error = utility.DoctrineError;\n  exports.type = {\n    Syntax: exports.Syntax,\n    parseType: typed.parseType,\n    parseParamType: typed.parseParamType,\n    stringify: typed.stringify\n  };\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["typed","utility","jsdoc","esutils","hasOwnProperty","require","sliceSource","source","index","last","slice","func","Object","prototype","obj","name","call","shallowCopy","ret","key","isASCIIAlphanumeric","ch","isParamTitle","title","isReturnTitle","isProperty","isNameParameterRequired","isAllowedName","isAllowedNested","isAllowedOptional","isTypeParameterRequired","isAllowedType","WHITESPACE","STAR_MATCHER","unwrapComment","doc","replace","RegExp","convertUnwrappedCommentIndex","originalSource","unwrappedIndex","replacedSource","numSkippedChars","matcher","match","exec","length","exports","Rules","lineNumber","recoverable","sloppy","strict","advance","charCodeAt","code","isLineTerminator","String","fromCharCode","scanTitle","seekContent","waiting","isWhiteSpace","parseType","addRange","brace","type","startIndex","direct","throwError","parseParamType","convertIndex","range","scanIdentifier","identifier","isIdentifierStartES5","isIdentifierPartES5","skipWhiteSpace","parseName","allowBrackets","allowNestedParams","useBrackets","insideString","bracketDepth","skipToTag","assert","rangeIndex","TagParser","options","_options","_title","toLowerCase","_tag","description","lineNumbers","_first","_last","_extra","addError","errorText","args","Array","arguments","msg","whole","errors","push","error","message","e","_parseNamePath","optional","parseNamePath","parseNamePathOptional","assign","charAt","substring","split","join","expression","parseDescription","trim","test","parseCaption","captionStartTag","captionEndTag","captionStart","indexOf","captionEnd","caption","parseKind","kind","kinds","parseAccess","access","parseThis","value","gotType","parseVariation","variation","text","parseFloat","isNaN","ensureEnd","shouldBeEmpty","epilogue","undefined","parse","i","iz","sequences","method","map","parseTag","parser","tag","scanJSDocDescription","preserveWhitespace","atAllowed","comment","tags","interestingTags","unwrap","isArray","version","VERSION","Syntax","Error","DoctrineError","stringify"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/doctrine/lib/doctrine.js"],"sourcesContent":["/*\n * @fileoverview Main Doctrine object\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n(function () {\n    'use strict';\n\n    var typed,\n        utility,\n        jsdoc,\n        esutils,\n        hasOwnProperty;\n\n    esutils = require('esutils');\n    typed = require('./typed');\n    utility = require('./utility');\n\n    function sliceSource(source, index, last) {\n        return source.slice(index, last);\n    }\n\n    hasOwnProperty = (function () {\n        var func = Object.prototype.hasOwnProperty;\n        return function hasOwnProperty(obj, name) {\n            return func.call(obj, name);\n        };\n    }());\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n\n    function isASCIIAlphanumeric(ch) {\n        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||\n            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||\n            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);\n    }\n\n    function isParamTitle(title) {\n        return title === 'param' || title === 'argument' || title === 'arg';\n    }\n\n    function isReturnTitle(title) {\n        return title === 'return' || title === 'returns';\n    }\n\n    function isProperty(title) {\n        return title === 'property' || title === 'prop';\n    }\n\n    function isNameParameterRequired(title) {\n        return isParamTitle(title) || isProperty(title) ||\n            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\n    }\n\n    function isAllowedName(title) {\n        return isNameParameterRequired(title) || title === 'const' || title === 'constant';\n    }\n\n    function isAllowedNested(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isAllowedOptional(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isTypeParameterRequired(title) {\n        return isParamTitle(title) || isReturnTitle(title) ||\n            title === 'define' || title === 'enum' ||\n            title === 'implements' || title === 'this' ||\n            title === 'type' || title === 'typedef' || isProperty(title);\n    }\n\n    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\n    // This would require changes to 'parseType'\n    function isAllowedType(title) {\n        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||\n            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||\n            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||\n            title === 'public' || title === 'private' || title === 'protected';\n    }\n\n    // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\n    var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\n\n    var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\n\n    function unwrapComment(doc) {\n        // JSDoc comment is following form\n        //   /**\n        //    * .......\n        //    */\n\n        return doc.\n            // remove /**\n            replace(/^\\/\\*\\*?/, '').\n            // remove */\n            replace(/\\*\\/$/, '').\n            // remove ' * ' at the beginning of a line\n            replace(new RegExp(STAR_MATCHER, 'g'), '$2').\n            // remove trailing whitespace\n            replace(/\\s*$/, '');\n    }\n\n    /**\n     * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\n     * @param {string} originalSource The original wrapped comment\n     * @param {number} unwrappedIndex The index of a character in the unwrapped string\n     * @returns {number} The index of the corresponding character in the original wrapped string\n     */\n    function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\n        var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\n        var numSkippedChars = 0;\n        var matcher = new RegExp(STAR_MATCHER, 'g');\n        var match;\n\n        while ((match = matcher.exec(replacedSource))) {\n            numSkippedChars += match[1].length;\n\n            if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\n                return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\n            }\n        }\n\n        return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\n    }\n\n    // JSDoc Tag Parser\n\n    (function (exports) {\n        var Rules,\n            index,\n            lineNumber,\n            length,\n            source,\n            originalSource,\n            recoverable,\n            sloppy,\n            strict;\n\n        function advance() {\n            var ch = source.charCodeAt(index);\n            index += 1;\n            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(index) === 0x0A  /* '\\n' */)) {\n                lineNumber += 1;\n            }\n            return String.fromCharCode(ch);\n        }\n\n        function scanTitle() {\n            var title = '';\n            // waste '@'\n            advance();\n\n            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\n                title += advance();\n            }\n\n            return title;\n        }\n\n        function seekContent() {\n            var ch, waiting, last = index;\n\n            waiting = false;\n            while (last < length) {\n                ch = source.charCodeAt(last);\n                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\\n' */)) {\n                    waiting = true;\n                } else if (waiting) {\n                    if (ch === 0x40  /* '@' */) {\n                        break;\n                    }\n                    if (!esutils.code.isWhiteSpace(ch)) {\n                        waiting = false;\n                    }\n                }\n                last += 1;\n            }\n            return last;\n        }\n\n        // type expression may have nest brace, such as,\n        // { { ok: string } }\n        //\n        // therefore, scanning type expression with balancing braces.\n        function parseType(title, last, addRange) {\n            var ch, brace, type, startIndex, direct = false;\n\n\n            // search '{'\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isWhiteSpace(ch)) {\n                    advance();\n                } else if (ch === 0x7B  /* '{' */) {\n                    advance();\n                    break;\n                } else {\n                    // this is direct pattern\n                    direct = true;\n                    break;\n                }\n            }\n\n\n            if (direct) {\n                return null;\n            }\n\n            // type expression { is found\n            brace = 1;\n            type = '';\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isLineTerminator(ch)) {\n                    advance();\n                } else {\n                    if (ch === 0x7D  /* '}' */) {\n                        brace -= 1;\n                        if (brace === 0) {\n                            advance();\n                            break;\n                        }\n                    } else if (ch === 0x7B  /* '{' */) {\n                        brace += 1;\n                    }\n                    if (type === '') {\n                        startIndex = index;\n                    }\n                    type += advance();\n                }\n            }\n\n            if (brace !== 0) {\n                // braces is not balanced\n                return utility.throwError('Braces are not balanced');\n            }\n\n            if (isAllowedOptional(title)) {\n                return typed.parseParamType(type, {startIndex: convertIndex(startIndex), range: addRange});\n            }\n\n            return typed.parseType(type, {startIndex: convertIndex(startIndex), range: addRange});\n        }\n\n        function scanIdentifier(last) {\n            var identifier;\n            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\n                return null;\n            }\n            identifier = advance();\n            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\n                identifier += advance();\n            }\n            return identifier;\n        }\n\n        function skipWhiteSpace(last) {\n            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\n                advance();\n            }\n        }\n\n        function parseName(last, allowBrackets, allowNestedParams) {\n            var name = '',\n                useBrackets,\n                insideString;\n\n\n            skipWhiteSpace(last);\n\n            if (index >= last) {\n                return null;\n            }\n\n            if (source.charCodeAt(index) === 0x5B  /* '[' */) {\n                if (allowBrackets) {\n                    useBrackets = true;\n                    name = advance();\n                } else {\n                    return null;\n                }\n            }\n\n            name += scanIdentifier(last);\n\n            if (allowNestedParams) {\n                if (source.charCodeAt(index) === 0x3A /* ':' */ && (\n                        name === 'module' ||\n                        name === 'external' ||\n                        name === 'event')) {\n                    name += advance();\n                    name += scanIdentifier(last);\n\n                }\n                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){\n                    name += advance();\n                    name += advance();\n                }\n                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||\n                        source.charCodeAt(index) === 0x2F  /* '/' */ ||\n                        source.charCodeAt(index) === 0x23  /* '#' */ ||\n                        source.charCodeAt(index) === 0x2D  /* '-' */ ||\n                        source.charCodeAt(index) === 0x7E  /* '~' */) {\n                    name += advance();\n                    name += scanIdentifier(last);\n                }\n            }\n\n            if (useBrackets) {\n                skipWhiteSpace(last);\n                // do we have a default value for this?\n                if (source.charCodeAt(index) === 0x3D  /* '=' */) {\n                    // consume the '='' symbol\n                    name += advance();\n                    skipWhiteSpace(last);\n\n                    var ch;\n                    var bracketDepth = 1;\n\n                    // scan in the default value\n                    while (index < last) {\n                        ch = source.charCodeAt(index);\n\n                        if (esutils.code.isWhiteSpace(ch)) {\n                            if (!insideString) {\n                                skipWhiteSpace(last);\n                                ch = source.charCodeAt(index);\n                            }\n                        }\n\n                        if (ch === 0x27 /* ''' */) {\n                            if (!insideString) {\n                                insideString = '\\'';\n                            } else {\n                                if (insideString === '\\'') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x22 /* '\"' */) {\n                            if (!insideString) {\n                                insideString = '\"';\n                            } else {\n                                if (insideString === '\"') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x5B /* '[' */) {\n                            bracketDepth++;\n                        } else if (ch === 0x5D  /* ']' */ &&\n                            --bracketDepth === 0) {\n                            break;\n                        }\n\n                        name += advance();\n                    }\n                }\n\n                skipWhiteSpace(last);\n\n                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) {\n                    // we never found a closing ']'\n                    return null;\n                }\n\n                // collect the last ']'\n                name += advance();\n            }\n\n            return name;\n        }\n\n        function skipToTag() {\n            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {\n                advance();\n            }\n            if (index >= length) {\n                return false;\n            }\n            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);\n            return true;\n        }\n\n        function convertIndex(rangeIndex) {\n            if (source === originalSource) {\n                return rangeIndex;\n            }\n            return convertUnwrappedCommentIndex(originalSource, rangeIndex);\n        }\n\n        function TagParser(options, title) {\n            this._options = options;\n            this._title = title.toLowerCase();\n            this._tag = {\n                title: title,\n                description: null\n            };\n            if (this._options.lineNumbers) {\n                this._tag.lineNumber = lineNumber;\n            }\n            this._first = index - title.length - 1;\n            this._last = 0;\n            // space to save special information for title parsers.\n            this._extra = { };\n        }\n\n        // addError(err, ...)\n        TagParser.prototype.addError = function addError(errorText) {\n            var args = Array.prototype.slice.call(arguments, 1),\n                msg = errorText.replace(\n                    /%(\\d)/g,\n                    function (whole, index) {\n                        utility.assert(index < args.length, 'Message reference must be in range');\n                        return args[index];\n                    }\n                );\n\n            if (!this._tag.errors) {\n                this._tag.errors = [];\n            }\n            if (strict) {\n                utility.throwError(msg);\n            }\n            this._tag.errors.push(msg);\n            return recoverable;\n        };\n\n        TagParser.prototype.parseType = function () {\n            // type required titles\n            if (isTypeParameterRequired(this._title)) {\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                    if (!this._tag.type) {\n                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\n                            if (!this.addError('Missing or invalid tag type')) {\n                                return false;\n                            }\n                        }\n                    }\n                } catch (error) {\n                    this._tag.type = null;\n                    if (!this.addError(error.message)) {\n                        return false;\n                    }\n                }\n            } else if (isAllowedType(this._title)) {\n                // optional types\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                } catch (e) {\n                    //For optional types, lets drop the thrown error when we hit the end of the file\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype._parseNamePath = function (optional) {\n            var name;\n            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\n            if (!name) {\n                if (!optional) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n            this._tag.name = name;\n            return true;\n        };\n\n        TagParser.prototype.parseNamePath = function () {\n            return this._parseNamePath(false);\n        };\n\n        TagParser.prototype.parseNamePathOptional = function () {\n            return this._parseNamePath(true);\n        };\n\n\n        TagParser.prototype.parseName = function () {\n            var assign, name;\n\n            // param, property requires name\n            if (isAllowedName(this._title)) {\n                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\n                if (!this._tag.name) {\n                    if (!isNameParameterRequired(this._title)) {\n                        return true;\n                    }\n\n                    // it's possible the name has already been parsed but interpreted as a type\n                    // it's also possible this is a sloppy declaration, in which case it will be\n                    // fixed at the end\n                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\n                        this._extra.name = this._tag.type;\n                        this._tag.name = this._tag.type.name;\n                        this._tag.type = null;\n                    } else {\n                        if (!this.addError('Missing or invalid tag name')) {\n                            return false;\n                        }\n                    }\n                } else {\n                    name = this._tag.name;\n                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\n                        // extract the default value if there is one\n                        // example: @param {string} [somebody=John Doe] description\n                        assign = name.substring(1, name.length - 1).split('=');\n                        if (assign.length > 1) {\n                            this._tag['default'] = assign.slice(1).join('=');\n                        }\n                        this._tag.name = assign[0];\n\n                        // convert to an optional type\n                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {\n                            this._tag.type = {\n                                type: 'OptionalType',\n                                expression: this._tag.type\n                            };\n                        }\n                    }\n                }\n            }\n\n\n            return true;\n        };\n\n        TagParser.prototype.parseDescription = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            if (description) {\n                if ((/^-\\s+/).test(description)) {\n                    description = description.substring(2);\n                }\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseCaption = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            var captionStartTag = '<caption>';\n            var captionEndTag = '</caption>';\n            var captionStart = description.indexOf(captionStartTag);\n            var captionEnd = description.indexOf(captionEndTag);\n            if (captionStart >= 0 && captionEnd >= 0) {\n                this._tag.caption = description.substring(\n                    captionStart + captionStartTag.length, captionEnd).trim();\n                this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\n            } else {\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseKind = function parseKind() {\n            var kind, kinds;\n            kinds = {\n                'class': true,\n                'constant': true,\n                'event': true,\n                'external': true,\n                'file': true,\n                'function': true,\n                'member': true,\n                'mixin': true,\n                'module': true,\n                'namespace': true,\n                'typedef': true\n            };\n            kind = sliceSource(source, index, this._last).trim();\n            this._tag.kind = kind;\n            if (!hasOwnProperty(kinds, kind)) {\n                if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseAccess = function parseAccess() {\n            var access;\n            access = sliceSource(source, index, this._last).trim();\n            this._tag.access = access;\n            if (access !== 'private' && access !== 'protected' && access !== 'public') {\n                if (!this.addError('Invalid access name \\'%0\\'', access)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseThis = function parseThis() {\n            // this name may be a name expression (e.g. {foo.bar}),\n            // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\n            var value = sliceSource(source, index, this._last).trim();\n            if (value && value.charAt(0) === '{') {\n                var gotType = this.parseType();\n                if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\n                    this._tag.name = this._tag.type.name;\n                    return true;\n                } else {\n                    return this.addError('Invalid name for this');\n                }\n            } else {\n                return this.parseNamePath();\n            }\n        };\n\n        TagParser.prototype.parseVariation = function parseVariation() {\n            var variation, text;\n            text = sliceSource(source, index, this._last).trim();\n            variation = parseFloat(text, 10);\n            this._tag.variation = variation;\n            if (isNaN(variation)) {\n                if (!this.addError('Invalid variation \\'%0\\'', text)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.ensureEnd = function () {\n            var shouldBeEmpty = sliceSource(source, index, this._last).trim();\n            if (shouldBeEmpty) {\n                if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.epilogue = function epilogue() {\n            var description;\n\n            description = this._tag.description;\n            // un-fix potentially sloppy declaration\n            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\n                this._tag.type = this._extra.name;\n                if (!this._tag.name) {\n                    this._tag.name = undefined;\n                }\n\n                if (!sloppy) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        };\n\n        Rules = {\n            // http://usejsdoc.org/tags-access.html\n            'access': ['parseAccess'],\n            // http://usejsdoc.org/tags-alias.html\n            'alias': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-augments.html\n            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-constructor.html\n            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-constructor.html\n            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-extends.html\n            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-example.html\n            'example': ['parseCaption'],\n            // http://usejsdoc.org/tags-deprecated.html\n            'deprecated': ['parseDescription'],\n            // http://usejsdoc.org/tags-global.html\n            'global': ['ensureEnd'],\n            // http://usejsdoc.org/tags-inner.html\n            'inner': ['ensureEnd'],\n            // http://usejsdoc.org/tags-instance.html\n            'instance': ['ensureEnd'],\n            // http://usejsdoc.org/tags-kind.html\n            'kind': ['parseKind'],\n            // http://usejsdoc.org/tags-mixes.html\n            'mixes': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-mixin.html\n            'mixin': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-member.html\n            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-method.html\n            'method': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-module.html\n            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'func': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'function': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-member.html\n            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-name.html\n            'name': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-namespace.html\n            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-private.html\n            'private': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-protected.html\n            'protected': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-public.html\n            'public': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-readonly.html\n            'readonly': ['ensureEnd'],\n            // http://usejsdoc.org/tags-requires.html\n            'requires': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-since.html\n            'since': ['parseDescription'],\n            // http://usejsdoc.org/tags-static.html\n            'static': ['ensureEnd'],\n            // http://usejsdoc.org/tags-summary.html\n            'summary': ['parseDescription'],\n            // http://usejsdoc.org/tags-this.html\n            'this': ['parseThis', 'ensureEnd'],\n            // http://usejsdoc.org/tags-todo.html\n            'todo': ['parseDescription'],\n            // http://usejsdoc.org/tags-typedef.html\n            'typedef': ['parseType', 'parseNamePathOptional'],\n            // http://usejsdoc.org/tags-variation.html\n            'variation': ['parseVariation'],\n            // http://usejsdoc.org/tags-version.html\n            'version': ['parseDescription']\n        };\n\n        TagParser.prototype.parse = function parse() {\n            var i, iz, sequences, method;\n\n\n            // empty title\n            if (!this._title) {\n                if (!this.addError('Missing or invalid title')) {\n                    return null;\n                }\n            }\n\n            // Seek to content last index.\n            this._last = seekContent(this._title);\n\n            if (this._options.range) {\n                this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\n            }\n\n            if (hasOwnProperty(Rules, this._title)) {\n                sequences = Rules[this._title];\n            } else {\n                // default sequences\n                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\n            }\n\n            for (i = 0, iz = sequences.length; i < iz; ++i) {\n                method = sequences[i];\n                if (!this[method]()) {\n                    return null;\n                }\n            }\n\n            return this._tag;\n        };\n\n        function parseTag(options) {\n            var title, parser, tag;\n\n            // skip to tag\n            if (!skipToTag()) {\n                return null;\n            }\n\n            // scan title\n            title = scanTitle();\n\n            // construct tag parser\n            parser = new TagParser(options, title);\n            tag = parser.parse();\n\n            // Seek global index to end of this tag.\n            while (index < parser._last) {\n                advance();\n            }\n\n            return tag;\n        }\n\n        //\n        // Parse JSDoc\n        //\n\n        function scanJSDocDescription(preserveWhitespace) {\n            var description = '', ch, atAllowed;\n\n            atAllowed = true;\n            while (index < length) {\n                ch = source.charCodeAt(index);\n\n                if (atAllowed && ch === 0x40  /* '@' */) {\n                    break;\n                }\n\n                if (esutils.code.isLineTerminator(ch)) {\n                    atAllowed = true;\n                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\n                    atAllowed = false;\n                }\n\n                description += advance();\n            }\n\n            return preserveWhitespace ? description : description.trim();\n        }\n\n        function parse(comment, options) {\n            var tags = [], tag, description, interestingTags, i, iz;\n\n            if (options === undefined) {\n                options = {};\n            }\n\n            if (typeof options.unwrap === 'boolean' && options.unwrap) {\n                source = unwrapComment(comment);\n            } else {\n                source = comment;\n            }\n\n            originalSource = comment;\n\n            // array of relevant tags\n            if (options.tags) {\n                if (Array.isArray(options.tags)) {\n                    interestingTags = { };\n                    for (i = 0, iz = options.tags.length; i < iz; i++) {\n                        if (typeof options.tags[i] === 'string') {\n                            interestingTags[options.tags[i]] = true;\n                        } else {\n                            utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                        }\n                    }\n                } else {\n                    utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                }\n            }\n\n            length = source.length;\n            index = 0;\n            lineNumber = 0;\n            recoverable = options.recoverable;\n            sloppy = options.sloppy;\n            strict = options.strict;\n\n            description = scanJSDocDescription(options.preserveWhitespace);\n\n            while (true) {\n                tag = parseTag(options);\n                if (!tag) {\n                    break;\n                }\n                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\n                    tags.push(tag);\n                }\n            }\n\n            return {\n                description: description,\n                tags: tags\n            };\n        }\n        exports.parse = parse;\n    }(jsdoc = {}));\n\n    exports.version = utility.VERSION;\n    exports.parse = jsdoc.parse;\n    exports.parseType = typed.parseType;\n    exports.parseParamType = typed.parseParamType;\n    exports.unwrapComment = unwrapComment;\n    exports.Syntax = shallowCopy(typed.Syntax);\n    exports.Error = utility.DoctrineError;\n    exports.type = {\n        Syntax: exports.Syntax,\n        parseType: typed.parseType,\n        parseParamType: typed.parseParamType,\n        stringify: typed.stringify\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}