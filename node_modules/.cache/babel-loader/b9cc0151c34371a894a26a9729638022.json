{"ast":null,"code":"/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\nfunction isReachable(segment) {\n  return segment.reachable;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in getters\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/getter-return\"\n    },\n    fixable: null,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected to return a value in {{name}}.\",\n      expectedAlways: \"Expected {{name}} to always return a value.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false\n    };\n    const sourceCode = context.getSourceCode();\n    let funcInfo = {\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n    /**\n     * Checks whether or not the last code path segment is reachable.\n     * Then reports this function if the segment is reachable.\n     *\n     * If the last code path segment is reachable, there are paths which are not\n     * returned or thrown.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n\n    function checkLastSegment(node) {\n      if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n          data: {\n            name: astUtils.getFunctionNameWithKind(funcInfo.node)\n          }\n        });\n      }\n    }\n    /**\n     * Checks whether a node means a getter function.\n     * @param {ASTNode} node a node to check.\n     * @returns {boolean} if node means a getter, return true; else return false.\n     */\n\n\n    function isGetter(node) {\n      const parent = node.parent;\n\n      if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n        if (parent.kind === \"get\") {\n          return true;\n        }\n\n        if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n          // Object.defineProperty()\n          if (parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n            return true;\n          } // Object.defineProperties()\n\n\n          if (parent.parent.parent.type === \"Property\" && parent.parent.parent.parent.type === \"ObjectExpression\" && parent.parent.parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: isGetter(node),\n          node\n        };\n      },\n\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (funcInfo.shouldCheck) {\n          funcInfo.hasReturn = true; // if allowImplicit: false, should also check node.argument\n\n          if (!options.allowImplicit && !node.argument) {\n            context.report({\n              node,\n              messageId: \"expected\",\n              data: {\n                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n              }\n            });\n          }\n        }\n      },\n\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","TARGET_NODE_TYPE","isReachable","segment","reachable","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","allowImplicit","default","additionalProperties","messages","expected","expectedAlways","create","context","options","sourceCode","getSourceCode","funcInfo","upper","codePath","hasReturn","shouldCheck","node","checkLastSegment","currentSegments","some","report","loc","getFunctionHeadLoc","messageId","data","name","getFunctionNameWithKind","isGetter","parent","test","body","kind","getStaticPropertyName","callee","onCodePathStart","onCodePathEnd","ReturnStatement","argument"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/getter-return.js"],"sourcesContent":["/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in getters\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/getter-return\"\n        },\n\n        fixable: null,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expected: \"Expected to return a value in {{name}}.\",\n            expectedAlways: \"Expected {{name}} to always return a value.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false };\n        const sourceCode = context.getSourceCode();\n\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks whether a node means a getter function.\n         * @param {ASTNode} node a node to check.\n         * @returns {boolean} if node means a getter, return true; else return false.\n         */\n        function isGetter(node) {\n            const parent = node.parent;\n\n            if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n                if (parent.kind === \"get\") {\n                    return true;\n                }\n                if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n\n                    // Object.defineProperty()\n                    if (parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n                        return true;\n                    }\n\n                    // Object.defineProperties()\n                    if (parent.parent.parent.type === \"Property\" &&\n                        parent.parent.parent.parent.type === \"ObjectExpression\" &&\n                        parent.parent.parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck: isGetter(node),\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        context.report({\n                            node,\n                            messageId: \"expected\",\n                            data: {\n                                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}