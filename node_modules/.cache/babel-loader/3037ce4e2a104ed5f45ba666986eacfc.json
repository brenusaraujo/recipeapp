{"ast":null,"code":"'use strict';\n\nconst XHTMLEntities = require('./xhtml');\n\nconst hexNumber = /^[\\da-fA-F]+$/;\nconst decimalNumber = /^\\d+$/; // The map to `acorn-jsx` tokens from `acorn` namespace objects.\n\nconst acornJsxMap = new WeakMap(); // Get the original tokens for the given `acorn` namespace object.\n\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  let acornJsx = acornJsxMap.get(acorn);\n\n  if (!acornJsx) {\n    const tt = acorn.tokTypes;\n    const TokContext = acorn.TokContext;\n    const TokenType = acorn.TokenType;\n    const tc_oTag = new TokContext('<tag', false);\n    const tc_cTag = new TokContext('</tag', false);\n    const tc_expr = new TokContext('<tag>...</tag>', true, true);\n    const tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    const tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {\n        beforeExpr: true\n      }),\n      jsxTagStart: new TokenType('jsxTagStart', {\n        startsExpr: true\n      }),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function () {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n\n      this.context.push(tc_oTag); // start opening tag context\n\n      this.exprAllowed = false;\n    };\n\n    tokTypes.jsxTagEnd.updateContext = function (prevType) {\n      let out = this.context.pop();\n\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = {\n      tokContexts: tokContexts,\n      tokTypes: tokTypes\n    };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n} // Transforms JSX element name to string.\n\n\nfunction getQualifiedJSXName(object) {\n  if (!object) return object;\n  if (object.type === 'JSXIdentifier') return object.name;\n  if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;\n  if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function (options) {\n  options = options || {};\n  return function (Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n}; // This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\n\n\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nfunction plugin(options, Parser) {\n  const acorn = Parser.acorn || require(\"acorn\");\n\n  const acornJsx = getJsxTokens(acorn);\n  const tt = acorn.tokTypes;\n  const tok = acornJsx.tokTypes;\n  const tokContexts = acorn.tokContexts;\n  const tc_oTag = acornJsx.tokContexts.tc_oTag;\n  const tc_cTag = acornJsx.tokContexts.tc_cTag;\n  const tc_expr = acornJsx.tokContexts.tc_expr;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierStart = acorn.isIdentifierStart;\n  const isIdentifierChar = acorn.isIdentifierChar;\n  return class extends Parser {\n    // Expose actual `tokTypes` and `tokContexts` to other plugins.\n    static get acornJsx() {\n      return acornJsx;\n    } // Reads inline JSX contents token.\n\n\n    jsx_readToken() {\n      let out = '',\n          chunkStart = this.pos;\n\n      for (;;) {\n        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');\n        let ch = this.input.charCodeAt(this.pos);\n\n        switch (ch) {\n          case 60: // '<'\n\n          case 123:\n            // '{'\n            if (this.pos === this.start) {\n              if (ch === 60 && this.exprAllowed) {\n                ++this.pos;\n                return this.finishToken(tok.jsxTagStart);\n              }\n\n              return this.getTokenFromCode(ch);\n            }\n\n            out += this.input.slice(chunkStart, this.pos);\n            return this.finishToken(tok.jsxText, out);\n\n          case 38:\n            // '&'\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readEntity();\n            chunkStart = this.pos;\n            break;\n\n          case 62: // '>'\n\n          case 125:\n            // '}'\n            this.raise(this.pos, \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" + (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\");\n\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.pos);\n              out += this.jsx_readNewLine(true);\n              chunkStart = this.pos;\n            } else {\n              ++this.pos;\n            }\n\n        }\n      }\n    }\n\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? '\\n' : '\\r\\n';\n      } else {\n        out = String.fromCharCode(ch);\n      }\n\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n\n      return out;\n    }\n\n    jsx_readString(quote) {\n      let out = '',\n          chunkStart = ++this.pos;\n\n      for (;;) {\n        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n\n        if (ch === 38) {\n          // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsx_readEntity() {\n      let str = '',\n          count = 0,\n          entity;\n      let ch = this.input[this.pos];\n      if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');\n      let startPos = ++this.pos;\n\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n\n        if (ch === ';') {\n          if (str[0] === '#') {\n            if (str[1] === 'x') {\n              str = str.substr(2);\n              if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n\n          break;\n        }\n\n        str += ch;\n      }\n\n      if (!entity) {\n        this.pos = startPos;\n        return '&';\n      }\n\n      return entity;\n    } // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n\n    jsx_readWord() {\n      let ch,\n          start = this.pos;\n\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45); // '-'\n\n\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    } // Parse next token as JSX identifier\n\n\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();\n      this.next();\n      return this.finishNode(node, 'JSXIdentifier');\n    } // Parse namespaced identifier.\n\n\n    jsx_parseNamespacedName() {\n      let startPos = this.start,\n          startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, 'JSXNamespacedName');\n    } // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return '';\n      let startPos = this.start,\n          startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n\n      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, 'JSXMemberExpression');\n      }\n\n      return node;\n    } // Parses any type of JSX attribute value.\n\n\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n        case tt.braceL:\n          let node = this.jsx_parseExpressionContainer();\n          if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n          return node;\n\n        case tok.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom();\n\n        default:\n          this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n      }\n    } // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n    } // Parses JSX expression enclosed into curly brackets.\n\n\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXExpressionContainer');\n    } // Parses following JSX attribute name-value pair.\n\n\n    jsx_parseAttribute() {\n      let node = this.startNode();\n\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXSpreadAttribute');\n      }\n\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, 'JSXAttribute');\n    } // Parses JSX opening tag starting after '<'.\n\n\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute());\n\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n    } // Parses JSX closing tag starting after '</'.\n\n\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n    } // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n\n\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.type) {\n            case tok.jsxTagStart:\n              startPos = this.start;\n              startLoc = this.startLoc;\n              this.next();\n\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n                break contents;\n              }\n\n              children.push(this.jsx_parseElementAt(startPos, startLoc));\n              break;\n\n            case tok.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n\n            case tt.braceL:\n              children.push(this.jsx_parseExpressionContainer());\n              break;\n\n            default:\n              this.unexpected();\n          }\n        }\n\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n        }\n      }\n\n      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n      node['opening' + fragmentOrElement] = openingElement;\n      node['closing' + fragmentOrElement] = closingElement;\n      node.children = children;\n\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n\n      return this.finishNode(node, 'JSX' + fragmentOrElement);\n    } // Parse JSX text\n\n\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    } // Parses entire JSX element from current position.\n\n\n    jsx_parseElement() {\n      let startPos = this.start,\n          startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n\n    parseExprAtom(refShortHandDefaultPos) {\n      if (this.type === tok.jsxText) return this.jsx_parseText();else if (this.type === tok.jsxTagStart) return this.jsx_parseElement();else return super.parseExprAtom(refShortHandDefaultPos);\n    }\n\n    readToken(code) {\n      let context = this.curContext();\n      if (context === tc_expr) return this.jsx_readToken();\n\n      if (context === tc_oTag || context === tc_cTag) {\n        if (isIdentifierStart(code)) return this.jsx_readWord();\n\n        if (code == 62) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context == tc_oTag) return this.jsx_readString(code);\n      }\n\n      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n        ++this.pos;\n        return this.finishToken(tok.jsxTagStart);\n      }\n\n      return super.readToken(code);\n    }\n\n    updateContext(prevType) {\n      if (this.type == tt.braceL) {\n        var curContext = this.curContext();\n        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);else super.updateContext(prevType);\n        this.exprAllowed = true;\n      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n\n        this.context.push(tc_cTag); // reconsider as closing tag context\n\n        this.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n\n  };\n}","map":{"version":3,"names":["XHTMLEntities","require","hexNumber","decimalNumber","acornJsxMap","WeakMap","getJsxTokens","acorn","Parser","acornJsx","get","tt","tokTypes","TokContext","TokenType","tc_oTag","tc_cTag","tc_expr","tokContexts","jsxName","jsxText","beforeExpr","jsxTagStart","startsExpr","jsxTagEnd","updateContext","context","push","exprAllowed","prevType","out","pop","slash","curContext","set","getQualifiedJSXName","object","type","name","namespace","property","module","exports","options","plugin","allowNamespaces","allowNamespacedObjects","Object","defineProperty","get_tokTypes","configurable","enumerable","tok","isNewLine","isIdentifierStart","isIdentifierChar","jsx_readToken","chunkStart","pos","input","length","raise","start","ch","charCodeAt","finishToken","getTokenFromCode","slice","jsx_readEntity","jsx_readNewLine","normalizeCRLF","String","fromCharCode","locations","curLine","lineStart","jsx_readString","quote","string","str","count","entity","startPos","substr","test","parseInt","jsx_readWord","jsx_parseIdentifier","node","startNode","value","keyword","unexpected","next","finishNode","jsx_parseNamespacedName","startLoc","eat","colon","startNodeAt","jsx_parseElementName","dot","newNode","jsx_parseAttributeValue","braceL","jsx_parseExpressionContainer","expression","parseExprAtom","jsx_parseEmptyExpression","lastTokEnd","lastTokEndLoc","finishNodeAt","braceR","parseExpression","expect","jsx_parseAttribute","ellipsis","argument","parseMaybeAssign","eq","jsx_parseOpeningElementAt","attributes","nodeName","selfClosing","jsx_parseClosingElementAt","jsx_parseElementAt","children","openingElement","closingElement","contents","fragmentOrElement","relational","jsx_parseText","parseLiteral","jsx_parseElement","refShortHandDefaultPos","readToken","code","b_expr","b_tmpl"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/acorn-jsx/index.js"],"sourcesContent":["'use strict';\n\nconst XHTMLEntities = require('./xhtml');\n\nconst hexNumber = /^[\\da-fA-F]+$/;\nconst decimalNumber = /^\\d+$/;\n\n// The map to `acorn-jsx` tokens from `acorn` namespace objects.\nconst acornJsxMap = new WeakMap();\n\n// Get the original tokens for the given `acorn` namespace object.\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  let acornJsx = acornJsxMap.get(acorn);\n  if (!acornJsx) {\n    const tt = acorn.tokTypes;\n    const TokContext = acorn.TokContext;\n    const TokenType = acorn.TokenType;\n    const tc_oTag = new TokContext('<tag', false);\n    const tc_cTag = new TokContext('</tag', false);\n    const tc_expr = new TokContext('<tag>...</tag>', true, true);\n    const tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    const tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {beforeExpr: true}),\n      jsxTagStart: new TokenType('jsxTagStart', {startsExpr: true}),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function() {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n      this.context.push(tc_oTag); // start opening tag context\n      this.exprAllowed = false;\n    };\n    tokTypes.jsxTagEnd.updateContext = function(prevType) {\n      let out = this.context.pop();\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = { tokContexts: tokContexts, tokTypes: tokTypes };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(object) {\n  if (!object)\n    return object;\n\n  if (object.type === 'JSXIdentifier')\n    return object.name;\n\n  if (object.type === 'JSXNamespacedName')\n    return object.namespace.name + ':' + object.name.name;\n\n  if (object.type === 'JSXMemberExpression')\n    return getQualifiedJSXName(object.object) + '.' +\n    getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function(options) {\n  options = options || {};\n  return function(Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n};\n\n// This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nfunction plugin(options, Parser) {\n  const acorn = Parser.acorn || require(\"acorn\");\n  const acornJsx = getJsxTokens(acorn);\n  const tt = acorn.tokTypes;\n  const tok = acornJsx.tokTypes;\n  const tokContexts = acorn.tokContexts;\n  const tc_oTag = acornJsx.tokContexts.tc_oTag;\n  const tc_cTag = acornJsx.tokContexts.tc_cTag;\n  const tc_expr = acornJsx.tokContexts.tc_expr;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierStart = acorn.isIdentifierStart;\n  const isIdentifierChar = acorn.isIdentifierChar;\n\n  return class extends Parser {\n    // Expose actual `tokTypes` and `tokContexts` to other plugins.\n    static get acornJsx() {\n      return acornJsx;\n    }\n\n    // Reads inline JSX contents token.\n    jsx_readToken() {\n      let out = '', chunkStart = this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated JSX contents');\n        let ch = this.input.charCodeAt(this.pos);\n\n        switch (ch) {\n        case 60: // '<'\n        case 123: // '{'\n          if (this.pos === this.start) {\n            if (ch === 60 && this.exprAllowed) {\n              ++this.pos;\n              return this.finishToken(tok.jsxTagStart);\n            }\n            return this.getTokenFromCode(ch);\n          }\n          out += this.input.slice(chunkStart, this.pos);\n          return this.finishToken(tok.jsxText, out);\n\n        case 38: // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n          break;\n\n        case 62: // '>'\n        case 125: // '}'\n          this.raise(\n            this.pos,\n            \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" +\n              (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\"\n          );\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readNewLine(true);\n            chunkStart = this.pos;\n          } else {\n            ++this.pos;\n          }\n        }\n      }\n    }\n\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? '\\n' : '\\r\\n';\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n\n      return out;\n    }\n\n    jsx_readString(quote) {\n      let out = '', chunkStart = ++this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated string constant');\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n        if (ch === 38) { // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsx_readEntity() {\n      let str = '', count = 0, entity;\n      let ch = this.input[this.pos];\n      if (ch !== '&')\n        this.raise(this.pos, 'Entity must start with an ampersand');\n      let startPos = ++this.pos;\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n        if (ch === ';') {\n          if (str[0] === '#') {\n            if (str[1] === 'x') {\n              str = str.substr(2);\n              if (hexNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.pos = startPos;\n        return '&';\n      }\n      return entity;\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsx_readWord() {\n      let ch, start = this.pos;\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45); // '-'\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName)\n        node.name = this.value;\n      else if (this.type.keyword)\n        node.name = this.type.keyword;\n      else\n        this.unexpected();\n      this.next();\n      return this.finishNode(node, 'JSXIdentifier');\n    }\n\n    // Parse namespaced identifier.\n\n    jsx_parseNamespacedName() {\n      let startPos = this.start, startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, 'JSXNamespacedName');\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return '';\n      let startPos = this.start, startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, 'JSXMemberExpression');\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n      case tt.braceL:\n        let node = this.jsx_parseExpressionContainer();\n        if (node.expression.type === 'JSXEmptyExpression')\n          this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n        return node;\n\n      case tok.jsxTagStart:\n      case tt.string:\n        return this.parseExprAtom();\n\n      default:\n        this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR\n        ? this.jsx_parseEmptyExpression()\n        : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXExpressionContainer');\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsx_parseAttribute() {\n      let node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXSpreadAttribute');\n      }\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, 'JSXAttribute');\n    }\n\n    // Parses JSX opening tag starting after '<'.\n\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\n        node.attributes.push(this.jsx_parseAttribute());\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n    }\n\n    // Parses JSX closing tag starting after '</'.\n\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n    }\n\n    // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.type) {\n          case tok.jsxTagStart:\n            startPos = this.start; startLoc = this.startLoc;\n            this.next();\n            if (this.eat(tt.slash)) {\n              closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n            children.push(this.jsx_parseElementAt(startPos, startLoc));\n            break;\n\n          case tok.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case tt.braceL:\n            children.push(this.jsx_parseExpressionContainer());\n            break;\n\n          default:\n            this.unexpected();\n          }\n        }\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(\n            closingElement.start,\n            'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n        }\n      }\n      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n\n      node['opening' + fragmentOrElement] = openingElement;\n      node['closing' + fragmentOrElement] = closingElement;\n      node.children = children;\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n      return this.finishNode(node, 'JSX' + fragmentOrElement);\n    }\n\n    // Parse JSX text\n\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsx_parseElement() {\n      let startPos = this.start, startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n\n    parseExprAtom(refShortHandDefaultPos) {\n      if (this.type === tok.jsxText)\n        return this.jsx_parseText();\n      else if (this.type === tok.jsxTagStart)\n        return this.jsx_parseElement();\n      else\n        return super.parseExprAtom(refShortHandDefaultPos);\n    }\n\n    readToken(code) {\n      let context = this.curContext();\n\n      if (context === tc_expr) return this.jsx_readToken();\n\n      if (context === tc_oTag || context === tc_cTag) {\n        if (isIdentifierStart(code)) return this.jsx_readWord();\n\n        if (code == 62) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context == tc_oTag)\n          return this.jsx_readString(code);\n      }\n\n      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n        ++this.pos;\n        return this.finishToken(tok.jsxTagStart);\n      }\n      return super.readToken(code);\n    }\n\n    updateContext(prevType) {\n      if (this.type == tt.braceL) {\n        var curContext = this.curContext();\n        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);\n        else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);\n        else super.updateContext(prevType);\n        this.exprAllowed = true;\n      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.context.push(tc_cTag); // reconsider as closing tag context\n        this.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}