{"ast":null,"code":"/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary computed property keys in objects and classes\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n    function check(node) {\n      if (!node.computed) {\n        return;\n      }\n\n      const key = node.key,\n            nodeType = typeof key.value;\n      let allowedKey;\n\n      if (node.type === \"MethodDefinition\") {\n        allowedKey = node.static ? \"prototype\" : \"constructor\";\n      } else {\n        allowedKey = \"__proto__\";\n      }\n\n      if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== allowedKey) {\n        context.report({\n          node,\n          messageId: \"unnecessarilyComputedProperty\",\n          data: {\n            property: sourceCode.getText(key)\n          },\n\n          fix(fixer) {\n            const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n            const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken); // If there are comments between the brackets and the property name, don't do a fix.\n\n            if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n              return null;\n            }\n\n            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket); // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n\n            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n          }\n\n        });\n      }\n    }\n    /**\n     * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\n     * @returns {void}\n     * @private\n     */\n\n\n    function noop() {}\n\n    return {\n      Property: check,\n      MethodDefinition: enforceForClassMembers ? check : noop\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","enforceForClassMembers","default","additionalProperties","fixable","messages","unnecessarilyComputedProperty","create","context","sourceCode","getSourceCode","options","check","node","computed","key","nodeType","value","allowedKey","static","report","messageId","data","property","getText","fix","fixer","leftSquareBracket","getTokenBefore","isOpeningBracketToken","rightSquareBracket","getTokenAfter","isClosingBracketToken","commentsExistBetween","tokenBeforeLeftBracket","needsSpaceBeforeKey","range","canTokensBeAdjacent","getFirstToken","replacementKey","raw","replaceTextRange","noop","Property","MethodDefinition"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-useless-computed-key.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary computed property keys in objects and classes\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForClassMembers: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n        }\n    },\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (!node.computed) {\n                return;\n            }\n\n            const key = node.key,\n                nodeType = typeof key.value;\n\n            let allowedKey;\n\n            if (node.type === \"MethodDefinition\") {\n                allowedKey = node.static ? \"prototype\" : \"constructor\";\n            } else {\n                allowedKey = \"__proto__\";\n            }\n\n            if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== allowedKey) {\n                context.report({\n                    node,\n                    messageId: \"unnecessarilyComputedProperty\",\n                    data: { property: sourceCode.getText(key) },\n                    fix(fixer) {\n                        const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n                        const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\n\n                        // If there are comments between the brackets and the property name, don't do a fix.\n                        if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n                            return null;\n                        }\n\n                        const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                        // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                        const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                            !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n\n                        const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                        return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                    }\n                });\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        return {\n            Property: check,\n            MethodDefinition: enforceForClassMembers ? check : noop\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}