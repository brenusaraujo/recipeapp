{"ast":null,"code":"/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  findVariable\n} = require(\"eslint-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\n\n\nfunction isStringLiteral(node) {\n  return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\n\n\nfunction isRegexLiteral(node) {\n  return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n/**\n * Determines whether the given node is a template literal without expressions.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a template literal without expressions.\n */\n\n\nfunction isStaticTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        disallowRedundantWrapping: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n      unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n      unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n    }\n  },\n\n  create(context) {\n    const [{\n      disallowRedundantWrapping = false\n    } = {}] = context.options;\n    /**\n     * Determines whether the given identifier node is a reference to a global variable.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} True if the identifier is a reference to a global variable.\n     */\n\n    function isGlobalReference(node) {\n      const scope = context.getScope();\n      const variable = findVariable(scope, node);\n      return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n    }\n    /**\n     * Determines whether the given node is a String.raw`` tagged template expression\n     * with a static template literal.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is String.raw`` with a static template.\n     */\n\n\n    function isStringRawTaggedStaticTemplateLiteral(node) {\n      return node.type === \"TaggedTemplateExpression\" && astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") && isGlobalReference(astUtils.skipChainExpression(node.tag).object) && isStaticTemplateLiteral(node.quasi);\n    }\n    /**\n     * Determines whether the given node is considered to be a static string by the logic of this rule.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is a static string.\n     */\n\n\n    function isStaticString(node) {\n      return isStringLiteral(node) || isStaticTemplateLiteral(node) || isStringRawTaggedStaticTemplateLiteral(node);\n    }\n    /**\n     * Determines whether the relevant arguments of the given are all static string literals.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if all arguments are static strings.\n     */\n\n\n    function hasOnlyStaticStringArguments(node) {\n      const args = node.arguments;\n\n      if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node already contains a regex literal argument.\n     */\n\n\n    function isUnnecessarilyWrappedRegexLiteral(node) {\n      const args = node.arguments;\n\n      if (args.length === 1 && isRegexLiteral(args[0])) {\n        return true;\n      }\n\n      if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const traceMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\n            if (node.arguments.length === 2) {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExpWithFlags\"\n              });\n            } else {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExp\"\n              });\n            }\n          } else if (hasOnlyStaticStringArguments(node)) {\n            context.report({\n              node,\n              messageId: \"unexpectedRegExp\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","CALL","CONSTRUCT","ReferenceTracker","findVariable","isStringLiteral","node","type","value","isRegexLiteral","Object","prototype","hasOwnProperty","call","isStaticTemplateLiteral","expressions","length","module","exports","meta","docs","description","category","recommended","url","schema","properties","disallowRedundantWrapping","default","additionalProperties","messages","unexpectedRegExp","unexpectedRedundantRegExp","unexpectedRedundantRegExpWithFlags","create","context","options","isGlobalReference","scope","getScope","variable","defs","isStringRawTaggedStaticTemplateLiteral","isSpecificMemberAccess","tag","skipChainExpression","object","quasi","isStaticString","hasOnlyStaticStringArguments","args","arguments","every","isUnnecessarilyWrappedRegexLiteral","Program","tracker","traceMap","RegExp","iterateGlobalReferences","report","messageId"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/prefer-regex-literals.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, CONSTRUCT, ReferenceTracker, findVariable } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\nfunction isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\nfunction isRegexLiteral(node) {\n    return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n\n/**\n * Determines whether the given node is a template literal without expressions.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a template literal without expressions.\n */\nfunction isStaticTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    disallowRedundantWrapping: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n            unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n            unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n        }\n    },\n\n    create(context) {\n        const [{ disallowRedundantWrapping = false } = {}] = context.options;\n\n        /**\n         * Determines whether the given identifier node is a reference to a global variable.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} True if the identifier is a reference to a global variable.\n         */\n        function isGlobalReference(node) {\n            const scope = context.getScope();\n            const variable = findVariable(scope, node);\n\n            return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n        }\n\n        /**\n         * Determines whether the given node is a String.raw`` tagged template expression\n         * with a static template literal.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is String.raw`` with a static template.\n         */\n        function isStringRawTaggedStaticTemplateLiteral(node) {\n            return node.type === \"TaggedTemplateExpression\" &&\n                astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") &&\n                isGlobalReference(astUtils.skipChainExpression(node.tag).object) &&\n                isStaticTemplateLiteral(node.quasi);\n        }\n\n        /**\n         * Determines whether the given node is considered to be a static string by the logic of this rule.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is a static string.\n         */\n        function isStaticString(node) {\n            return isStringLiteral(node) ||\n                isStaticTemplateLiteral(node) ||\n                isStringRawTaggedStaticTemplateLiteral(node);\n        }\n\n        /**\n         * Determines whether the relevant arguments of the given are all static string literals.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if all arguments are static strings.\n         */\n        function hasOnlyStaticStringArguments(node) {\n            const args = node.arguments;\n\n            if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node already contains a regex literal argument.\n         */\n        function isUnnecessarilyWrappedRegexLiteral(node) {\n            const args = node.arguments;\n\n            if (args.length === 1 && isRegexLiteral(args[0])) {\n                return true;\n            }\n\n            if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n                return true;\n            }\n\n            return false;\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\n                        if (node.arguments.length === 2) {\n                            context.report({ node, messageId: \"unexpectedRedundantRegExpWithFlags\" });\n                        } else {\n                            context.report({ node, messageId: \"unexpectedRedundantRegExp\" });\n                        }\n                    } else if (hasOnlyStaticStringArguments(node)) {\n                        context.report({ node, messageId: \"unexpectedRegExp\" });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}