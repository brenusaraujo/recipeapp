{"ast":null,"code":"/**\n * @fileoverview Rule to enforce spacing around colons of switch statements.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce spacing around colons of switch statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/switch-colon-spacing\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: false\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expectedBefore: \"Expected space(s) before this colon.\",\n      expectedAfter: \"Expected space(s) after this colon.\",\n      unexpectedBefore: \"Unexpected space(s) before this colon.\",\n      unexpectedAfter: \"Unexpected space(s) after this colon.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const beforeSpacing = options.before === true; // false by default\n\n    const afterSpacing = options.after !== false; // true by default\n\n    /**\n     * Get the colon token of the given SwitchCase node.\n     * @param {ASTNode} node The SwitchCase node to get.\n     * @returns {Token} The colon token of the node.\n     */\n\n    function getColonToken(node) {\n      if (node.test) {\n        return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);\n      }\n\n      return sourceCode.getFirstToken(node, 1);\n    }\n    /**\n     * Check whether the spacing between the given 2 tokens is valid or not.\n     * @param {Token} left The left token to check.\n     * @param {Token} right The right token to check.\n     * @param {boolean} expected The expected spacing to check. `true` if there should be a space.\n     * @returns {boolean} `true` if the spacing between the tokens is valid.\n     */\n\n\n    function isValidSpacing(left, right, expected) {\n      return astUtils.isClosingBraceToken(right) || !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === expected;\n    }\n    /**\n     * Check whether comments exist between the given 2 tokens.\n     * @param {Token} left The left token to check.\n     * @param {Token} right The right token to check.\n     * @returns {boolean} `true` if comments exist between the given 2 tokens.\n     */\n\n\n    function commentsExistBetween(left, right) {\n      return sourceCode.getFirstTokenBetween(left, right, {\n        includeComments: true,\n        filter: astUtils.isCommentToken\n      }) !== null;\n    }\n    /**\n     * Fix the spacing between the given 2 tokens.\n     * @param {RuleFixer} fixer The fixer to fix.\n     * @param {Token} left The left token of fix range.\n     * @param {Token} right The right token of fix range.\n     * @param {boolean} spacing The spacing style. `true` if there should be a space.\n     * @returns {Fix|null} The fix object.\n     */\n\n\n    function fix(fixer, left, right, spacing) {\n      if (commentsExistBetween(left, right)) {\n        return null;\n      }\n\n      if (spacing) {\n        return fixer.insertTextAfter(left, \" \");\n      }\n\n      return fixer.removeRange([left.range[1], right.range[0]]);\n    }\n\n    return {\n      SwitchCase(node) {\n        const colonToken = getColonToken(node);\n        const beforeToken = sourceCode.getTokenBefore(colonToken);\n        const afterToken = sourceCode.getTokenAfter(colonToken);\n\n        if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {\n          context.report({\n            node,\n            loc: colonToken.loc,\n            messageId: beforeSpacing ? \"expectedBefore\" : \"unexpectedBefore\",\n            fix: fixer => fix(fixer, beforeToken, colonToken, beforeSpacing)\n          });\n        }\n\n        if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {\n          context.report({\n            node,\n            loc: colonToken.loc,\n            messageId: afterSpacing ? \"expectedAfter\" : \"unexpectedAfter\",\n            fix: fixer => fix(fixer, colonToken, afterToken, afterSpacing)\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","before","default","after","additionalProperties","fixable","messages","expectedBefore","expectedAfter","unexpectedBefore","unexpectedAfter","create","context","sourceCode","getSourceCode","options","beforeSpacing","afterSpacing","getColonToken","node","test","getTokenAfter","isColonToken","getFirstToken","isValidSpacing","left","right","expected","isClosingBraceToken","isTokenOnSameLine","isSpaceBetweenTokens","commentsExistBetween","getFirstTokenBetween","includeComments","filter","isCommentToken","fix","fixer","spacing","insertTextAfter","removeRange","range","SwitchCase","colonToken","beforeToken","getTokenBefore","afterToken","report","loc","messageId"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/switch-colon-spacing.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce spacing around colons of switch statements.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce spacing around colons of switch statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/switch-colon-spacing\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\", default: false },\n                    after: { type: \"boolean\", default: true }\n                },\n                additionalProperties: false\n            }\n        ],\n        fixable: \"whitespace\",\n        messages: {\n            expectedBefore: \"Expected space(s) before this colon.\",\n            expectedAfter: \"Expected space(s) after this colon.\",\n            unexpectedBefore: \"Unexpected space(s) before this colon.\",\n            unexpectedAfter: \"Unexpected space(s) after this colon.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const beforeSpacing = options.before === true; // false by default\n        const afterSpacing = options.after !== false; // true by default\n\n        /**\n         * Get the colon token of the given SwitchCase node.\n         * @param {ASTNode} node The SwitchCase node to get.\n         * @returns {Token} The colon token of the node.\n         */\n        function getColonToken(node) {\n            if (node.test) {\n                return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);\n            }\n            return sourceCode.getFirstToken(node, 1);\n        }\n\n        /**\n         * Check whether the spacing between the given 2 tokens is valid or not.\n         * @param {Token} left The left token to check.\n         * @param {Token} right The right token to check.\n         * @param {boolean} expected The expected spacing to check. `true` if there should be a space.\n         * @returns {boolean} `true` if the spacing between the tokens is valid.\n         */\n        function isValidSpacing(left, right, expected) {\n            return (\n                astUtils.isClosingBraceToken(right) ||\n                !astUtils.isTokenOnSameLine(left, right) ||\n                sourceCode.isSpaceBetweenTokens(left, right) === expected\n            );\n        }\n\n        /**\n         * Check whether comments exist between the given 2 tokens.\n         * @param {Token} left The left token to check.\n         * @param {Token} right The right token to check.\n         * @returns {boolean} `true` if comments exist between the given 2 tokens.\n         */\n        function commentsExistBetween(left, right) {\n            return sourceCode.getFirstTokenBetween(\n                left,\n                right,\n                {\n                    includeComments: true,\n                    filter: astUtils.isCommentToken\n                }\n            ) !== null;\n        }\n\n        /**\n         * Fix the spacing between the given 2 tokens.\n         * @param {RuleFixer} fixer The fixer to fix.\n         * @param {Token} left The left token of fix range.\n         * @param {Token} right The right token of fix range.\n         * @param {boolean} spacing The spacing style. `true` if there should be a space.\n         * @returns {Fix|null} The fix object.\n         */\n        function fix(fixer, left, right, spacing) {\n            if (commentsExistBetween(left, right)) {\n                return null;\n            }\n            if (spacing) {\n                return fixer.insertTextAfter(left, \" \");\n            }\n            return fixer.removeRange([left.range[1], right.range[0]]);\n        }\n\n        return {\n            SwitchCase(node) {\n                const colonToken = getColonToken(node);\n                const beforeToken = sourceCode.getTokenBefore(colonToken);\n                const afterToken = sourceCode.getTokenAfter(colonToken);\n\n                if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {\n                    context.report({\n                        node,\n                        loc: colonToken.loc,\n                        messageId: beforeSpacing ? \"expectedBefore\" : \"unexpectedBefore\",\n                        fix: fixer => fix(fixer, beforeToken, colonToken, beforeSpacing)\n                    });\n                }\n                if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {\n                    context.report({\n                        node,\n                        loc: colonToken.loc,\n                        messageId: afterSpacing ? \"expectedAfter\" : \"unexpectedAfter\",\n                        fix: fixer => fix(fixer, colonToken, afterToken, afterSpacing)\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}