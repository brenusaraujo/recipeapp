{"ast":null,"code":"/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unused variables\",\n      category: \"Variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unused-vars\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"all\", \"local\"]\n      }, {\n        type: \"object\",\n        properties: {\n          vars: {\n            enum: [\"all\", \"local\"]\n          },\n          varsIgnorePattern: {\n            type: \"string\"\n          },\n          args: {\n            enum: [\"all\", \"after-used\", \"none\"]\n          },\n          ignoreRestSiblings: {\n            type: \"boolean\"\n          },\n          argsIgnorePattern: {\n            type: \"string\"\n          },\n          caughtErrors: {\n            enum: [\"all\", \"none\"]\n          },\n          caughtErrorsIgnorePattern: {\n            type: \"string\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n    const config = {\n      vars: \"all\",\n      args: \"after-used\",\n      ignoreRestSiblings: false,\n      caughtErrors: \"none\"\n    };\n    const firstOption = context.options[0];\n\n    if (firstOption) {\n      if (typeof firstOption === \"string\") {\n        config.vars = firstOption;\n      } else {\n        config.vars = firstOption.vars || config.vars;\n        config.args = firstOption.args || config.args;\n        config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n        config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n        if (firstOption.varsIgnorePattern) {\n          config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.argsIgnorePattern) {\n          config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.caughtErrorsIgnorePattern) {\n          config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n        }\n      }\n    }\n    /**\n     * Generates the message data about the variable being defined and unused,\n     * including the ignore pattern if configured.\n     * @param {Variable} unusedVar eslint-scope variable object.\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n     */\n\n\n    function getDefinedMessageData(unusedVar) {\n      const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n      let type;\n      let pattern;\n\n      if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n        type = \"args\";\n        pattern = config.caughtErrorsIgnorePattern.toString();\n      } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n        type = \"args\";\n        pattern = config.argsIgnorePattern.toString();\n      } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n        type = \"vars\";\n        pattern = config.varsIgnorePattern.toString();\n      }\n\n      const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n      return {\n        varName: unusedVar.name,\n        action: \"defined\",\n        additional\n      };\n    }\n    /**\n     * Generate the warning message about the variable being\n     * assigned and unused, including the ignore pattern if configured.\n     * @param {Variable} unusedVar eslint-scope variable object.\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n     */\n\n\n    function getAssignedMessageData(unusedVar) {\n      const additional = config.varsIgnorePattern ? `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}` : \"\";\n      return {\n        varName: unusedVar.name,\n        action: \"assigned a value\",\n        additional\n      };\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n\n    const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n    /**\n     * Determines if a given variable is being exported from a module.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n\n    function isExported(variable) {\n      const definition = variable.defs[0];\n\n      if (definition) {\n        let node = definition.node;\n\n        if (node.type === \"VariableDeclarator\") {\n          node = node.parent;\n        } else if (definition.type === \"Parameter\") {\n          return false;\n        }\n\n        return node.parent.type.indexOf(\"Export\") === 0;\n      }\n\n      return false;\n    }\n    /**\n     * Checks whether a node is a sibling of the rest property or not.\n     * @param {ASTNode} node a node to check\n     * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n     */\n\n\n    function hasRestSibling(node) {\n      return node.type === \"Property\" && node.parent.type === \"ObjectPattern\" && REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\n    }\n    /**\n     * Determines if a variable has a sibling rest property\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n\n\n    function hasRestSpreadSibling(variable) {\n      if (config.ignoreRestSiblings) {\n        const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n        const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n        return hasRestSiblingDefinition || hasRestSiblingReference;\n      }\n\n      return false;\n    }\n    /**\n     * Determines if a reference is a read operation.\n     * @param {Reference} ref An eslint-scope Reference\n     * @returns {boolean} whether the given reference represents a read operation\n     * @private\n     */\n\n\n    function isReadRef(ref) {\n      return ref.isRead();\n    }\n    /**\n     * Determine if an identifier is referencing an enclosing function name.\n     * @param {Reference} ref The reference to check.\n     * @param {ASTNode[]} nodes The candidate function nodes.\n     * @returns {boolean} True if it's a self-reference, false if not.\n     * @private\n     */\n\n\n    function isSelfReference(ref, nodes) {\n      let scope = ref.from;\n\n      while (scope) {\n        if (nodes.indexOf(scope.block) >= 0) {\n          return true;\n        }\n\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n    /**\n     * Gets a list of function definitions for a specified variable.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {ASTNode[]} Function nodes.\n     * @private\n     */\n\n\n    function getFunctionDefinitions(variable) {\n      const functionDefinitions = [];\n      variable.defs.forEach(def => {\n        const {\n          type,\n          node\n        } = def; // FunctionDeclarations\n\n        if (type === \"FunctionName\") {\n          functionDefinitions.push(node);\n        } // FunctionExpressions\n\n\n        if (type === \"Variable\" && node.init && (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n          functionDefinitions.push(node.init);\n        }\n      });\n      return functionDefinitions;\n    }\n    /**\n     * Checks the position of given nodes.\n     * @param {ASTNode} inner A node which is expected as inside.\n     * @param {ASTNode} outer A node which is expected as outside.\n     * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n     * @private\n     */\n\n\n    function isInside(inner, outer) {\n      return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n    }\n    /**\n     * If a given reference is left-hand side of an assignment, this gets\n     * the right-hand side node of the assignment.\n     *\n     * In the following cases, this returns null.\n     *\n     * - The reference is not the LHS of an assignment expression.\n     * - The reference is inside of a loop.\n     * - The reference is inside of a function scope which is different from\n     *   the declaration.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} prevRhsNode The previous RHS node.\n     * @returns {ASTNode|null} The RHS node or null.\n     * @private\n     */\n\n\n    function getRhsNode(ref, prevRhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      const grandparent = parent.parent;\n      const refScope = ref.from.variableScope;\n      const varScope = ref.resolved.scope.variableScope;\n      const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n      /*\n       * Inherits the previous node if this reference is in the node.\n       * This is for `a = a + a`-like code.\n       */\n\n      if (prevRhsNode && isInside(id, prevRhsNode)) {\n        return prevRhsNode;\n      }\n\n      if (parent.type === \"AssignmentExpression\" && grandparent.type === \"ExpressionStatement\" && id === parent.left && !canBeUsedLater) {\n        return parent.right;\n      }\n\n      return null;\n    }\n    /**\n     * Checks whether a given function node is stored to somewhere or not.\n     * If the function node is stored, the function can be used later.\n     * @param {ASTNode} funcNode A function node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if under the following conditions:\n     *      - the funcNode is assigned to a variable.\n     *      - the funcNode is bound as an argument of a function call.\n     *      - the function is bound to a property and the object satisfies above conditions.\n     * @private\n     */\n\n\n    function isStorableFunction(funcNode, rhsNode) {\n      let node = funcNode;\n      let parent = funcNode.parent;\n\n      while (parent && isInside(parent, rhsNode)) {\n        switch (parent.type) {\n          case \"SequenceExpression\":\n            if (parent.expressions[parent.expressions.length - 1] !== node) {\n              return false;\n            }\n\n            break;\n\n          case \"CallExpression\":\n          case \"NewExpression\":\n            return parent.callee !== node;\n\n          case \"AssignmentExpression\":\n          case \"TaggedTemplateExpression\":\n          case \"YieldExpression\":\n            return true;\n\n          default:\n            if (STATEMENT_TYPE.test(parent.type)) {\n              /*\n               * If it encountered statements, this is a complex pattern.\n               * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n               */\n              return true;\n            }\n\n        }\n\n        node = parent;\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Checks whether a given Identifier node exists inside of a function node which can be used later.\n     *\n     * \"can be used later\" means:\n     * - the function is assigned to a variable.\n     * - the function is bound to a property and the object can be used later.\n     * - the function is bound as an argument of a function call.\n     *\n     * If a reference exists in a function which can be used later, the reference is read when the function is called.\n     * @param {ASTNode} id An Identifier node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n     * @private\n     */\n\n\n    function isInsideOfStorableFunction(id, rhsNode) {\n      const funcNode = astUtils.getUpperFunction(id);\n      return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);\n    }\n    /**\n     * Checks whether a given node is unused expression or not.\n     * @param {ASTNode} node The node itself\n     * @returns {boolean} The node is an unused expression.\n     * @private\n     */\n\n\n    function isUnusedExpression(node) {\n      const parent = node.parent;\n\n      if (parent.type === \"ExpressionStatement\") {\n        return true;\n      }\n\n      if (parent.type === \"SequenceExpression\") {\n        const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n\n        if (!isLastExpression) {\n          return true;\n        }\n\n        return isUnusedExpression(parent);\n      }\n\n      return false;\n    }\n    /**\n     * Checks whether a given reference is a read to update itself or not.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} The reference is a read to update itself.\n     * @private\n     */\n\n\n    function isReadForItself(ref, rhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      return ref.isRead() && ( // self update. e.g. `a += 1`, `a++`\n      parent.type === \"AssignmentExpression\" && parent.left === id && isUnusedExpression(parent) || parent.type === \"UpdateExpression\" && isUnusedExpression(parent) || // in RHS of an assignment for itself. e.g. `a = a + 1`\n      rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));\n    }\n    /**\n     * Determine if an identifier is used either in for-in loops.\n     * @param {Reference} ref The reference to check.\n     * @returns {boolean} whether reference is used in the for-in loops\n     * @private\n     */\n\n\n    function isForInRef(ref) {\n      let target = ref.identifier.parent; // \"for (var ...) { return; }\"\n\n      if (target.type === \"VariableDeclarator\") {\n        target = target.parent.parent;\n      }\n\n      if (target.type !== \"ForInStatement\") {\n        return false;\n      } // \"for (...) { return; }\"\n\n\n      if (target.body.type === \"BlockStatement\") {\n        target = target.body.body[0]; // \"for (...) return;\"\n      } else {\n        target = target.body;\n      } // For empty loop body\n\n\n      if (!target) {\n        return false;\n      }\n\n      return target.type === \"ReturnStatement\";\n    }\n    /**\n     * Determines if the variable is used.\n     * @param {Variable} variable The variable to check.\n     * @returns {boolean} True if the variable is used\n     * @private\n     */\n\n\n    function isUsedVariable(variable) {\n      const functionNodes = getFunctionDefinitions(variable),\n            isFunctionDefinition = functionNodes.length > 0;\n      let rhsNode = null;\n      return variable.references.some(ref => {\n        if (isForInRef(ref)) {\n          return true;\n        }\n\n        const forItself = isReadForItself(ref, rhsNode);\n        rhsNode = getRhsNode(ref, rhsNode);\n        return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));\n      });\n    }\n    /**\n     * Checks whether the given variable is after the last used parameter.\n     * @param {eslint-scope.Variable} variable The variable to check.\n     * @returns {boolean} `true` if the variable is defined after the last\n     * used parameter.\n     */\n\n\n    function isAfterLastUsedArg(variable) {\n      const def = variable.defs[0];\n      const params = context.getDeclaredVariables(def.node);\n      const posteriorParams = params.slice(params.indexOf(variable) + 1); // If any used parameters occur after this parameter, do not report.\n\n      return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n    }\n    /**\n     * Gets an array of variables without read references.\n     * @param {Scope} scope an eslint-scope Scope object.\n     * @param {Variable[]} unusedVars an array that saving result.\n     * @returns {Variable[]} unused variables of the scope and descendant scopes.\n     * @private\n     */\n\n\n    function collectUnusedVariables(scope, unusedVars) {\n      const variables = scope.variables;\n      const childScopes = scope.childScopes;\n      let i, l;\n\n      if (scope.type !== \"global\" || config.vars === \"all\") {\n        for (i = 0, l = variables.length; i < l; ++i) {\n          const variable = variables[i]; // skip a variable of class itself name in the class scope\n\n          if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n            continue;\n          } // skip function expression names and variables marked with markVariableAsUsed()\n\n\n          if (scope.functionExpressionScope || variable.eslintUsed) {\n            continue;\n          } // skip implicit \"arguments\" variable\n\n\n          if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n            continue;\n          } // explicit global variables don't have definitions.\n\n\n          const def = variable.defs[0];\n\n          if (def) {\n            const type = def.type; // skip catch variables\n\n            if (type === \"CatchClause\") {\n              if (config.caughtErrors === \"none\") {\n                continue;\n              } // skip ignored parameters\n\n\n              if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n\n            if (type === \"Parameter\") {\n              // skip any setter argument\n              if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                continue;\n              } // if \"args\" option is \"none\", skip any parameter\n\n\n              if (config.args === \"none\") {\n                continue;\n              } // skip ignored parameters\n\n\n              if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                continue;\n              } // if \"args\" option is \"after-used\", skip used variables\n\n\n              if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                continue;\n              }\n            } else {\n              // skip ignored variables\n              if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n          }\n\n          if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n            unusedVars.push(variable);\n          }\n        }\n      }\n\n      for (i = 0, l = childScopes.length; i < l; ++i) {\n        collectUnusedVariables(childScopes[i], unusedVars);\n      }\n\n      return unusedVars;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      \"Program:exit\"(programNode) {\n        const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n        for (let i = 0, l = unusedVars.length; i < l; ++i) {\n          const unusedVar = unusedVars[i]; // Report the first declaration.\n\n          if (unusedVar.defs.length > 0) {\n            // report last write reference, https://github.com/eslint/eslint/issues/14324\n            const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n            let referenceToReport;\n\n            if (writeReferences.length > 0) {\n              referenceToReport = writeReferences[writeReferences.length - 1];\n            }\n\n            context.report({\n              node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n              messageId: \"unusedVar\",\n              data: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)\n            }); // If there are no regular declaration, report the first `/*globals*/` comment directive.\n          } else if (unusedVar.eslintExplicitGlobalComments) {\n            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n            context.report({\n              node: programNode,\n              loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n              messageId: \"unusedVar\",\n              data: getDefinedMessageData(unusedVar)\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","enum","properties","vars","varsIgnorePattern","args","ignoreRestSiblings","argsIgnorePattern","caughtErrors","caughtErrorsIgnorePattern","additionalProperties","messages","unusedVar","create","context","sourceCode","getSourceCode","REST_PROPERTY_TYPE","config","firstOption","options","RegExp","getDefinedMessageData","defType","defs","pattern","toString","additional","varName","name","action","getAssignedMessageData","STATEMENT_TYPE","isExported","variable","definition","node","parent","indexOf","hasRestSibling","test","length","hasRestSpreadSibling","hasRestSiblingDefinition","some","def","hasRestSiblingReference","references","ref","identifier","isReadRef","isRead","isSelfReference","nodes","scope","from","block","upper","getFunctionDefinitions","functionDefinitions","forEach","push","init","isInside","inner","outer","range","getRhsNode","prevRhsNode","id","grandparent","refScope","variableScope","varScope","resolved","canBeUsedLater","isInLoop","left","right","isStorableFunction","funcNode","rhsNode","expressions","callee","isInsideOfStorableFunction","getUpperFunction","isUnusedExpression","isLastExpression","isReadForItself","isForInRef","target","body","isUsedVariable","functionNodes","isFunctionDefinition","forItself","isAfterLastUsedArg","params","getDeclaredVariables","posteriorParams","slice","v","eslintUsed","collectUnusedVariables","unusedVars","variables","childScopes","i","l","identifiers","functionExpressionScope","kind","isFunction","programNode","getScope","writeReferences","filter","isWrite","referenceToReport","report","messageId","data","eslintExplicitGlobalComments","directiveComment","loc","getNameLocationInGlobalDirectiveComment"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-unused-vars.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unused variables\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unused-vars\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"none\"\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n                }\n            }\n        }\n\n        /**\n         * Generates the message data about the variable being defined and unused,\n         * including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getDefinedMessageData(unusedVar) {\n            const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n            let type;\n            let pattern;\n\n            if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n                type = \"args\";\n                pattern = config.caughtErrorsIgnorePattern.toString();\n            } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n                type = \"args\";\n                pattern = config.argsIgnorePattern.toString();\n            } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n                type = \"vars\";\n                pattern = config.varsIgnorePattern.toString();\n            }\n\n            const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n\n            return {\n                varName: unusedVar.name,\n                action: \"defined\",\n                additional\n            };\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getAssignedMessageData(unusedVar) {\n            const additional = config.varsIgnorePattern ? `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}` : \"\";\n\n            return {\n                varName: unusedVar.name,\n                action: \"assigned a value\",\n                additional\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Checks whether a node is a sibling of the rest property or not.\n         * @param {ASTNode} node a node to check\n         * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n         */\n        function hasRestSibling(node) {\n            return node.type === \"Property\" &&\n                node.parent.type === \"ObjectPattern\" &&\n                REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n                const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n\n                return hasRestSiblingDefinition || hasRestSiblingReference;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref An eslint-scope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref The reference to check.\n         * @param {ASTNode[]} nodes The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.indexOf(scope.block) >= 0) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets a list of function definitions for a specified variable.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {ASTNode[]} Function nodes.\n         * @private\n         */\n        function getFunctionDefinitions(variable) {\n            const functionDefinitions = [];\n\n            variable.defs.forEach(def => {\n                const { type, node } = def;\n\n                // FunctionDeclarations\n                if (type === \"FunctionName\") {\n                    functionDefinitions.push(node);\n                }\n\n                // FunctionExpressions\n                if (type === \"Variable\" && node.init &&\n                    (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n                    functionDefinitions.push(node.init);\n                }\n            });\n            return functionDefinitions;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         * @param {ASTNode} inner A node which is expected as inside.\n         * @param {ASTNode} outer A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} prevRhsNode The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const grandparent = parent.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                grandparent.type === \"ExpressionStatement\" &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         * @param {ASTNode} funcNode A function node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         * @param {ASTNode} id An Identifier node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given node is unused expression or not.\n         * @param {ASTNode} node The node itself\n         * @returns {boolean} The node is an unused expression.\n         * @private\n         */\n        function isUnusedExpression(node) {\n            const parent = node.parent;\n\n            if (parent.type === \"ExpressionStatement\") {\n                return true;\n            }\n\n            if (parent.type === \"SequenceExpression\") {\n                const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n\n                if (!isLastExpression) {\n                    return true;\n                }\n                return isUnusedExpression(parent);\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (\n                    (\n                        parent.type === \"AssignmentExpression\" &&\n                        parent.left === id &&\n                        isUnusedExpression(parent)\n                    ) ||\n                    (\n                        parent.type === \"UpdateExpression\" &&\n                        isUnusedExpression(parent)\n                    )\n                ) ||\n\n                // in RHS of an assignment for itself. e.g. `a = a + 1`\n                (\n                    rhsNode &&\n                    isInside(id, rhsNode) &&\n                    !isInsideOfStorableFunction(id, rhsNode)\n                )\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in loops.\n         * @param {Reference} ref The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            const functionNodes = getFunctionDefinitions(variable),\n                isFunctionDefinition = functionNodes.length > 0;\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is after the last used parameter.\n         * @param {eslint-scope.Variable} variable The variable to check.\n         * @returns {boolean} `true` if the variable is defined after the last\n         * used parameter.\n         */\n        function isAfterLastUsedArg(variable) {\n            const def = variable.defs[0];\n            const params = context.getDeclaredVariables(def.node);\n            const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n            // If any used parameters occur after this parameter, do not report.\n            return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope an eslint-scope Scope object.\n         * @param {Variable[]} unusedVars an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"global\" || config.vars === \"all\") {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names and variables marked with markVariableAsUsed()\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n\n                        if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip used variables\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    // Report the first declaration.\n                    if (unusedVar.defs.length > 0) {\n\n                        // report last write reference, https://github.com/eslint/eslint/issues/14324\n                        const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n\n                        let referenceToReport;\n\n                        if (writeReferences.length > 0) {\n                            referenceToReport = writeReferences[writeReferences.length - 1];\n                        }\n\n                        context.report({\n                            node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n                            messageId: \"unusedVar\",\n                            data: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessageData(unusedVar)\n                                : getDefinedMessageData(unusedVar)\n                        });\n\n                    // If there are no regular declaration, report the first `/*globals*/` comment directive.\n                    } else if (unusedVar.eslintExplicitGlobalComments) {\n                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n\n                        context.report({\n                            node: programNode,\n                            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n                            messageId: \"unusedVar\",\n                            data: getDefinedMessageData(unusedVar)\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}