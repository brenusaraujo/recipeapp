{"ast":null,"code":"/**\n * @fileoverview Restrict usage of duplicate imports.\n * @author Simen Bekkhus\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NAMED_TYPES = [\"ImportSpecifier\", \"ExportSpecifier\"];\nconst NAMESPACE_TYPES = [\"ImportNamespaceSpecifier\", \"ExportNamespaceSpecifier\"]; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Check if an import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier).\n * @param {string} importExportType An import/export type to check.\n * @param {string} type Can be \"named\" or \"namespace\"\n * @returns {boolean} True if import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier) and false if it doesn't.\n */\n\nfunction isImportExportSpecifier(importExportType, type) {\n  const arrayToCheck = type === \"named\" ? NAMED_TYPES : NAMESPACE_TYPES;\n  return arrayToCheck.includes(importExportType);\n}\n/**\n * Return the type of (import|export).\n * @param {ASTNode} node A node to get.\n * @returns {string} The type of the (import|export).\n */\n\n\nfunction getImportExportType(node) {\n  if (node.specifiers && node.specifiers.length > 0) {\n    const nodeSpecifiers = node.specifiers;\n    const index = nodeSpecifiers.findIndex(_ref => {\n      let {\n        type\n      } = _ref;\n      return isImportExportSpecifier(type, \"named\") || isImportExportSpecifier(type, \"namespace\");\n    });\n    const i = index > -1 ? index : 0;\n    return nodeSpecifiers[i].type;\n  }\n\n  if (node.type === \"ExportAllDeclaration\") {\n    if (node.exported) {\n      return \"ExportNamespaceSpecifier\";\n    }\n\n    return \"ExportAll\";\n  }\n\n  return \"SideEffectImport\";\n}\n/**\n * Returns a boolean indicates if two (import|export) can be merged\n * @param {ASTNode} node1 A node to check.\n * @param {ASTNode} node2 A node to check.\n * @returns {boolean} True if two (import|export) can be merged, false if they can't.\n */\n\n\nfunction isImportExportCanBeMerged(node1, node2) {\n  const importExportType1 = getImportExportType(node1);\n  const importExportType2 = getImportExportType(node2);\n\n  if (importExportType1 === \"ExportAll\" && importExportType2 !== \"ExportAll\" && importExportType2 !== \"SideEffectImport\" || importExportType1 !== \"ExportAll\" && importExportType1 !== \"SideEffectImport\" && importExportType2 === \"ExportAll\") {\n    return false;\n  }\n\n  if (isImportExportSpecifier(importExportType1, \"namespace\") && isImportExportSpecifier(importExportType2, \"named\") || isImportExportSpecifier(importExportType2, \"namespace\") && isImportExportSpecifier(importExportType1, \"named\")) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Returns a boolean if we should report (import|export).\n * @param {ASTNode} node A node to be reported or not.\n * @param {[ASTNode]} previousNodes An array contains previous nodes of the module imported or exported.\n * @returns {boolean} True if the (import|export) should be reported.\n */\n\n\nfunction shouldReportImportExport(node, previousNodes) {\n  let i = 0;\n\n  while (i < previousNodes.length) {\n    if (isImportExportCanBeMerged(node, previousNodes[i])) {\n      return true;\n    }\n\n    i++;\n  }\n\n  return false;\n}\n/**\n * Returns array contains only nodes with declarations types equal to type.\n * @param {[{node: ASTNode, declarationType: string}]} nodes An array contains objects, each object contains a node and a declaration type.\n * @param {string} type Declaration type.\n * @returns {[ASTNode]} An array contains only nodes with declarations types equal to type.\n */\n\n\nfunction getNodesByDeclarationType(nodes, type) {\n  return nodes.filter(_ref2 => {\n    let {\n      declarationType\n    } = _ref2;\n    return declarationType === type;\n  }).map(_ref3 => {\n    let {\n      node\n    } = _ref3;\n    return node;\n  });\n}\n/**\n * Returns the name of the module imported or re-exported.\n * @param {ASTNode} node A node to get.\n * @returns {string} The name of the module, or empty string if no name.\n */\n\n\nfunction getModule(node) {\n  if (node && node.source && node.source.value) {\n    return node.source.value.trim();\n  }\n\n  return \"\";\n}\n/**\n * Checks if the (import|export) can be merged with at least one import or one export, and reports if so.\n * @param {RuleContext} context The ESLint rule context object.\n * @param {ASTNode} node A node to get.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {void} No return value.\n */\n\n\nfunction checkAndReport(context, node, modules, declarationType, includeExports) {\n  const module = getModule(node);\n\n  if (modules.has(module)) {\n    const previousNodes = modules.get(module);\n    const messagesIds = [];\n    const importNodes = getNodesByDeclarationType(previousNodes, \"import\");\n    let exportNodes;\n\n    if (includeExports) {\n      exportNodes = getNodesByDeclarationType(previousNodes, \"export\");\n    }\n\n    if (declarationType === \"import\") {\n      if (shouldReportImportExport(node, importNodes)) {\n        messagesIds.push(\"import\");\n      }\n\n      if (includeExports) {\n        if (shouldReportImportExport(node, exportNodes)) {\n          messagesIds.push(\"importAs\");\n        }\n      }\n    } else if (declarationType === \"export\") {\n      if (shouldReportImportExport(node, exportNodes)) {\n        messagesIds.push(\"export\");\n      }\n\n      if (shouldReportImportExport(node, importNodes)) {\n        messagesIds.push(\"exportAs\");\n      }\n    }\n\n    messagesIds.forEach(messageId => context.report({\n      node,\n      messageId,\n      data: {\n        module\n      }\n    }));\n  }\n}\n/**\n * @callback nodeCallback\n * @param {ASTNode} node A node to handle.\n */\n\n/**\n * Returns a function handling the (imports|exports) of a given file\n * @param {RuleContext} context The ESLint rule context object.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\n\n\nfunction handleImportsExports(context, modules, declarationType, includeExports) {\n  return function (node) {\n    const module = getModule(node);\n\n    if (module) {\n      checkAndReport(context, node, modules, declarationType, includeExports);\n      const currentNode = {\n        node,\n        declarationType\n      };\n      let nodes = [currentNode];\n\n      if (modules.has(module)) {\n        const previousNodes = modules.get(module);\n        nodes = [...previousNodes, currentNode];\n      }\n\n      modules.set(module, nodes);\n    }\n  };\n}\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate module imports\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-duplicate-imports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        includeExports: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      import: \"'{{module}}' import is duplicated.\",\n      importAs: \"'{{module}}' import is duplicated as export.\",\n      export: \"'{{module}}' export is duplicated.\",\n      exportAs: \"'{{module}}' export is duplicated as import.\"\n    }\n  },\n\n  create(context) {\n    const includeExports = (context.options[0] || {}).includeExports,\n          modules = new Map();\n    const handlers = {\n      ImportDeclaration: handleImportsExports(context, modules, \"import\", includeExports)\n    };\n\n    if (includeExports) {\n      handlers.ExportNamedDeclaration = handleImportsExports(context, modules, \"export\", includeExports);\n      handlers.ExportAllDeclaration = handleImportsExports(context, modules, \"export\", includeExports);\n    }\n\n    return handlers;\n  }\n\n};","map":{"version":3,"names":["NAMED_TYPES","NAMESPACE_TYPES","isImportExportSpecifier","importExportType","type","arrayToCheck","includes","getImportExportType","node","specifiers","length","nodeSpecifiers","index","findIndex","i","exported","isImportExportCanBeMerged","node1","node2","importExportType1","importExportType2","shouldReportImportExport","previousNodes","getNodesByDeclarationType","nodes","filter","declarationType","map","getModule","source","value","trim","checkAndReport","context","modules","includeExports","module","has","get","messagesIds","importNodes","exportNodes","push","forEach","messageId","report","data","handleImportsExports","currentNode","set","exports","meta","docs","description","category","recommended","url","schema","properties","default","additionalProperties","messages","import","importAs","export","exportAs","create","options","Map","handlers","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-duplicate-imports.js"],"sourcesContent":["/**\n * @fileoverview Restrict usage of duplicate imports.\n * @author Simen Bekkhus\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NAMED_TYPES = [\"ImportSpecifier\", \"ExportSpecifier\"];\nconst NAMESPACE_TYPES = [\n    \"ImportNamespaceSpecifier\",\n    \"ExportNamespaceSpecifier\"\n];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Check if an import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier).\n * @param {string} importExportType An import/export type to check.\n * @param {string} type Can be \"named\" or \"namespace\"\n * @returns {boolean} True if import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier) and false if it doesn't.\n */\nfunction isImportExportSpecifier(importExportType, type) {\n    const arrayToCheck = type === \"named\" ? NAMED_TYPES : NAMESPACE_TYPES;\n\n    return arrayToCheck.includes(importExportType);\n}\n\n/**\n * Return the type of (import|export).\n * @param {ASTNode} node A node to get.\n * @returns {string} The type of the (import|export).\n */\nfunction getImportExportType(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n        const nodeSpecifiers = node.specifiers;\n        const index = nodeSpecifiers.findIndex(\n            ({ type }) =>\n                isImportExportSpecifier(type, \"named\") ||\n                isImportExportSpecifier(type, \"namespace\")\n        );\n        const i = index > -1 ? index : 0;\n\n        return nodeSpecifiers[i].type;\n    }\n    if (node.type === \"ExportAllDeclaration\") {\n        if (node.exported) {\n            return \"ExportNamespaceSpecifier\";\n        }\n        return \"ExportAll\";\n    }\n    return \"SideEffectImport\";\n}\n\n/**\n * Returns a boolean indicates if two (import|export) can be merged\n * @param {ASTNode} node1 A node to check.\n * @param {ASTNode} node2 A node to check.\n * @returns {boolean} True if two (import|export) can be merged, false if they can't.\n */\nfunction isImportExportCanBeMerged(node1, node2) {\n    const importExportType1 = getImportExportType(node1);\n    const importExportType2 = getImportExportType(node2);\n\n    if (\n        (importExportType1 === \"ExportAll\" &&\n            importExportType2 !== \"ExportAll\" &&\n            importExportType2 !== \"SideEffectImport\") ||\n        (importExportType1 !== \"ExportAll\" &&\n            importExportType1 !== \"SideEffectImport\" &&\n            importExportType2 === \"ExportAll\")\n    ) {\n        return false;\n    }\n    if (\n        (isImportExportSpecifier(importExportType1, \"namespace\") &&\n            isImportExportSpecifier(importExportType2, \"named\")) ||\n        (isImportExportSpecifier(importExportType2, \"namespace\") &&\n            isImportExportSpecifier(importExportType1, \"named\"))\n    ) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Returns a boolean if we should report (import|export).\n * @param {ASTNode} node A node to be reported or not.\n * @param {[ASTNode]} previousNodes An array contains previous nodes of the module imported or exported.\n * @returns {boolean} True if the (import|export) should be reported.\n */\nfunction shouldReportImportExport(node, previousNodes) {\n    let i = 0;\n\n    while (i < previousNodes.length) {\n        if (isImportExportCanBeMerged(node, previousNodes[i])) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\n\n/**\n * Returns array contains only nodes with declarations types equal to type.\n * @param {[{node: ASTNode, declarationType: string}]} nodes An array contains objects, each object contains a node and a declaration type.\n * @param {string} type Declaration type.\n * @returns {[ASTNode]} An array contains only nodes with declarations types equal to type.\n */\nfunction getNodesByDeclarationType(nodes, type) {\n    return nodes\n        .filter(({ declarationType }) => declarationType === type)\n        .map(({ node }) => node);\n}\n\n/**\n * Returns the name of the module imported or re-exported.\n * @param {ASTNode} node A node to get.\n * @returns {string} The name of the module, or empty string if no name.\n */\nfunction getModule(node) {\n    if (node && node.source && node.source.value) {\n        return node.source.value.trim();\n    }\n    return \"\";\n}\n\n/**\n * Checks if the (import|export) can be merged with at least one import or one export, and reports if so.\n * @param {RuleContext} context The ESLint rule context object.\n * @param {ASTNode} node A node to get.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {void} No return value.\n */\nfunction checkAndReport(\n    context,\n    node,\n    modules,\n    declarationType,\n    includeExports\n) {\n    const module = getModule(node);\n\n    if (modules.has(module)) {\n        const previousNodes = modules.get(module);\n        const messagesIds = [];\n        const importNodes = getNodesByDeclarationType(previousNodes, \"import\");\n        let exportNodes;\n\n        if (includeExports) {\n            exportNodes = getNodesByDeclarationType(previousNodes, \"export\");\n        }\n        if (declarationType === \"import\") {\n            if (shouldReportImportExport(node, importNodes)) {\n                messagesIds.push(\"import\");\n            }\n            if (includeExports) {\n                if (shouldReportImportExport(node, exportNodes)) {\n                    messagesIds.push(\"importAs\");\n                }\n            }\n        } else if (declarationType === \"export\") {\n            if (shouldReportImportExport(node, exportNodes)) {\n                messagesIds.push(\"export\");\n            }\n            if (shouldReportImportExport(node, importNodes)) {\n                messagesIds.push(\"exportAs\");\n            }\n        }\n        messagesIds.forEach(messageId =>\n            context.report({\n                node,\n                messageId,\n                data: {\n                    module\n                }\n            }));\n    }\n}\n\n/**\n * @callback nodeCallback\n * @param {ASTNode} node A node to handle.\n */\n\n/**\n * Returns a function handling the (imports|exports) of a given file\n * @param {RuleContext} context The ESLint rule context object.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleImportsExports(\n    context,\n    modules,\n    declarationType,\n    includeExports\n) {\n    return function(node) {\n        const module = getModule(node);\n\n        if (module) {\n            checkAndReport(\n                context,\n                node,\n                modules,\n                declarationType,\n                includeExports\n            );\n            const currentNode = { node, declarationType };\n            let nodes = [currentNode];\n\n            if (modules.has(module)) {\n                const previousNodes = modules.get(module);\n\n                nodes = [...previousNodes, currentNode];\n            }\n            modules.set(module, nodes);\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate module imports\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-duplicate-imports\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    includeExports: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            import: \"'{{module}}' import is duplicated.\",\n            importAs: \"'{{module}}' import is duplicated as export.\",\n            export: \"'{{module}}' export is duplicated.\",\n            exportAs: \"'{{module}}' export is duplicated as import.\"\n        }\n    },\n\n    create(context) {\n        const includeExports = (context.options[0] || {}).includeExports,\n            modules = new Map();\n        const handlers = {\n            ImportDeclaration: handleImportsExports(\n                context,\n                modules,\n                \"import\",\n                includeExports\n            )\n        };\n\n        if (includeExports) {\n            handlers.ExportNamedDeclaration = handleImportsExports(\n                context,\n                modules,\n                \"export\",\n                includeExports\n            );\n            handlers.ExportAllDeclaration = handleImportsExports(\n                context,\n                modules,\n                \"export\",\n                includeExports\n            );\n        }\n        return handlers;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}