{"ast":null,"code":"/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      CodePathSegment = require(\"./code-path-segment\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n * @param {ForkContext} context An instance.\n * @param {number} begin The first index of the previous segments.\n * @param {number} end The last index of the previous segments.\n * @param {Function} create A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\n\n\nfunction makeSegments(context, begin, end, create) {\n  const list = context.segmentsList;\n  const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n  const normalizedEnd = end >= 0 ? end : list.length + end;\n  const segments = [];\n\n  for (let i = 0; i < context.count; ++i) {\n    const allPrevSegments = [];\n\n    for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n      allPrevSegments.push(list[j][i]);\n    }\n\n    segments.push(create(context.idGenerator.next(), allPrevSegments));\n  }\n\n  return segments;\n}\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n * @param {ForkContext} context An instance.\n * @param {CodePathSegment[]} segments Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\n\n\nfunction mergeExtraSegments(context, segments) {\n  let currentSegments = segments;\n\n  while (currentSegments.length > context.count) {\n    const merged = [];\n\n    for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n      merged.push(CodePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));\n    }\n\n    currentSegments = merged;\n  }\n\n  return currentSegments;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\n\n\nclass ForkContext {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\n   * @param {ForkContext|null} upper An upper fork context.\n   * @param {number} count A number of parallel segments.\n   */\n  constructor(idGenerator, upper, count) {\n    this.idGenerator = idGenerator;\n    this.upper = upper;\n    this.count = count;\n    this.segmentsList = [];\n  }\n  /**\n   * The head segments.\n   * @type {CodePathSegment[]}\n   */\n\n\n  get head() {\n    const list = this.segmentsList;\n    return list.length === 0 ? [] : list[list.length - 1];\n  }\n  /**\n   * A flag which shows empty.\n   * @type {boolean}\n   */\n\n\n  get empty() {\n    return this.segmentsList.length === 0;\n  }\n  /**\n   * A flag which shows reachable.\n   * @type {boolean}\n   */\n\n\n  get reachable() {\n    const segments = this.head;\n    return segments.length > 0 && segments.some(isReachable);\n  }\n  /**\n   * Creates new segments from this context.\n   * @param {number} begin The first index of previous segments.\n   * @param {number} end The last index of previous segments.\n   * @returns {CodePathSegment[]} New segments.\n   */\n\n\n  makeNext(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newNext);\n  }\n  /**\n   * Creates new segments from this context.\n   * The new segments is always unreachable.\n   * @param {number} begin The first index of previous segments.\n   * @param {number} end The last index of previous segments.\n   * @returns {CodePathSegment[]} New segments.\n   */\n\n\n  makeUnreachable(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n  }\n  /**\n   * Creates new segments from this context.\n   * The new segments don't have connections for previous segments.\n   * But these inherit the reachable flag from this context.\n   * @param {number} begin The first index of previous segments.\n   * @param {number} end The last index of previous segments.\n   * @returns {CodePathSegment[]} New segments.\n   */\n\n\n  makeDisconnected(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n  }\n  /**\n   * Adds segments into this context.\n   * The added segments become the head.\n   * @param {CodePathSegment[]} segments Segments to add.\n   * @returns {void}\n   */\n\n\n  add(segments) {\n    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.push(mergeExtraSegments(this, segments));\n  }\n  /**\n   * Replaces the head segments with given segments.\n   * The current head segments are removed.\n   * @param {CodePathSegment[]} segments Segments to add.\n   * @returns {void}\n   */\n\n\n  replaceHead(segments) {\n    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n  }\n  /**\n   * Adds all segments of a given fork context into this context.\n   * @param {ForkContext} context A fork context to add.\n   * @returns {void}\n   */\n\n\n  addAll(context) {\n    assert(context.count === this.count);\n    const source = context.segmentsList;\n\n    for (let i = 0; i < source.length; ++i) {\n      this.segmentsList.push(source[i]);\n    }\n  }\n  /**\n   * Clears all segments in this context.\n   * @returns {void}\n   */\n\n\n  clear() {\n    this.segmentsList = [];\n  }\n  /**\n   * Creates the root fork context.\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\n   * @returns {ForkContext} New fork context.\n   */\n\n\n  static newRoot(idGenerator) {\n    const context = new ForkContext(idGenerator, null, 1);\n    context.add([CodePathSegment.newRoot(idGenerator.next())]);\n    return context;\n  }\n  /**\n   * Creates an empty fork context preceded by a given context.\n   * @param {ForkContext} parentContext The parent fork context.\n   * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.\n   * @returns {ForkContext} New fork context.\n   */\n\n\n  static newEmpty(parentContext, forkLeavingPath) {\n    return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);\n  }\n\n}\n\nmodule.exports = ForkContext;","map":{"version":3,"names":["assert","require","CodePathSegment","isReachable","segment","reachable","makeSegments","context","begin","end","create","list","segmentsList","normalizedBegin","length","normalizedEnd","segments","i","count","allPrevSegments","j","push","idGenerator","next","mergeExtraSegments","currentSegments","merged","newNext","ForkContext","constructor","upper","head","empty","some","makeNext","makeUnreachable","newUnreachable","makeDisconnected","newDisconnected","add","replaceHead","splice","addAll","source","clear","newRoot","newEmpty","parentContext","forkLeavingPath","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/code-path-analysis/fork-context.js"],"sourcesContent":["/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n * @param {ForkContext} context An instance.\n * @param {number} begin The first index of the previous segments.\n * @param {number} end The last index of the previous segments.\n * @param {Function} create A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\nfunction makeSegments(context, begin, end, create) {\n    const list = context.segmentsList;\n\n    const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n    const normalizedEnd = end >= 0 ? end : list.length + end;\n\n    const segments = [];\n\n    for (let i = 0; i < context.count; ++i) {\n        const allPrevSegments = [];\n\n        for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n * @param {ForkContext} context An instance.\n * @param {CodePathSegment[]} segments Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    let currentSegments = segments;\n\n    while (currentSegments.length > context.count) {\n        const merged = [];\n\n        for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [currentSegments[i], currentSegments[i + length]]\n            ));\n        }\n        currentSegments = merged;\n    }\n    return currentSegments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\nclass ForkContext {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @param {ForkContext|null} upper An upper fork context.\n     * @param {number} count A number of parallel segments.\n     */\n    constructor(idGenerator, upper, count) {\n        this.idGenerator = idGenerator;\n        this.upper = upper;\n        this.count = count;\n        this.segmentsList = [];\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get head() {\n        const list = this.segmentsList;\n\n        return list.length === 0 ? [] : list[list.length - 1];\n    }\n\n    /**\n     * A flag which shows empty.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    }\n\n    /**\n     * A flag which shows reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        const segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeNext(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newNext);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments is always unreachable.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeUnreachable(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments don't have connections for previous segments.\n     * But these inherit the reachable flag from this context.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeDisconnected(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n    }\n\n    /**\n     * Adds segments into this context.\n     * The added segments become the head.\n     * @param {CodePathSegment[]} segments Segments to add.\n     * @returns {void}\n     */\n    add(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Replaces the head segments with given segments.\n     * The current head segments are removed.\n     * @param {CodePathSegment[]} segments Segments to add.\n     * @returns {void}\n     */\n    replaceHead(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     * @param {ForkContext} context A fork context to add.\n     * @returns {void}\n     */\n    addAll(context) {\n        assert(context.count === this.count);\n\n        const source = context.segmentsList;\n\n        for (let i = 0; i < source.length; ++i) {\n            this.segmentsList.push(source[i]);\n        }\n    }\n\n    /**\n     * Clears all segments in this context.\n     * @returns {void}\n     */\n    clear() {\n        this.segmentsList = [];\n    }\n\n    /**\n     * Creates the root fork context.\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @returns {ForkContext} New fork context.\n     */\n    static newRoot(idGenerator) {\n        const context = new ForkContext(idGenerator, null, 1);\n\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n        return context;\n    }\n\n    /**\n     * Creates an empty fork context preceded by a given context.\n     * @param {ForkContext} parentContext The parent fork context.\n     * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.\n     * @returns {ForkContext} New fork context.\n     */\n    static newEmpty(parentContext, forkLeavingPath) {\n        return new ForkContext(\n            parentContext.idGenerator,\n            parentContext,\n            (forkLeavingPath ? 2 : 1) * parentContext.count\n        );\n    }\n}\n\nmodule.exports = ForkContext;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}