{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\n\nconst react_1 = require(\"react\");\n\nconst utils_1 = require(\"./utils\");\n\nconst getSlideWidth = (count, wrapAround) => `${wrapAround ? 100 / (3 * count) : 100 / count}%`;\n\nconst getSlideStyles = (count, isCurrentSlide, isVisibleSlide, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight) => {\n  const width = getSlideWidth(count, wrapAround);\n  const visibleSlideOpacity = isVisibleSlide ? 1 : 0;\n  const animationSpeed = animation === 'fade' ? 200 : 500;\n  let height = 'auto';\n\n  if (adaptiveHeight) {\n    if (initializedAdaptiveHeight) {\n      // Once adaptiveHeight is initialized, the frame will size to the height\n      // of all the visible slides\n      height = '100%';\n    } else if (isVisibleSlide) {\n      // If the slide is visible but we're still measuring heights, have\n      // visible slides just take up their natural height\n      height = 'auto';\n    } else {\n      // If the slide is not visible and we're still measuring heights, the\n      // slide should have height 0 so it doesn't contribute to the measured\n      // height of the frame\n      height = '0';\n    }\n  }\n\n  return {\n    width,\n    flex: 1,\n    height,\n    padding: `0 ${cellSpacing ? cellSpacing / 2 : 0}px`,\n    transition: animation ? `${speed || animationSpeed}ms ease 0s` : undefined,\n    transform: animation === 'zoom' ? `scale(${isCurrentSlide && isVisibleSlide ? 1 : zoomScale || 0.85})` : undefined,\n    opacity: animation === 'fade' ? visibleSlideOpacity : 1\n  };\n};\n\nconst generateIndex = (index, count, typeOfSlide) => {\n  if (typeOfSlide === 'prev-cloned') {\n    return index - count;\n  }\n\n  if (typeOfSlide === 'next-cloned') {\n    return index + count;\n  }\n\n  return index;\n};\n\nconst Slide = _ref => {\n  let {\n    count,\n    children,\n    currentSlide,\n    index,\n    isCurrentSlide,\n    typeOfSlide,\n    wrapAround,\n    cellSpacing,\n    animation,\n    speed,\n    slidesToShow,\n    zoomScale,\n    cellAlign,\n    onVisibleSlideHeightChange,\n    adaptiveHeight,\n    initializedAdaptiveHeight\n  } = _ref;\n  const customIndex = wrapAround ? generateIndex(index, count, typeOfSlide) : index;\n  const isVisible = (0, utils_1.isSlideVisible)(currentSlide, customIndex, slidesToShow, cellAlign);\n  const slideRef = (0, react_1.useRef)(null);\n  const prevIsVisibleRef = (0, react_1.useRef)(false);\n  (0, react_1.useEffect)(() => {\n    var _a;\n\n    const node = slideRef.current;\n\n    if (node) {\n      const slideHeight = (_a = node.getBoundingClientRect()) === null || _a === void 0 ? void 0 : _a.height;\n\n      if (isVisible) {\n        node.removeAttribute('inert');\n      } else {\n        node.setAttribute('inert', 'true');\n      }\n\n      const prevIsVisible = prevIsVisibleRef.current;\n\n      if (isVisible && !prevIsVisible) {\n        onVisibleSlideHeightChange(customIndex, slideHeight);\n      } else if (!isVisible && prevIsVisible) {\n        onVisibleSlideHeightChange(customIndex, null);\n      }\n\n      prevIsVisibleRef.current = isVisible;\n    }\n  }, [adaptiveHeight, customIndex, isVisible, onVisibleSlideHeightChange, slidesToShow]);\n  const currentSlideClass = isCurrentSlide && isVisible ? ' slide-current' : '';\n  return (0, jsx_runtime_1.jsx)(\"div\", Object.assign({\n    ref: slideRef,\n    className: `slide${currentSlideClass}${typeOfSlide ? ` ${typeOfSlide}` : ''}${isVisible ? ' slide-visible' : ''}`,\n    style: getSlideStyles(count, isCurrentSlide, isVisible, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight)\n  }, {\n    children: children\n  }));\n};\n\nexports.default = Slide;","map":{"version":3,"sources":["../src/slide.tsx"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"./utils\");\nconst getSlideWidth = (count, wrapAround) => `${wrapAround ? 100 / (3 * count) : 100 / count}%`;\nconst getSlideStyles = (count, isCurrentSlide, isVisibleSlide, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight) => {\n    const width = getSlideWidth(count, wrapAround);\n    const visibleSlideOpacity = isVisibleSlide ? 1 : 0;\n    const animationSpeed = animation === 'fade' ? 200 : 500;\n    let height = 'auto';\n    if (adaptiveHeight) {\n        if (initializedAdaptiveHeight) {\n            // Once adaptiveHeight is initialized, the frame will size to the height\n            // of all the visible slides\n            height = '100%';\n        }\n        else if (isVisibleSlide) {\n            // If the slide is visible but we're still measuring heights, have\n            // visible slides just take up their natural height\n            height = 'auto';\n        }\n        else {\n            // If the slide is not visible and we're still measuring heights, the\n            // slide should have height 0 so it doesn't contribute to the measured\n            // height of the frame\n            height = '0';\n        }\n    }\n    return {\n        width,\n        flex: 1,\n        height,\n        padding: `0 ${cellSpacing ? cellSpacing / 2 : 0}px`,\n        transition: animation ? `${speed || animationSpeed}ms ease 0s` : undefined,\n        transform: animation === 'zoom'\n            ? `scale(${isCurrentSlide && isVisibleSlide ? 1 : zoomScale || 0.85})`\n            : undefined,\n        opacity: animation === 'fade' ? visibleSlideOpacity : 1,\n    };\n};\nconst generateIndex = (index, count, typeOfSlide) => {\n    if (typeOfSlide === 'prev-cloned') {\n        return index - count;\n    }\n    if (typeOfSlide === 'next-cloned') {\n        return index + count;\n    }\n    return index;\n};\nconst Slide = ({ count, children, currentSlide, index, isCurrentSlide, typeOfSlide, wrapAround, cellSpacing, animation, speed, slidesToShow, zoomScale, cellAlign, onVisibleSlideHeightChange, adaptiveHeight, initializedAdaptiveHeight, }) => {\n    const customIndex = wrapAround\n        ? generateIndex(index, count, typeOfSlide)\n        : index;\n    const isVisible = (0, utils_1.isSlideVisible)(currentSlide, customIndex, slidesToShow, cellAlign);\n    const slideRef = (0, react_1.useRef)(null);\n    const prevIsVisibleRef = (0, react_1.useRef)(false);\n    (0, react_1.useEffect)(() => {\n        var _a;\n        const node = slideRef.current;\n        if (node) {\n            const slideHeight = (_a = node.getBoundingClientRect()) === null || _a === void 0 ? void 0 : _a.height;\n            if (isVisible) {\n                node.removeAttribute('inert');\n            }\n            else {\n                node.setAttribute('inert', 'true');\n            }\n            const prevIsVisible = prevIsVisibleRef.current;\n            if (isVisible && !prevIsVisible) {\n                onVisibleSlideHeightChange(customIndex, slideHeight);\n            }\n            else if (!isVisible && prevIsVisible) {\n                onVisibleSlideHeightChange(customIndex, null);\n            }\n            prevIsVisibleRef.current = isVisible;\n        }\n    }, [\n        adaptiveHeight,\n        customIndex,\n        isVisible,\n        onVisibleSlideHeightChange,\n        slidesToShow,\n    ]);\n    const currentSlideClass = isCurrentSlide && isVisible ? ' slide-current' : '';\n    return ((0, jsx_runtime_1.jsx)(\"div\", Object.assign({ ref: slideRef, className: `slide${currentSlideClass}${typeOfSlide ? ` ${typeOfSlide}` : ''}${isVisible ? ' slide-visible' : ''}`, style: getSlideStyles(count, isCurrentSlide, isVisible, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight) }, { children: children })));\n};\nexports.default = Slide;\n"]},"metadata":{},"sourceType":"script"}