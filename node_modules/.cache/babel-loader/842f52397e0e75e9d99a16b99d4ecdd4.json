{"ast":null,"code":"/**\n * @fileoverview Rule to flag use constant conditions\n * @author Christian Schulz <http://rndm.de>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow constant expressions in conditions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-constant-condition\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        checkLoops: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Unexpected constant condition.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          checkLoops = options.checkLoops !== false,\n          loopSetStack = [];\n    let loopsInCurrentScope = new Set(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Returns literal's value converted to the Boolean type\n     * @param {ASTNode} node any `Literal` node\n     * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,\n     *  `null` when it cannot be determined.\n     */\n\n    function getBooleanValue(node) {\n      if (node.value === null) {\n        /*\n         * it might be a null literal or bigint/regex literal in unsupported environments .\n         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral\n         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral\n         */\n        if (node.raw === \"null\") {\n          return false;\n        } // regex is always truthy\n\n\n        if (typeof node.regex === \"object\") {\n          return true;\n        }\n\n        return null;\n      }\n\n      return !!node.value;\n    }\n    /**\n     * Checks if a branch node of LogicalExpression short circuits the whole condition\n     * @param {ASTNode} node The branch of main condition which needs to be checked\n     * @param {string} operator The operator of the main LogicalExpression.\n     * @returns {boolean} true when condition short circuits whole condition\n     */\n\n\n    function isLogicalIdentity(node, operator) {\n      switch (node.type) {\n        case \"Literal\":\n          return operator === \"||\" && getBooleanValue(node) === true || operator === \"&&\" && getBooleanValue(node) === false;\n\n        case \"UnaryExpression\":\n          return operator === \"&&\" && node.operator === \"void\";\n\n        case \"LogicalExpression\":\n          /*\n           * handles `a && false || b`\n           * `false` is an identity element of `&&` but not `||`\n           */\n          return operator === node.operator && (isLogicalIdentity(node.left, operator) || isLogicalIdentity(node.right, operator));\n\n        case \"AssignmentExpression\":\n          return [\"||=\", \"&&=\"].includes(node.operator) && operator === node.operator.slice(0, -1) && isLogicalIdentity(node.right, operator);\n        // no default\n      }\n\n      return false;\n    }\n    /**\n     * Checks if a node has a constant truthiness value.\n     * @param {ASTNode} node The AST node to check.\n     * @param {boolean} inBooleanPosition `false` if checking branch of a condition.\n     *  `true` in all other cases\n     * @returns {Bool} true when node's truthiness is constant\n     * @private\n     */\n\n\n    function isConstant(node, inBooleanPosition) {\n      // node.elements can return null values in the case of sparse arrays ex. [,]\n      if (!node) {\n        return true;\n      }\n\n      switch (node.type) {\n        case \"Literal\":\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n        case \"ObjectExpression\":\n          return true;\n\n        case \"TemplateLiteral\":\n          return inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length) || node.expressions.every(exp => isConstant(exp, inBooleanPosition));\n\n        case \"ArrayExpression\":\n          {\n            if (node.parent.type === \"BinaryExpression\" && node.parent.operator === \"+\") {\n              return node.elements.every(element => isConstant(element, false));\n            }\n\n            return true;\n          }\n\n        case \"UnaryExpression\":\n          if (node.operator === \"void\" || node.operator === \"typeof\" && inBooleanPosition) {\n            return true;\n          }\n\n          if (node.operator === \"!\") {\n            return isConstant(node.argument, true);\n          }\n\n          return isConstant(node.argument, false);\n\n        case \"BinaryExpression\":\n          return isConstant(node.left, false) && isConstant(node.right, false) && node.operator !== \"in\";\n\n        case \"LogicalExpression\":\n          {\n            const isLeftConstant = isConstant(node.left, inBooleanPosition);\n            const isRightConstant = isConstant(node.right, inBooleanPosition);\n            const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);\n            const isRightShortCircuit = inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator);\n            return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;\n          }\n\n        case \"AssignmentExpression\":\n          if (node.operator === \"=\") {\n            return isConstant(node.right, inBooleanPosition);\n          }\n\n          if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\n            return isLogicalIdentity(node.right, node.operator.slice(0, -1));\n          }\n\n          return false;\n\n        case \"SequenceExpression\":\n          return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n        // no default\n      }\n\n      return false;\n    }\n    /**\n     * Tracks when the given node contains a constant condition.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function trackConstantConditionLoop(node) {\n      if (node.test && isConstant(node.test, true)) {\n        loopsInCurrentScope.add(node);\n      }\n    }\n    /**\n     * Reports when the set contains the given constant condition node\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkConstantConditionLoopInSet(node) {\n      if (loopsInCurrentScope.has(node)) {\n        loopsInCurrentScope.delete(node);\n        context.report({\n          node: node.test,\n          messageId: \"unexpected\"\n        });\n      }\n    }\n    /**\n     * Reports when the given node contains a constant condition.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function reportIfConstant(node) {\n      if (node.test && isConstant(node.test, true)) {\n        context.report({\n          node: node.test,\n          messageId: \"unexpected\"\n        });\n      }\n    }\n    /**\n     * Stores current set of constant loops in loopSetStack temporarily\n     * and uses a new set to track constant loops\n     * @returns {void}\n     * @private\n     */\n\n\n    function enterFunction() {\n      loopSetStack.push(loopsInCurrentScope);\n      loopsInCurrentScope = new Set();\n    }\n    /**\n     * Reports when the set still contains stored constant conditions\n     * @returns {void}\n     * @private\n     */\n\n\n    function exitFunction() {\n      loopsInCurrentScope = loopSetStack.pop();\n    }\n    /**\n     * Checks node when checkLoops option is enabled\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkLoop(node) {\n      if (checkLoops) {\n        trackConstantConditionLoop(node);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      ConditionalExpression: reportIfConstant,\n      IfStatement: reportIfConstant,\n      WhileStatement: checkLoop,\n      \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n      DoWhileStatement: checkLoop,\n      \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n      ForStatement: checkLoop,\n      \"ForStatement > .test\": node => checkLoop(node.parent),\n      \"ForStatement:exit\": checkConstantConditionLoopInSet,\n      FunctionDeclaration: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      FunctionExpression: enterFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      YieldExpression: () => loopsInCurrentScope.clear()\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","checkLoops","default","additionalProperties","messages","unexpected","create","context","options","loopSetStack","loopsInCurrentScope","Set","getBooleanValue","node","value","raw","regex","isLogicalIdentity","operator","left","right","includes","slice","isConstant","inBooleanPosition","quasis","some","quasi","cooked","length","expressions","every","exp","parent","elements","element","argument","isLeftConstant","isRightConstant","isLeftShortCircuit","isRightShortCircuit","trackConstantConditionLoop","test","add","checkConstantConditionLoopInSet","has","delete","report","messageId","reportIfConstant","enterFunction","push","exitFunction","pop","checkLoop","ConditionalExpression","IfStatement","WhileStatement","DoWhileStatement","ForStatement","FunctionDeclaration","FunctionExpression","YieldExpression","clear"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-constant-condition.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use constant conditions\n * @author Christian Schulz <http://rndm.de>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow constant expressions in conditions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-constant-condition\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    checkLoops: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected constant condition.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            checkLoops = options.checkLoops !== false,\n            loopSetStack = [];\n\n        let loopsInCurrentScope = new Set();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Returns literal's value converted to the Boolean type\n         * @param {ASTNode} node any `Literal` node\n         * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,\n         *  `null` when it cannot be determined.\n         */\n        function getBooleanValue(node) {\n            if (node.value === null) {\n\n                /*\n                 * it might be a null literal or bigint/regex literal in unsupported environments .\n                 * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral\n                 * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral\n                 */\n\n                if (node.raw === \"null\") {\n                    return false;\n                }\n\n                // regex is always truthy\n                if (typeof node.regex === \"object\") {\n                    return true;\n                }\n\n                return null;\n            }\n\n            return !!node.value;\n        }\n\n        /**\n         * Checks if a branch node of LogicalExpression short circuits the whole condition\n         * @param {ASTNode} node The branch of main condition which needs to be checked\n         * @param {string} operator The operator of the main LogicalExpression.\n         * @returns {boolean} true when condition short circuits whole condition\n         */\n        function isLogicalIdentity(node, operator) {\n            switch (node.type) {\n                case \"Literal\":\n                    return (operator === \"||\" && getBooleanValue(node) === true) ||\n                           (operator === \"&&\" && getBooleanValue(node) === false);\n\n                case \"UnaryExpression\":\n                    return (operator === \"&&\" && node.operator === \"void\");\n\n                case \"LogicalExpression\":\n\n                    /*\n                     * handles `a && false || b`\n                     * `false` is an identity element of `&&` but not `||`\n                     */\n                    return operator === node.operator &&\n                             (\n                                 isLogicalIdentity(node.left, operator) ||\n                                 isLogicalIdentity(node.right, operator)\n                             );\n\n                case \"AssignmentExpression\":\n                    return [\"||=\", \"&&=\"].includes(node.operator) &&\n                        operator === node.operator.slice(0, -1) &&\n                        isLogicalIdentity(node.right, operator);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node has a constant truthiness value.\n         * @param {ASTNode} node The AST node to check.\n         * @param {boolean} inBooleanPosition `false` if checking branch of a condition.\n         *  `true` in all other cases\n         * @returns {Bool} true when node's truthiness is constant\n         * @private\n         */\n        function isConstant(node, inBooleanPosition) {\n\n            // node.elements can return null values in the case of sparse arrays ex. [,]\n            if (!node) {\n                return true;\n            }\n            switch (node.type) {\n                case \"Literal\":\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                case \"ObjectExpression\":\n                    return true;\n                case \"TemplateLiteral\":\n                    return (inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length)) ||\n                        node.expressions.every(exp => isConstant(exp, inBooleanPosition));\n\n                case \"ArrayExpression\": {\n                    if (node.parent.type === \"BinaryExpression\" && node.parent.operator === \"+\") {\n                        return node.elements.every(element => isConstant(element, false));\n                    }\n                    return true;\n                }\n\n                case \"UnaryExpression\":\n                    if (\n                        node.operator === \"void\" ||\n                        node.operator === \"typeof\" && inBooleanPosition\n                    ) {\n                        return true;\n                    }\n\n                    if (node.operator === \"!\") {\n                        return isConstant(node.argument, true);\n                    }\n\n                    return isConstant(node.argument, false);\n\n                case \"BinaryExpression\":\n                    return isConstant(node.left, false) &&\n                            isConstant(node.right, false) &&\n                            node.operator !== \"in\";\n\n                case \"LogicalExpression\": {\n                    const isLeftConstant = isConstant(node.left, inBooleanPosition);\n                    const isRightConstant = isConstant(node.right, inBooleanPosition);\n                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));\n                    const isRightShortCircuit = (inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator));\n\n                    return (isLeftConstant && isRightConstant) ||\n                        isLeftShortCircuit ||\n                        isRightShortCircuit;\n                }\n\n                case \"AssignmentExpression\":\n                    if (node.operator === \"=\") {\n                        return isConstant(node.right, inBooleanPosition);\n                    }\n\n                    if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\n                        return isLogicalIdentity(node.right, node.operator.slice(0, -1));\n                    }\n\n                    return false;\n\n                case \"SequenceExpression\":\n                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Tracks when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function trackConstantConditionLoop(node) {\n            if (node.test && isConstant(node.test, true)) {\n                loopsInCurrentScope.add(node);\n            }\n        }\n\n        /**\n         * Reports when the set contains the given constant condition node\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkConstantConditionLoopInSet(node) {\n            if (loopsInCurrentScope.has(node)) {\n                loopsInCurrentScope.delete(node);\n                context.report({ node: node.test, messageId: \"unexpected\" });\n            }\n        }\n\n        /**\n         * Reports when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function reportIfConstant(node) {\n            if (node.test && isConstant(node.test, true)) {\n                context.report({ node: node.test, messageId: \"unexpected\" });\n            }\n        }\n\n        /**\n         * Stores current set of constant loops in loopSetStack temporarily\n         * and uses a new set to track constant loops\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            loopSetStack.push(loopsInCurrentScope);\n            loopsInCurrentScope = new Set();\n        }\n\n        /**\n         * Reports when the set still contains stored constant conditions\n         * @returns {void}\n         * @private\n         */\n        function exitFunction() {\n            loopsInCurrentScope = loopSetStack.pop();\n        }\n\n        /**\n         * Checks node when checkLoops option is enabled\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLoop(node) {\n            if (checkLoops) {\n                trackConstantConditionLoop(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression: reportIfConstant,\n            IfStatement: reportIfConstant,\n            WhileStatement: checkLoop,\n            \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n            DoWhileStatement: checkLoop,\n            \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n            ForStatement: checkLoop,\n            \"ForStatement > .test\": node => checkLoop(node.parent),\n            \"ForStatement:exit\": checkConstantConditionLoopInSet,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            YieldExpression: () => loopsInCurrentScope.clear()\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}