{"ast":null,"code":"/**\n * @fileoverview Rule to flag updates of imported bindings.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst {\n  findVariable\n} = require(\"eslint-utils\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst WellKnownMutationFunctions = {\n  Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,\n  Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u\n};\n/**\n * Check if a given node is LHS of an assignment node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is LHS.\n */\n\nfunction isAssignmentLeft(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"AssignmentExpression\" && parent.left === node || // Destructuring assignments\n  parent.type === \"ArrayPattern\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"RestElement\" || parent.type === \"AssignmentPattern\" && parent.left === node;\n}\n/**\n * Check if a given node is the operand of mutation unary operator.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\n */\n\n\nfunction isOperandOfMutationUnaryOperator(node) {\n  const argumentNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n  const {\n    parent\n  } = argumentNode;\n  return parent.type === \"UpdateExpression\" && parent.argument === argumentNode || parent.type === \"UnaryExpression\" && parent.operator === \"delete\" && parent.argument === argumentNode;\n}\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the iteration variable.\n */\n\n\nfunction isIterationVariable(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"ForInStatement\" && parent.left === node || parent.type === \"ForOfStatement\" && parent.left === node;\n}\n/**\n * Check if a given node is at the first argument of a well-known mutation function.\n * - `Object.assign`\n * - `Object.defineProperty`\n * - `Object.defineProperties`\n * - `Object.freeze`\n * - `Object.setPrototypeOf`\n * - `Reflect.defineProperty`\n * - `Reflect.deleteProperty`\n * - `Reflect.set`\n * - `Reflect.setPrototypeOf`\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the node is at the first argument of a well-known mutation function.\n */\n\n\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n  const {\n    parent\n  } = node;\n\n  if (parent.type !== \"CallExpression\" || parent.arguments[0] !== node) {\n    return false;\n  }\n\n  const callee = astUtils.skipChainExpression(parent.callee);\n\n  if (!astUtils.isSpecificMemberAccess(callee, \"Object\", WellKnownMutationFunctions.Object) && !astUtils.isSpecificMemberAccess(callee, \"Reflect\", WellKnownMutationFunctions.Reflect)) {\n    return false;\n  }\n\n  const variable = findVariable(scope, callee.object);\n  return variable !== null && variable.scope.type === \"global\";\n}\n/**\n * Check if the identifier node is placed at to update members.\n * @param {ASTNode} id The Identifier node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the member of `id` was updated.\n */\n\n\nfunction isMemberWrite(id, scope) {\n  const {\n    parent\n  } = id;\n  return parent.type === \"MemberExpression\" && parent.object === id && (isAssignmentLeft(parent) || isOperandOfMutationUnaryOperator(parent) || isIterationVariable(parent)) || isArgumentOfWellKnownMutationFunction(id, scope);\n}\n/**\n * Get the mutation node.\n * @param {ASTNode} id The Identifier node to get.\n * @returns {ASTNode} The mutation node.\n */\n\n\nfunction getWriteNode(id) {\n  let node = id.parent;\n\n  while (node && node.type !== \"AssignmentExpression\" && node.type !== \"UpdateExpression\" && node.type !== \"UnaryExpression\" && node.type !== \"CallExpression\" && node.type !== \"ForInStatement\" && node.type !== \"ForOfStatement\") {\n    node = node.parent;\n  }\n\n  return node || id;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assigning to imported bindings\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-import-assign\"\n    },\n    schema: [],\n    messages: {\n      readonly: \"'{{name}}' is read-only.\",\n      readonlyMember: \"The members of '{{name}}' are read-only.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ImportDeclaration(node) {\n        const scope = context.getScope();\n\n        for (const variable of context.getDeclaredVariables(node)) {\n          const shouldCheckMembers = variable.defs.some(d => d.node.type === \"ImportNamespaceSpecifier\");\n          let prevIdNode = null;\n\n          for (const reference of variable.references) {\n            const idNode = reference.identifier;\n            /*\n             * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\n             * references for the same identifier. This should skip\n             * the one of the two in order to prevent redundant reports.\n             */\n\n            if (idNode === prevIdNode) {\n              continue;\n            }\n\n            prevIdNode = idNode;\n\n            if (reference.isWrite()) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonly\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonlyMember\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["findVariable","require","astUtils","WellKnownMutationFunctions","Object","Reflect","isAssignmentLeft","node","parent","type","left","value","isOperandOfMutationUnaryOperator","argumentNode","argument","operator","isIterationVariable","isArgumentOfWellKnownMutationFunction","scope","arguments","callee","skipChainExpression","isSpecificMemberAccess","variable","object","isMemberWrite","id","getWriteNode","module","exports","meta","docs","description","category","recommended","url","schema","messages","readonly","readonlyMember","create","context","ImportDeclaration","getScope","getDeclaredVariables","shouldCheckMembers","defs","some","d","prevIdNode","reference","references","idNode","identifier","isWrite","report","messageId","data","name"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-import-assign.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag updates of imported bindings.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst { findVariable } = require(\"eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst WellKnownMutationFunctions = {\n    Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,\n    Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u\n};\n\n/**\n * Check if a given node is LHS of an assignment node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is LHS.\n */\nfunction isAssignmentLeft(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // Destructuring assignments\n        parent.type === \"ArrayPattern\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is the operand of mutation unary operator.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\n */\nfunction isOperandOfMutationUnaryOperator(node) {\n    const argumentNode = node.parent.type === \"ChainExpression\"\n        ? node.parent\n        : node;\n    const { parent } = argumentNode;\n\n    return (\n        (\n            parent.type === \"UpdateExpression\" &&\n            parent.argument === argumentNode\n        ) ||\n        (\n            parent.type === \"UnaryExpression\" &&\n            parent.operator === \"delete\" &&\n            parent.argument === argumentNode\n        )\n    );\n}\n\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the iteration variable.\n */\nfunction isIterationVariable(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"ForInStatement\" &&\n            parent.left === node\n        ) ||\n        (\n            parent.type === \"ForOfStatement\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is at the first argument of a well-known mutation function.\n * - `Object.assign`\n * - `Object.defineProperty`\n * - `Object.defineProperties`\n * - `Object.freeze`\n * - `Object.setPrototypeOf`\n * - `Reflect.defineProperty`\n * - `Reflect.deleteProperty`\n * - `Reflect.set`\n * - `Reflect.setPrototypeOf`\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the node is at the first argument of a well-known mutation function.\n */\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n    const { parent } = node;\n\n    if (parent.type !== \"CallExpression\" || parent.arguments[0] !== node) {\n        return false;\n    }\n    const callee = astUtils.skipChainExpression(parent.callee);\n\n    if (\n        !astUtils.isSpecificMemberAccess(callee, \"Object\", WellKnownMutationFunctions.Object) &&\n        !astUtils.isSpecificMemberAccess(callee, \"Reflect\", WellKnownMutationFunctions.Reflect)\n    ) {\n        return false;\n    }\n    const variable = findVariable(scope, callee.object);\n\n    return variable !== null && variable.scope.type === \"global\";\n}\n\n/**\n * Check if the identifier node is placed at to update members.\n * @param {ASTNode} id The Identifier node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the member of `id` was updated.\n */\nfunction isMemberWrite(id, scope) {\n    const { parent } = id;\n\n    return (\n        (\n            parent.type === \"MemberExpression\" &&\n            parent.object === id &&\n            (\n                isAssignmentLeft(parent) ||\n                isOperandOfMutationUnaryOperator(parent) ||\n                isIterationVariable(parent)\n            )\n        ) ||\n        isArgumentOfWellKnownMutationFunction(id, scope)\n    );\n}\n\n/**\n * Get the mutation node.\n * @param {ASTNode} id The Identifier node to get.\n * @returns {ASTNode} The mutation node.\n */\nfunction getWriteNode(id) {\n    let node = id.parent;\n\n    while (\n        node &&\n        node.type !== \"AssignmentExpression\" &&\n        node.type !== \"UpdateExpression\" &&\n        node.type !== \"UnaryExpression\" &&\n        node.type !== \"CallExpression\" &&\n        node.type !== \"ForInStatement\" &&\n        node.type !== \"ForOfStatement\"\n    ) {\n        node = node.parent;\n    }\n\n    return node || id;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assigning to imported bindings\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-import-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            readonly: \"'{{name}}' is read-only.\",\n            readonlyMember: \"The members of '{{name}}' are read-only.\"\n        }\n    },\n\n    create(context) {\n        return {\n            ImportDeclaration(node) {\n                const scope = context.getScope();\n\n                for (const variable of context.getDeclaredVariables(node)) {\n                    const shouldCheckMembers = variable.defs.some(\n                        d => d.node.type === \"ImportNamespaceSpecifier\"\n                    );\n                    let prevIdNode = null;\n\n                    for (const reference of variable.references) {\n                        const idNode = reference.identifier;\n\n                        /*\n                         * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\n                         * references for the same identifier. This should skip\n                         * the one of the two in order to prevent redundant reports.\n                         */\n                        if (idNode === prevIdNode) {\n                            continue;\n                        }\n                        prevIdNode = idNode;\n\n                        if (reference.isWrite()) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonly\",\n                                data: { name: idNode.name }\n                            });\n                        } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonlyMember\",\n                                data: { name: idNode.name }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}