{"ast":null,"code":"\"use strict\";\n/* eslint-disable no-param-reassign*/\n\nconst TokenTranslator = require(\"./token-translator\");\n\nconst {\n  normalizeOptions\n} = require(\"./options\");\n\nconst STATE = Symbol(\"espree's internal state\");\nconst ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n/**\n * Converts an Acorn comment to a Esprima comment.\n * @param {boolean} block True if it's a block comment, false if not.\n * @param {string} text The text of the comment.\n * @param {int} start The index at which the comment starts.\n * @param {int} end The index at which the comment ends.\n * @param {Location} startLoc The location at which the comment starts.\n * @param {Location} endLoc The location at which the comment ends.\n * @returns {Object} The comment object.\n * @private\n */\n\nfunction convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {\n  const comment = {\n    type: block ? \"Block\" : \"Line\",\n    value: text\n  };\n\n  if (typeof start === \"number\") {\n    comment.start = start;\n    comment.end = end;\n    comment.range = [start, end];\n  }\n\n  if (typeof startLoc === \"object\") {\n    comment.loc = {\n      start: startLoc,\n      end: endLoc\n    };\n  }\n\n  return comment;\n}\n\nmodule.exports = () => Parser => {\n  const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n  if (Parser.acornJsx) {\n    Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n  }\n\n  return class Espree extends Parser {\n    constructor(opts, code) {\n      if (typeof opts !== \"object\" || opts === null) {\n        opts = {};\n      }\n\n      if (typeof code !== \"string\" && !(code instanceof String)) {\n        code = String(code);\n      }\n\n      const options = normalizeOptions(opts);\n      const ecmaFeatures = options.ecmaFeatures || {};\n      const tokenTranslator = options.tokens === true ? new TokenTranslator(tokTypes, code) : null; // Initialize acorn parser.\n\n      super({\n        // TODO: use {...options} when spread is supported(Node.js >= 8.3.0).\n        ecmaVersion: options.ecmaVersion,\n        sourceType: options.sourceType,\n        ranges: options.ranges,\n        locations: options.locations,\n        // Truthy value is true for backward compatibility.\n        allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),\n        // Collect tokens\n        onToken: token => {\n          if (tokenTranslator) {\n            // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n            tokenTranslator.onToken(token, this[STATE]);\n          }\n\n          if (token.type !== tokTypes.eof) {\n            this[STATE].lastToken = token;\n          }\n        },\n        // Collect comments\n        onComment: (block, text, start, end, startLoc, endLoc) => {\n          if (this[STATE].comments) {\n            const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);\n            this[STATE].comments.push(comment);\n          }\n        }\n      }, code); // Initialize internal state.\n\n      this[STATE] = {\n        tokens: tokenTranslator ? [] : null,\n        comments: options.comment === true ? [] : null,\n        impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,\n        ecmaVersion: this.options.ecmaVersion,\n        jsxAttrValueToken: false,\n        lastToken: null\n      };\n    }\n\n    tokenize() {\n      do {\n        this.next();\n      } while (this.type !== tokTypes.eof); // Consume the final eof token\n\n\n      this.next();\n      const extra = this[STATE];\n      const tokens = extra.tokens;\n\n      if (extra.comments) {\n        tokens.comments = extra.comments;\n      }\n\n      return tokens;\n    }\n\n    finishNode() {\n      const result = super.finishNode(...arguments);\n      return this[ESPRIMA_FINISH_NODE](result);\n    }\n\n    finishNodeAt() {\n      const result = super.finishNodeAt(...arguments);\n      return this[ESPRIMA_FINISH_NODE](result);\n    }\n\n    parse() {\n      const extra = this[STATE];\n      const program = super.parse();\n      program.sourceType = this.options.sourceType;\n\n      if (extra.comments) {\n        program.comments = extra.comments;\n      }\n\n      if (extra.tokens) {\n        program.tokens = extra.tokens;\n      }\n      /*\n       * Adjust opening and closing position of program to match Esprima.\n       * Acorn always starts programs at range 0 whereas Esprima starts at the\n       * first AST node's start (the only real difference is when there's leading\n       * whitespace or leading comments). Acorn also counts trailing whitespace\n       * as part of the program whereas Esprima only counts up to the last token.\n       */\n\n\n      if (program.range) {\n        program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];\n        program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];\n      }\n\n      if (program.loc) {\n        program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;\n        program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;\n      }\n\n      return program;\n    }\n\n    parseTopLevel(node) {\n      if (this[STATE].impliedStrict) {\n        this.strict = true;\n      }\n\n      return super.parseTopLevel(node);\n    }\n    /**\n     * Overwrites the default raise method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @param {string} message The error message.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n\n\n    raise(pos, message) {\n      const loc = Parser.acorn.getLineInfo(this.input, pos);\n      const err = new SyntaxError(message);\n      err.index = pos;\n      err.lineNumber = loc.line;\n      err.column = loc.column + 1; // acorn uses 0-based columns\n\n      throw err;\n    }\n    /**\n     * Overwrites the default raise method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @param {string} message The error message.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n\n\n    raiseRecoverable(pos, message) {\n      this.raise(pos, message);\n    }\n    /**\n     * Overwrites the default unexpected method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n\n\n    unexpected(pos) {\n      let message = \"Unexpected token\";\n\n      if (pos !== null && pos !== void 0) {\n        this.pos = pos;\n\n        if (this.options.locations) {\n          while (this.pos < this.lineStart) {\n            this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n            --this.curLine;\n          }\n        }\n\n        this.nextToken();\n      }\n\n      if (this.end > this.start) {\n        message += ` ${this.input.slice(this.start, this.end)}`;\n      }\n\n      this.raise(this.start, message);\n    }\n    /*\n    * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n    * uses regular tt.string without any distinction between this and regular JS\n    * strings. As such, we intercept an attempt to read a JSX string and set a flag\n    * on extra so that when tokens are converted, the next token will be switched\n    * to JSXText via onToken.\n    */\n\n\n    jsx_readString(quote) {\n      // eslint-disable-line camelcase\n      const result = super.jsx_readString(quote);\n\n      if (this.type === tokTypes.string) {\n        this[STATE].jsxAttrValueToken = true;\n      }\n\n      return result;\n    }\n    /**\n     * Performs last-minute Esprima-specific compatibility checks and fixes.\n     * @param {ASTNode} result The node to check.\n     * @returns {ASTNode} The finished node.\n     */\n\n\n    [ESPRIMA_FINISH_NODE](result) {\n      // Acorn doesn't count the opening and closing backticks as part of templates\n      // so we have to adjust ranges/locations appropriately.\n      if (result.type === \"TemplateElement\") {\n        // additional adjustment needed if ${ is the last token\n        const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === \"${\";\n\n        if (result.range) {\n          result.range[0]--;\n          result.range[1] += terminalDollarBraceL ? 2 : 1;\n        }\n\n        if (result.loc) {\n          result.loc.start.column--;\n          result.loc.end.column += terminalDollarBraceL ? 2 : 1;\n        }\n      }\n\n      if (result.type.indexOf(\"Function\") > -1 && !result.generator) {\n        result.generator = false;\n      }\n\n      return result;\n    }\n\n  };\n};","map":{"version":3,"names":["TokenTranslator","require","normalizeOptions","STATE","Symbol","ESPRIMA_FINISH_NODE","convertAcornCommentToEsprimaComment","block","text","start","end","startLoc","endLoc","comment","type","value","range","loc","module","exports","Parser","tokTypes","Object","assign","acorn","acornJsx","Espree","constructor","opts","code","String","options","ecmaFeatures","tokenTranslator","tokens","ecmaVersion","sourceType","ranges","locations","allowReturnOutsideFunction","Boolean","globalReturn","onToken","token","eof","lastToken","onComment","comments","push","impliedStrict","jsxAttrValueToken","tokenize","next","extra","finishNode","result","finishNodeAt","parse","program","body","length","parseTopLevel","node","strict","raise","pos","message","getLineInfo","input","err","SyntaxError","index","lineNumber","line","column","raiseRecoverable","unexpected","lineStart","lastIndexOf","curLine","nextToken","slice","jsx_readString","quote","string","terminalDollarBraceL","indexOf","generator"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/espree/lib/espree.js"],"sourcesContent":["\"use strict\";\n\n/* eslint-disable no-param-reassign*/\nconst TokenTranslator = require(\"./token-translator\");\nconst { normalizeOptions } = require(\"./options\");\n\nconst STATE = Symbol(\"espree's internal state\");\nconst ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n\n\n/**\n * Converts an Acorn comment to a Esprima comment.\n * @param {boolean} block True if it's a block comment, false if not.\n * @param {string} text The text of the comment.\n * @param {int} start The index at which the comment starts.\n * @param {int} end The index at which the comment ends.\n * @param {Location} startLoc The location at which the comment starts.\n * @param {Location} endLoc The location at which the comment ends.\n * @returns {Object} The comment object.\n * @private\n */\nfunction convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text\n    };\n\n    if (typeof start === \"number\") {\n        comment.start = start;\n        comment.end = end;\n        comment.range = [start, end];\n    }\n\n    if (typeof startLoc === \"object\") {\n        comment.loc = {\n            start: startLoc,\n            end: endLoc\n        };\n    }\n\n    return comment;\n}\n\nmodule.exports = () => Parser => {\n    const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n    if (Parser.acornJsx) {\n        Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n    }\n\n    return class Espree extends Parser {\n        constructor(opts, code) {\n            if (typeof opts !== \"object\" || opts === null) {\n                opts = {};\n            }\n            if (typeof code !== \"string\" && !(code instanceof String)) {\n                code = String(code);\n            }\n\n            const options = normalizeOptions(opts);\n            const ecmaFeatures = options.ecmaFeatures || {};\n            const tokenTranslator =\n                options.tokens === true\n                    ? new TokenTranslator(tokTypes, code)\n                    : null;\n\n            // Initialize acorn parser.\n            super({\n\n                // TODO: use {...options} when spread is supported(Node.js >= 8.3.0).\n                ecmaVersion: options.ecmaVersion,\n                sourceType: options.sourceType,\n                ranges: options.ranges,\n                locations: options.locations,\n\n                // Truthy value is true for backward compatibility.\n                allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),\n\n                // Collect tokens\n                onToken: token => {\n                    if (tokenTranslator) {\n\n                        // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n                        tokenTranslator.onToken(token, this[STATE]);\n                    }\n                    if (token.type !== tokTypes.eof) {\n                        this[STATE].lastToken = token;\n                    }\n                },\n\n                // Collect comments\n                onComment: (block, text, start, end, startLoc, endLoc) => {\n                    if (this[STATE].comments) {\n                        const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);\n\n                        this[STATE].comments.push(comment);\n                    }\n                }\n            }, code);\n\n            // Initialize internal state.\n            this[STATE] = {\n                tokens: tokenTranslator ? [] : null,\n                comments: options.comment === true ? [] : null,\n                impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,\n                ecmaVersion: this.options.ecmaVersion,\n                jsxAttrValueToken: false,\n                lastToken: null\n            };\n        }\n\n        tokenize() {\n            do {\n                this.next();\n            } while (this.type !== tokTypes.eof);\n\n            // Consume the final eof token\n            this.next();\n\n            const extra = this[STATE];\n            const tokens = extra.tokens;\n\n            if (extra.comments) {\n                tokens.comments = extra.comments;\n            }\n\n            return tokens;\n        }\n\n        finishNode(...args) {\n            const result = super.finishNode(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        finishNodeAt(...args) {\n            const result = super.finishNodeAt(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        parse() {\n            const extra = this[STATE];\n            const program = super.parse();\n\n            program.sourceType = this.options.sourceType;\n\n            if (extra.comments) {\n                program.comments = extra.comments;\n            }\n            if (extra.tokens) {\n                program.tokens = extra.tokens;\n            }\n\n            /*\n             * Adjust opening and closing position of program to match Esprima.\n             * Acorn always starts programs at range 0 whereas Esprima starts at the\n             * first AST node's start (the only real difference is when there's leading\n             * whitespace or leading comments). Acorn also counts trailing whitespace\n             * as part of the program whereas Esprima only counts up to the last token.\n             */\n            if (program.range) {\n                program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];\n                program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];\n            }\n            if (program.loc) {\n                program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;\n                program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;\n            }\n\n            return program;\n        }\n\n        parseTopLevel(node) {\n            if (this[STATE].impliedStrict) {\n                this.strict = true;\n            }\n            return super.parseTopLevel(node);\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raise(pos, message) {\n            const loc = Parser.acorn.getLineInfo(this.input, pos);\n            const err = new SyntaxError(message);\n\n            err.index = pos;\n            err.lineNumber = loc.line;\n            err.column = loc.column + 1; // acorn uses 0-based columns\n            throw err;\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raiseRecoverable(pos, message) {\n            this.raise(pos, message);\n        }\n\n        /**\n         * Overwrites the default unexpected method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        unexpected(pos) {\n            let message = \"Unexpected token\";\n\n            if (pos !== null && pos !== void 0) {\n                this.pos = pos;\n\n                if (this.options.locations) {\n                    while (this.pos < this.lineStart) {\n                        this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n                        --this.curLine;\n                    }\n                }\n\n                this.nextToken();\n            }\n\n            if (this.end > this.start) {\n                message += ` ${this.input.slice(this.start, this.end)}`;\n            }\n\n            this.raise(this.start, message);\n        }\n\n        /*\n        * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n        * uses regular tt.string without any distinction between this and regular JS\n        * strings. As such, we intercept an attempt to read a JSX string and set a flag\n        * on extra so that when tokens are converted, the next token will be switched\n        * to JSXText via onToken.\n        */\n        jsx_readString(quote) { // eslint-disable-line camelcase\n            const result = super.jsx_readString(quote);\n\n            if (this.type === tokTypes.string) {\n                this[STATE].jsxAttrValueToken = true;\n            }\n            return result;\n        }\n\n        /**\n         * Performs last-minute Esprima-specific compatibility checks and fixes.\n         * @param {ASTNode} result The node to check.\n         * @returns {ASTNode} The finished node.\n         */\n        [ESPRIMA_FINISH_NODE](result) {\n\n            // Acorn doesn't count the opening and closing backticks as part of templates\n            // so we have to adjust ranges/locations appropriately.\n            if (result.type === \"TemplateElement\") {\n\n                // additional adjustment needed if ${ is the last token\n                const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === \"${\";\n\n                if (result.range) {\n                    result.range[0]--;\n                    result.range[1] += (terminalDollarBraceL ? 2 : 1);\n                }\n\n                if (result.loc) {\n                    result.loc.start.column--;\n                    result.loc.end.column += (terminalDollarBraceL ? 2 : 1);\n                }\n            }\n\n            if (result.type.indexOf(\"Function\") > -1 && !result.generator) {\n                result.generator = false;\n            }\n\n            return result;\n        }\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}