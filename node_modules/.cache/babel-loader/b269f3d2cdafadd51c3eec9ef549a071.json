{"ast":null,"code":"/**\n * @fileoverview Rule to enforce spacing before and after keywords.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n      keywords = require(\"./utils/keywords\"); //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\nconst PREV_TOKEN = /^[)\\]}>]$/u;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/u;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/u;\nconst NEXT_TOKEN_M = /^[{*]$/u;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/u;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/u;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/u;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]); // check duplications.\n\n(function () {\n  KEYS.sort();\n\n  for (let i = 1; i < KEYS.length; ++i) {\n    if (KEYS[i] === KEYS[i - 1]) {\n      throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n    }\n  }\n})(); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\n */\n\n\nfunction isOpenParenOfTemplate(token) {\n  return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n/**\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\n */\n\n\nfunction isCloseParenOfTemplate(token) {\n  return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after keywords\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/keyword-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: true\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        },\n        overrides: {\n          type: \"object\",\n          properties: KEYS.reduce((retv, key) => {\n            retv[key] = {\n              type: \"object\",\n              properties: {\n                before: {\n                  type: \"boolean\"\n                },\n                after: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            };\n            return retv;\n          }, {}),\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedBefore: \"Expected space(s) before \\\"{{value}}\\\".\",\n      expectedAfter: \"Expected space(s) after \\\"{{value}}\\\".\",\n      unexpectedBefore: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n      unexpectedAfter: \"Unexpected space(s) after \\\"{{value}}\\\".\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Reports a given token if there are not space(s) before the token.\n     * @param {Token} token A token to report.\n     * @param {RegExp} pattern A pattern of the previous token to check.\n     * @returns {void}\n     */\n\n    function expectSpaceBefore(token, pattern) {\n      const prevToken = sourceCode.getTokenBefore(token);\n\n      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {\n        context.report({\n          loc: token.loc,\n          messageId: \"expectedBefore\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.insertTextBefore(token, \" \");\n          }\n\n        });\n      }\n    }\n    /**\n     * Reports a given token if there are space(s) before the token.\n     * @param {Token} token A token to report.\n     * @param {RegExp} pattern A pattern of the previous token to check.\n     * @returns {void}\n     */\n\n\n    function unexpectSpaceBefore(token, pattern) {\n      const prevToken = sourceCode.getTokenBefore(token);\n\n      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {\n        context.report({\n          loc: {\n            start: prevToken.loc.end,\n            end: token.loc.start\n          },\n          messageId: \"unexpectedBefore\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.removeRange([prevToken.range[1], token.range[0]]);\n          }\n\n        });\n      }\n    }\n    /**\n     * Reports a given token if there are not space(s) after the token.\n     * @param {Token} token A token to report.\n     * @param {RegExp} pattern A pattern of the next token to check.\n     * @returns {void}\n     */\n\n\n    function expectSpaceAfter(token, pattern) {\n      const nextToken = sourceCode.getTokenAfter(token);\n\n      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {\n        context.report({\n          loc: token.loc,\n          messageId: \"expectedAfter\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.insertTextAfter(token, \" \");\n          }\n\n        });\n      }\n    }\n    /**\n     * Reports a given token if there are space(s) after the token.\n     * @param {Token} token A token to report.\n     * @param {RegExp} pattern A pattern of the next token to check.\n     * @returns {void}\n     */\n\n\n    function unexpectSpaceAfter(token, pattern) {\n      const nextToken = sourceCode.getTokenAfter(token);\n\n      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {\n        context.report({\n          loc: {\n            start: token.loc.end,\n            end: nextToken.loc.start\n          },\n          messageId: \"unexpectedAfter\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.removeRange([token.range[1], nextToken.range[0]]);\n          }\n\n        });\n      }\n    }\n    /**\n     * Parses the option object and determines check methods for each keyword.\n     * @param {Object|undefined} options The option object to parse.\n     * @returns {Object} - Normalized option object.\n     *      Keys are keywords (there are for every keyword).\n     *      Values are instances of `{\"before\": function, \"after\": function}`.\n     */\n\n\n    function parseOptions() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const before = options.before !== false;\n      const after = options.after !== false;\n      const defaultValue = {\n        before: before ? expectSpaceBefore : unexpectSpaceBefore,\n        after: after ? expectSpaceAfter : unexpectSpaceAfter\n      };\n      const overrides = options && options.overrides || {};\n      const retv = Object.create(null);\n\n      for (let i = 0; i < KEYS.length; ++i) {\n        const key = KEYS[i];\n        const override = overrides[key];\n\n        if (override) {\n          const thisBefore = \"before\" in override ? override.before : before;\n          const thisAfter = \"after\" in override ? override.after : after;\n          retv[key] = {\n            before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n            after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n          };\n        } else {\n          retv[key] = defaultValue;\n        }\n      }\n\n      return retv;\n    }\n\n    const checkMethodMap = parseOptions(context.options[0]);\n    /**\n     * Reports a given token if usage of spacing followed by the token is\n     * invalid.\n     * @param {Token} token A token to report.\n     * @param {RegExp} [pattern] Optional. A pattern of the previous\n     *      token to check.\n     * @returns {void}\n     */\n\n    function checkSpacingBefore(token, pattern) {\n      checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);\n    }\n    /**\n     * Reports a given token if usage of spacing preceded by the token is\n     * invalid.\n     * @param {Token} token A token to report.\n     * @param {RegExp} [pattern] Optional. A pattern of the next\n     *      token to check.\n     * @returns {void}\n     */\n\n\n    function checkSpacingAfter(token, pattern) {\n      checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);\n    }\n    /**\n     * Reports a given token if usage of spacing around the token is invalid.\n     * @param {Token} token A token to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingAround(token) {\n      checkSpacingBefore(token);\n      checkSpacingAfter(token);\n    }\n    /**\n     * Reports the first token of a given node if the first token is a keyword\n     * and usage of spacing around the token is invalid.\n     * @param {ASTNode|null} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingAroundFirstToken(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n\n      if (firstToken && firstToken.type === \"Keyword\") {\n        checkSpacingAround(firstToken);\n      }\n    }\n    /**\n     * Reports the first token of a given node if the first token is a keyword\n     * and usage of spacing followed by the token is invalid.\n     *\n     * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\n     * Other rules are handling usage of spacing preceded by those keywords.\n     * @param {ASTNode|null} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingBeforeFirstToken(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n\n      if (firstToken && firstToken.type === \"Keyword\") {\n        checkSpacingBefore(firstToken);\n      }\n    }\n    /**\n     * Reports the previous token of a given node if the token is a keyword and\n     * usage of spacing around the token is invalid.\n     * @param {ASTNode|null} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingAroundTokenBefore(node) {\n      if (node) {\n        const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n        checkSpacingAround(token);\n      }\n    }\n    /**\n     * Reports `async` or `function` keywords of a given node if usage of\n     * spacing around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForFunction(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n\n      if (firstToken && (firstToken.type === \"Keyword\" && firstToken.value === \"function\" || firstToken.value === \"async\")) {\n        checkSpacingBefore(firstToken);\n      }\n    }\n    /**\n     * Reports `class` and `extends` keywords of a given node if usage of\n     * spacing around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForClass(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.superClass);\n    }\n    /**\n     * Reports `if` and `else` keywords of a given node if usage of spacing\n     * around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForIfStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.alternate);\n    }\n    /**\n     * Reports `try`, `catch`, and `finally` keywords of a given node if usage\n     * of spacing around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForTryStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundFirstToken(node.handler);\n      checkSpacingAroundTokenBefore(node.finalizer);\n    }\n    /**\n     * Reports `do` and `while` keywords of a given node if usage of spacing\n     * around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForDoWhileStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.test);\n    }\n    /**\n     * Reports `for` and `in` keywords of a given node if usage of spacing\n     * around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForForInStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.right);\n    }\n    /**\n     * Reports `for` and `of` keywords of a given node if usage of spacing\n     * around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForForOfStatement(node) {\n      if (node.await) {\n        checkSpacingBefore(sourceCode.getFirstToken(node, 0));\n        checkSpacingAfter(sourceCode.getFirstToken(node, 1));\n      } else {\n        checkSpacingAroundFirstToken(node);\n      }\n\n      checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));\n    }\n    /**\n     * Reports `import`, `export`, `as`, and `from` keywords of a given node if\n     * usage of spacing around those keywords is invalid.\n     *\n     * This rule handles the `*` token in module declarations.\n     *\n     *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\n     *                               error Expected space(s) before \"as\".\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForModuleDeclaration(node) {\n      const firstToken = sourceCode.getFirstToken(node);\n      checkSpacingBefore(firstToken, PREV_TOKEN_M);\n      checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n      if (node.type === \"ExportDefaultDeclaration\") {\n        checkSpacingAround(sourceCode.getTokenAfter(firstToken));\n      }\n\n      if (node.type === \"ExportAllDeclaration\" && node.exported) {\n        const asToken = sourceCode.getTokenBefore(node.exported);\n        checkSpacingBefore(asToken, PREV_TOKEN_M);\n      }\n\n      if (node.source) {\n        const fromToken = sourceCode.getTokenBefore(node.source);\n        checkSpacingBefore(fromToken, PREV_TOKEN_M);\n        checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n      }\n    }\n    /**\n     * Reports `as` keyword of a given node if usage of spacing around this\n     * keyword is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForImportNamespaceSpecifier(node) {\n      const asToken = sourceCode.getFirstToken(node, 1);\n      checkSpacingBefore(asToken, PREV_TOKEN_M);\n    }\n    /**\n     * Reports `static`, `get`, and `set` keywords of a given node if usage of\n     * spacing around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForProperty(node) {\n      if (node.static) {\n        checkSpacingAroundFirstToken(node);\n      }\n\n      if (node.kind === \"get\" || node.kind === \"set\" || (node.method || node.type === \"MethodDefinition\") && node.value.async) {\n        const token = sourceCode.getTokenBefore(node.key, tok => {\n          switch (tok.value) {\n            case \"get\":\n            case \"set\":\n            case \"async\":\n              return true;\n\n            default:\n              return false;\n          }\n        });\n\n        if (!token) {\n          throw new Error(\"Failed to find token get, set, or async beside method name\");\n        }\n\n        checkSpacingAround(token);\n      }\n    }\n    /**\n     * Reports `await` keyword of a given node if usage of spacing before\n     * this keyword is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function checkSpacingForAwaitExpression(node) {\n      checkSpacingBefore(sourceCode.getFirstToken(node));\n    }\n\n    return {\n      // Statements\n      DebuggerStatement: checkSpacingAroundFirstToken,\n      WithStatement: checkSpacingAroundFirstToken,\n      // Statements - Control flow\n      BreakStatement: checkSpacingAroundFirstToken,\n      ContinueStatement: checkSpacingAroundFirstToken,\n      ReturnStatement: checkSpacingAroundFirstToken,\n      ThrowStatement: checkSpacingAroundFirstToken,\n      TryStatement: checkSpacingForTryStatement,\n      // Statements - Choice\n      IfStatement: checkSpacingForIfStatement,\n      SwitchStatement: checkSpacingAroundFirstToken,\n      SwitchCase: checkSpacingAroundFirstToken,\n      // Statements - Loops\n      DoWhileStatement: checkSpacingForDoWhileStatement,\n      ForInStatement: checkSpacingForForInStatement,\n      ForOfStatement: checkSpacingForForOfStatement,\n      ForStatement: checkSpacingAroundFirstToken,\n      WhileStatement: checkSpacingAroundFirstToken,\n      // Statements - Declarations\n      ClassDeclaration: checkSpacingForClass,\n      ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n      ExportDefaultDeclaration: checkSpacingForModuleDeclaration,\n      ExportAllDeclaration: checkSpacingForModuleDeclaration,\n      FunctionDeclaration: checkSpacingForFunction,\n      ImportDeclaration: checkSpacingForModuleDeclaration,\n      VariableDeclaration: checkSpacingAroundFirstToken,\n      // Expressions\n      ArrowFunctionExpression: checkSpacingForFunction,\n      AwaitExpression: checkSpacingForAwaitExpression,\n      ClassExpression: checkSpacingForClass,\n      FunctionExpression: checkSpacingForFunction,\n      NewExpression: checkSpacingBeforeFirstToken,\n      Super: checkSpacingBeforeFirstToken,\n      ThisExpression: checkSpacingBeforeFirstToken,\n      UnaryExpression: checkSpacingBeforeFirstToken,\n      YieldExpression: checkSpacingBeforeFirstToken,\n      // Others\n      ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n      MethodDefinition: checkSpacingForProperty,\n      Property: checkSpacingForProperty\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","keywords","PREV_TOKEN","NEXT_TOKEN","PREV_TOKEN_M","NEXT_TOKEN_M","TEMPLATE_OPEN_PAREN","TEMPLATE_CLOSE_PAREN","CHECK_TYPE","KEYS","concat","sort","i","length","Error","isOpenParenOfTemplate","token","type","test","value","isCloseParenOfTemplate","module","exports","meta","docs","description","category","recommended","url","fixable","schema","properties","before","default","after","overrides","reduce","retv","key","additionalProperties","messages","expectedBefore","expectedAfter","unexpectedBefore","unexpectedAfter","create","context","sourceCode","getSourceCode","expectSpaceBefore","pattern","prevToken","getTokenBefore","isTokenOnSameLine","isSpaceBetweenTokens","report","loc","messageId","data","fix","fixer","insertTextBefore","unexpectSpaceBefore","start","end","removeRange","range","expectSpaceAfter","nextToken","getTokenAfter","insertTextAfter","unexpectSpaceAfter","parseOptions","options","defaultValue","Object","override","thisBefore","thisAfter","checkMethodMap","checkSpacingBefore","checkSpacingAfter","checkSpacingAround","checkSpacingAroundFirstToken","node","firstToken","getFirstToken","checkSpacingBeforeFirstToken","checkSpacingAroundTokenBefore","isKeywordToken","checkSpacingForFunction","checkSpacingForClass","superClass","checkSpacingForIfStatement","alternate","checkSpacingForTryStatement","handler","finalizer","checkSpacingForDoWhileStatement","checkSpacingForForInStatement","right","checkSpacingForForOfStatement","await","isNotOpeningParenToken","checkSpacingForModuleDeclaration","exported","asToken","source","fromToken","checkSpacingForImportNamespaceSpecifier","checkSpacingForProperty","static","kind","method","async","tok","checkSpacingForAwaitExpression","DebuggerStatement","WithStatement","BreakStatement","ContinueStatement","ReturnStatement","ThrowStatement","TryStatement","IfStatement","SwitchStatement","SwitchCase","DoWhileStatement","ForInStatement","ForOfStatement","ForStatement","WhileStatement","ClassDeclaration","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration","FunctionDeclaration","ImportDeclaration","VariableDeclaration","ArrowFunctionExpression","AwaitExpression","ClassExpression","FunctionExpression","NewExpression","Super","ThisExpression","UnaryExpression","YieldExpression","ImportNamespaceSpecifier","MethodDefinition","Property"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/keyword-spacing.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce spacing before and after keywords.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PREV_TOKEN = /^[)\\]}>]$/u;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/u;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/u;\nconst NEXT_TOKEN_M = /^[{*]$/u;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/u;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/u;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/u;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\n\n// check duplications.\n(function() {\n    KEYS.sort();\n    for (let i = 1; i < KEYS.length; ++i) {\n        if (KEYS[i] === KEYS[i - 1]) {\n            throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n        }\n    }\n}());\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\n */\nfunction isOpenParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n\n/**\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\n */\nfunction isCloseParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after keywords\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/keyword-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\", default: true },\n                    after: { type: \"boolean\", default: true },\n                    overrides: {\n                        type: \"object\",\n                        properties: KEYS.reduce((retv, key) => {\n                            retv[key] = {\n                                type: \"object\",\n                                properties: {\n                                    before: { type: \"boolean\" },\n                                    after: { type: \"boolean\" }\n                                },\n                                additionalProperties: false\n                            };\n                            return retv;\n                        }, {}),\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expectedBefore: \"Expected space(s) before \\\"{{value}}\\\".\",\n            expectedAfter: \"Expected space(s) after \\\"{{value}}\\\".\",\n            unexpectedBefore: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n            unexpectedAfter: \"Unexpected space(s) after \\\"{{value}}\\\".\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given token if there are not space(s) before the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the previous token to check.\n         * @returns {void}\n         */\n        function expectSpaceBefore(token, pattern) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                !sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc,\n                    messageId: \"expectedBefore\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextBefore(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) before the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the previous token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceBefore(token, pattern) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: { start: prevToken.loc.end, end: token.loc.start },\n                    messageId: \"unexpectedBefore\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are not space(s) after the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the next token to check.\n         * @returns {void}\n         */\n        function expectSpaceAfter(token, pattern) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                !sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc,\n                    messageId: \"expectedAfter\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) after the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the next token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceAfter(token, pattern) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n\n                context.report({\n                    loc: { start: token.loc.end, end: nextToken.loc.start },\n                    messageId: \"unexpectedAfter\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Parses the option object and determines check methods for each keyword.\n         * @param {Object|undefined} options The option object to parse.\n         * @returns {Object} - Normalized option object.\n         *      Keys are keywords (there are for every keyword).\n         *      Values are instances of `{\"before\": function, \"after\": function}`.\n         */\n        function parseOptions(options = {}) {\n            const before = options.before !== false;\n            const after = options.after !== false;\n            const defaultValue = {\n                before: before ? expectSpaceBefore : unexpectSpaceBefore,\n                after: after ? expectSpaceAfter : unexpectSpaceAfter\n            };\n            const overrides = (options && options.overrides) || {};\n            const retv = Object.create(null);\n\n            for (let i = 0; i < KEYS.length; ++i) {\n                const key = KEYS[i];\n                const override = overrides[key];\n\n                if (override) {\n                    const thisBefore = (\"before\" in override) ? override.before : before;\n                    const thisAfter = (\"after\" in override) ? override.after : after;\n\n                    retv[key] = {\n                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n                    };\n                } else {\n                    retv[key] = defaultValue;\n                }\n            }\n\n            return retv;\n        }\n\n        const checkMethodMap = parseOptions(context.options[0]);\n\n        /**\n         * Reports a given token if usage of spacing followed by the token is\n         * invalid.\n         * @param {Token} token A token to report.\n         * @param {RegExp} [pattern] Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token, pattern) {\n            checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);\n        }\n\n        /**\n         * Reports a given token if usage of spacing preceded by the token is\n         * invalid.\n         * @param {Token} token A token to report.\n         * @param {RegExp} [pattern] Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token, pattern) {\n            checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);\n        }\n\n        /**\n         * Reports a given token if usage of spacing around the token is invalid.\n         * @param {Token} token A token to report.\n         * @returns {void}\n         */\n        function checkSpacingAround(token) {\n            checkSpacingBefore(token);\n            checkSpacingAfter(token);\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing around the token is invalid.\n         * @param {ASTNode|null} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingAround(firstToken);\n            }\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing followed by the token is invalid.\n         *\n         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\n         * Other rules are handling usage of spacing preceded by those keywords.\n         * @param {ASTNode|null} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingBeforeFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports the previous token of a given node if the token is a keyword and\n         * usage of spacing around the token is invalid.\n         * @param {ASTNode|null} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundTokenBefore(node) {\n            if (node) {\n                const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `async` or `function` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForFunction(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken &&\n                ((firstToken.type === \"Keyword\" && firstToken.value === \"function\") ||\n                firstToken.value === \"async\")\n            ) {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports `class` and `extends` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForClass(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.superClass);\n        }\n\n        /**\n         * Reports `if` and `else` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForIfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.alternate);\n        }\n\n        /**\n         * Reports `try`, `catch`, and `finally` keywords of a given node if usage\n         * of spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForTryStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundFirstToken(node.handler);\n            checkSpacingAroundTokenBefore(node.finalizer);\n        }\n\n        /**\n         * Reports `do` and `while` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForDoWhileStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.test);\n        }\n\n        /**\n         * Reports `for` and `in` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForInStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.right);\n        }\n\n        /**\n         * Reports `for` and `of` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForOfStatement(node) {\n            if (node.await) {\n                checkSpacingBefore(sourceCode.getFirstToken(node, 0));\n                checkSpacingAfter(sourceCode.getFirstToken(node, 1));\n            } else {\n                checkSpacingAroundFirstToken(node);\n            }\n            checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));\n        }\n\n        /**\n         * Reports `import`, `export`, `as`, and `from` keywords of a given node if\n         * usage of spacing around those keywords is invalid.\n         *\n         * This rule handles the `*` token in module declarations.\n         *\n         *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\n         *                               error Expected space(s) before \"as\".\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForModuleDeclaration(node) {\n            const firstToken = sourceCode.getFirstToken(node);\n\n            checkSpacingBefore(firstToken, PREV_TOKEN_M);\n            checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n            if (node.type === \"ExportDefaultDeclaration\") {\n                checkSpacingAround(sourceCode.getTokenAfter(firstToken));\n            }\n\n            if (node.type === \"ExportAllDeclaration\" && node.exported) {\n                const asToken = sourceCode.getTokenBefore(node.exported);\n\n                checkSpacingBefore(asToken, PREV_TOKEN_M);\n            }\n\n            if (node.source) {\n                const fromToken = sourceCode.getTokenBefore(node.source);\n\n                checkSpacingBefore(fromToken, PREV_TOKEN_M);\n                checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n            }\n        }\n\n        /**\n         * Reports `as` keyword of a given node if usage of spacing around this\n         * keyword is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForImportNamespaceSpecifier(node) {\n            const asToken = sourceCode.getFirstToken(node, 1);\n\n            checkSpacingBefore(asToken, PREV_TOKEN_M);\n        }\n\n        /**\n         * Reports `static`, `get`, and `set` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForProperty(node) {\n            if (node.static) {\n                checkSpacingAroundFirstToken(node);\n            }\n            if (node.kind === \"get\" ||\n                node.kind === \"set\" ||\n                (\n                    (node.method || node.type === \"MethodDefinition\") &&\n                    node.value.async\n                )\n            ) {\n                const token = sourceCode.getTokenBefore(\n                    node.key,\n                    tok => {\n                        switch (tok.value) {\n                            case \"get\":\n                            case \"set\":\n                            case \"async\":\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                );\n\n                if (!token) {\n                    throw new Error(\"Failed to find token get, set, or async beside method name\");\n                }\n\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `await` keyword of a given node if usage of spacing before\n         * this keyword is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForAwaitExpression(node) {\n            checkSpacingBefore(sourceCode.getFirstToken(node));\n        }\n\n        return {\n\n            // Statements\n            DebuggerStatement: checkSpacingAroundFirstToken,\n            WithStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Control flow\n            BreakStatement: checkSpacingAroundFirstToken,\n            ContinueStatement: checkSpacingAroundFirstToken,\n            ReturnStatement: checkSpacingAroundFirstToken,\n            ThrowStatement: checkSpacingAroundFirstToken,\n            TryStatement: checkSpacingForTryStatement,\n\n            // Statements - Choice\n            IfStatement: checkSpacingForIfStatement,\n            SwitchStatement: checkSpacingAroundFirstToken,\n            SwitchCase: checkSpacingAroundFirstToken,\n\n            // Statements - Loops\n            DoWhileStatement: checkSpacingForDoWhileStatement,\n            ForInStatement: checkSpacingForForInStatement,\n            ForOfStatement: checkSpacingForForOfStatement,\n            ForStatement: checkSpacingAroundFirstToken,\n            WhileStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Declarations\n            ClassDeclaration: checkSpacingForClass,\n            ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n            ExportDefaultDeclaration: checkSpacingForModuleDeclaration,\n            ExportAllDeclaration: checkSpacingForModuleDeclaration,\n            FunctionDeclaration: checkSpacingForFunction,\n            ImportDeclaration: checkSpacingForModuleDeclaration,\n            VariableDeclaration: checkSpacingAroundFirstToken,\n\n            // Expressions\n            ArrowFunctionExpression: checkSpacingForFunction,\n            AwaitExpression: checkSpacingForAwaitExpression,\n            ClassExpression: checkSpacingForClass,\n            FunctionExpression: checkSpacingForFunction,\n            NewExpression: checkSpacingBeforeFirstToken,\n            Super: checkSpacingBeforeFirstToken,\n            ThisExpression: checkSpacingBeforeFirstToken,\n            UnaryExpression: checkSpacingBeforeFirstToken,\n            YieldExpression: checkSpacingBeforeFirstToken,\n\n            // Others\n            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n            MethodDefinition: checkSpacingForProperty,\n            Property: checkSpacingForProperty\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}