{"ast":null,"code":"/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\"use strict\";\n/* eslint class-methods-use-this: \"off\" */\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst util = require(\"util\"),\n      configSchema = require(\"../../conf/config-schema\"),\n      BuiltInEnvironments = require(\"../../conf/environments\"),\n      ConfigOps = require(\"./config-ops\"),\n      {\n  emitDeprecationWarning\n} = require(\"./deprecation-warnings\");\n\nconst ajv = require(\"./ajv\")();\n\nconst ruleValidators = new WeakMap();\nconst noop = Function.prototype; //------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nlet validateSchema;\nconst severityMap = {\n  error: 2,\n  warn: 1,\n  off: 0\n};\nconst validated = new WeakSet(); //-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = class ConfigValidator {\n  constructor() {\n    let {\n      builtInRules = new Map()\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.builtInRules = builtInRules;\n  }\n  /**\n   * Gets a complete options schema for a rule.\n   * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n   * @returns {Object} JSON Schema for the rule's options.\n   */\n\n\n  getRuleOptionsSchema(rule) {\n    if (!rule) {\n      return null;\n    }\n\n    const schema = rule.schema || rule.meta && rule.meta.schema; // Given a tuple of schemas, insert warning level at the beginning\n\n    if (Array.isArray(schema)) {\n      if (schema.length) {\n        return {\n          type: \"array\",\n          items: schema,\n          minItems: 0,\n          maxItems: schema.length\n        };\n      }\n\n      return {\n        type: \"array\",\n        minItems: 0,\n        maxItems: 0\n      };\n    } // Given a full schema, leave it alone\n\n\n    return schema || null;\n  }\n  /**\n   * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\n   * @param {options} options The given options for the rule.\n   * @returns {number|string} The rule's severity value\n   */\n\n\n  validateRuleSeverity(options) {\n    const severity = Array.isArray(options) ? options[0] : options;\n    const normSeverity = typeof severity === \"string\" ? severityMap[severity.toLowerCase()] : severity;\n\n    if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {\n      return normSeverity;\n    }\n\n    throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, \"\\\"\").replace(/\\n/gu, \"\")}').\\n`);\n  }\n  /**\n   * Validates the non-severity options passed to a rule, based on its schema.\n   * @param {{create: Function}} rule The rule to validate\n   * @param {Array} localOptions The options for the rule, excluding severity\n   * @returns {void}\n   */\n\n\n  validateRuleSchema(rule, localOptions) {\n    if (!ruleValidators.has(rule)) {\n      const schema = this.getRuleOptionsSchema(rule);\n\n      if (schema) {\n        ruleValidators.set(rule, ajv.compile(schema));\n      }\n    }\n\n    const validateRule = ruleValidators.get(rule);\n\n    if (validateRule) {\n      validateRule(localOptions);\n\n      if (validateRule.errors) {\n        throw new Error(validateRule.errors.map(error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`).join(\"\"));\n      }\n    }\n  }\n  /**\n   * Validates a rule's options against its schema.\n   * @param {{create: Function}|null} rule The rule that the config is being validated for\n   * @param {string} ruleId The rule's unique name.\n   * @param {Array|number} options The given options for the rule.\n   * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,\n   * no source is prepended to the message.\n   * @returns {void}\n   */\n\n\n  validateRuleOptions(rule, ruleId, options) {\n    let source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    try {\n      const severity = this.validateRuleSeverity(options);\n\n      if (severity !== 0) {\n        this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);\n      }\n    } catch (err) {\n      const enhancedMessage = `Configuration for rule \"${ruleId}\" is invalid:\\n${err.message}`;\n\n      if (typeof source === \"string\") {\n        throw new Error(`${source}:\\n\\t${enhancedMessage}`);\n      } else {\n        throw new Error(enhancedMessage);\n      }\n    }\n  }\n  /**\n   * Validates an environment object\n   * @param {Object} environment The environment config object to validate.\n   * @param {string} source The name of the configuration source to report in any errors.\n   * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.\n   * @returns {void}\n   */\n\n\n  validateEnvironment(environment, source) {\n    let getAdditionalEnv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n\n    // not having an environment is ok\n    if (!environment) {\n      return;\n    }\n\n    Object.keys(environment).forEach(id => {\n      const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;\n\n      if (!env) {\n        const message = `${source}:\\n\\tEnvironment key \"${id}\" is unknown\\n`;\n        throw new Error(message);\n      }\n    });\n  }\n  /**\n   * Validates a rules config object\n   * @param {Object} rulesConfig The rules config object to validate.\n   * @param {string} source The name of the configuration source to report in any errors.\n   * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules\n   * @returns {void}\n   */\n\n\n  validateRules(rulesConfig, source) {\n    let getAdditionalRule = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n\n    if (!rulesConfig) {\n      return;\n    }\n\n    Object.keys(rulesConfig).forEach(id => {\n      const rule = getAdditionalRule(id) || this.builtInRules.get(id) || null;\n      this.validateRuleOptions(rule, id, rulesConfig[id], source);\n    });\n  }\n  /**\n   * Validates a `globals` section of a config file\n   * @param {Object} globalsConfig The `globals` section\n   * @param {string|null} source The name of the configuration source to report in the event of an error.\n   * @returns {void}\n   */\n\n\n  validateGlobals(globalsConfig) {\n    let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (!globalsConfig) {\n      return;\n    }\n\n    Object.entries(globalsConfig).forEach(_ref => {\n      let [configuredGlobal, configuredValue] = _ref;\n\n      try {\n        ConfigOps.normalizeConfigGlobal(configuredValue);\n      } catch (err) {\n        throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:\\n${err.message}`);\n      }\n    });\n  }\n  /**\n   * Validate `processor` configuration.\n   * @param {string|undefined} processorName The processor name.\n   * @param {string} source The name of config file.\n   * @param {function(id:string): Processor} getProcessor The getter of defined processors.\n   * @returns {void}\n   */\n\n\n  validateProcessor(processorName, source, getProcessor) {\n    if (processorName && !getProcessor(processorName)) {\n      throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);\n    }\n  }\n  /**\n   * Formats an array of schema validation errors.\n   * @param {Array} errors An array of error messages to format.\n   * @returns {string} Formatted error message\n   */\n\n\n  formatErrors(errors) {\n    return errors.map(error => {\n      if (error.keyword === \"additionalProperties\") {\n        const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;\n        return `Unexpected top-level property \"${formattedPropertyPath}\"`;\n      }\n\n      if (error.keyword === \"type\") {\n        const formattedField = error.dataPath.slice(1);\n        const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(\"/\") : error.schema;\n        const formattedValue = JSON.stringify(error.data);\n        return `Property \"${formattedField}\" is the wrong type (expected ${formattedExpectedType} but got \\`${formattedValue}\\`)`;\n      }\n\n      const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n      return `\"${field}\" ${error.message}. Value: ${JSON.stringify(error.data)}`;\n    }).map(message => `\\t- ${message}.\\n`).join(\"\");\n  }\n  /**\n   * Validates the top level properties of the config object.\n   * @param {Object} config The config object to validate.\n   * @param {string} source The name of the configuration source to report in any errors.\n   * @returns {void}\n   */\n\n\n  validateConfigSchema(config) {\n    let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    validateSchema = validateSchema || ajv.compile(configSchema);\n\n    if (!validateSchema(config)) {\n      throw new Error(`ESLint configuration in ${source} is invalid:\\n${this.formatErrors(validateSchema.errors)}`);\n    }\n\n    if (Object.hasOwnProperty.call(config, \"ecmaFeatures\")) {\n      emitDeprecationWarning(source, \"ESLINT_LEGACY_ECMAFEATURES\");\n    }\n  }\n  /**\n   * Validates an entire config object.\n   * @param {Object} config The config object to validate.\n   * @param {string} source The name of the configuration source to report in any errors.\n   * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.\n   * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.\n   * @returns {void}\n   */\n\n\n  validate(config, source, getAdditionalRule, getAdditionalEnv) {\n    this.validateConfigSchema(config, source);\n    this.validateRules(config.rules, source, getAdditionalRule);\n    this.validateEnvironment(config.env, source, getAdditionalEnv);\n    this.validateGlobals(config.globals, source);\n\n    for (const override of config.overrides || []) {\n      this.validateRules(override.rules, source, getAdditionalRule);\n      this.validateEnvironment(override.env, source, getAdditionalEnv);\n      this.validateGlobals(config.globals, source);\n    }\n  }\n  /**\n   * Validate config array object.\n   * @param {ConfigArray} configArray The config array to validate.\n   * @returns {void}\n   */\n\n\n  validateConfigArray(configArray) {\n    const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);\n    const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);\n    const getPluginRule = Map.prototype.get.bind(configArray.pluginRules); // Validate.\n\n    for (const element of configArray) {\n      if (validated.has(element)) {\n        continue;\n      }\n\n      validated.add(element);\n      this.validateEnvironment(element.env, element.name, getPluginEnv);\n      this.validateGlobals(element.globals, element.name);\n      this.validateProcessor(element.processor, element.name, getPluginProcessor);\n      this.validateRules(element.rules, element.name, getPluginRule);\n    }\n  }\n\n};","map":{"version":3,"names":["util","require","configSchema","BuiltInEnvironments","ConfigOps","emitDeprecationWarning","ajv","ruleValidators","WeakMap","noop","Function","prototype","validateSchema","severityMap","error","warn","off","validated","WeakSet","module","exports","ConfigValidator","constructor","builtInRules","Map","getRuleOptionsSchema","rule","schema","meta","Array","isArray","length","type","items","minItems","maxItems","validateRuleSeverity","options","severity","normSeverity","toLowerCase","Error","inspect","replace","validateRuleSchema","localOptions","has","set","compile","validateRule","get","errors","map","JSON","stringify","data","message","join","validateRuleOptions","ruleId","source","slice","err","enhancedMessage","validateEnvironment","environment","getAdditionalEnv","Object","keys","forEach","id","env","validateRules","rulesConfig","getAdditionalRule","validateGlobals","globalsConfig","entries","configuredGlobal","configuredValue","normalizeConfigGlobal","validateProcessor","processorName","getProcessor","formatErrors","keyword","formattedPropertyPath","dataPath","params","additionalProperty","formattedField","formattedExpectedType","formattedValue","field","validateConfigSchema","config","hasOwnProperty","call","validate","rules","globals","override","overrides","validateConfigArray","configArray","getPluginEnv","bind","pluginEnvironments","getPluginProcessor","pluginProcessors","getPluginRule","pluginRules","element","add","name","processor"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/@eslint/eslintrc/lib/shared/config-validator.js"],"sourcesContent":["/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n/* eslint class-methods-use-this: \"off\" */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    util = require(\"util\"),\n    configSchema = require(\"../../conf/config-schema\"),\n    BuiltInEnvironments = require(\"../../conf/environments\"),\n    ConfigOps = require(\"./config-ops\"),\n    { emitDeprecationWarning } = require(\"./deprecation-warnings\");\n\nconst ajv = require(\"./ajv\")();\nconst ruleValidators = new WeakMap();\nconst noop = Function.prototype;\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\nlet validateSchema;\nconst severityMap = {\n    error: 2,\n    warn: 1,\n    off: 0\n};\n\nconst validated = new WeakSet();\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = class ConfigValidator {\n    constructor({ builtInRules = new Map() } = {}) {\n        this.builtInRules = builtInRules;\n    }\n\n    /**\n     * Gets a complete options schema for a rule.\n     * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n     * @returns {Object} JSON Schema for the rule's options.\n     */\n    getRuleOptionsSchema(rule) {\n        if (!rule) {\n            return null;\n        }\n\n        const schema = rule.schema || rule.meta && rule.meta.schema;\n\n        // Given a tuple of schemas, insert warning level at the beginning\n        if (Array.isArray(schema)) {\n            if (schema.length) {\n                return {\n                    type: \"array\",\n                    items: schema,\n                    minItems: 0,\n                    maxItems: schema.length\n                };\n            }\n            return {\n                type: \"array\",\n                minItems: 0,\n                maxItems: 0\n            };\n\n        }\n\n        // Given a full schema, leave it alone\n        return schema || null;\n    }\n\n    /**\n     * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\n     * @param {options} options The given options for the rule.\n     * @returns {number|string} The rule's severity value\n     */\n    validateRuleSeverity(options) {\n        const severity = Array.isArray(options) ? options[0] : options;\n        const normSeverity = typeof severity === \"string\" ? severityMap[severity.toLowerCase()] : severity;\n\n        if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {\n            return normSeverity;\n        }\n\n        throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, \"\\\"\").replace(/\\n/gu, \"\")}').\\n`);\n\n    }\n\n    /**\n     * Validates the non-severity options passed to a rule, based on its schema.\n     * @param {{create: Function}} rule The rule to validate\n     * @param {Array} localOptions The options for the rule, excluding severity\n     * @returns {void}\n     */\n    validateRuleSchema(rule, localOptions) {\n        if (!ruleValidators.has(rule)) {\n            const schema = this.getRuleOptionsSchema(rule);\n\n            if (schema) {\n                ruleValidators.set(rule, ajv.compile(schema));\n            }\n        }\n\n        const validateRule = ruleValidators.get(rule);\n\n        if (validateRule) {\n            validateRule(localOptions);\n            if (validateRule.errors) {\n                throw new Error(validateRule.errors.map(\n                    error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`\n                ).join(\"\"));\n            }\n        }\n    }\n\n    /**\n     * Validates a rule's options against its schema.\n     * @param {{create: Function}|null} rule The rule that the config is being validated for\n     * @param {string} ruleId The rule's unique name.\n     * @param {Array|number} options The given options for the rule.\n     * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,\n     * no source is prepended to the message.\n     * @returns {void}\n     */\n    validateRuleOptions(rule, ruleId, options, source = null) {\n        try {\n            const severity = this.validateRuleSeverity(options);\n\n            if (severity !== 0) {\n                this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);\n            }\n        } catch (err) {\n            const enhancedMessage = `Configuration for rule \"${ruleId}\" is invalid:\\n${err.message}`;\n\n            if (typeof source === \"string\") {\n                throw new Error(`${source}:\\n\\t${enhancedMessage}`);\n            } else {\n                throw new Error(enhancedMessage);\n            }\n        }\n    }\n\n    /**\n     * Validates an environment object\n     * @param {Object} environment The environment config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.\n     * @returns {void}\n     */\n    validateEnvironment(\n        environment,\n        source,\n        getAdditionalEnv = noop\n    ) {\n\n        // not having an environment is ok\n        if (!environment) {\n            return;\n        }\n\n        Object.keys(environment).forEach(id => {\n            const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;\n\n            if (!env) {\n                const message = `${source}:\\n\\tEnvironment key \"${id}\" is unknown\\n`;\n\n                throw new Error(message);\n            }\n        });\n    }\n\n    /**\n     * Validates a rules config object\n     * @param {Object} rulesConfig The rules config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules\n     * @returns {void}\n     */\n    validateRules(\n        rulesConfig,\n        source,\n        getAdditionalRule = noop\n    ) {\n        if (!rulesConfig) {\n            return;\n        }\n\n        Object.keys(rulesConfig).forEach(id => {\n            const rule = getAdditionalRule(id) || this.builtInRules.get(id) || null;\n\n            this.validateRuleOptions(rule, id, rulesConfig[id], source);\n        });\n    }\n\n    /**\n     * Validates a `globals` section of a config file\n     * @param {Object} globalsConfig The `globals` section\n     * @param {string|null} source The name of the configuration source to report in the event of an error.\n     * @returns {void}\n     */\n    validateGlobals(globalsConfig, source = null) {\n        if (!globalsConfig) {\n            return;\n        }\n\n        Object.entries(globalsConfig)\n            .forEach(([configuredGlobal, configuredValue]) => {\n                try {\n                    ConfigOps.normalizeConfigGlobal(configuredValue);\n                } catch (err) {\n                    throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:\\n${err.message}`);\n                }\n            });\n    }\n\n    /**\n     * Validate `processor` configuration.\n     * @param {string|undefined} processorName The processor name.\n     * @param {string} source The name of config file.\n     * @param {function(id:string): Processor} getProcessor The getter of defined processors.\n     * @returns {void}\n     */\n    validateProcessor(processorName, source, getProcessor) {\n        if (processorName && !getProcessor(processorName)) {\n            throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);\n        }\n    }\n\n    /**\n     * Formats an array of schema validation errors.\n     * @param {Array} errors An array of error messages to format.\n     * @returns {string} Formatted error message\n     */\n    formatErrors(errors) {\n        return errors.map(error => {\n            if (error.keyword === \"additionalProperties\") {\n                const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;\n\n                return `Unexpected top-level property \"${formattedPropertyPath}\"`;\n            }\n            if (error.keyword === \"type\") {\n                const formattedField = error.dataPath.slice(1);\n                const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(\"/\") : error.schema;\n                const formattedValue = JSON.stringify(error.data);\n\n                return `Property \"${formattedField}\" is the wrong type (expected ${formattedExpectedType} but got \\`${formattedValue}\\`)`;\n            }\n\n            const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n            return `\"${field}\" ${error.message}. Value: ${JSON.stringify(error.data)}`;\n        }).map(message => `\\t- ${message}.\\n`).join(\"\");\n    }\n\n    /**\n     * Validates the top level properties of the config object.\n     * @param {Object} config The config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @returns {void}\n     */\n    validateConfigSchema(config, source = null) {\n        validateSchema = validateSchema || ajv.compile(configSchema);\n\n        if (!validateSchema(config)) {\n            throw new Error(`ESLint configuration in ${source} is invalid:\\n${this.formatErrors(validateSchema.errors)}`);\n        }\n\n        if (Object.hasOwnProperty.call(config, \"ecmaFeatures\")) {\n            emitDeprecationWarning(source, \"ESLINT_LEGACY_ECMAFEATURES\");\n        }\n    }\n\n    /**\n     * Validates an entire config object.\n     * @param {Object} config The config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.\n     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.\n     * @returns {void}\n     */\n    validate(config, source, getAdditionalRule, getAdditionalEnv) {\n        this.validateConfigSchema(config, source);\n        this.validateRules(config.rules, source, getAdditionalRule);\n        this.validateEnvironment(config.env, source, getAdditionalEnv);\n        this.validateGlobals(config.globals, source);\n\n        for (const override of config.overrides || []) {\n            this.validateRules(override.rules, source, getAdditionalRule);\n            this.validateEnvironment(override.env, source, getAdditionalEnv);\n            this.validateGlobals(config.globals, source);\n        }\n    }\n\n    /**\n     * Validate config array object.\n     * @param {ConfigArray} configArray The config array to validate.\n     * @returns {void}\n     */\n    validateConfigArray(configArray) {\n        const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);\n        const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);\n        const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);\n\n        // Validate.\n        for (const element of configArray) {\n            if (validated.has(element)) {\n                continue;\n            }\n            validated.add(element);\n\n            this.validateEnvironment(element.env, element.name, getPluginEnv);\n            this.validateGlobals(element.globals, element.name);\n            this.validateProcessor(element.processor, element.name, getPluginProcessor);\n            this.validateRules(element.rules, element.name, getPluginRule);\n        }\n    }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}