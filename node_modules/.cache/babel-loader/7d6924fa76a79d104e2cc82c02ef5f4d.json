{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\n\n\nfunction isFunctionName(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n}\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node A MetaProperty node to check.\n * @param {string} metaName The name of `MetaProperty.meta`.\n * @param {string} propertyName The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\n\n\nfunction checkMetaProperty(node, metaName, propertyName) {\n  return node.meta.name === metaName && node.property.name === propertyName;\n}\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\n\n\nfunction getVariableOfArguments(scope) {\n  const variables = scope.variables;\n\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n\n    if (variable.name === \"arguments\") {\n      /*\n       * If there was a parameter which is named \"arguments\", the\n       * implicit \"arguments\" is not defined.\n       * So does fast return with null.\n       */\n      return variable.identifiers.length === 0 ? variable : null;\n    }\n  }\n  /* istanbul ignore next */\n\n\n  return null;\n}\n/**\n * Checks whether or not a given node is a callback.\n * @param {ASTNode} node A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\n\n\nfunction getCallbackInfo(node) {\n  const retv = {\n    isCallback: false,\n    isLexicalThis: false\n  };\n  let currentNode = node;\n  let parent = node.parent;\n  let bound = false;\n\n  while (currentNode) {\n    switch (parent.type) {\n      // Checks parents recursively.\n      case \"LogicalExpression\":\n      case \"ChainExpression\":\n      case \"ConditionalExpression\":\n        break;\n      // Checks whether the parent node is `.bind(this)` call.\n\n      case \"MemberExpression\":\n        if (parent.object === currentNode && !parent.property.computed && parent.property.type === \"Identifier\" && parent.property.name === \"bind\") {\n          const maybeCallee = parent.parent.type === \"ChainExpression\" ? parent.parent : parent;\n\n          if (astUtils.isCallee(maybeCallee)) {\n            if (!bound) {\n              bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.\n\n              retv.isLexicalThis = maybeCallee.parent.arguments.length === 1 && maybeCallee.parent.arguments[0].type === \"ThisExpression\";\n            }\n\n            parent = maybeCallee.parent;\n          } else {\n            return retv;\n          }\n        } else {\n          return retv;\n        }\n\n        break;\n      // Checks whether the node is a callback.\n\n      case \"CallExpression\":\n      case \"NewExpression\":\n        if (parent.callee !== currentNode) {\n          retv.isCallback = true;\n        }\n\n        return retv;\n\n      default:\n        return retv;\n    }\n\n    currentNode = parent;\n    parent = parent.parent;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"unreachable\");\n}\n/**\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\n * @param {ASTNode[]} paramsList The list of parameters for a function\n * @returns {boolean} `true` if the list of parameters contains any duplicates\n */\n\n\nfunction hasDuplicateParams(paramsList) {\n  return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require using arrow functions for callbacks\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowNamedFunctions: {\n          type: \"boolean\",\n          default: false\n        },\n        allowUnboundThis: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      preferArrowCallback: \"Unexpected function expression.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n\n    const allowNamedFunctions = options.allowNamedFunctions;\n    const sourceCode = context.getSourceCode();\n    /*\n     * {Array<{this: boolean, super: boolean, meta: boolean}>}\n     * - this - A flag which shows there are one or more ThisExpression.\n     * - super - A flag which shows there are one or more Super.\n     * - meta - A flag which shows there are one or more MethProperty.\n     */\n\n    let stack = [];\n    /**\n     * Pushes new function scope with all `false` flags.\n     * @returns {void}\n     */\n\n    function enterScope() {\n      stack.push({\n        this: false,\n        super: false,\n        meta: false\n      });\n    }\n    /**\n     * Pops a function scope from the stack.\n     * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n     */\n\n\n    function exitScope() {\n      return stack.pop();\n    }\n\n    return {\n      // Reset internal state.\n      Program() {\n        stack = [];\n      },\n\n      // If there are below, it cannot replace with arrow functions merely.\n      ThisExpression() {\n        const info = stack[stack.length - 1];\n\n        if (info) {\n          info.this = true;\n        }\n      },\n\n      Super() {\n        const info = stack[stack.length - 1];\n\n        if (info) {\n          info.super = true;\n        }\n      },\n\n      MetaProperty(node) {\n        const info = stack[stack.length - 1];\n\n        if (info && checkMetaProperty(node, \"new\", \"target\")) {\n          info.meta = true;\n        }\n      },\n\n      // To skip nested scopes.\n      FunctionDeclaration: enterScope,\n      \"FunctionDeclaration:exit\": exitScope,\n      // Main.\n      FunctionExpression: enterScope,\n\n      \"FunctionExpression:exit\"(node) {\n        const scopeInfo = exitScope(); // Skip named function expressions\n\n        if (allowNamedFunctions && node.id && node.id.name) {\n          return;\n        } // Skip generators.\n\n\n        if (node.generator) {\n          return;\n        } // Skip recursive functions.\n\n\n        const nameVar = context.getDeclaredVariables(node)[0];\n\n        if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n          return;\n        } // Skip if it's using arguments.\n\n\n        const variable = getVariableOfArguments(context.getScope());\n\n        if (variable && variable.references.length > 0) {\n          return;\n        } // Reports if it's a callback which can replace with arrows.\n\n\n        const callbackInfo = getCallbackInfo(node);\n\n        if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {\n          context.report({\n            node,\n            messageId: \"preferArrowCallback\",\n\n            *fix(fixer) {\n              if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {\n                /*\n                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\n                 * is no way to determine what `this` should be, so don't perform any fixes.\n                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                 */\n                return;\n              } // Remove `.bind(this)` if exists.\n\n\n              if (callbackInfo.isLexicalThis) {\n                const memberNode = node.parent;\n                /*\n                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.\n                 * E.g. `(foo || function(){}).bind(this)`\n                 */\n\n                if (memberNode.type !== \"MemberExpression\") {\n                  return;\n                }\n\n                const callNode = memberNode.parent;\n                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);\n                const lastTokenToRemove = sourceCode.getLastToken(callNode);\n                /*\n                 * If the member expression is parenthesized, don't remove the right paren.\n                 * E.g. `(function(){}.bind)(this)`\n                 *                    ^^^^^^^^^^^^\n                 */\n\n                if (astUtils.isParenthesised(sourceCode, memberNode)) {\n                  return;\n                } // If comments exist in the `.bind(this)`, don't remove those.\n\n\n                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                  return;\n                }\n\n                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);\n              } // Convert the function expression to an arrow function.\n\n\n              const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);\n              const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);\n\n              if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {\n                // Remove only extra tokens to keep comments.\n                yield fixer.remove(functionToken);\n\n                if (node.id) {\n                  yield fixer.remove(node.id);\n                }\n              } else {\n                // Remove extra tokens and spaces.\n                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);\n              }\n\n              yield fixer.insertTextBefore(node.body, \"=> \"); // Get the node that will become the new arrow function.\n\n              let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n              if (replacedNode.type === \"ChainExpression\") {\n                replacedNode = replacedNode.parent;\n              }\n              /*\n               * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n               * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n               * though `foo || function() {}` is valid.\n               */\n\n\n              if (replacedNode.parent.type !== \"CallExpression\" && replacedNode.parent.type !== \"ConditionalExpression\" && !astUtils.isParenthesised(sourceCode, replacedNode) && !astUtils.isParenthesised(sourceCode, node)) {\n                yield fixer.insertTextBefore(replacedNode, \"(\");\n                yield fixer.insertTextAfter(replacedNode, \")\");\n              }\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isFunctionName","variable","defs","type","checkMetaProperty","node","metaName","propertyName","meta","name","property","getVariableOfArguments","scope","variables","i","length","identifiers","getCallbackInfo","retv","isCallback","isLexicalThis","currentNode","parent","bound","object","computed","maybeCallee","isCallee","arguments","callee","Error","hasDuplicateParams","paramsList","every","param","Set","map","size","module","exports","docs","description","category","recommended","url","schema","properties","allowNamedFunctions","default","allowUnboundThis","additionalProperties","fixable","messages","preferArrowCallback","create","context","options","sourceCode","getSourceCode","stack","enterScope","push","this","super","exitScope","pop","Program","ThisExpression","info","Super","MetaProperty","FunctionDeclaration","FunctionExpression","scopeInfo","id","generator","nameVar","getDeclaredVariables","references","getScope","callbackInfo","report","messageId","fix","fixer","params","memberNode","callNode","firstTokenToRemove","getTokenAfter","isNotClosingParenToken","lastTokenToRemove","getLastToken","isParenthesised","commentsExistBetween","removeRange","range","functionToken","getFirstToken","async","leftParenToken","isOpeningParenToken","remove","insertTextBefore","body","replacedNode","insertTextAfter"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/prefer-arrow-callback.js"],"sourcesContent":["/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node A MetaProperty node to check.\n * @param {string} metaName The name of `MetaProperty.meta`.\n * @param {string} propertyName The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the\n             * implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next */\n    return null;\n}\n\n/**\n * Checks whether or not a given node is a callback.\n * @param {ASTNode} node A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    const retv = { isCallback: false, isLexicalThis: false };\n    let currentNode = node;\n    let parent = node.parent;\n    let bound = false;\n\n    while (currentNode) {\n        switch (parent.type) {\n\n            // Checks parents recursively.\n\n            case \"LogicalExpression\":\n            case \"ChainExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (\n                    parent.object === currentNode &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\"\n                ) {\n                    const maybeCallee = parent.parent.type === \"ChainExpression\"\n                        ? parent.parent\n                        : parent;\n\n                    if (astUtils.isCallee(maybeCallee)) {\n                        if (!bound) {\n                            bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.\n                            retv.isLexicalThis = (\n                                maybeCallee.parent.arguments.length === 1 &&\n                                maybeCallee.parent.arguments[0].type === \"ThisExpression\"\n                            );\n                        }\n                        parent = maybeCallee.parent;\n                    } else {\n                        return retv;\n                    }\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== currentNode) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        currentNode = parent;\n        parent = parent.parent;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\"unreachable\");\n}\n\n/**\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\n * @param {ASTNode[]} paramsList The list of parameters for a function\n * @returns {boolean} `true` if the list of parameters contains any duplicates\n */\nfunction hasDuplicateParams(paramsList) {\n    return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require using arrow functions for callbacks\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowNamedFunctions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowUnboundThis: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            preferArrowCallback: \"Unexpected function expression.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n\n        const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n        const allowNamedFunctions = options.allowNamedFunctions;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\n         * - this - A flag which shows there are one or more ThisExpression.\n         * - super - A flag which shows there are one or more Super.\n         * - meta - A flag which shows there are one or more MethProperty.\n         */\n        let stack = [];\n\n        /**\n         * Pushes new function scope with all `false` flags.\n         * @returns {void}\n         */\n        function enterScope() {\n            stack.push({ this: false, super: false, meta: false });\n        }\n\n        /**\n         * Pops a function scope from the stack.\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n         */\n        function exitScope() {\n            return stack.pop();\n        }\n\n        return {\n\n            // Reset internal state.\n            Program() {\n                stack = [];\n            },\n\n            // If there are below, it cannot replace with arrow functions merely.\n            ThisExpression() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.this = true;\n                }\n            },\n\n            Super() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.super = true;\n                }\n            },\n\n            MetaProperty(node) {\n                const info = stack[stack.length - 1];\n\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                    info.meta = true;\n                }\n            },\n\n            // To skip nested scopes.\n            FunctionDeclaration: enterScope,\n            \"FunctionDeclaration:exit\": exitScope,\n\n            // Main.\n            FunctionExpression: enterScope,\n            \"FunctionExpression:exit\"(node) {\n                const scopeInfo = exitScope();\n\n                // Skip named function expressions\n                if (allowNamedFunctions && node.id && node.id.name) {\n                    return;\n                }\n\n                // Skip generators.\n                if (node.generator) {\n                    return;\n                }\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                // Skip if it's using arguments.\n                const variable = getVariableOfArguments(context.getScope());\n\n                if (variable && variable.references.length > 0) {\n                    return;\n                }\n\n                // Reports if it's a callback which can replace with arrows.\n                const callbackInfo = getCallbackInfo(node);\n\n                if (callbackInfo.isCallback &&\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\n                    !scopeInfo.super &&\n                    !scopeInfo.meta\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"preferArrowCallback\",\n                        *fix(fixer) {\n                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {\n\n                                /*\n                                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\n                                 * is no way to determine what `this` should be, so don't perform any fixes.\n                                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                                 */\n                                return;\n                            }\n\n                            // Remove `.bind(this)` if exists.\n                            if (callbackInfo.isLexicalThis) {\n                                const memberNode = node.parent;\n\n                                /*\n                                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.\n                                 * E.g. `(foo || function(){}).bind(this)`\n                                 */\n                                if (memberNode.type !== \"MemberExpression\") {\n                                    return;\n                                }\n\n                                const callNode = memberNode.parent;\n                                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);\n                                const lastTokenToRemove = sourceCode.getLastToken(callNode);\n\n                                /*\n                                 * If the member expression is parenthesized, don't remove the right paren.\n                                 * E.g. `(function(){}.bind)(this)`\n                                 *                    ^^^^^^^^^^^^\n                                 */\n                                if (astUtils.isParenthesised(sourceCode, memberNode)) {\n                                    return;\n                                }\n\n                                // If comments exist in the `.bind(this)`, don't remove those.\n                                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                                    return;\n                                }\n\n                                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);\n                            }\n\n                            // Convert the function expression to an arrow function.\n                            const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);\n                            const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);\n\n                            if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {\n\n                                // Remove only extra tokens to keep comments.\n                                yield fixer.remove(functionToken);\n                                if (node.id) {\n                                    yield fixer.remove(node.id);\n                                }\n                            } else {\n\n                                // Remove extra tokens and spaces.\n                                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);\n                            }\n                            yield fixer.insertTextBefore(node.body, \"=> \");\n\n                            // Get the node that will become the new arrow function.\n                            let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n                            if (replacedNode.type === \"ChainExpression\") {\n                                replacedNode = replacedNode.parent;\n                            }\n\n                            /*\n                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n                             * though `foo || function() {}` is valid.\n                             */\n                            if (\n                                replacedNode.parent.type !== \"CallExpression\" &&\n                                replacedNode.parent.type !== \"ConditionalExpression\" &&\n                                !astUtils.isParenthesised(sourceCode, replacedNode) &&\n                                !astUtils.isParenthesised(sourceCode, node)\n                            ) {\n                                yield fixer.insertTextBefore(replacedNode, \"(\");\n                                yield fixer.insertTextAfter(replacedNode, \")\");\n                            }\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}