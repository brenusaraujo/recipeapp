{"ast":null,"code":"/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n * @param {CodePathSegment} segment A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\n\n\nfunction isConstructorFunction(node) {\n  return node.type === \"FunctionExpression\" && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n}\n/**\n * Checks whether a given node can be a constructor or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\n\n\nfunction isPossibleConstructor(node) {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"FunctionExpression\":\n    case \"ThisExpression\":\n    case \"MemberExpression\":\n    case \"CallExpression\":\n    case \"NewExpression\":\n    case \"ChainExpression\":\n    case \"YieldExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"MetaProperty\":\n      return true;\n\n    case \"Identifier\":\n      return node.name !== \"undefined\";\n\n    case \"AssignmentExpression\":\n      if ([\"=\", \"&&=\"].includes(node.operator)) {\n        return isPossibleConstructor(node.right);\n      }\n\n      if ([\"||=\", \"??=\"].includes(node.operator)) {\n        return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);\n      }\n      /**\n       * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\n       * An assignment expression with a mathematical operator can either evaluate to a primitive value,\n       * or throw, depending on the operands. Thus, it cannot evaluate to a constructor function.\n       */\n\n\n      return false;\n\n    case \"LogicalExpression\":\n      /*\n       * If the && operator short-circuits, the left side was falsy and therefore not a constructor, and if\n       * it doesn't short-circuit, it takes the value from the right side, so the right side must always be a\n       * possible constructor. A future improvement could verify that the left side could be truthy by\n       * excluding falsy literals.\n       */\n      if (node.operator === \"&&\") {\n        return isPossibleConstructor(node.right);\n      }\n\n      return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);\n\n    case \"ConditionalExpression\":\n      return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);\n\n    case \"SequenceExpression\":\n      {\n        const lastExpression = node.expressions[node.expressions.length - 1];\n        return isPossibleConstructor(lastExpression);\n      }\n\n    default:\n      return false;\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"require `super()` calls in constructors\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/constructor-super\"\n    },\n    schema: [],\n    messages: {\n      missingSome: \"Lacked a call of 'super()' in some code paths.\",\n      missingAll: \"Expected to call 'super()'.\",\n      duplicate: \"Unexpected duplicate 'super()'.\",\n      badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n      unexpected: \"Unexpected 'super()'.\"\n    }\n  },\n\n  create(context) {\n    /*\n     * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n     * Information for each constructor.\n     * - upper:      Information of the upper constructor.\n     * - hasExtends: A flag which shows whether own class has a valid `extends`\n     *               part.\n     * - scope:      The scope of own class.\n     * - codePath:   The code path object of the constructor.\n     */\n    let funcInfo = null;\n    /*\n     * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n     * Information for each code path segment.\n     * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n     * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n     * - validNodes:\n     */\n\n    let segInfoMap = Object.create(null);\n    /**\n     * Gets the flag which shows `super()` is called in some paths.\n     * @param {CodePathSegment} segment A code path segment to get.\n     * @returns {boolean} The flag which shows `super()` is called in some paths\n     */\n\n    function isCalledInSomePath(segment) {\n      return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n    }\n    /**\n     * Gets the flag which shows `super()` is called in all paths.\n     * @param {CodePathSegment} segment A code path segment to get.\n     * @returns {boolean} The flag which shows `super()` is called in all paths.\n     */\n\n\n    function isCalledInEveryPath(segment) {\n      /*\n       * If specific segment is the looped segment of the current segment,\n       * skip the segment.\n       * If not skipped, this never becomes true after a loop.\n       */\n      if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {\n        return true;\n      }\n\n      return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n    }\n\n    return {\n      /**\n       * Stacks a constructor information.\n       * @param {CodePath} codePath A code path which was started.\n       * @param {ASTNode} node The current node.\n       * @returns {void}\n       */\n      onCodePathStart(codePath, node) {\n        if (isConstructorFunction(node)) {\n          // Class > ClassBody > MethodDefinition > FunctionExpression\n          const classNode = node.parent.parent.parent;\n          const superClass = classNode.superClass;\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: true,\n            hasExtends: Boolean(superClass),\n            superIsConstructor: isPossibleConstructor(superClass),\n            codePath\n          };\n        } else {\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: false,\n            hasExtends: false,\n            superIsConstructor: false,\n            codePath\n          };\n        }\n      },\n\n      /**\n       * Pops a constructor information.\n       * And reports if `super()` lacked.\n       * @param {CodePath} codePath A code path which was ended.\n       * @param {ASTNode} node The current node.\n       * @returns {void}\n       */\n      onCodePathEnd(codePath, node) {\n        const hasExtends = funcInfo.hasExtends; // Pop.\n\n        funcInfo = funcInfo.upper;\n\n        if (!hasExtends) {\n          return;\n        } // Reports if `super()` lacked.\n\n\n        const segments = codePath.returnedSegments;\n        const calledInEveryPaths = segments.every(isCalledInEveryPath);\n        const calledInSomePaths = segments.some(isCalledInSomePath);\n\n        if (!calledInEveryPaths) {\n          context.report({\n            messageId: calledInSomePaths ? \"missingSome\" : \"missingAll\",\n            node: node.parent\n          });\n        }\n      },\n\n      /**\n       * Initialize information of a given code path segment.\n       * @param {CodePathSegment} segment A code path segment to initialize.\n       * @returns {void}\n       */\n      onCodePathSegmentStart(segment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        } // Initialize info.\n\n\n        const info = segInfoMap[segment.id] = {\n          calledInSomePaths: false,\n          calledInEveryPaths: false,\n          validNodes: []\n        }; // When there are previous segments, aggregates these.\n\n        const prevSegments = segment.prevSegments;\n\n        if (prevSegments.length > 0) {\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n        }\n      },\n\n      /**\n       * Update information of the code path segment when a code path was\n       * looped.\n       * @param {CodePathSegment} fromSegment The code path segment of the\n       *      end of a loop.\n       * @param {CodePathSegment} toSegment A code path segment of the head\n       *      of a loop.\n       * @returns {void}\n       */\n      onCodePathSegmentLoop(fromSegment, toSegment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        } // Update information inside of the loop.\n\n\n        const isRealLoop = toSegment.prevSegments.length >= 2;\n        funcInfo.codePath.traverseSegments({\n          first: toSegment,\n          last: fromSegment\n        }, segment => {\n          const info = segInfoMap[segment.id];\n          const prevSegments = segment.prevSegments; // Updates flags.\n\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath); // If flags become true anew, reports the valid nodes.\n\n          if (info.calledInSomePaths || isRealLoop) {\n            const nodes = info.validNodes;\n            info.validNodes = [];\n\n            for (let i = 0; i < nodes.length; ++i) {\n              const node = nodes[i];\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            }\n          }\n        });\n      },\n\n      /**\n       * Checks for a call of `super()`.\n       * @param {ASTNode} node A CallExpression node to check.\n       * @returns {void}\n       */\n      \"CallExpression:exit\"(node) {\n        if (!(funcInfo && funcInfo.isConstructor)) {\n          return;\n        } // Skips except `super()`.\n\n\n        if (node.callee.type !== \"Super\") {\n          return;\n        } // Reports if needed.\n\n\n        if (funcInfo.hasExtends) {\n          const segments = funcInfo.codePath.currentSegments;\n          let duplicate = false;\n          let info = null;\n\n          for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            if (segment.reachable) {\n              info = segInfoMap[segment.id];\n              duplicate = duplicate || info.calledInSomePaths;\n              info.calledInSomePaths = info.calledInEveryPaths = true;\n            }\n          }\n\n          if (info) {\n            if (duplicate) {\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            } else if (!funcInfo.superIsConstructor) {\n              context.report({\n                messageId: \"badSuper\",\n                node\n              });\n            } else {\n              info.validNodes.push(node);\n            }\n          }\n        } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n          context.report({\n            messageId: \"unexpected\",\n            node\n          });\n        }\n      },\n\n      /**\n       * Set the mark to the returned path as `super()` was called.\n       * @param {ASTNode} node A ReturnStatement node to check.\n       * @returns {void}\n       */\n      ReturnStatement(node) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        } // Skips if no argument.\n\n\n        if (!node.argument) {\n          return;\n        } // Returning argument is a substitute of 'super()'.\n\n\n        const segments = funcInfo.codePath.currentSegments;\n\n        for (let i = 0; i < segments.length; ++i) {\n          const segment = segments[i];\n\n          if (segment.reachable) {\n            const info = segInfoMap[segment.id];\n            info.calledInSomePaths = info.calledInEveryPaths = true;\n          }\n        }\n      },\n\n      /**\n       * Resets state.\n       * @returns {void}\n       */\n      \"Program:exit\"() {\n        segInfoMap = Object.create(null);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["isReachable","segment","reachable","isConstructorFunction","node","type","parent","kind","isPossibleConstructor","name","includes","operator","right","left","alternate","consequent","lastExpression","expressions","length","module","exports","meta","docs","description","category","recommended","url","schema","messages","missingSome","missingAll","duplicate","badSuper","unexpected","create","context","funcInfo","segInfoMap","Object","isCalledInSomePath","id","calledInSomePaths","isCalledInEveryPath","nextSegments","isLoopedPrevSegment","calledInEveryPaths","onCodePathStart","codePath","classNode","superClass","upper","isConstructor","hasExtends","Boolean","superIsConstructor","onCodePathEnd","segments","returnedSegments","every","some","report","messageId","onCodePathSegmentStart","info","validNodes","prevSegments","onCodePathSegmentLoop","fromSegment","toSegment","isRealLoop","traverseSegments","first","last","nodes","i","callee","currentSegments","push","ReturnStatement","argument"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/constructor-super.js"],"sourcesContent":["/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n * @param {CodePathSegment} segment A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"ChainExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            if ([\"=\", \"&&=\"].includes(node.operator)) {\n                return isPossibleConstructor(node.right);\n            }\n\n            if ([\"||=\", \"??=\"].includes(node.operator)) {\n                return (\n                    isPossibleConstructor(node.left) ||\n                    isPossibleConstructor(node.right)\n                );\n            }\n\n            /**\n             * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\n             * An assignment expression with a mathematical operator can either evaluate to a primitive value,\n             * or throw, depending on the operands. Thus, it cannot evaluate to a constructor function.\n             */\n            return false;\n\n        case \"LogicalExpression\":\n\n            /*\n             * If the && operator short-circuits, the left side was falsy and therefore not a constructor, and if\n             * it doesn't short-circuit, it takes the value from the right side, so the right side must always be a\n             * possible constructor. A future improvement could verify that the left side could be truthy by\n             * excluding falsy literals.\n             */\n            if (node.operator === \"&&\") {\n                return isPossibleConstructor(node.right);\n            }\n\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/constructor-super\"\n        },\n\n        schema: [],\n\n        messages: {\n            missingSome: \"Lacked a call of 'super()' in some code paths.\",\n            missingAll: \"Expected to call 'super()'.\",\n\n            duplicate: \"Unexpected duplicate 'super()'.\",\n            badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n            unexpected: \"Unexpected 'super()'.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath A code path which was started.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath A code path which was ended.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const segments = codePath.returnedSegments;\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\n                const calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        messageId: calledInSomePaths\n                            ? \"missingSome\"\n                            : \"missingAll\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                const prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                const isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    segment => {\n                        const info = segInfoMap[segment.id];\n                        const prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    messageId: \"duplicate\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    const segments = funcInfo.codePath.currentSegments;\n                    let duplicate = false;\n                    let info = null;\n\n                    for (let i = 0; i < segments.length; ++i) {\n                        const segment = segments[i];\n\n                        if (segment.reachable) {\n                            info = segInfoMap[segment.id];\n\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (info) {\n                        if (duplicate) {\n                            context.report({\n                                messageId: \"duplicate\",\n                                node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                messageId: \"badSuper\",\n                                node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        messageId: \"unexpected\",\n                        node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.codePath.currentSegments;\n\n                for (let i = 0; i < segments.length; ++i) {\n                    const segment = segments[i];\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}