{"ast":null,"code":"/**\n * @fileoverview Prefers object spread property over Object.assign\n * @author Sharmila Jesupaul\n * See LICENSE file in root directory for full license.\n */\n\"use strict\";\n\nconst {\n  CALL,\n  ReferenceTracker\n} = require(\"eslint-utils\");\n\nconst {\n  isCommaToken,\n  isOpeningParenToken,\n  isClosingParenToken,\n  isParenthesised\n} = require(\"./utils/ast-utils\");\n\nconst ANY_SPACE = /\\s/u;\n/**\n * Helper that checks if the Object.assign call has array spread\n * @param {ASTNode} node The node that the rule warns on\n * @returns {boolean} - Returns true if the Object.assign call has array spread\n */\n\nfunction hasArraySpread(node) {\n  return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n/**\n * Determines whether the given node is an accessor property (getter/setter).\n * @param {ASTNode} node Node to check.\n * @returns {boolean} `true` if the node is a getter or a setter.\n */\n\n\nfunction isAccessorProperty(node) {\n  return node.type === \"Property\" && (node.kind === \"get\" || node.kind === \"set\");\n}\n/**\n * Determines whether the given object expression node has accessor properties (getters/setters).\n * @param {ASTNode} node `ObjectExpression` node to check.\n * @returns {boolean} `true` if the node has at least one getter/setter.\n */\n\n\nfunction hasAccessors(node) {\n  return node.properties.some(isAccessorProperty);\n}\n/**\n * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).\n * @param {ASTNode} node `CallExpression` node to check.\n * @returns {boolean} `true` if the node has at least one argument that is an object expression with at least one getter/setter.\n */\n\n\nfunction hasArgumentsWithAccessors(node) {\n  return node.arguments.filter(arg => arg.type === \"ObjectExpression\").some(hasAccessors);\n}\n/**\n * Helper that checks if the node needs parentheses to be valid JS.\n * The default is to wrap the node in parentheses to avoid parsing errors.\n * @param {ASTNode} node The node that the rule warns on\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} - Returns true if the node needs parentheses\n */\n\n\nfunction needsParens(node, sourceCode) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"VariableDeclarator\":\n    case \"ArrayExpression\":\n    case \"ReturnStatement\":\n    case \"CallExpression\":\n    case \"Property\":\n      return false;\n\n    case \"AssignmentExpression\":\n      return parent.left === node && !isParenthesised(sourceCode, node);\n\n    default:\n      return !isParenthesised(sourceCode, node);\n  }\n}\n/**\n * Determines if an argument needs parentheses. The default is to not add parens.\n * @param {ASTNode} node The node to be checked.\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} True if the node needs parentheses\n */\n\n\nfunction argNeedsParens(node, sourceCode) {\n  switch (node.type) {\n    case \"AssignmentExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ConditionalExpression\":\n      return !isParenthesised(sourceCode, node);\n\n    default:\n      return false;\n  }\n}\n/**\n * Get the parenthesis tokens of a given ObjectExpression node.\n * This includes the braces of the object literal and enclosing parentheses.\n * @param {ASTNode} node The node to get.\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\n */\n\n\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n  const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n  let leftNext = sourceCode.getTokenBefore(node);\n  let rightNext = sourceCode.getTokenAfter(node); // Note: don't include the parens of the argument list.\n\n  while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {\n    parens.push(leftNext, rightNext);\n    leftNext = sourceCode.getTokenBefore(leftNext);\n    rightNext = sourceCode.getTokenAfter(rightNext);\n  }\n\n  return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The end of the range of the token and around whitespaces.\n */\n\n\nfunction getStartWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let start = token.range[0]; // If the previous token is a line comment then skip this step to avoid commenting this token out.\n\n  {\n    const prevToken = sourceCode.getTokenBefore(token, {\n      includeComments: true\n    });\n\n    if (prevToken && prevToken.type === \"Line\") {\n      return start;\n    }\n  } // Detect spaces before the token.\n\n  while (ANY_SPACE.test(text[start - 1] || \"\")) {\n    start -= 1;\n  }\n\n  return start;\n}\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The start of the range of the token and around whitespaces.\n */\n\n\nfunction getEndWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let end = token.range[1]; // Detect spaces after the token.\n\n  while (ANY_SPACE.test(text[end] || \"\")) {\n    end += 1;\n  }\n\n  return end;\n}\n/**\n * Autofixes the Object.assign call to use an object spread instead.\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\n * @param {string} sourceCode sourceCode of the Object.assign call\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\n */\n\n\nfunction defineFixer(node, sourceCode) {\n  return function* (fixer) {\n    const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n    const rightParen = sourceCode.getLastToken(node); // Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.\n\n    yield fixer.removeRange([node.range[0], leftParen.range[0]]); // Replace the parens of argument list to braces.\n\n    if (needsParens(node, sourceCode)) {\n      yield fixer.replaceText(leftParen, \"({\");\n      yield fixer.replaceText(rightParen, \"})\");\n    } else {\n      yield fixer.replaceText(leftParen, \"{\");\n      yield fixer.replaceText(rightParen, \"}\");\n    } // Process arguments.\n\n\n    for (const argNode of node.arguments) {\n      const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n      const left = innerParens.shift();\n      const right = innerParens.pop();\n\n      if (argNode.type === \"ObjectExpression\") {\n        const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n        const maybeArgumentComma = sourceCode.getTokenAfter(right);\n        /*\n         * Make bare this object literal.\n         * And remove spaces inside of the braces for better formatting.\n         */\n\n        for (const innerParen of innerParens) {\n          yield fixer.remove(innerParen);\n        }\n\n        const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n        const rightRange = [Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\n        right.range[1]];\n        yield fixer.removeRange(leftRange);\n        yield fixer.removeRange(rightRange); // Remove the comma of this argument if it's duplication.\n\n        if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {\n          yield fixer.remove(maybeArgumentComma);\n        }\n      } else {\n        // Make spread.\n        if (argNeedsParens(argNode, sourceCode)) {\n          yield fixer.insertTextBefore(left, \"...(\");\n          yield fixer.insertTextAfter(right, \")\");\n        } else {\n          yield fixer.insertTextBefore(left, \"...\");\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n      useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const trackMap = {\n          Object: {\n            assign: {\n              [CALL]: true\n            }\n          }\n        }; // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          if (node.arguments.length >= 1 && node.arguments[0].type === \"ObjectExpression\" && !hasArraySpread(node) && !(node.arguments.length > 1 && hasArgumentsWithAccessors(node))) {\n            const messageId = node.arguments.length === 1 ? \"useLiteralMessage\" : \"useSpreadMessage\";\n            const fix = defineFixer(node, sourceCode);\n            context.report({\n              node,\n              messageId,\n              fix\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["CALL","ReferenceTracker","require","isCommaToken","isOpeningParenToken","isClosingParenToken","isParenthesised","ANY_SPACE","hasArraySpread","node","arguments","some","arg","type","isAccessorProperty","kind","hasAccessors","properties","hasArgumentsWithAccessors","filter","needsParens","sourceCode","parent","left","argNeedsParens","getParenTokens","leftArgumentListParen","parens","getFirstToken","getLastToken","leftNext","getTokenBefore","rightNext","getTokenAfter","range","push","sort","a","b","getStartWithSpaces","token","text","start","prevToken","includeComments","test","getEndWithSpaces","end","defineFixer","fixer","leftParen","callee","rightParen","removeRange","replaceText","argNode","innerParens","shift","right","pop","maybeTrailingComma","maybeArgumentComma","innerParen","remove","leftRange","rightRange","Math","max","length","insertTextBefore","insertTextAfter","module","exports","meta","docs","description","category","recommended","url","schema","fixable","messages","useSpreadMessage","useLiteralMessage","create","context","getSourceCode","Program","scope","getScope","tracker","trackMap","Object","assign","iterateGlobalReferences","messageId","fix","report"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/prefer-object-spread.js"],"sourcesContent":["/**\n * @fileoverview Prefers object spread property over Object.assign\n * @author Sharmila Jesupaul\n * See LICENSE file in root directory for full license.\n */\n\n\"use strict\";\n\nconst { CALL, ReferenceTracker } = require(\"eslint-utils\");\nconst {\n    isCommaToken,\n    isOpeningParenToken,\n    isClosingParenToken,\n    isParenthesised\n} = require(\"./utils/ast-utils\");\n\nconst ANY_SPACE = /\\s/u;\n\n/**\n * Helper that checks if the Object.assign call has array spread\n * @param {ASTNode} node The node that the rule warns on\n * @returns {boolean} - Returns true if the Object.assign call has array spread\n */\nfunction hasArraySpread(node) {\n    return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n\n/**\n * Determines whether the given node is an accessor property (getter/setter).\n * @param {ASTNode} node Node to check.\n * @returns {boolean} `true` if the node is a getter or a setter.\n */\nfunction isAccessorProperty(node) {\n    return node.type === \"Property\" &&\n        (node.kind === \"get\" || node.kind === \"set\");\n}\n\n/**\n * Determines whether the given object expression node has accessor properties (getters/setters).\n * @param {ASTNode} node `ObjectExpression` node to check.\n * @returns {boolean} `true` if the node has at least one getter/setter.\n */\nfunction hasAccessors(node) {\n    return node.properties.some(isAccessorProperty);\n}\n\n/**\n * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).\n * @param {ASTNode} node `CallExpression` node to check.\n * @returns {boolean} `true` if the node has at least one argument that is an object expression with at least one getter/setter.\n */\nfunction hasArgumentsWithAccessors(node) {\n    return node.arguments\n        .filter(arg => arg.type === \"ObjectExpression\")\n        .some(hasAccessors);\n}\n\n/**\n * Helper that checks if the node needs parentheses to be valid JS.\n * The default is to wrap the node in parentheses to avoid parsing errors.\n * @param {ASTNode} node The node that the rule warns on\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} - Returns true if the node needs parentheses\n */\nfunction needsParens(node, sourceCode) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"VariableDeclarator\":\n        case \"ArrayExpression\":\n        case \"ReturnStatement\":\n        case \"CallExpression\":\n        case \"Property\":\n            return false;\n        case \"AssignmentExpression\":\n            return parent.left === node && !isParenthesised(sourceCode, node);\n        default:\n            return !isParenthesised(sourceCode, node);\n    }\n}\n\n/**\n * Determines if an argument needs parentheses. The default is to not add parens.\n * @param {ASTNode} node The node to be checked.\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} True if the node needs parentheses\n */\nfunction argNeedsParens(node, sourceCode) {\n    switch (node.type) {\n        case \"AssignmentExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ConditionalExpression\":\n            return !isParenthesised(sourceCode, node);\n        default:\n            return false;\n    }\n}\n\n/**\n * Get the parenthesis tokens of a given ObjectExpression node.\n * This includes the braces of the object literal and enclosing parentheses.\n * @param {ASTNode} node The node to get.\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\n */\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n    const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n    let leftNext = sourceCode.getTokenBefore(node);\n    let rightNext = sourceCode.getTokenAfter(node);\n\n    // Note: don't include the parens of the argument list.\n    while (\n        leftNext &&\n        rightNext &&\n        leftNext.range[0] > leftArgumentListParen.range[0] &&\n        isOpeningParenToken(leftNext) &&\n        isClosingParenToken(rightNext)\n    ) {\n        parens.push(leftNext, rightNext);\n        leftNext = sourceCode.getTokenBefore(leftNext);\n        rightNext = sourceCode.getTokenAfter(rightNext);\n    }\n\n    return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The end of the range of the token and around whitespaces.\n */\nfunction getStartWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let start = token.range[0];\n\n    // If the previous token is a line comment then skip this step to avoid commenting this token out.\n    {\n        const prevToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n        if (prevToken && prevToken.type === \"Line\") {\n            return start;\n        }\n    }\n\n    // Detect spaces before the token.\n    while (ANY_SPACE.test(text[start - 1] || \"\")) {\n        start -= 1;\n    }\n\n    return start;\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The start of the range of the token and around whitespaces.\n */\nfunction getEndWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let end = token.range[1];\n\n    // Detect spaces after the token.\n    while (ANY_SPACE.test(text[end] || \"\")) {\n        end += 1;\n    }\n\n    return end;\n}\n\n/**\n * Autofixes the Object.assign call to use an object spread instead.\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\n * @param {string} sourceCode sourceCode of the Object.assign call\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\n */\nfunction defineFixer(node, sourceCode) {\n    return function *(fixer) {\n        const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n        const rightParen = sourceCode.getLastToken(node);\n\n        // Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.\n        yield fixer.removeRange([node.range[0], leftParen.range[0]]);\n\n        // Replace the parens of argument list to braces.\n        if (needsParens(node, sourceCode)) {\n            yield fixer.replaceText(leftParen, \"({\");\n            yield fixer.replaceText(rightParen, \"})\");\n        } else {\n            yield fixer.replaceText(leftParen, \"{\");\n            yield fixer.replaceText(rightParen, \"}\");\n        }\n\n        // Process arguments.\n        for (const argNode of node.arguments) {\n            const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n            const left = innerParens.shift();\n            const right = innerParens.pop();\n\n            if (argNode.type === \"ObjectExpression\") {\n                const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n                const maybeArgumentComma = sourceCode.getTokenAfter(right);\n\n                /*\n                 * Make bare this object literal.\n                 * And remove spaces inside of the braces for better formatting.\n                 */\n                for (const innerParen of innerParens) {\n                    yield fixer.remove(innerParen);\n                }\n                const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n                const rightRange = [\n                    Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\n                    right.range[1]\n                ];\n\n                yield fixer.removeRange(leftRange);\n                yield fixer.removeRange(rightRange);\n\n                // Remove the comma of this argument if it's duplication.\n                if (\n                    (argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) &&\n                    isCommaToken(maybeArgumentComma)\n                ) {\n                    yield fixer.remove(maybeArgumentComma);\n                }\n            } else {\n\n                // Make spread.\n                if (argNeedsParens(argNode, sourceCode)) {\n                    yield fixer.insertTextBefore(left, \"...(\");\n                    yield fixer.insertTextAfter(right, \")\");\n                } else {\n                    yield fixer.insertTextBefore(left, \"...\");\n                }\n            }\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description:\n                \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n            useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Object: {\n                        assign: { [CALL]: true }\n                    }\n                };\n\n                // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\n                    if (\n                        node.arguments.length >= 1 &&\n                        node.arguments[0].type === \"ObjectExpression\" &&\n                        !hasArraySpread(node) &&\n                        !(\n                            node.arguments.length > 1 &&\n                            hasArgumentsWithAccessors(node)\n                        )\n                    ) {\n                        const messageId = node.arguments.length === 1\n                            ? \"useLiteralMessage\"\n                            : \"useSpreadMessage\";\n                        const fix = defineFixer(node, sourceCode);\n\n                        context.report({ node, messageId, fix });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}