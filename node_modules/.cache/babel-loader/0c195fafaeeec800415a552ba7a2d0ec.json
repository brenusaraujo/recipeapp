{"ast":null,"code":"/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce sorted import declarations within modules\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-imports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreCase: {\n          type: \"boolean\",\n          default: false\n        },\n        memberSyntaxSortOrder: {\n          type: \"array\",\n          items: {\n            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n          },\n          uniqueItems: true,\n          minItems: 4,\n          maxItems: 4\n        },\n        ignoreDeclarationSort: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreMemberSort: {\n          type: \"boolean\",\n          default: false\n        },\n        allowSeparatedGroups: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      sortImportsAlphabetically: \"Imports should be sorted alphabetically.\",\n      sortMembersAlphabetically: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n      unexpectedSyntaxOrder: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\"\n    }\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {},\n          ignoreCase = configuration.ignoreCase || false,\n          ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n          ignoreMemberSort = configuration.ignoreMemberSort || false,\n          memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n          allowSeparatedGroups = configuration.allowSeparatedGroups || false,\n          sourceCode = context.getSourceCode();\n    let previousDeclaration = null;\n    /**\n     * Gets the used member syntax style.\n     *\n     * import \"my-module.js\" --> none\n     * import * as myModule from \"my-module.js\" --> all\n     * import {myMember} from \"my-module.js\" --> single\n     * import {foo, bar} from  \"my-module.js\" --> multiple\n     * @param {ASTNode} node the ImportDeclaration node.\n     * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n     */\n\n    function usedMemberSyntax(node) {\n      if (node.specifiers.length === 0) {\n        return \"none\";\n      }\n\n      if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n        return \"all\";\n      }\n\n      if (node.specifiers.length === 1) {\n        return \"single\";\n      }\n\n      return \"multiple\";\n    }\n    /**\n     * Gets the group by member parameter index for given declaration.\n     * @param {ASTNode} node the ImportDeclaration node.\n     * @returns {number} the declaration group by member index.\n     */\n\n\n    function getMemberParameterGroupIndex(node) {\n      return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n    }\n    /**\n     * Gets the local name of the first imported module.\n     * @param {ASTNode} node the ImportDeclaration node.\n     * @returns {?string} the local name of the first imported module.\n     */\n\n\n    function getFirstLocalMemberName(node) {\n      if (node.specifiers[0]) {\n        return node.specifiers[0].local.name;\n      }\n\n      return null;\n    }\n    /**\n     * Calculates number of lines between two nodes. It is assumed that the given `left` node appears before\n     * the given `right` node in the source code. Lines are counted from the end of the `left` node till the\n     * start of the `right` node. If the given nodes are on the same line, it returns `0`, same as if they were\n     * on two consecutive lines.\n     * @param {ASTNode} left node that appears before the given `right` node.\n     * @param {ASTNode} right node that appears after the given `left` node.\n     * @returns {number} number of lines between nodes.\n     */\n\n\n    function getNumberOfLinesBetween(left, right) {\n      return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);\n    }\n\n    return {\n      ImportDeclaration(node) {\n        if (!ignoreDeclarationSort) {\n          if (previousDeclaration && allowSeparatedGroups && getNumberOfLinesBetween(previousDeclaration, node) > 0) {\n            // reset declaration sort\n            previousDeclaration = null;\n          }\n\n          if (previousDeclaration) {\n            const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                  previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n            let currentLocalMemberName = getFirstLocalMemberName(node),\n                previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n            if (ignoreCase) {\n              previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n              currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n            }\n            /*\n             * When the current declaration uses a different member syntax,\n             * then check if the ordering is correct.\n             * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n             */\n\n\n            if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n              if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                context.report({\n                  node,\n                  messageId: \"unexpectedSyntaxOrder\",\n                  data: {\n                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                  }\n                });\n              }\n            } else {\n              if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {\n                context.report({\n                  node,\n                  messageId: \"sortImportsAlphabetically\"\n                });\n              }\n            }\n          }\n\n          previousDeclaration = node;\n        }\n\n        if (!ignoreMemberSort) {\n          const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n          const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n          const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n          if (firstUnsortedIndex !== -1) {\n            context.report({\n              node: importSpecifiers[firstUnsortedIndex],\n              messageId: \"sortMembersAlphabetically\",\n              data: {\n                memberName: importSpecifiers[firstUnsortedIndex].local.name\n              },\n\n              fix(fixer) {\n                if (importSpecifiers.some(specifier => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n                  // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                  return null;\n                }\n\n                return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers // Clone the importSpecifiers array to avoid mutating it\n                .slice() // Sort the array into the desired order\n                .sort((specifierA, specifierB) => {\n                  const aName = getSortableName(specifierA);\n                  const bName = getSortableName(specifierB);\n                  return aName > bName ? 1 : -1;\n                }) // Build a string out of the sorted list of import specifiers and the text between the originals\n                .reduce((sourceText, specifier, index) => {\n                  const textAfterSpecifier = index === importSpecifiers.length - 1 ? \"\" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n                  return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                }, \"\"));\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","ignoreCase","default","memberSyntaxSortOrder","items","enum","uniqueItems","minItems","maxItems","ignoreDeclarationSort","ignoreMemberSort","allowSeparatedGroups","additionalProperties","fixable","messages","sortImportsAlphabetically","sortMembersAlphabetically","unexpectedSyntaxOrder","create","context","configuration","options","sourceCode","getSourceCode","previousDeclaration","usedMemberSyntax","node","specifiers","length","getMemberParameterGroupIndex","indexOf","getFirstLocalMemberName","local","name","getNumberOfLinesBetween","left","right","Math","max","loc","start","line","end","ImportDeclaration","currentMemberSyntaxGroupIndex","previousMemberSyntaxGroupIndex","currentLocalMemberName","previousLocalMemberName","toLowerCase","report","messageId","data","syntaxA","syntaxB","importSpecifiers","filter","specifier","getSortableName","firstUnsortedIndex","map","findIndex","index","array","memberName","fix","fixer","some","getCommentsBefore","getCommentsAfter","replaceTextRange","range","slice","sort","specifierA","specifierB","aName","bName","reduce","sourceText","textAfterSpecifier","getText"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/sort-imports.js"],"sourcesContent":["/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce sorted import declarations within modules\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-imports\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    memberSyntaxSortOrder: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n                        },\n                        uniqueItems: true,\n                        minItems: 4,\n                        maxItems: 4\n                    },\n                    ignoreDeclarationSort: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreMemberSort: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowSeparatedGroups: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            sortImportsAlphabetically: \"Imports should be sorted alphabetically.\",\n            sortMembersAlphabetically: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n            unexpectedSyntaxOrder: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\"\n        }\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n            ignoreMemberSort = configuration.ignoreMemberSort || false,\n            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n            allowSeparatedGroups = configuration.allowSeparatedGroups || false,\n            sourceCode = context.getSourceCode();\n        let previousDeclaration = null;\n\n        /**\n         * Gets the used member syntax style.\n         *\n         * import \"my-module.js\" --> none\n         * import * as myModule from \"my-module.js\" --> all\n         * import {myMember} from \"my-module.js\" --> single\n         * import {foo, bar} from  \"my-module.js\" --> multiple\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n         */\n        function usedMemberSyntax(node) {\n            if (node.specifiers.length === 0) {\n                return \"none\";\n            }\n            if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n                return \"all\";\n            }\n            if (node.specifiers.length === 1) {\n                return \"single\";\n            }\n            return \"multiple\";\n\n        }\n\n        /**\n         * Gets the group by member parameter index for given declaration.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {number} the declaration group by member index.\n         */\n        function getMemberParameterGroupIndex(node) {\n            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n        }\n\n        /**\n         * Gets the local name of the first imported module.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {?string} the local name of the first imported module.\n         */\n        function getFirstLocalMemberName(node) {\n            if (node.specifiers[0]) {\n                return node.specifiers[0].local.name;\n            }\n            return null;\n\n        }\n\n        /**\n         * Calculates number of lines between two nodes. It is assumed that the given `left` node appears before\n         * the given `right` node in the source code. Lines are counted from the end of the `left` node till the\n         * start of the `right` node. If the given nodes are on the same line, it returns `0`, same as if they were\n         * on two consecutive lines.\n         * @param {ASTNode} left node that appears before the given `right` node.\n         * @param {ASTNode} right node that appears after the given `left` node.\n         * @returns {number} number of lines between nodes.\n         */\n        function getNumberOfLinesBetween(left, right) {\n            return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);\n        }\n\n        return {\n            ImportDeclaration(node) {\n                if (!ignoreDeclarationSort) {\n                    if (\n                        previousDeclaration &&\n                        allowSeparatedGroups &&\n                        getNumberOfLinesBetween(previousDeclaration, node) > 0\n                    ) {\n\n                        // reset declaration sort\n                        previousDeclaration = null;\n                    }\n\n                    if (previousDeclaration) {\n                        const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                            previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n                        let currentLocalMemberName = getFirstLocalMemberName(node),\n                            previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n                        if (ignoreCase) {\n                            previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n                            currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n                        }\n\n                        /*\n                         * When the current declaration uses a different member syntax,\n                         * then check if the ordering is correct.\n                         * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n                         */\n                        if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n                            if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                                context.report({\n                                    node,\n                                    messageId: \"unexpectedSyntaxOrder\",\n                                    data: {\n                                        syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                                        syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                                    }\n                                });\n                            }\n                        } else {\n                            if (previousLocalMemberName &&\n                                currentLocalMemberName &&\n                                currentLocalMemberName < previousLocalMemberName\n                            ) {\n                                context.report({\n                                    node,\n                                    messageId: \"sortImportsAlphabetically\"\n                                });\n                            }\n                        }\n                    }\n\n                    previousDeclaration = node;\n                }\n\n                if (!ignoreMemberSort) {\n                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n                    if (firstUnsortedIndex !== -1) {\n                        context.report({\n                            node: importSpecifiers[firstUnsortedIndex],\n                            messageId: \"sortMembersAlphabetically\",\n                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },\n                            fix(fixer) {\n                                if (importSpecifiers.some(specifier =>\n                                    sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n\n                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(\n                                    [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],\n                                    importSpecifiers\n\n                                        // Clone the importSpecifiers array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((specifierA, specifierB) => {\n                                            const aName = getSortableName(specifierA);\n                                            const bName = getSortableName(specifierB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of import specifiers and the text between the originals\n                                        .reduce((sourceText, specifier, index) => {\n                                            const textAfterSpecifier = index === importSpecifiers.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                                        }, \"\")\n                                );\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}