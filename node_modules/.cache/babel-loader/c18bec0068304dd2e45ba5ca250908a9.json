{"ast":null,"code":"/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce linebreaks after opening and before closing array brackets\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-bracket-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\"]\n      }, {\n        type: \"object\",\n        properties: {\n          multiline: {\n            type: \"boolean\"\n          },\n          minItems: {\n            type: [\"integer\", \"null\"],\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n      unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n      missingOpeningLinebreak: \"A linebreak is required after '['.\",\n      missingClosingLinebreak: \"A linebreak is required before ']'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} option An option value to parse.\n     * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n     */\n\n    function normalizeOptionValue(option) {\n      let consistent = false;\n      let multiline = false;\n      let minItems = 0;\n\n      if (option) {\n        if (option === \"consistent\") {\n          consistent = true;\n          minItems = Number.POSITIVE_INFINITY;\n        } else if (option === \"always\" || option.minItems === 0) {\n          minItems = 0;\n        } else if (option === \"never\") {\n          minItems = Number.POSITIVE_INFINITY;\n        } else {\n          multiline = Boolean(option.multiline);\n          minItems = option.minItems || Number.POSITIVE_INFINITY;\n        }\n      } else {\n        consistent = false;\n        multiline = true;\n        minItems = Number.POSITIVE_INFINITY;\n      }\n\n      return {\n        consistent,\n        multiline,\n        minItems\n      };\n    }\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} options An option value to parse.\n     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n     */\n\n\n    function normalizeOptions(options) {\n      const value = normalizeOptionValue(options);\n      return {\n        ArrayExpression: value,\n        ArrayPattern: value\n      };\n    }\n    /**\n     * Reports that there shouldn't be a linebreak after the first token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportNoBeginningLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"unexpectedOpeningLinebreak\",\n\n        fix(fixer) {\n          const nextToken = sourceCode.getTokenAfter(token, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(nextToken)) {\n            return null;\n          }\n\n          return fixer.removeRange([token.range[1], nextToken.range[0]]);\n        }\n\n      });\n    }\n    /**\n     * Reports that there shouldn't be a linebreak before the last token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportNoEndingLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"unexpectedClosingLinebreak\",\n\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(token, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(previousToken)) {\n            return null;\n          }\n\n          return fixer.removeRange([previousToken.range[1], token.range[0]]);\n        }\n\n      });\n    }\n    /**\n     * Reports that there should be a linebreak after the first token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportRequiredBeginningLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingOpeningLinebreak\",\n\n        fix(fixer) {\n          return fixer.insertTextAfter(token, \"\\n\");\n        }\n\n      });\n    }\n    /**\n     * Reports that there should be a linebreak before the last token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportRequiredEndingLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingClosingLinebreak\",\n\n        fix(fixer) {\n          return fixer.insertTextBefore(token, \"\\n\");\n        }\n\n      });\n    }\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node A node to check. This is an ArrayExpression node or an ArrayPattern node.\n     * @returns {void}\n     */\n\n\n    function check(node) {\n      const elements = node.elements;\n      const normalizedOptions = normalizeOptions(context.options[0]);\n      const options = normalizedOptions[node.type];\n      const openBracket = sourceCode.getFirstToken(node);\n      const closeBracket = sourceCode.getLastToken(node);\n      const firstIncComment = sourceCode.getTokenAfter(openBracket, {\n        includeComments: true\n      });\n      const lastIncComment = sourceCode.getTokenBefore(closeBracket, {\n        includeComments: true\n      });\n      const first = sourceCode.getTokenAfter(openBracket);\n      const last = sourceCode.getTokenBefore(closeBracket);\n      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === \"Block\" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && openBracket.loc.end.line !== first.loc.start.line;\n      /*\n       * Use tokens or comments to check multiline or not.\n       * But use only tokens to check whether linebreaks are needed.\n       * This allows:\n       *     var arr = [ // eslint-disable-line foo\n       *         'a'\n       *     ]\n       */\n\n      if (needsLinebreaks) {\n        if (astUtils.isTokenOnSameLine(openBracket, first)) {\n          reportRequiredBeginningLinebreak(node, openBracket);\n        }\n\n        if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n          reportRequiredEndingLinebreak(node, closeBracket);\n        }\n      } else {\n        if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n          reportNoBeginningLinebreak(node, openBracket);\n        }\n\n        if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n          reportNoEndingLinebreak(node, closeBracket);\n        }\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      ArrayPattern: check,\n      ArrayExpression: check\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","multiline","minItems","minimum","additionalProperties","messages","unexpectedOpeningLinebreak","unexpectedClosingLinebreak","missingOpeningLinebreak","missingClosingLinebreak","create","context","sourceCode","getSourceCode","normalizeOptionValue","option","consistent","Number","POSITIVE_INFINITY","Boolean","normalizeOptions","options","value","ArrayExpression","ArrayPattern","reportNoBeginningLinebreak","node","token","report","loc","messageId","fix","fixer","nextToken","getTokenAfter","includeComments","isCommentToken","removeRange","range","reportNoEndingLinebreak","previousToken","getTokenBefore","reportRequiredBeginningLinebreak","insertTextAfter","reportRequiredEndingLinebreak","insertTextBefore","check","elements","normalizedOptions","openBracket","getFirstToken","closeBracket","getLastToken","firstIncComment","lastIncComment","first","last","needsLinebreaks","length","start","line","end","isTokenOnSameLine"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/array-bracket-newline.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce linebreaks after opening and before closing array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-bracket-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n            unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n            missingOpeningLinebreak: \"A linebreak is required after '['.\",\n            missingClosingLinebreak: \"A linebreak is required before ']'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} option An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(option) {\n            let consistent = false;\n            let multiline = false;\n            let minItems = 0;\n\n            if (option) {\n                if (option === \"consistent\") {\n                    consistent = true;\n                    minItems = Number.POSITIVE_INFINITY;\n                } else if (option === \"always\" || option.minItems === 0) {\n                    minItems = 0;\n                } else if (option === \"never\") {\n                    minItems = Number.POSITIVE_INFINITY;\n                } else {\n                    multiline = Boolean(option.multiline);\n                    minItems = option.minItems || Number.POSITIVE_INFINITY;\n                }\n            } else {\n                consistent = false;\n                multiline = true;\n                minItems = Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedOpeningLinebreak\",\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(nextToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedClosingLinebreak\",\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(previousToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingOpeningLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingClosingLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ArrayExpression node or an ArrayPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n            const openBracket = sourceCode.getFirstToken(node);\n            const closeBracket = sourceCode.getLastToken(node);\n            const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });\n            const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });\n            const first = sourceCode.getTokenAfter(openBracket);\n            const last = sourceCode.getTokenBefore(closeBracket);\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elements.length > 0 &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line\n                ) ||\n                (\n                    elements.length === 0 &&\n                    firstIncComment.type === \"Block\" &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line &&\n                    firstIncComment === lastIncComment\n                ) ||\n                (\n                    options.consistent &&\n                    openBracket.loc.end.line !== first.loc.start.line\n                )\n            );\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether linebreaks are needed.\n             * This allows:\n             *     var arr = [ // eslint-disable-line foo\n             *         'a'\n             *     ]\n             */\n\n            if (needsLinebreaks) {\n                if (astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportRequiredBeginningLinebreak(node, openBracket);\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportRequiredEndingLinebreak(node, closeBracket);\n                }\n            } else {\n                if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportNoBeginningLinebreak(node, openBracket);\n                }\n                if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportNoEndingLinebreak(node, closeBracket);\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}