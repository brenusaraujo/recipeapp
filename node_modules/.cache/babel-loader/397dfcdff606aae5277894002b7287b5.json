{"ast":null,"code":"/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint-disable class-methods-use-this*/\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst levn = require(\"levn\"),\n      ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\");\n\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\"); //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\n\n\nmodule.exports = class ConfigCommentParser {\n  /**\n   * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n   * whitespace. Used for \"global\" and \"exported\" comments.\n   * @param {string} string The string to parse.\n   * @param {Comment} comment The comment node which has the string.\n   * @returns {Object} Result map object of names and string values, or null values if no value was provided\n   */\n  parseStringConfig(string, comment) {\n    debug(\"Parsing String config\");\n    const items = {}; // Collapse whitespace around `:` and `,` to make parsing easier\n\n    const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n    trimmedString.split(/\\s|,+/u).forEach(name => {\n      if (!name) {\n        return;\n      } // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n\n\n      const [key, value = null] = name.split(\":\");\n      items[key] = {\n        value,\n        comment\n      };\n    });\n    return items;\n  }\n  /**\n   * Parses a JSON-like config.\n   * @param {string} string The string to parse.\n   * @param {Object} location Start line and column of comments for potential error message.\n   * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n   */\n\n\n  parseJsonConfig(string, location) {\n    debug(\"Parsing JSON config\");\n    let items = {}; // Parses a JSON-like comment by the same way as parsing CLI option.\n\n    try {\n      items = levn.parse(\"Object\", string) || {}; // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n      // Also, commaless notations have invalid severity:\n      //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n      // Should ignore that case as well.\n\n      if (ConfigOps.isEverySeverityValid(items)) {\n        return {\n          success: true,\n          config: items\n        };\n      }\n    } catch {\n      debug(\"Levn parsing failed; falling back to manual parsing.\"); // ignore to parse the string by a fallback.\n    }\n    /*\n     * Optionator cannot parse commaless notations.\n     * But we are supporting that. So this is a fallback for that.\n     */\n\n\n    items = {};\n    const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n    try {\n      items = JSON.parse(`{${normalizedString}}`);\n    } catch (ex) {\n      debug(\"Manual parsing failed.\");\n      return {\n        success: false,\n        error: {\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n          line: location.start.line,\n          column: location.start.column + 1\n        }\n      };\n    }\n\n    return {\n      success: true,\n      config: items\n    };\n  }\n  /**\n   * Parses a config of values separated by comma.\n   * @param {string} string The string to parse.\n   * @returns {Object} Result map of values and true values\n   */\n\n\n  parseListConfig(string) {\n    debug(\"Parsing list config\");\n    const items = {}; // Collapse whitespace around commas\n\n    string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n      const trimmedName = name.trim();\n\n      if (trimmedName) {\n        items[trimmedName] = true;\n      }\n    });\n    return items;\n  }\n\n};","map":{"version":3,"names":["levn","require","ConfigOps","debug","module","exports","ConfigCommentParser","parseStringConfig","string","comment","items","trimmedString","replace","split","forEach","name","key","value","parseJsonConfig","location","parse","isEverySeverityValid","success","config","normalizedString","JSON","ex","error","ruleId","fatal","severity","message","line","start","column","parseListConfig","trimmedName","trim"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/config-comment-parser.js"],"sourcesContent":["/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint-disable class-methods-use-this*/\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst levn = require(\"levn\"),\n    ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\");\n\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\nmodule.exports = class ConfigCommentParser {\n\n    /**\n     * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n     * whitespace. Used for \"global\" and \"exported\" comments.\n     * @param {string} string The string to parse.\n     * @param {Comment} comment The comment node which has the string.\n     * @returns {Object} Result map object of names and string values, or null values if no value was provided\n     */\n    parseStringConfig(string, comment) {\n        debug(\"Parsing String config\");\n\n        const items = {};\n\n        // Collapse whitespace around `:` and `,` to make parsing easier\n        const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n\n        trimmedString.split(/\\s|,+/u).forEach(name => {\n            if (!name) {\n                return;\n            }\n\n            // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n            const [key, value = null] = name.split(\":\");\n\n            items[key] = { value, comment };\n        });\n        return items;\n    }\n\n    /**\n     * Parses a JSON-like config.\n     * @param {string} string The string to parse.\n     * @param {Object} location Start line and column of comments for potential error message.\n     * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n     */\n    parseJsonConfig(string, location) {\n        debug(\"Parsing JSON config\");\n\n        let items = {};\n\n        // Parses a JSON-like comment by the same way as parsing CLI option.\n        try {\n            items = levn.parse(\"Object\", string) || {};\n\n            // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n            // Also, commaless notations have invalid severity:\n            //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n            // Should ignore that case as well.\n            if (ConfigOps.isEverySeverityValid(items)) {\n                return {\n                    success: true,\n                    config: items\n                };\n            }\n        } catch {\n\n            debug(\"Levn parsing failed; falling back to manual parsing.\");\n\n            // ignore to parse the string by a fallback.\n        }\n\n        /*\n         * Optionator cannot parse commaless notations.\n         * But we are supporting that. So this is a fallback for that.\n         */\n        items = {};\n        const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n        try {\n            items = JSON.parse(`{${normalizedString}}`);\n        } catch (ex) {\n            debug(\"Manual parsing failed.\");\n\n            return {\n                success: false,\n                error: {\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n                    line: location.start.line,\n                    column: location.start.column + 1\n                }\n            };\n\n        }\n\n        return {\n            success: true,\n            config: items\n        };\n    }\n\n    /**\n     * Parses a config of values separated by comma.\n     * @param {string} string The string to parse.\n     * @returns {Object} Result map of values and true values\n     */\n    parseListConfig(string) {\n        debug(\"Parsing list config\");\n\n        const items = {};\n\n        // Collapse whitespace around commas\n        string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n            const trimmedName = name.trim();\n\n            if (trimmedName) {\n                items[trimmedName] = true;\n            }\n        });\n        return items;\n    }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}