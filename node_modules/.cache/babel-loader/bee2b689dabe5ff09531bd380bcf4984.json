{"ast":null,"code":"/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require a newline after each call in a method chain\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreChainWithDepth: {\n          type: \"integer\",\n          minimum: 1,\n          maximum: 10,\n          default: 2\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected line break before `{{callee}}`.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Get the prefix of a given MemberExpression node.\n     * If the MemberExpression node is a computed value it returns a\n     * left bracket. If not it returns a period.\n     * @param  {ASTNode} node A MemberExpression node to get\n     * @returns {string} The prefix of the node.\n     */\n\n    function getPrefix(node) {\n      if (node.computed) {\n        if (node.optional) {\n          return \"?.[\";\n        }\n\n        return \"[\";\n      }\n\n      if (node.optional) {\n        return \"?.\";\n      }\n\n      return \".\";\n    }\n    /**\n     * Gets the property text of a given MemberExpression node.\n     * If the text is multiline, this returns only the first line.\n     * @param {ASTNode} node A MemberExpression node to get.\n     * @returns {string} The property text of the node.\n     */\n\n\n    function getPropertyText(node) {\n      const prefix = getPrefix(node);\n      const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n      const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n      return prefix + lines[0] + suffix;\n    }\n\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = astUtils.skipChainExpression(node.callee);\n\n        if (callee.type !== \"MemberExpression\") {\n          return;\n        }\n\n        let parent = astUtils.skipChainExpression(callee.object);\n        let depth = 1;\n\n        while (parent && parent.callee) {\n          depth += 1;\n          parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);\n        }\n\n        if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n          const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n          context.report({\n            node: callee.property,\n            loc: {\n              start: firstTokenAfterObject.loc.start,\n              end: callee.loc.end\n            },\n            messageId: \"expected\",\n            data: {\n              callee: getPropertyText(callee)\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","ignoreChainWithDepth","minimum","maximum","default","additionalProperties","messages","expected","create","context","options","sourceCode","getSourceCode","getPrefix","node","computed","optional","getPropertyText","prefix","lines","getText","property","split","LINEBREAK_MATCHER","suffix","length","callee","skipChainExpression","parent","object","depth","isTokenOnSameLine","firstTokenAfterObject","getTokenAfter","isNotClosingParenToken","report","loc","start","end","messageId","data","fix","fixer","insertTextBefore"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/newline-per-chained-call.js"],"sourcesContent":["/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require a newline after each call in a method chain\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignoreChainWithDepth: {\n                    type: \"integer\",\n                    minimum: 1,\n                    maximum: 10,\n                    default: 2\n                }\n            },\n            additionalProperties: false\n        }],\n        messages: {\n            expected: \"Expected line break before `{{callee}}`.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get the prefix of a given MemberExpression node.\n         * If the MemberExpression node is a computed value it returns a\n         * left bracket. If not it returns a period.\n         * @param  {ASTNode} node A MemberExpression node to get\n         * @returns {string} The prefix of the node.\n         */\n        function getPrefix(node) {\n            if (node.computed) {\n                if (node.optional) {\n                    return \"?.[\";\n                }\n                return \"[\";\n            }\n            if (node.optional) {\n                return \"?.\";\n            }\n            return \".\";\n        }\n\n        /**\n         * Gets the property text of a given MemberExpression node.\n         * If the text is multiline, this returns only the first line.\n         * @param {ASTNode} node A MemberExpression node to get.\n         * @returns {string} The property text of the node.\n         */\n        function getPropertyText(node) {\n            const prefix = getPrefix(node);\n            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n            const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n\n            return prefix + lines[0] + suffix;\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = astUtils.skipChainExpression(node.callee);\n\n                if (callee.type !== \"MemberExpression\") {\n                    return;\n                }\n\n                let parent = astUtils.skipChainExpression(callee.object);\n                let depth = 1;\n\n                while (parent && parent.callee) {\n                    depth += 1;\n                    parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);\n                }\n\n                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n                    const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n\n                    context.report({\n                        node: callee.property,\n                        loc: {\n                            start: firstTokenAfterObject.loc.start,\n                            end: callee.loc.end\n                        },\n                        messageId: \"expected\",\n                        data: {\n                            callee: getPropertyText(callee)\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}