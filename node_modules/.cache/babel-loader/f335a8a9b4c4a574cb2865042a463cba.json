{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDefaultSlideIndex = exports.getPrevMoveIndex = exports.getNextMoveIndex = exports.isSlideVisible = exports.getIndexes = void 0;\n\nconst default_controls_1 = require(\"./default-controls\");\n\nconst types_1 = require(\"./types\");\n\nconst getIndexes = (slide, endSlide, slideCount) => {\n  let slideIndex = slide;\n  let endSlideIndex = endSlide;\n\n  if (slideIndex < 0) {\n    slideIndex += slideCount;\n  } else if (slideIndex > slideCount - 1) {\n    slideIndex -= slideCount;\n  }\n\n  if (endSlideIndex < 0) {\n    endSlideIndex += slideCount;\n  } else if (endSlideIndex > slideCount - 1) {\n    endSlideIndex -= slideCount;\n  }\n\n  return [slideIndex, endSlideIndex];\n};\n\nexports.getIndexes = getIndexes;\n\nconst isSlideVisible = (currentSlide, indexToCheck, slidesToShow, cellAlign) => {\n  // The addition or subtraction of constants (1 , 0.5) in the following\n  // calculations are accounting for the fact that a slide will be visible even\n  // after the position associated with its index is off-screen. For example,\n  // with cellAlign=\"left\", slidesToShow=1 and indexToCheck=0,\n  // if the currentSlide is set to 0.99, both (a sliver of) slide 0 and slide 1\n  // will be visible at the same time, even though the position we associate\n  // with index 0, its leftmost edge, is off-screen.\n  if (cellAlign === types_1.Alignment.Left) {\n    return indexToCheck < currentSlide + slidesToShow && indexToCheck > currentSlide - 1;\n  }\n\n  if (cellAlign === types_1.Alignment.Center) {\n    return indexToCheck > currentSlide - slidesToShow / 2 - 0.5 && indexToCheck <= currentSlide || indexToCheck > currentSlide && indexToCheck < currentSlide + slidesToShow / 2 + 0.5;\n  }\n\n  if (cellAlign === types_1.Alignment.Right) {\n    return indexToCheck < currentSlide + 1 && indexToCheck > currentSlide - slidesToShow;\n  }\n\n  return false;\n};\n\nexports.isSlideVisible = isSlideVisible;\n\nconst getNextMoveIndex = (scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign) => {\n  if (wrapAround) {\n    return currentSlide + slidesToScroll;\n  } // Quit early if we're already as far right as we can go\n\n\n  if (currentSlide >= slideCount - 1 || cellAlign === types_1.Alignment.Left && currentSlide >= slideCount - slidesToShow) {\n    return currentSlide;\n  }\n\n  if (scrollMode === types_1.ScrollMode.remainder && cellAlign === types_1.Alignment.Left) {\n    return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);\n  }\n\n  return Math.min(currentSlide + slidesToScroll, slideCount - 1);\n};\n\nexports.getNextMoveIndex = getNextMoveIndex;\n\nconst getPrevMoveIndex = (scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign) => {\n  if (wrapAround) {\n    return currentSlide - slidesToScroll;\n  } // Quit early if we're already as far left as we can go\n\n\n  if (currentSlide <= 0 || cellAlign === types_1.Alignment.Right && currentSlide <= slidesToShow - 1) {\n    return currentSlide;\n  }\n\n  if (scrollMode === types_1.ScrollMode.remainder && cellAlign === types_1.Alignment.Right) {\n    return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);\n  }\n\n  return Math.max(currentSlide - slidesToScroll, 0);\n};\n\nexports.getPrevMoveIndex = getPrevMoveIndex;\n\nconst getDefaultSlideIndex = (slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode) => {\n  if (slideIndex !== undefined) {\n    return slideIndex;\n  }\n\n  const dotIndexes = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, false, cellAlign);\n  return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];\n};\n\nexports.getDefaultSlideIndex = getDefaultSlideIndex;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDefaultSlideIndex = exports.getPrevMoveIndex = exports.getNextMoveIndex = exports.isSlideVisible = exports.getIndexes = void 0;\nconst default_controls_1 = require(\"./default-controls\");\nconst types_1 = require(\"./types\");\nconst getIndexes = (slide, endSlide, slideCount) => {\n    let slideIndex = slide;\n    let endSlideIndex = endSlide;\n    if (slideIndex < 0) {\n        slideIndex += slideCount;\n    }\n    else if (slideIndex > slideCount - 1) {\n        slideIndex -= slideCount;\n    }\n    if (endSlideIndex < 0) {\n        endSlideIndex += slideCount;\n    }\n    else if (endSlideIndex > slideCount - 1) {\n        endSlideIndex -= slideCount;\n    }\n    return [slideIndex, endSlideIndex];\n};\nexports.getIndexes = getIndexes;\nconst isSlideVisible = (currentSlide, indexToCheck, slidesToShow, cellAlign) => {\n    // The addition or subtraction of constants (1 , 0.5) in the following\n    // calculations are accounting for the fact that a slide will be visible even\n    // after the position associated with its index is off-screen. For example,\n    // with cellAlign=\"left\", slidesToShow=1 and indexToCheck=0,\n    // if the currentSlide is set to 0.99, both (a sliver of) slide 0 and slide 1\n    // will be visible at the same time, even though the position we associate\n    // with index 0, its leftmost edge, is off-screen.\n    if (cellAlign === types_1.Alignment.Left) {\n        return (indexToCheck < currentSlide + slidesToShow &&\n            indexToCheck > currentSlide - 1);\n    }\n    if (cellAlign === types_1.Alignment.Center) {\n        return ((indexToCheck > currentSlide - slidesToShow / 2 - 0.5 &&\n            indexToCheck <= currentSlide) ||\n            (indexToCheck > currentSlide &&\n                indexToCheck < currentSlide + slidesToShow / 2 + 0.5));\n    }\n    if (cellAlign === types_1.Alignment.Right) {\n        return (indexToCheck < currentSlide + 1 &&\n            indexToCheck > currentSlide - slidesToShow);\n    }\n    return false;\n};\nexports.isSlideVisible = isSlideVisible;\nconst getNextMoveIndex = (scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign) => {\n    if (wrapAround) {\n        return currentSlide + slidesToScroll;\n    }\n    // Quit early if we're already as far right as we can go\n    if (currentSlide >= slideCount - 1 ||\n        (cellAlign === types_1.Alignment.Left && currentSlide >= slideCount - slidesToShow)) {\n        return currentSlide;\n    }\n    if (scrollMode === types_1.ScrollMode.remainder && cellAlign === types_1.Alignment.Left) {\n        return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);\n    }\n    return Math.min(currentSlide + slidesToScroll, slideCount - 1);\n};\nexports.getNextMoveIndex = getNextMoveIndex;\nconst getPrevMoveIndex = (scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign) => {\n    if (wrapAround) {\n        return currentSlide - slidesToScroll;\n    }\n    // Quit early if we're already as far left as we can go\n    if (currentSlide <= 0 ||\n        (cellAlign === types_1.Alignment.Right && currentSlide <= slidesToShow - 1)) {\n        return currentSlide;\n    }\n    if (scrollMode === types_1.ScrollMode.remainder && cellAlign === types_1.Alignment.Right) {\n        return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);\n    }\n    return Math.max(currentSlide - slidesToScroll, 0);\n};\nexports.getPrevMoveIndex = getPrevMoveIndex;\nconst getDefaultSlideIndex = (slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode) => {\n    if (slideIndex !== undefined) {\n        return slideIndex;\n    }\n    const dotIndexes = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, false, cellAlign);\n    return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];\n};\nexports.getDefaultSlideIndex = getDefaultSlideIndex;\n"]},"metadata":{},"sourceType":"script"}