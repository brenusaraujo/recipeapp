{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\n\nfunction isInitOfForStatement(node) {\n  return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n * @param {ASTNode} identifier An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\n\n\nfunction canBecomeVariableDeclaration(identifier) {\n  let node = identifier.parent;\n\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n\n  return node.type === \"VariableDeclarator\" || node.type === \"AssignmentExpression\" && node.parent.type === \"ExpressionStatement\" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);\n}\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n * @param {string} name A variable name to be checked.\n * @param {eslint-scope.Scope} initScope A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\n\n\nfunction isOuterVariableInDestructing(name, initScope) {\n  if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n    return true;\n  }\n\n  const variable = astUtils.getVariableByName(initScope, name);\n\n  if (variable !== null) {\n    return variable.defs.some(def => def.type === \"Parameter\");\n  }\n\n  return false;\n}\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\n\n\nfunction getDestructuringHost(reference) {\n  if (!reference.isWrite()) {\n    return null;\n  }\n\n  let node = reference.identifier.parent;\n\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n\n  if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n    return null;\n  }\n\n  return node;\n}\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\n\n\nfunction hasMemberExpressionAssignment(node) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      return node.properties.some(prop => {\n        if (prop) {\n          /*\n           * Spread elements have an argument property while\n           * others have a value property. Because different\n           * parsers use different node types for spread elements,\n           * we just check if there is an argument property.\n           */\n          return hasMemberExpressionAssignment(prop.argument || prop.value);\n        }\n\n        return false;\n      });\n\n    case \"ArrayPattern\":\n      return node.elements.some(element => {\n        if (element) {\n          return hasMemberExpressionAssignment(element);\n        }\n\n        return false;\n      });\n\n    case \"AssignmentPattern\":\n      return hasMemberExpressionAssignment(node.left);\n\n    case \"MemberExpression\":\n      return true;\n    // no default\n  }\n\n  return false;\n}\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n * @param {eslint-scope.Variable} variable A variable to get.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\n\n\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n  if (variable.eslintUsed && variable.scope.type === \"global\") {\n    return null;\n  } // Finds the unique WriteReference.\n\n\n  let writer = null;\n  let isReadBeforeInit = false;\n  const references = variable.references;\n\n  for (let i = 0; i < references.length; ++i) {\n    const reference = references[i];\n\n    if (reference.isWrite()) {\n      const isReassigned = writer !== null && writer.identifier !== reference.identifier;\n\n      if (isReassigned) {\n        return null;\n      }\n\n      const destructuringHost = getDestructuringHost(reference);\n\n      if (destructuringHost !== null && destructuringHost.left !== void 0) {\n        const leftNode = destructuringHost.left;\n        let hasOuterVariables = false,\n            hasNonIdentifiers = false;\n\n        if (leftNode.type === \"ObjectPattern\") {\n          const properties = leftNode.properties;\n          hasOuterVariables = properties.filter(prop => prop.value).map(prop => prop.value.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        } else if (leftNode.type === \"ArrayPattern\") {\n          const elements = leftNode.elements;\n          hasOuterVariables = elements.map(element => element && element.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        }\n\n        if (hasOuterVariables || hasNonIdentifiers) {\n          return null;\n        }\n      }\n\n      writer = reference;\n    } else if (reference.isRead() && writer === null) {\n      if (ignoreReadBeforeAssign) {\n        return null;\n      }\n\n      isReadBeforeInit = true;\n    }\n  }\n  /*\n   * If the assignment is from a different scope, ignore it.\n   * If the assignment cannot change to a declaration, ignore it.\n   */\n\n\n  const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);\n\n  if (!shouldBeConst) {\n    return null;\n  }\n\n  if (isReadBeforeInit) {\n    return variable.defs[0].name;\n  }\n\n  return writer.identifier;\n}\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\n\n\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n  const identifierMap = new Map();\n\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n    const references = variable.references;\n    const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n    let prevId = null;\n\n    for (let j = 0; j < references.length; ++j) {\n      const reference = references[j];\n      const id = reference.identifier;\n      /*\n       * Avoid counting a reference twice or more for default values of\n       * destructuring.\n       */\n\n      if (id === prevId) {\n        continue;\n      }\n\n      prevId = id; // Add the identifier node into the destructuring group.\n\n      const group = getDestructuringHost(reference);\n\n      if (group) {\n        if (identifierMap.has(group)) {\n          identifierMap.get(group).push(identifier);\n        } else {\n          identifierMap.set(group, [identifier]);\n        }\n      }\n    }\n  }\n\n  return identifierMap;\n}\n/**\n * Finds the nearest parent of node with a given type.\n * @param {ASTNode} node The node to search from.\n * @param {string} type The type field of the parent node.\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\n\n\nfunction findUp(node, type, shouldStop) {\n  if (!node || shouldStop(node)) {\n    return null;\n  }\n\n  if (node.type === type) {\n    return node;\n  }\n\n  return findUp(node.parent, type, shouldStop);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `const` declarations for variables that are never reassigned after declared\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-const\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        destructuring: {\n          enum: [\"any\", \"all\"],\n          default: \"any\"\n        },\n        ignoreReadBeforeAssign: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const sourceCode = context.getSourceCode();\n    const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n    const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n    const variables = [];\n    let reportCount = 0;\n    let checkedId = null;\n    let checkedName = \"\";\n    /**\n     * Reports given identifier nodes if all of the nodes should be declared\n     * as const.\n     *\n     * The argument 'nodes' is an array of Identifier nodes.\n     * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n     * nullable. In simple declaration or assignment cases, the length of\n     * the array is 1. In destructuring cases, the length of the array can\n     * be 2 or more.\n     * @param {(eslint-scope.Reference|null)[]} nodes\n     *      References which are grouped by destructuring to report.\n     * @returns {void}\n     */\n\n    function checkGroup(nodes) {\n      const nodesToReport = nodes.filter(Boolean);\n\n      if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n        const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n        const isVarDecParentNull = varDeclParent === null;\n\n        if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n          const firstDeclaration = varDeclParent.declarations[0];\n\n          if (firstDeclaration.init) {\n            const firstDecParent = firstDeclaration.init.parent;\n            /*\n             * First we check the declaration type and then depending on\n             * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n             * we compare the name and id from the first identifier, if the names are different\n             * we assign the new name, id and reset the count of reportCount and nodeCount in\n             * order to check each block for the number of reported errors and base our fix\n             * based on comparing nodes.length and nodesToReport.length.\n             */\n\n            if (firstDecParent.type === \"VariableDeclarator\") {\n              if (firstDecParent.id.name !== checkedName) {\n                checkedName = firstDecParent.id.name;\n                reportCount = 0;\n              }\n\n              if (firstDecParent.id.type === \"ObjectPattern\") {\n                if (firstDecParent.init.name !== checkedName) {\n                  checkedName = firstDecParent.init.name;\n                  reportCount = 0;\n                }\n              }\n\n              if (firstDecParent.id !== checkedId) {\n                checkedId = firstDecParent.id;\n                reportCount = 0;\n              }\n            }\n          }\n        }\n\n        let shouldFix = varDeclParent && ( // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n        varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" || varDeclParent.declarations.every(declaration => declaration.init)) &&\n        /*\n         * If options.destructuring is \"all\", then this warning will not occur unless\n         * every assignment in the destructuring should be const. In that case, it's safe\n         * to apply the fix.\n         */\n        nodesToReport.length === nodes.length;\n\n        if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n          if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n            /*\n             * Add nodesToReport.length to a count, then comparing the count to the length\n             * of the declarations in the current block.\n             */\n            reportCount += nodesToReport.length;\n            shouldFix = shouldFix && reportCount === varDeclParent.declarations.length;\n          }\n        }\n\n        nodesToReport.forEach(node => {\n          context.report({\n            node,\n            messageId: \"useConst\",\n            data: node,\n            fix: shouldFix ? fixer => {\n              const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);\n              /**\n               * Extend the replacement range to the whole declaration,\n               * in order to prevent other fixes in the same pass\n               * https://github.com/eslint/eslint/issues/13899\n               */\n\n              return new FixTracker(fixer, sourceCode).retainRange(varDeclParent.range).replaceTextRange(letKeywordToken.range, \"const\");\n            } : null\n          });\n        });\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n      },\n\n      VariableDeclaration(node) {\n        if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n          variables.push(...context.getDeclaredVariables(node));\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["FixTracker","require","astUtils","PATTERN_TYPE","DECLARATION_HOST_TYPE","DESTRUCTURING_HOST_TYPE","isInitOfForStatement","node","parent","type","init","canBecomeVariableDeclaration","identifier","test","isOuterVariableInDestructing","name","initScope","through","find","ref","resolved","variable","getVariableByName","defs","some","def","getDestructuringHost","reference","isWrite","hasMemberExpressionAssignment","properties","prop","argument","value","elements","element","left","getIdentifierIfShouldBeConst","ignoreReadBeforeAssign","eslintUsed","scope","writer","isReadBeforeInit","references","i","length","isReassigned","destructuringHost","leftNode","hasOuterVariables","hasNonIdentifiers","filter","map","isRead","shouldBeConst","from","groupByDestructuring","variables","identifierMap","Map","prevId","j","id","group","has","get","push","set","findUp","shouldStop","module","exports","meta","docs","description","category","recommended","url","fixable","schema","destructuring","enum","default","additionalProperties","messages","useConst","create","context","options","sourceCode","getSourceCode","shouldMatchAnyDestructuredVariable","reportCount","checkedId","checkedName","checkGroup","nodes","nodesToReport","Boolean","varDeclParent","parentNode","endsWith","isVarDecParentNull","declarations","firstDeclaration","firstDecParent","shouldFix","every","declaration","forEach","report","messageId","data","fix","fixer","letKeywordToken","getFirstToken","t","kind","retainRange","range","replaceTextRange","VariableDeclaration","getDeclaredVariables"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/prefer-const.js"],"sourcesContent":["/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n * @param {ASTNode} identifier An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    let node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n * @param {string} name A variable name to be checked.\n * @param {eslint-scope.Scope} initScope A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\nfunction isOuterVariableInDestructing(name, initScope) {\n\n    if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n        return true;\n    }\n\n    const variable = astUtils.getVariableByName(initScope, name);\n\n    if (variable !== null) {\n        return variable.defs.some(def => def.type === \"Parameter\");\n    }\n\n    return false;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    let node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\nfunction hasMemberExpressionAssignment(node) {\n    switch (node.type) {\n        case \"ObjectPattern\":\n            return node.properties.some(prop => {\n                if (prop) {\n\n                    /*\n                     * Spread elements have an argument property while\n                     * others have a value property. Because different\n                     * parsers use different node types for spread elements,\n                     * we just check if there is an argument property.\n                     */\n                    return hasMemberExpressionAssignment(prop.argument || prop.value);\n                }\n\n                return false;\n            });\n\n        case \"ArrayPattern\":\n            return node.elements.some(element => {\n                if (element) {\n                    return hasMemberExpressionAssignment(element);\n                }\n\n                return false;\n            });\n\n        case \"AssignmentPattern\":\n            return hasMemberExpressionAssignment(node.left);\n\n        case \"MemberExpression\":\n            return true;\n\n        // no default\n    }\n\n    return false;\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n * @param {eslint-scope.Variable} variable A variable to get.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    let writer = null;\n    let isReadBeforeInit = false;\n    const references = variable.references;\n\n    for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n\n        if (reference.isWrite()) {\n            const isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n\n            const destructuringHost = getDestructuringHost(reference);\n\n            if (destructuringHost !== null && destructuringHost.left !== void 0) {\n                const leftNode = destructuringHost.left;\n                let hasOuterVariables = false,\n                    hasNonIdentifiers = false;\n\n                if (leftNode.type === \"ObjectPattern\") {\n                    const properties = leftNode.properties;\n\n                    hasOuterVariables = properties\n                        .filter(prop => prop.value)\n                        .map(prop => prop.value.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n\n                } else if (leftNode.type === \"ArrayPattern\") {\n                    const elements = leftNode.elements;\n\n                    hasOuterVariables = elements\n                        .map(element => element && element.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n                }\n\n                if (hasOuterVariables || hasNonIdentifiers) {\n                    return null;\n                }\n\n            }\n\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    /*\n     * If the assignment is from a different scope, ignore it.\n     * If the assignment cannot change to a declaration, ignore it.\n     */\n    const shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n\n    return writer.identifier;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    const identifierMap = new Map();\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const references = variable.references;\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        let prevId = null;\n\n        for (let j = 0; j < references.length; ++j) {\n            const reference = references[j];\n            const id = reference.identifier;\n\n            /*\n             * Avoid counting a reference twice or more for default values of\n             * destructuring.\n             */\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            const group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n * @param {ASTNode} node The node to search from.\n * @param {string} type The type field of the parent node.\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n    if (!node || shouldStop(node)) {\n        return null;\n    }\n    if (node.type === type) {\n        return node;\n    }\n    return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-const\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: { enum: [\"any\", \"all\"], default: \"any\" },\n                    ignoreReadBeforeAssign: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n        const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n        const variables = [];\n        let reportCount = 0;\n        let checkedId = null;\n        let checkedName = \"\";\n\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         * @param {(eslint-scope.Reference|null)[]} nodes\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            const nodesToReport = nodes.filter(Boolean);\n\n            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                const isVarDecParentNull = varDeclParent === null;\n\n                if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n                    const firstDeclaration = varDeclParent.declarations[0];\n\n                    if (firstDeclaration.init) {\n                        const firstDecParent = firstDeclaration.init.parent;\n\n                        /*\n                         * First we check the declaration type and then depending on\n                         * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n                         * we compare the name and id from the first identifier, if the names are different\n                         * we assign the new name, id and reset the count of reportCount and nodeCount in\n                         * order to check each block for the number of reported errors and base our fix\n                         * based on comparing nodes.length and nodesToReport.length.\n                         */\n\n                        if (firstDecParent.type === \"VariableDeclarator\") {\n\n                            if (firstDecParent.id.name !== checkedName) {\n                                checkedName = firstDecParent.id.name;\n                                reportCount = 0;\n                            }\n\n                            if (firstDecParent.id.type === \"ObjectPattern\") {\n                                if (firstDecParent.init.name !== checkedName) {\n                                    checkedName = firstDecParent.init.name;\n                                    reportCount = 0;\n                                }\n                            }\n\n                            if (firstDecParent.id !== checkedId) {\n                                checkedId = firstDecParent.id;\n                                reportCount = 0;\n                            }\n                        }\n                    }\n                }\n\n                let shouldFix = varDeclParent &&\n\n                    // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" ||\n                        varDeclParent.declarations.every(declaration => declaration.init)) &&\n\n                    /*\n                     * If options.destructuring is \"all\", then this warning will not occur unless\n                     * every assignment in the destructuring should be const. In that case, it's safe\n                     * to apply the fix.\n                     */\n                    nodesToReport.length === nodes.length;\n\n                if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n\n                    if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n\n                        /*\n                         * Add nodesToReport.length to a count, then comparing the count to the length\n                         * of the declarations in the current block.\n                         */\n\n                        reportCount += nodesToReport.length;\n\n                        shouldFix = shouldFix && (reportCount === varDeclParent.declarations.length);\n                    }\n                }\n\n                nodesToReport.forEach(node => {\n                    context.report({\n                        node,\n                        messageId: \"useConst\",\n                        data: node,\n                        fix: shouldFix\n                            ? fixer => {\n                                const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);\n\n                                /**\n                                 * Extend the replacement range to the whole declaration,\n                                 * in order to prevent other fixes in the same pass\n                                 * https://github.com/eslint/eslint/issues/13899\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainRange(varDeclParent.range)\n                                    .replaceTextRange(letKeywordToken.range, \"const\");\n                            }\n                            : null\n                    });\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n            },\n\n            VariableDeclaration(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    variables.push(...context.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}