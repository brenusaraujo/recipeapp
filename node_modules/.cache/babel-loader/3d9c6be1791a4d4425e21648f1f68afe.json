{"ast":null,"code":"/**\n * @fileoverview Rule to enforce line breaks between arguments of a function call\n * @author Alexey Gonchar <https://github.com/finico>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks between arguments of a function call\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"consistent\"]\n    }],\n    messages: {\n      unexpectedLineBreak: \"There should be no line break here.\",\n      missingLineBreak: \"There should be a line break after this argument.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const checkers = {\n      unexpected: {\n        messageId: \"unexpectedLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\n      },\n      missing: {\n        messageId: \"missingLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\n      }\n    };\n    /**\n     * Check all arguments for line breaks in the CallExpression\n     * @param {CallExpression} node node to evaluate\n     * @param {{ messageId: string, check: Function }} checker selected checker\n     * @returns {void}\n     * @private\n     */\n\n    function checkArguments(node, checker) {\n      for (let i = 1; i < node.arguments.length; i++) {\n        const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\n        const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\n\n        if (checker.check(prevArgToken, currentArgToken)) {\n          const tokenBefore = sourceCode.getTokenBefore(currentArgToken, {\n            includeComments: true\n          });\n          const hasLineCommentBefore = tokenBefore.type === \"Line\";\n          context.report({\n            node,\n            loc: {\n              start: tokenBefore.loc.end,\n              end: currentArgToken.loc.start\n            },\n            messageId: checker.messageId,\n            fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\n          });\n        }\n      }\n    }\n    /**\n     * Check if open space is present in a function name\n     * @param {CallExpression} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n\n\n    function check(node) {\n      if (node.arguments.length < 2) {\n        return;\n      }\n\n      const option = context.options[0] || \"always\";\n\n      if (option === \"never\") {\n        checkArguments(node, checkers.unexpected);\n      } else if (option === \"always\") {\n        checkArguments(node, checkers.missing);\n      } else if (option === \"consistent\") {\n        const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\n        const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\n\n        if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\n          checkArguments(node, checkers.unexpected);\n        } else {\n          checkArguments(node, checkers.missing);\n        }\n      }\n    }\n\n    return {\n      CallExpression: check,\n      NewExpression: check\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","unexpectedLineBreak","missingLineBreak","create","context","sourceCode","getSourceCode","checkers","unexpected","messageId","check","prevToken","currentToken","loc","end","line","start","createFix","token","tokenBefore","fixer","replaceTextRange","range","missing","checkArguments","node","checker","i","arguments","length","prevArgToken","getLastToken","currentArgToken","getFirstToken","getTokenBefore","includeComments","hasLineCommentBefore","report","fix","option","options","firstArgToken","secondArgToken","CallExpression","NewExpression"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/function-call-argument-newline.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce line breaks between arguments of a function call\n * @author Alexey Gonchar <https://github.com/finico>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce line breaks between arguments of a function call\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"consistent\"]\n            }\n        ],\n\n        messages: {\n            unexpectedLineBreak: \"There should be no line break here.\",\n            missingLineBreak: \"There should be a line break after this argument.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const checkers = {\n            unexpected: {\n                messageId: \"unexpectedLineBreak\",\n                check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\n                createFix: (token, tokenBefore) => fixer =>\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\n            },\n            missing: {\n                messageId: \"missingLineBreak\",\n                check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\n                createFix: (token, tokenBefore) => fixer =>\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\n            }\n        };\n\n        /**\n         * Check all arguments for line breaks in the CallExpression\n         * @param {CallExpression} node node to evaluate\n         * @param {{ messageId: string, check: Function }} checker selected checker\n         * @returns {void}\n         * @private\n         */\n        function checkArguments(node, checker) {\n            for (let i = 1; i < node.arguments.length; i++) {\n                const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\n                const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\n\n                if (checker.check(prevArgToken, currentArgToken)) {\n                    const tokenBefore = sourceCode.getTokenBefore(\n                        currentArgToken,\n                        { includeComments: true }\n                    );\n\n                    const hasLineCommentBefore = tokenBefore.type === \"Line\";\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBefore.loc.end,\n                            end: currentArgToken.loc.start\n                        },\n                        messageId: checker.messageId,\n                        fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check if open space is present in a function name\n         * @param {CallExpression} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (node.arguments.length < 2) {\n                return;\n            }\n\n            const option = context.options[0] || \"always\";\n\n            if (option === \"never\") {\n                checkArguments(node, checkers.unexpected);\n            } else if (option === \"always\") {\n                checkArguments(node, checkers.missing);\n            } else if (option === \"consistent\") {\n                const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\n                const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\n\n                if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\n                    checkArguments(node, checkers.unexpected);\n                } else {\n                    checkArguments(node, checkers.missing);\n                }\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}