{"ast":null,"code":"/**\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\n * @author Milos Djermanovic\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n/**\n * Determines whether the given node is the first node in the code path to which a loop statement\n * 'loops' for the next iteration.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a looping target.\n */\n\nfunction isLoopingTarget(node) {\n  const parent = node.parent;\n\n  if (parent) {\n    switch (parent.type) {\n      case \"WhileStatement\":\n        return node === parent.test;\n\n      case \"DoWhileStatement\":\n        return node === parent.body;\n\n      case \"ForStatement\":\n        return node === (parent.update || parent.test || parent.body);\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        return node === parent.left;\n      // no default\n    }\n  }\n\n  return false;\n}\n/**\n * Creates an array with elements from the first given array that are not included in the second given array.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {Array} a new array that represents `arrA \\ arrB`.\n */\n\n\nfunction getDifference(arrA, arrB) {\n  return arrA.filter(a => !arrB.includes(a));\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow loops with a body that allows only one iteration\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unreachable-loop\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignore: {\n          type: \"array\",\n          items: {\n            enum: allLoopTypes\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalid: \"Invalid loop. Its body allows only one iteration.\"\n    }\n  },\n\n  create(context) {\n    const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\n          loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n          loopSelector = loopTypesToCheck.join(\",\"),\n          loopsByTargetSegments = new Map(),\n          loopsToReport = new Set();\n    let currentCodePath = null;\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      [loopSelector](node) {\n        /**\n         * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\n         * For unreachable segments, the code path analysis does not raise events required for this implementation.\n         */\n        if (currentCodePath.currentSegments.some(segment => segment.reachable)) {\n          loopsToReport.add(node);\n        }\n      },\n\n      onCodePathSegmentStart(segment, node) {\n        if (isLoopingTarget(node)) {\n          const loop = node.parent;\n          loopsByTargetSegments.set(segment, loop);\n        }\n      },\n\n      onCodePathSegmentLoop(_, toSegment, node) {\n        const loop = loopsByTargetSegments.get(toSegment);\n        /**\n         * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\n         * only if there is at least one loop event with the appropriate target (which has been already\n         * determined in the `loopsByTargetSegments` map), raised from either:\n         *\n         * - the end of the loop's body (in which case `node === loop`)\n         * - a `continue` statement\n         *\n         * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\n         */\n\n        if (node === loop || node.type === \"ContinueStatement\") {\n          // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\n          loopsToReport.delete(loop);\n        }\n      },\n\n      \"Program:exit\"() {\n        loopsToReport.forEach(node => context.report({\n          node,\n          messageId: \"invalid\"\n        }));\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["allLoopTypes","isLoopingTarget","node","parent","type","test","body","update","left","getDifference","arrA","arrB","filter","a","includes","module","exports","meta","docs","description","category","recommended","url","schema","properties","ignore","items","enum","uniqueItems","additionalProperties","messages","invalid","create","context","ignoredLoopTypes","options","loopTypesToCheck","loopSelector","join","loopsByTargetSegments","Map","loopsToReport","Set","currentCodePath","onCodePathStart","codePath","onCodePathEnd","upper","currentSegments","some","segment","reachable","add","onCodePathSegmentStart","loop","set","onCodePathSegmentLoop","_","toSegment","get","delete","forEach","report","messageId"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-unreachable-loop.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n\n/**\n * Determines whether the given node is the first node in the code path to which a loop statement\n * 'loops' for the next iteration.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a looping target.\n */\nfunction isLoopingTarget(node) {\n    const parent = node.parent;\n\n    if (parent) {\n        switch (parent.type) {\n            case \"WhileStatement\":\n                return node === parent.test;\n            case \"DoWhileStatement\":\n                return node === parent.body;\n            case \"ForStatement\":\n                return node === (parent.update || parent.test || parent.body);\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                return node === parent.left;\n\n            // no default\n        }\n    }\n\n    return false;\n}\n\n/**\n * Creates an array with elements from the first given array that are not included in the second given array.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {Array} a new array that represents `arrA \\ arrB`.\n */\nfunction getDifference(arrA, arrB) {\n    return arrA.filter(a => !arrB.includes(a));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow loops with a body that allows only one iteration\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unreachable-loop\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        enum: allLoopTypes\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            invalid: \"Invalid loop. Its body allows only one iteration.\"\n        }\n    },\n\n    create(context) {\n        const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\n            loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n            loopSelector = loopTypesToCheck.join(\",\"),\n            loopsByTargetSegments = new Map(),\n            loopsToReport = new Set();\n\n        let currentCodePath = null;\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            [loopSelector](node) {\n\n                /**\n                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\n                 * For unreachable segments, the code path analysis does not raise events required for this implementation.\n                 */\n                if (currentCodePath.currentSegments.some(segment => segment.reachable)) {\n                    loopsToReport.add(node);\n                }\n            },\n\n            onCodePathSegmentStart(segment, node) {\n                if (isLoopingTarget(node)) {\n                    const loop = node.parent;\n\n                    loopsByTargetSegments.set(segment, loop);\n                }\n            },\n\n            onCodePathSegmentLoop(_, toSegment, node) {\n                const loop = loopsByTargetSegments.get(toSegment);\n\n                /**\n                 * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\n                 * only if there is at least one loop event with the appropriate target (which has been already\n                 * determined in the `loopsByTargetSegments` map), raised from either:\n                 *\n                 * - the end of the loop's body (in which case `node === loop`)\n                 * - a `continue` statement\n                 *\n                 * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\n                 */\n                if (node === loop || node.type === \"ContinueStatement\") {\n\n                    // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\n                    loopsToReport.delete(loop);\n                }\n            },\n\n            \"Program:exit\"() {\n                loopsToReport.forEach(\n                    node => context.report({ node, messageId: \"invalid\" })\n                );\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}