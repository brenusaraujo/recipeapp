{"ast":null,"code":"/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow reassigning `function` parameters\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-param-reassign\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [false]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [true]\n          },\n          ignorePropertyModificationsFor: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          },\n          ignorePropertyModificationsForRegex: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      assignmentToFunctionParam: \"Assignment to function parameter '{{name}}'.\",\n      assignmentToFunctionParamProp: \"Assignment to property of function parameter '{{name}}'.\"\n    }\n  },\n\n  create(context) {\n    const props = context.options[0] && context.options[0].props;\n    const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n    const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n    /**\n     * Checks whether or not the reference modifies properties of its variable.\n     * @param {Reference} reference A reference to check.\n     * @returns {boolean} Whether or not the reference modifies properties of its variable.\n     */\n\n    function isModifyingProp(reference) {\n      let node = reference.identifier;\n      let parent = node.parent;\n\n      while (parent && (!stopNodePattern.test(parent.type) || parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n        switch (parent.type) {\n          // e.g. foo.a = 0;\n          case \"AssignmentExpression\":\n            return parent.left === node;\n          // e.g. ++foo.a;\n\n          case \"UpdateExpression\":\n            return true;\n          // e.g. delete foo.a;\n\n          case \"UnaryExpression\":\n            if (parent.operator === \"delete\") {\n              return true;\n            }\n\n            break;\n          // e.g. for (foo.a in b) {}\n\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            if (parent.left === node) {\n              return true;\n            } // this is a stop node for parent.right and parent.body\n\n\n            return false;\n          // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n\n          case \"CallExpression\":\n            if (parent.callee !== node) {\n              return false;\n            }\n\n            break;\n          // EXCLUDES: e.g. cache[foo.a] = 0;\n\n          case \"MemberExpression\":\n            if (parent.property === node) {\n              return false;\n            }\n\n            break;\n          // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n\n          case \"Property\":\n            if (parent.key === node) {\n              return false;\n            }\n\n            break;\n          // EXCLUDES: e.g. (foo ? a : b).c = bar;\n\n          case \"ConditionalExpression\":\n            if (parent.test === node) {\n              return false;\n            }\n\n            break;\n          // no default\n        }\n\n        node = parent;\n        parent = node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Tests that an identifier name matches any of the ignored property assignments.\n     * First we test strings in ignoredPropertyAssignmentsFor.\n     * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\n     * @param {string} identifierName A string that describes the name of an identifier to\n     * ignore property assignments for.\n     * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\n     */\n\n\n    function isIgnoredPropertyAssignment(identifierName) {\n      return ignoredPropertyAssignmentsFor.includes(identifierName) || ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n    }\n    /**\n     * Reports a reference if is non initializer and writable.\n     * @param {Reference} reference A reference to check.\n     * @param {int} index The index of the reference in the references.\n     * @param {Reference[]} references The array that the reference belongs to.\n     * @returns {void}\n     */\n\n\n    function checkReference(reference, index, references) {\n      const identifier = reference.identifier;\n\n      if (identifier && !reference.init && (\n      /*\n       * Destructuring assignments can have multiple default value,\n       * so possibly there are multiple writeable references for the same identifier.\n       */\n      index === 0 || references[index - 1].identifier !== identifier)) {\n        if (reference.isWrite()) {\n          context.report({\n            node: identifier,\n            messageId: \"assignmentToFunctionParam\",\n            data: {\n              name: identifier.name\n            }\n          });\n        } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n          context.report({\n            node: identifier,\n            messageId: \"assignmentToFunctionParamProp\",\n            data: {\n              name: identifier.name\n            }\n          });\n        }\n      }\n    }\n    /**\n     * Finds and reports references that are non initializer and writable.\n     * @param {Variable} variable A variable to check.\n     * @returns {void}\n     */\n\n\n    function checkVariable(variable) {\n      if (variable.defs[0].type === \"Parameter\") {\n        variable.references.forEach(checkReference);\n      }\n    }\n    /**\n     * Checks parameters of a given function node.\n     * @param {ASTNode} node A function node to check.\n     * @returns {void}\n     */\n\n\n    function checkForFunction(node) {\n      context.getDeclaredVariables(node).forEach(checkVariable);\n    }\n\n    return {\n      // `:exit` is needed for the `node.parent` property of identifier nodes.\n      \"FunctionDeclaration:exit\": checkForFunction,\n      \"FunctionExpression:exit\": checkForFunction,\n      \"ArrowFunctionExpression:exit\": checkForFunction\n    };\n  }\n\n};","map":{"version":3,"names":["stopNodePattern","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","properties","props","enum","additionalProperties","ignorePropertyModificationsFor","items","uniqueItems","ignorePropertyModificationsForRegex","messages","assignmentToFunctionParam","assignmentToFunctionParamProp","create","context","options","ignoredPropertyAssignmentsFor","ignoredPropertyAssignmentsForRegex","isModifyingProp","reference","node","identifier","parent","test","left","operator","callee","property","key","isIgnoredPropertyAssignment","identifierName","includes","some","ignored","RegExp","checkReference","index","references","init","isWrite","report","messageId","data","name","checkVariable","variable","defs","forEach","checkForFunction","getDeclaredVariables"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-param-reassign.js"],"sourcesContent":["/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow reassigning `function` parameters\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-param-reassign\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [false]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [true]\n                            },\n                            ignorePropertyModificationsFor: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            },\n                            ignorePropertyModificationsForRegex: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            assignmentToFunctionParam: \"Assignment to function parameter '{{name}}'.\",\n            assignmentToFunctionParamProp: \"Assignment to property of function parameter '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n        const props = context.options[0] && context.options[0].props;\n        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n        const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n\n        /**\n         * Checks whether or not the reference modifies properties of its variable.\n         * @param {Reference} reference A reference to check.\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\n         */\n        function isModifyingProp(reference) {\n            let node = reference.identifier;\n            let parent = node.parent;\n\n            while (parent && (!stopNodePattern.test(parent.type) ||\n                    parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n                switch (parent.type) {\n\n                    // e.g. foo.a = 0;\n                    case \"AssignmentExpression\":\n                        return parent.left === node;\n\n                    // e.g. ++foo.a;\n                    case \"UpdateExpression\":\n                        return true;\n\n                    // e.g. delete foo.a;\n                    case \"UnaryExpression\":\n                        if (parent.operator === \"delete\") {\n                            return true;\n                        }\n                        break;\n\n                    // e.g. for (foo.a in b) {}\n                    case \"ForInStatement\":\n                    case \"ForOfStatement\":\n                        if (parent.left === node) {\n                            return true;\n                        }\n\n                        // this is a stop node for parent.right and parent.body\n                        return false;\n\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n                    case \"CallExpression\":\n                        if (parent.callee !== node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\n                    case \"MemberExpression\":\n                        if (parent.property === node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n                    case \"Property\":\n                        if (parent.key === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // EXCLUDES: e.g. (foo ? a : b).c = bar;\n                    case \"ConditionalExpression\":\n                        if (parent.test === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // no default\n                }\n\n                node = parent;\n                parent = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Tests that an identifier name matches any of the ignored property assignments.\n         * First we test strings in ignoredPropertyAssignmentsFor.\n         * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\n         * @param {string} identifierName A string that describes the name of an identifier to\n         * ignore property assignments for.\n         * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\n         */\n        function isIgnoredPropertyAssignment(identifierName) {\n            return ignoredPropertyAssignmentsFor.includes(identifierName) ||\n                ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n        }\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {Reference} reference A reference to check.\n         * @param {int} index The index of the reference in the references.\n         * @param {Reference[]} references The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (identifier &&\n                !reference.init &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                if (reference.isWrite()) {\n                    context.report({\n                        node: identifier,\n                        messageId: \"assignmentToFunctionParam\",\n                        data: { name: identifier.name }\n                    });\n                } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n                    context.report({\n                        node: identifier,\n                        messageId: \"assignmentToFunctionParamProp\",\n                        data: { name: identifier.name }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"Parameter\") {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\n            \"FunctionDeclaration:exit\": checkForFunction,\n            \"FunctionExpression:exit\": checkForFunction,\n            \"ArrowFunctionExpression:exit\": checkForFunction\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}