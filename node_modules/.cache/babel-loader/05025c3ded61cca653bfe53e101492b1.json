{"ast":null,"code":"/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst globals = require(\"globals\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow extending native types\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extend-native\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const exceptions = new Set(config.exceptions || []);\n    const modifiedBuiltins = new Set(Object.keys(globals.builtin).filter(builtin => builtin[0].toUpperCase() === builtin[0]).filter(builtin => !exceptions.has(builtin)));\n    /**\n     * Reports a lint error for the given node.\n     * @param {ASTNode} node The node to report.\n     * @param {string} builtin The name of the native builtin being extended.\n     * @returns {void}\n     */\n\n    function reportNode(node, builtin) {\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        data: {\n          builtin\n        }\n      });\n    }\n    /**\n     * Check to see if the `prototype` property of the given object\n     * identifier node is being accessed.\n     * @param {ASTNode} identifierNode The Identifier representing the object\n     * to check.\n     * @returns {boolean} True if the identifier is the object of a\n     * MemberExpression and its `prototype` property is being accessed,\n     * false otherwise.\n     */\n\n\n    function isPrototypePropertyAccessed(identifierNode) {\n      return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === \"MemberExpression\" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\");\n    }\n    /**\n     * Check if it's an assignment to the property of the given node.\n     * Example: `*.prop = 0` // the `*` is the given node.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if an assignment to the property of the node.\n     */\n\n\n    function isAssigningToPropertyOf(node) {\n      return node.parent.type === \"MemberExpression\" && node.parent.object === node && node.parent.parent.type === \"AssignmentExpression\" && node.parent.parent.left === node.parent;\n    }\n    /**\n     * Checks if the given node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if the node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n     */\n\n\n    function isInDefinePropertyCall(node) {\n      return node.parent.type === \"CallExpression\" && node.parent.arguments[0] === node && astUtils.isSpecificMemberAccess(node.parent.callee, \"Object\", /^definePropert(?:y|ies)$/u);\n    }\n    /**\n     * Check to see if object prototype access is part of a prototype\n     * extension. There are three ways a prototype can be extended:\n     * 1. Assignment to prototype property (Object.prototype.foo = 1)\n     * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n     * If prototype extension is detected, report the AssignmentExpression\n     * or CallExpression node.\n     * @param {ASTNode} identifierNode The Identifier representing the object\n     * which prototype is being accessed and possibly extended.\n     * @returns {void}\n     */\n\n\n    function checkAndReportPrototypeExtension(identifierNode) {\n      if (!isPrototypePropertyAccessed(identifierNode)) {\n        return; // This is not `*.prototype` access.\n      }\n      /*\n       * `identifierNode.parent` is a MemberExpression `*.prototype`.\n       * If it's an optional member access, it may be wrapped by a `ChainExpression` node.\n       */\n\n\n      const prototypeNode = identifierNode.parent.parent.type === \"ChainExpression\" ? identifierNode.parent.parent : identifierNode.parent;\n\n      if (isAssigningToPropertyOf(prototypeNode)) {\n        // `*.prototype` -> MemberExpression -> AssignmentExpression\n        reportNode(prototypeNode.parent.parent, identifierNode.name);\n      } else if (isInDefinePropertyCall(prototypeNode)) {\n        // `*.prototype` -> CallExpression\n        reportNode(prototypeNode.parent, identifierNode.name);\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        modifiedBuiltins.forEach(builtin => {\n          const builtinVar = globalScope.set.get(builtin);\n\n          if (builtinVar && builtinVar.references) {\n            builtinVar.references.map(ref => ref.identifier).forEach(checkAndReportPrototypeExtension);\n          }\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","globals","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","exceptions","items","uniqueItems","additionalProperties","messages","unexpected","create","context","config","options","Set","modifiedBuiltins","Object","keys","builtin","filter","toUpperCase","has","reportNode","node","report","messageId","data","isPrototypePropertyAccessed","identifierNode","Boolean","parent","object","getStaticPropertyName","isAssigningToPropertyOf","left","isInDefinePropertyCall","arguments","isSpecificMemberAccess","callee","checkAndReportPrototypeExtension","prototypeNode","name","globalScope","getScope","forEach","builtinVar","set","get","references","map","ref","identifier"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-extend-native.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow extending native types\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extend-native\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0] || {};\n        const exceptions = new Set(config.exceptions || []);\n        const modifiedBuiltins = new Set(\n            Object.keys(globals.builtin)\n                .filter(builtin => builtin[0].toUpperCase() === builtin[0])\n                .filter(builtin => !exceptions.has(builtin))\n        );\n\n        /**\n         * Reports a lint error for the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} builtin The name of the native builtin being extended.\n         * @returns {void}\n         */\n        function reportNode(node, builtin) {\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                data: {\n                    builtin\n                }\n            });\n        }\n\n        /**\n         * Check to see if the `prototype` property of the given object\n         * identifier node is being accessed.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * to check.\n         * @returns {boolean} True if the identifier is the object of a\n         * MemberExpression and its `prototype` property is being accessed,\n         * false otherwise.\n         */\n        function isPrototypePropertyAccessed(identifierNode) {\n            return Boolean(\n                identifierNode &&\n                identifierNode.parent &&\n                identifierNode.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.object === identifierNode &&\n                astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\"\n            );\n        }\n\n        /**\n         * Check if it's an assignment to the property of the given node.\n         * Example: `*.prop = 0` // the `*` is the given node.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if an assignment to the property of the node.\n         */\n        function isAssigningToPropertyOf(node) {\n            return (\n                node.parent.type === \"MemberExpression\" &&\n                node.parent.object === node &&\n                node.parent.parent.type === \"AssignmentExpression\" &&\n                node.parent.parent.left === node.parent\n            );\n        }\n\n        /**\n         * Checks if the given node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n         */\n        function isInDefinePropertyCall(node) {\n            return (\n                node.parent.type === \"CallExpression\" &&\n                node.parent.arguments[0] === node &&\n                astUtils.isSpecificMemberAccess(node.parent.callee, \"Object\", /^definePropert(?:y|ies)$/u)\n            );\n        }\n\n        /**\n         * Check to see if object prototype access is part of a prototype\n         * extension. There are three ways a prototype can be extended:\n         * 1. Assignment to prototype property (Object.prototype.foo = 1)\n         * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n         * If prototype extension is detected, report the AssignmentExpression\n         * or CallExpression node.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * which prototype is being accessed and possibly extended.\n         * @returns {void}\n         */\n        function checkAndReportPrototypeExtension(identifierNode) {\n            if (!isPrototypePropertyAccessed(identifierNode)) {\n                return; // This is not `*.prototype` access.\n            }\n\n            /*\n             * `identifierNode.parent` is a MemberExpression `*.prototype`.\n             * If it's an optional member access, it may be wrapped by a `ChainExpression` node.\n             */\n            const prototypeNode =\n                identifierNode.parent.parent.type === \"ChainExpression\"\n                    ? identifierNode.parent.parent\n                    : identifierNode.parent;\n\n            if (isAssigningToPropertyOf(prototypeNode)) {\n\n                // `*.prototype` -> MemberExpression -> AssignmentExpression\n                reportNode(prototypeNode.parent.parent, identifierNode.name);\n            } else if (isInDefinePropertyCall(prototypeNode)) {\n\n                // `*.prototype` -> CallExpression\n                reportNode(prototypeNode.parent, identifierNode.name);\n            }\n        }\n\n        return {\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                modifiedBuiltins.forEach(builtin => {\n                    const builtinVar = globalScope.set.get(builtin);\n\n                    if (builtinVar && builtinVar.references) {\n                        builtinVar.references\n                            .map(ref => ref.identifier)\n                            .forEach(checkAndReportPrototypeExtension);\n                    }\n                });\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}