{"ast":null,"code":"/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\n\n\nfunction union(setA, setB) {\n  return new Set(function* () {\n    yield* setA;\n    yield* setB;\n  }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n/**\n * Parses a regular expression into a list of characters with character class info.\n * @param {string} regExpText The raw text used to create the regular expression\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n * @example\n *\n * parseRegExp('a\\\\b[cd-]')\n *\n * returns:\n * [\n *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n * ]\n */\n\nfunction parseRegExp(regExpText) {\n  const charList = [];\n  regExpText.split(\"\").reduce((state, char, index) => {\n    if (!state.escapeNextChar) {\n      if (char === \"\\\\\") {\n        return Object.assign(state, {\n          escapeNextChar: true\n        });\n      }\n\n      if (char === \"[\" && !state.inCharClass) {\n        return Object.assign(state, {\n          inCharClass: true,\n          startingCharClass: true\n        });\n      }\n\n      if (char === \"]\" && state.inCharClass) {\n        if (charList.length && charList[charList.length - 1].inCharClass) {\n          charList[charList.length - 1].endsCharClass = true;\n        }\n\n        return Object.assign(state, {\n          inCharClass: false,\n          startingCharClass: false\n        });\n      }\n    }\n\n    charList.push({\n      text: char,\n      index,\n      escaped: state.escapeNextChar,\n      inCharClass: state.inCharClass,\n      startsCharClass: state.startingCharClass,\n      endsCharClass: false\n    });\n    return Object.assign(state, {\n      escapeNextChar: false,\n      startingCharClass: false\n    });\n  }, {\n    escapeNextChar: false,\n    inCharClass: false,\n    startingCharClass: false\n  });\n  return charList;\n}\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary escape characters\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-useless-escape\",\n      suggestion: true\n    },\n    messages: {\n      unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n      removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n      escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Reports a node\n     * @param {ASTNode} node The node to report\n     * @param {number} startOffset The backslash's offset from the start of the node\n     * @param {string} character The uselessly escaped character (not including the backslash)\n     * @returns {void}\n     */\n\n    function report(node, startOffset, character) {\n      const rangeStart = node.range[0] + startOffset;\n      const range = [rangeStart, rangeStart + 1];\n      const start = sourceCode.getLocFromIndex(rangeStart);\n      context.report({\n        node,\n        loc: {\n          start,\n          end: {\n            line: start.line,\n            column: start.column + 1\n          }\n        },\n        messageId: \"unnecessaryEscape\",\n        data: {\n          character\n        },\n        suggest: [{\n          messageId: \"removeEscape\",\n\n          fix(fixer) {\n            return fixer.removeRange(range);\n          }\n\n        }, {\n          messageId: \"escapeBackslash\",\n\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\\\\");\n          }\n\n        }]\n      });\n    }\n    /**\n     * Checks if the escape character in given string slice is unnecessary.\n     * @private\n     * @param {ASTNode} node node to validate.\n     * @param {string} match string slice to validate.\n     * @returns {void}\n     */\n\n\n    function validateString(node, match) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n      const escapedChar = match[0][1];\n      let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n      let isQuoteEscape;\n\n      if (isTemplateElement) {\n        isQuoteEscape = escapedChar === \"`\";\n\n        if (escapedChar === \"$\") {\n          // Warn if `\\$` is not followed by `{`\n          isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n        } else if (escapedChar === \"{\") {\n          /*\n           * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n           * is necessary and the rule should not warn. If preceded by `/$`, the rule\n           * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n           */\n          isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n        }\n      } else {\n        isQuoteEscape = escapedChar === node.raw[0];\n      }\n\n      if (isUnnecessaryEscape && !isQuoteEscape) {\n        report(node, match.index, match[0].slice(1));\n      }\n    }\n    /**\n     * Checks if a node has an escape.\n     * @param {ASTNode} node node to check.\n     * @returns {void}\n     */\n\n\n    function check(node) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n\n      if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === \"TaggedTemplateExpression\" && node.parent === node.parent.parent.quasi) {\n        // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n        return;\n      }\n\n      if (typeof node.value === \"string\" || isTemplateElement) {\n        /*\n         * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n         * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n         */\n        if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n          return;\n        }\n\n        const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n        const pattern = /\\\\[^\\d]/gu;\n        let match;\n\n        while (match = pattern.exec(value)) {\n          validateString(node, match);\n        }\n      } else if (node.regex) {\n        parseRegExp(node.regex.pattern)\n        /*\n         * The '-' character is a special case, because it's only valid to escape it if it's in a character\n         * class, and is not at either edge of the character class. To account for this, don't consider '-'\n         * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n         * character class.\n         */\n        .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n        /*\n         * The '^' character is also a special case; it must always be escaped outside of character classes, but\n         * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n         * account for this, consider it to be a valid escape character outside of character classes, and filter\n         * out '^' characters that appear at the start of a character class.\n         */\n        .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass)) // Filter out characters that aren't escaped.\n        .filter(charInfo => charInfo.escaped) // Filter out characters that are valid to escape, based on their position in the regular expression.\n        .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text)) // Report all the remaining characters.\n        .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n      }\n    }\n\n    return {\n      Literal: check,\n      TemplateElement: check\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","union","setA","setB","Set","VALID_STRING_ESCAPES","LINEBREAKS","REGEX_GENERAL_ESCAPES","REGEX_NON_CHARCLASS_ESCAPES","parseRegExp","regExpText","charList","split","reduce","state","char","index","escapeNextChar","Object","assign","inCharClass","startingCharClass","length","endsCharClass","push","text","escaped","startsCharClass","module","exports","meta","type","docs","description","category","recommended","url","suggestion","messages","unnecessaryEscape","removeEscape","escapeBackslash","schema","create","context","sourceCode","getSourceCode","report","node","startOffset","character","rangeStart","range","start","getLocFromIndex","loc","end","line","column","messageId","data","suggest","fix","fixer","removeRange","insertTextBeforeRange","validateString","match","isTemplateElement","escapedChar","isUnnecessaryEscape","has","isQuoteEscape","input","raw","slice","check","parent","quasi","value","getText","pattern","exec","regex","filter","charInfo","forEach","Literal","TemplateElement"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-useless-escape.js"],"sourcesContent":["/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\nfunction union(setA, setB) {\n    return new Set(function *() {\n        yield* setA;\n        yield* setB;\n    }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\n/**\n * Parses a regular expression into a list of characters with character class info.\n * @param {string} regExpText The raw text used to create the regular expression\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n * @example\n *\n * parseRegExp('a\\\\b[cd-]')\n *\n * returns:\n * [\n *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n * ]\n */\nfunction parseRegExp(regExpText) {\n    const charList = [];\n\n    regExpText.split(\"\").reduce((state, char, index) => {\n        if (!state.escapeNextChar) {\n            if (char === \"\\\\\") {\n                return Object.assign(state, { escapeNextChar: true });\n            }\n            if (char === \"[\" && !state.inCharClass) {\n                return Object.assign(state, { inCharClass: true, startingCharClass: true });\n            }\n            if (char === \"]\" && state.inCharClass) {\n                if (charList.length && charList[charList.length - 1].inCharClass) {\n                    charList[charList.length - 1].endsCharClass = true;\n                }\n                return Object.assign(state, { inCharClass: false, startingCharClass: false });\n            }\n        }\n        charList.push({\n            text: char,\n            index,\n            escaped: state.escapeNextChar,\n            inCharClass: state.inCharClass,\n            startsCharClass: state.startingCharClass,\n            endsCharClass: false\n        });\n        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });\n    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });\n\n    return charList;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary escape characters\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-useless-escape\",\n            suggestion: true\n        },\n\n        messages: {\n            unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n            removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n            escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a node\n         * @param {ASTNode} node The node to report\n         * @param {number} startOffset The backslash's offset from the start of the node\n         * @param {string} character The uselessly escaped character (not including the backslash)\n         * @returns {void}\n         */\n        function report(node, startOffset, character) {\n            const rangeStart = node.range[0] + startOffset;\n            const range = [rangeStart, rangeStart + 1];\n            const start = sourceCode.getLocFromIndex(rangeStart);\n\n            context.report({\n                node,\n                loc: {\n                    start,\n                    end: { line: start.line, column: start.column + 1 }\n                },\n                messageId: \"unnecessaryEscape\",\n                data: { character },\n                suggest: [\n                    {\n                        messageId: \"removeEscape\",\n                        fix(fixer) {\n                            return fixer.removeRange(range);\n                        }\n                    },\n                    {\n                        messageId: \"escapeBackslash\",\n                        fix(fixer) {\n                            return fixer.insertTextBeforeRange(range, \"\\\\\");\n                        }\n                    }\n                ]\n            });\n        }\n\n        /**\n         * Checks if the escape character in given string slice is unnecessary.\n         * @private\n         * @param {ASTNode} node node to validate.\n         * @param {string} match string slice to validate.\n         * @returns {void}\n         */\n        function validateString(node, match) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n            const escapedChar = match[0][1];\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n            let isQuoteEscape;\n\n            if (isTemplateElement) {\n                isQuoteEscape = escapedChar === \"`\";\n\n                if (escapedChar === \"$\") {\n\n                    // Warn if `\\$` is not followed by `{`\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n                } else if (escapedChar === \"{\") {\n\n                    /*\n                     * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n                     */\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n                }\n            } else {\n                isQuoteEscape = escapedChar === node.raw[0];\n            }\n\n            if (isUnnecessaryEscape && !isQuoteEscape) {\n                report(node, match.index, match[0].slice(1));\n            }\n        }\n\n        /**\n         * Checks if a node has an escape.\n         * @param {ASTNode} node node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n\n            if (\n                isTemplateElement &&\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\n                node.parent === node.parent.parent.quasi\n            ) {\n\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n                return;\n            }\n\n            if (typeof node.value === \"string\" || isTemplateElement) {\n\n                /*\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n                 */\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n                    return;\n                }\n\n                const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n                const pattern = /\\\\[^\\d]/gu;\n                let match;\n\n                while ((match = pattern.exec(value))) {\n                    validateString(node, match);\n                }\n            } else if (node.regex) {\n                parseRegExp(node.regex.pattern)\n\n                    /*\n                     * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                     * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                     * character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n\n                    /*\n                     * The '^' character is also a special case; it must always be escaped outside of character classes, but\n                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n                     * account for this, consider it to be a valid escape character outside of character classes, and filter\n                     * out '^' characters that appear at the start of a character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass))\n\n                    // Filter out characters that aren't escaped.\n                    .filter(charInfo => charInfo.escaped)\n\n                    // Filter out characters that are valid to escape, based on their position in the regular expression.\n                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))\n\n                    // Report all the remaining characters.\n                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n            }\n\n        }\n\n        return {\n            Literal: check,\n            TemplateElement: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}