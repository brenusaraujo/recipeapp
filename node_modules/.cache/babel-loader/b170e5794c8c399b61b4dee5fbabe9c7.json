{"ast":null,"code":"/**\n * @fileoverview disallow unnecessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\n\n\nfunction isConcatenation(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\n\n\nfunction isConcatOperatorToken(token) {\n  return token.value === \"+\" && token.type === \"Punctuator\";\n}\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\n\n\nfunction getLeft(node) {\n  let left = node.left;\n\n  while (isConcatenation(left)) {\n    left = left.right;\n  }\n\n  return left;\n}\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\n\n\nfunction getRight(node) {\n  let right = node.right;\n\n  while (isConcatenation(right)) {\n    right = right.left;\n  }\n\n  return right;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary concatenation of literals or template literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-concat\"\n    },\n    schema: [],\n    messages: {\n      unexpectedConcat: \"Unexpected string concatenation of literals.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      BinaryExpression(node) {\n        // check if not concatenation\n        if (node.operator !== \"+\") {\n          return;\n        } // account for the `foo + \"a\" + \"b\"` case\n\n\n        const left = getLeft(node);\n        const right = getRight(node);\n\n        if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {\n          const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n          context.report({\n            node,\n            loc: operatorToken.loc,\n            messageId: \"unexpectedConcat\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isConcatenation","node","type","operator","isConcatOperatorToken","token","value","getLeft","left","right","getRight","module","exports","meta","docs","description","category","recommended","url","schema","messages","unexpectedConcat","create","context","sourceCode","getSourceCode","BinaryExpression","isStringLiteral","isTokenOnSameLine","operatorToken","getFirstTokenBetween","report","loc","messageId"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-useless-concat.js"],"sourcesContent":["/**\n * @fileoverview disallow unnecessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\nfunction isConcatOperatorToken(token) {\n    return token.value === \"+\" && token.type === \"Punctuator\";\n}\n\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getLeft(node) {\n    let left = node.left;\n\n    while (isConcatenation(left)) {\n        left = left.right;\n    }\n    return left;\n}\n\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getRight(node) {\n    let right = node.right;\n\n    while (isConcatenation(right)) {\n        right = right.left;\n    }\n    return right;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary concatenation of literals or template literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-concat\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedConcat: \"Unexpected string concatenation of literals.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n\n                // check if not concatenation\n                if (node.operator !== \"+\") {\n                    return;\n                }\n\n                // account for the `foo + \"a\" + \"b\"` case\n                const left = getLeft(node);\n                const right = getRight(node);\n\n                if (astUtils.isStringLiteral(left) &&\n                    astUtils.isStringLiteral(right) &&\n                    astUtils.isTokenOnSameLine(left, right)\n                ) {\n                    const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n\n                    context.report({\n                        node,\n                        loc: operatorToken.loc,\n                        messageId: \"unexpectedConcat\"\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASC,eAAT,CAAyBC,IAAzB,EAA+B;EAC3B,OAAOA,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoCD,IAAI,CAACE,QAAL,KAAkB,GAA7D;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,qBAAT,CAA+BC,KAA/B,EAAsC;EAClC,OAAOA,KAAK,CAACC,KAAN,KAAgB,GAAhB,IAAuBD,KAAK,CAACH,IAAN,KAAe,YAA7C;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASK,OAAT,CAAiBN,IAAjB,EAAuB;EACnB,IAAIO,IAAI,GAAGP,IAAI,CAACO,IAAhB;;EAEA,OAAOR,eAAe,CAACQ,IAAD,CAAtB,EAA8B;IAC1BA,IAAI,GAAGA,IAAI,CAACC,KAAZ;EACH;;EACD,OAAOD,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASE,QAAT,CAAkBT,IAAlB,EAAwB;EACpB,IAAIQ,KAAK,GAAGR,IAAI,CAACQ,KAAjB;;EAEA,OAAOT,eAAe,CAACS,KAAD,CAAtB,EAA+B;IAC3BA,KAAK,GAAGA,KAAK,CAACD,IAAd;EACH;;EACD,OAAOC,KAAP;AACH,C,CAED;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFX,IAAI,EAAE,YADJ;IAGFY,IAAI,EAAE;MACFC,WAAW,EAAE,qEADX;MAEFC,QAAQ,EAAE,gBAFR;MAGFC,WAAW,EAAE,KAHX;MAIFC,GAAG,EAAE;IAJH,CAHJ;IAUFC,MAAM,EAAE,EAVN;IAYFC,QAAQ,EAAE;MACNC,gBAAgB,EAAE;IADZ;EAZR,CADO;;EAkBbC,MAAM,CAACC,OAAD,EAAU;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;IAEA,OAAO;MACHC,gBAAgB,CAACzB,IAAD,EAAO;QAEnB;QACA,IAAIA,IAAI,CAACE,QAAL,KAAkB,GAAtB,EAA2B;UACvB;QACH,CALkB,CAOnB;;;QACA,MAAMK,IAAI,GAAGD,OAAO,CAACN,IAAD,CAApB;QACA,MAAMQ,KAAK,GAAGC,QAAQ,CAACT,IAAD,CAAtB;;QAEA,IAAIH,QAAQ,CAAC6B,eAAT,CAAyBnB,IAAzB,KACAV,QAAQ,CAAC6B,eAAT,CAAyBlB,KAAzB,CADA,IAEAX,QAAQ,CAAC8B,iBAAT,CAA2BpB,IAA3B,EAAiCC,KAAjC,CAFJ,EAGE;UACE,MAAMoB,aAAa,GAAGL,UAAU,CAACM,oBAAX,CAAgCtB,IAAhC,EAAsCC,KAAtC,EAA6CL,qBAA7C,CAAtB;UAEAmB,OAAO,CAACQ,MAAR,CAAe;YACX9B,IADW;YAEX+B,GAAG,EAAEH,aAAa,CAACG,GAFR;YAGXC,SAAS,EAAE;UAHA,CAAf;QAKH;MACJ;;IAxBE,CAAP;EA0BH;;AA/CY,CAAjB"},"metadata":{},"sourceType":"script"}