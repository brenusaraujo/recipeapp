{"ast":null,"code":"/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow an empty line between class members\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptAfterSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      never: \"Unexpected blank line between class members.\",\n      always: \"Expected blank line between class members.\"\n    }\n  },\n\n  create(context) {\n    const options = [];\n    options[0] = context.options[0] || \"always\";\n    options[1] = context.options[1] || {\n      exceptAfterSingleLine: false\n    };\n    const sourceCode = context.getSourceCode();\n    /**\n     * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The last token among the consecutive tokens.\n     */\n\n    function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n      const after = sourceCode.getTokenAfter(prevLastToken, {\n        includeComments: true\n      });\n\n      if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n        return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n      }\n\n      return prevLastToken;\n    }\n    /**\n     * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The first token among the consecutive tokens.\n     */\n\n\n    function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n      const before = sourceCode.getTokenBefore(nextFirstToken, {\n        includeComments: true\n      });\n\n      if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n        return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n      }\n\n      return nextFirstToken;\n    }\n    /**\n     * Checks if there is a token or comment between two tokens.\n     * @param {Token} before The token before.\n     * @param {Token} after The token after.\n     * @returns {boolean} True if there is a token or comment between two tokens.\n     */\n\n\n    function hasTokenOrCommentBetween(before, after) {\n      return sourceCode.getTokensBetween(before, after, {\n        includeComments: true\n      }).length !== 0;\n    }\n\n    return {\n      ClassBody(node) {\n        const body = node.body;\n\n        for (let i = 0; i < body.length - 1; i++) {\n          const curFirst = sourceCode.getFirstToken(body[i]);\n          const curLast = sourceCode.getLastToken(body[i]);\n          const nextFirst = sourceCode.getFirstToken(body[i + 1]);\n          const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n          const skip = !isMulti && options[1].exceptAfterSingleLine;\n          const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n          const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n          const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n          const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n          const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n          if (options[0] === \"always\" && !skip && !isPadded || options[0] === \"never\" && isPadded) {\n            context.report({\n              node: body[i + 1],\n              messageId: isPadded ? \"never\" : \"always\",\n\n              fix(fixer) {\n                if (hasTokenInPadding) {\n                  return null;\n                }\n\n                return isPadded ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\") : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","exceptAfterSingleLine","default","additionalProperties","messages","never","always","create","context","options","sourceCode","getSourceCode","findLastConsecutiveTokenAfter","prevLastToken","nextFirstToken","maxLine","after","getTokenAfter","includeComments","loc","start","line","end","findFirstConsecutiveTokenBefore","before","getTokenBefore","hasTokenOrCommentBetween","getTokensBetween","length","ClassBody","node","body","i","curFirst","getFirstToken","curLast","getLastToken","nextFirst","isMulti","isTokenOnSameLine","skip","beforePadding","afterPadding","isPadded","hasTokenInPadding","curLineLastToken","report","messageId","fix","fixer","replaceTextRange","range","insertTextAfter"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/lines-between-class-members.js"],"sourcesContent":["/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow an empty line between class members\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptAfterSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            never: \"Unexpected blank line between class members.\",\n            always: \"Expected blank line between class members.\"\n        }\n    },\n\n    create(context) {\n\n        const options = [];\n\n        options[0] = context.options[0] || \"always\";\n        options[1] = context.options[1] || { exceptAfterSingleLine: false };\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The last token among the consecutive tokens.\n         */\n        function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n            const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });\n\n            if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n                return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n            }\n            return prevLastToken;\n        }\n\n        /**\n         * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The first token among the consecutive tokens.\n         */\n        function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n            const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });\n\n            if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n                return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n            }\n            return nextFirstToken;\n        }\n\n        /**\n         * Checks if there is a token or comment between two tokens.\n         * @param {Token} before The token before.\n         * @param {Token} after The token after.\n         * @returns {boolean} True if there is a token or comment between two tokens.\n         */\n        function hasTokenOrCommentBetween(before, after) {\n            return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;\n        }\n\n        return {\n            ClassBody(node) {\n                const body = node.body;\n\n                for (let i = 0; i < body.length - 1; i++) {\n                    const curFirst = sourceCode.getFirstToken(body[i]);\n                    const curLast = sourceCode.getLastToken(body[i]);\n                    const nextFirst = sourceCode.getFirstToken(body[i + 1]);\n                    const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n                    const skip = !isMulti && options[1].exceptAfterSingleLine;\n                    const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n                    const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n                    const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n                    const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n                    const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n                    if ((options[0] === \"always\" && !skip && !isPadded) ||\n                        (options[0] === \"never\" && isPadded)) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: isPadded ? \"never\" : \"always\",\n                            fix(fixer) {\n                                if (hasTokenInPadding) {\n                                    return null;\n                                }\n                                return isPadded\n                                    ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\")\n                                    : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}