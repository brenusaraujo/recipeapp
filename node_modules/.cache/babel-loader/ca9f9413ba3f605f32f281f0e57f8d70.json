{"ast":null,"code":"/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newline at the end of files\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eol-last\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"unix\", \"windows\"]\n    }],\n    messages: {\n      missing: \"Newline required at end of file but not found.\",\n      unexpected: \"Newline not allowed at end of file.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n    return {\n      Program: function checkBadEOF(node) {\n        const sourceCode = context.getSourceCode(),\n              src = sourceCode.getText(),\n              lastLine = sourceCode.lines[sourceCode.lines.length - 1],\n              location = {\n          column: lastLine.length,\n          line: sourceCode.lines.length\n        },\n              LF = \"\\n\",\n              CRLF = `\\r${LF}`,\n              endsWithNewline = src.endsWith(LF);\n        /*\n         * Empty source is always valid: No content in file so we don't\n         * need to lint for a newline on the last line of content.\n         */\n\n        if (!src.length) {\n          return;\n        }\n\n        let mode = context.options[0] || \"always\",\n            appendCRLF = false;\n\n        if (mode === \"unix\") {\n          // `\"unix\"` should behave exactly as `\"always\"`\n          mode = \"always\";\n        }\n\n        if (mode === \"windows\") {\n          // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n          mode = \"always\";\n          appendCRLF = true;\n        }\n\n        if (mode === \"always\" && !endsWithNewline) {\n          // File is not newline-terminated, but should be\n          context.report({\n            node,\n            loc: location,\n            messageId: \"missing\",\n\n            fix(fixer) {\n              return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n            }\n\n          });\n        } else if (mode === \"never\" && endsWithNewline) {\n          // File is newline-terminated, but shouldn't be\n          context.report({\n            node,\n            loc: location,\n            messageId: \"unexpected\",\n\n            fix(fixer) {\n              const finalEOLs = /(?:\\r?\\n)+$/u,\n                    match = finalEOLs.exec(sourceCode.text),\n                    start = match.index,\n                    end = sourceCode.text.length;\n              return fixer.replaceTextRange([start, end], \"\");\n            }\n\n          });\n        }\n      }\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","missing","unexpected","create","context","Program","checkBadEOF","node","sourceCode","getSourceCode","src","getText","lastLine","lines","length","location","column","line","LF","CRLF","endsWithNewline","endsWith","mode","options","appendCRLF","report","loc","messageId","fix","fixer","insertTextAfterRange","finalEOLs","match","exec","text","start","index","end","replaceTextRange"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/eol-last.js"],"sourcesContent":["/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newline at the end of files\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eol-last\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"unix\", \"windows\"]\n            }\n        ],\n\n        messages: {\n            missing: \"Newline required at end of file but not found.\",\n            unexpected: \"Newline not allowed at end of file.\"\n        }\n    },\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkBadEOF(node) {\n                const sourceCode = context.getSourceCode(),\n                    src = sourceCode.getText(),\n                    lastLine = sourceCode.lines[sourceCode.lines.length - 1],\n                    location = {\n                        column: lastLine.length,\n                        line: sourceCode.lines.length\n                    },\n                    LF = \"\\n\",\n                    CRLF = `\\r${LF}`,\n                    endsWithNewline = src.endsWith(LF);\n\n                /*\n                 * Empty source is always valid: No content in file so we don't\n                 * need to lint for a newline on the last line of content.\n                 */\n                if (!src.length) {\n                    return;\n                }\n\n                let mode = context.options[0] || \"always\",\n                    appendCRLF = false;\n\n                if (mode === \"unix\") {\n\n                    // `\"unix\"` should behave exactly as `\"always\"`\n                    mode = \"always\";\n                }\n                if (mode === \"windows\") {\n\n                    // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n                    mode = \"always\";\n                    appendCRLF = true;\n                }\n                if (mode === \"always\" && !endsWithNewline) {\n\n                    // File is not newline-terminated, but should be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"missing\",\n                        fix(fixer) {\n                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n                        }\n                    });\n                } else if (mode === \"never\" && endsWithNewline) {\n\n                    // File is newline-terminated, but shouldn't be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"unexpected\",\n                        fix(fixer) {\n                            const finalEOLs = /(?:\\r?\\n)+$/u,\n                                match = finalEOLs.exec(sourceCode.text),\n                                start = match.index,\n                                end = sourceCode.text.length;\n\n                            return fixer.replaceTextRange([start, end], \"\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}