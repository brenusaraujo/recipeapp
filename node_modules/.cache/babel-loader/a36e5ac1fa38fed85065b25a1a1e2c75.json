{"ast":null,"code":"/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce comparing `typeof` expressions against valid strings\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/valid-typeof\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        requireStringLiterals: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalidValue: \"Invalid typeof comparison value.\",\n      notString: \"Typeof comparisons should be to string literals.\"\n    }\n  },\n\n  create(context) {\n    const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"],\n          OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n    const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n    /**\n     * Determines whether a node is a typeof expression.\n     * @param {ASTNode} node The node\n     * @returns {boolean} `true` if the node is a typeof expression\n     */\n\n    function isTypeofExpression(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      UnaryExpression(node) {\n        if (isTypeofExpression(node)) {\n          const parent = context.getAncestors().pop();\n\n          if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n            const sibling = parent.left === node ? parent.right : parent.left;\n\n            if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n              const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n              if (VALID_TYPES.indexOf(value) === -1) {\n                context.report({\n                  node: sibling,\n                  messageId: \"invalidValue\"\n                });\n              }\n            } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n              context.report({\n                node: sibling,\n                messageId: \"notString\"\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","requireStringLiterals","default","additionalProperties","messages","invalidValue","notString","create","context","VALID_TYPES","OPERATORS","options","isTypeofExpression","node","operator","UnaryExpression","parent","getAncestors","pop","indexOf","sibling","left","right","expressions","length","value","quasis","cooked","report","messageId"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/valid-typeof.js"],"sourcesContent":["/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce comparing `typeof` expressions against valid strings\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/valid-typeof\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireStringLiterals: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            invalidValue: \"Invalid typeof comparison value.\",\n            notString: \"Typeof comparisons should be to string literals.\"\n        }\n    },\n\n    create(context) {\n\n        const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"],\n            OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n\n        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n        /**\n         * Determines whether a node is a typeof expression.\n         * @param {ASTNode} node The node\n         * @returns {boolean} `true` if the node is a typeof expression\n         */\n        function isTypeofExpression(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            UnaryExpression(node) {\n                if (isTypeofExpression(node)) {\n                    const parent = context.getAncestors().pop();\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n                        const sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n                            if (VALID_TYPES.indexOf(value) === -1) {\n                                context.report({ node: sibling, messageId: \"invalidValue\" });\n                            }\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n                            context.report({ node: sibling, messageId: \"notString\" });\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,SADJ;IAGFC,IAAI,EAAE;MACFC,WAAW,EAAE,8DADX;MAEFC,QAAQ,EAAE,iBAFR;MAGFC,WAAW,EAAE,IAHX;MAIFC,GAAG,EAAE;IAJH,CAHJ;IAUFC,MAAM,EAAE,CACJ;MACIN,IAAI,EAAE,QADV;MAEIO,UAAU,EAAE;QACRC,qBAAqB,EAAE;UACnBR,IAAI,EAAE,SADa;UAEnBS,OAAO,EAAE;QAFU;MADf,CAFhB;MAQIC,oBAAoB,EAAE;IAR1B,CADI,CAVN;IAsBFC,QAAQ,EAAE;MACNC,YAAY,EAAE,kCADR;MAENC,SAAS,EAAE;IAFL;EAtBR,CADO;;EA6BbC,MAAM,CAACC,OAAD,EAAU;IAEZ,MAAMC,WAAW,GAAG,CAAC,QAAD,EAAW,WAAX,EAAwB,QAAxB,EAAkC,SAAlC,EAA6C,QAA7C,EAAuD,QAAvD,EAAiE,UAAjE,EAA6E,QAA7E,CAApB;IAAA,MACIC,SAAS,GAAG,CAAC,IAAD,EAAO,KAAP,EAAc,IAAd,EAAoB,KAApB,CADhB;IAGA,MAAMT,qBAAqB,GAAGO,OAAO,CAACG,OAAR,CAAgB,CAAhB,KAAsBH,OAAO,CAACG,OAAR,CAAgB,CAAhB,EAAmBV,qBAAvE;IAEA;AACR;AACA;AACA;AACA;;IACQ,SAASW,kBAAT,CAA4BC,IAA5B,EAAkC;MAC9B,OAAOA,IAAI,CAACpB,IAAL,KAAc,iBAAd,IAAmCoB,IAAI,CAACC,QAAL,KAAkB,QAA5D;IACH,CAdW,CAgBZ;IACA;IACA;;;IAEA,OAAO;MAEHC,eAAe,CAACF,IAAD,EAAO;QAClB,IAAID,kBAAkB,CAACC,IAAD,CAAtB,EAA8B;UAC1B,MAAMG,MAAM,GAAGR,OAAO,CAACS,YAAR,GAAuBC,GAAvB,EAAf;;UAEA,IAAIF,MAAM,CAACvB,IAAP,KAAgB,kBAAhB,IAAsCiB,SAAS,CAACS,OAAV,CAAkBH,MAAM,CAACF,QAAzB,MAAuC,CAAC,CAAlF,EAAqF;YACjF,MAAMM,OAAO,GAAGJ,MAAM,CAACK,IAAP,KAAgBR,IAAhB,GAAuBG,MAAM,CAACM,KAA9B,GAAsCN,MAAM,CAACK,IAA7D;;YAEA,IAAID,OAAO,CAAC3B,IAAR,KAAiB,SAAjB,IAA8B2B,OAAO,CAAC3B,IAAR,KAAiB,iBAAjB,IAAsC,CAAC2B,OAAO,CAACG,WAAR,CAAoBC,MAA7F,EAAqG;cACjG,MAAMC,KAAK,GAAGL,OAAO,CAAC3B,IAAR,KAAiB,SAAjB,GAA6B2B,OAAO,CAACK,KAArC,GAA6CL,OAAO,CAACM,MAAR,CAAe,CAAf,EAAkBD,KAAlB,CAAwBE,MAAnF;;cAEA,IAAIlB,WAAW,CAACU,OAAZ,CAAoBM,KAApB,MAA+B,CAAC,CAApC,EAAuC;gBACnCjB,OAAO,CAACoB,MAAR,CAAe;kBAAEf,IAAI,EAAEO,OAAR;kBAAiBS,SAAS,EAAE;gBAA5B,CAAf;cACH;YACJ,CAND,MAMO,IAAI5B,qBAAqB,IAAI,CAACW,kBAAkB,CAACQ,OAAD,CAAhD,EAA2D;cAC9DZ,OAAO,CAACoB,MAAR,CAAe;gBAAEf,IAAI,EAAEO,OAAR;gBAAiBS,SAAS,EAAE;cAA5B,CAAf;YACH;UACJ;QACJ;MACJ;;IApBE,CAAP;EAwBH;;AAzEY,CAAjB"},"metadata":{},"sourceType":"script"}