{"ast":null,"code":"/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow trailing whitespace at the end of lines\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        skipBlankLines: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      trailingSpace: \"Trailing spaces not allowed.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n          SKIP_BLANK = `^${BLANK_CLASS}*$`,\n          NONBLANK = `${BLANK_CLASS}+$`;\n    const options = context.options[0] || {},\n          skipBlankLines = options.skipBlankLines || false,\n          ignoreComments = options.ignoreComments || false;\n    /**\n     * Report the error message\n     * @param {ASTNode} node node to report\n     * @param {int[]} location range information\n     * @param {int[]} fixRange Range based on the whole program\n     * @returns {void}\n     */\n\n    function report(node, location, fixRange) {\n      /*\n       * Passing node is a bit dirty, because message data will contain big\n       * text in `source`. But... who cares :) ?\n       * One more kludge will not make worse the bloody wizardry of this\n       * plugin.\n       */\n      context.report({\n        node,\n        loc: location,\n        messageId: \"trailingSpace\",\n\n        fix(fixer) {\n          return fixer.removeRange(fixRange);\n        }\n\n      });\n    }\n    /**\n     * Given a list of comment nodes, return the line numbers for those comments.\n     * @param {Array} comments An array of comment nodes.\n     * @returns {number[]} An array of line numbers containing comments.\n     */\n\n\n    function getCommentLineNumbers(comments) {\n      const lines = new Set();\n      comments.forEach(comment => {\n        const endLine = comment.type === \"Block\" ? comment.loc.end.line - 1 : comment.loc.end.line;\n\n        for (let i = comment.loc.start.line; i <= endLine; i++) {\n          lines.add(i);\n        }\n      });\n      return lines;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: function checkTrailingSpaces(node) {\n        /*\n         * Let's hack. Since Espree does not return whitespace nodes,\n         * fetch the source code and do matching via regexps.\n         */\n        const re = new RegExp(NONBLANK, \"u\"),\n              skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n              lines = sourceCode.lines,\n              linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n              comments = sourceCode.getAllComments(),\n              commentLineNumbers = getCommentLineNumbers(comments);\n        let totalLength = 0,\n            fixRange = [];\n\n        for (let i = 0, ii = lines.length; i < ii; i++) {\n          const lineNumber = i + 1;\n          /*\n           * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n           * Because during the fix time they also reserve one spot in the array.\n           * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n           */\n\n          const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n          const lineLength = lines[i].length + linebreakLength;\n          const matches = re.exec(lines[i]);\n\n          if (matches) {\n            const location = {\n              start: {\n                line: lineNumber,\n                column: matches.index\n              },\n              end: {\n                line: lineNumber,\n                column: lineLength - linebreakLength\n              }\n            };\n            const rangeStart = totalLength + location.start.column;\n            const rangeEnd = totalLength + location.end.column;\n            const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n            if (containingNode && containingNode.type === \"TemplateElement\" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {\n              totalLength += lineLength;\n              continue;\n            }\n            /*\n             * If the line has only whitespace, and skipBlankLines\n             * is true, don't report it\n             */\n\n\n            if (skipBlankLines && skipMatch.test(lines[i])) {\n              totalLength += lineLength;\n              continue;\n            }\n\n            fixRange = [rangeStart, rangeEnd];\n\n            if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n              report(node, location, fixRange);\n            }\n          }\n\n          totalLength += lineLength;\n        }\n      }\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","skipBlankLines","default","ignoreComments","additionalProperties","messages","trailingSpace","create","context","sourceCode","getSourceCode","BLANK_CLASS","SKIP_BLANK","NONBLANK","options","report","node","location","fixRange","loc","messageId","fix","fixer","removeRange","getCommentLineNumbers","comments","lines","Set","forEach","comment","endLine","end","line","i","start","add","Program","checkTrailingSpaces","re","RegExp","skipMatch","linebreaks","getText","match","createGlobalLinebreakMatcher","getAllComments","commentLineNumbers","totalLength","ii","length","lineNumber","linebreakLength","lineLength","matches","exec","column","index","rangeStart","rangeEnd","containingNode","getNodeByRangeIndex","parent","range","test","has"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-trailing-spaces.js"],"sourcesContent":["/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow trailing whitespace at the end of lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipBlankLines: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            trailingSpace: \"Trailing spaces not allowed.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n            SKIP_BLANK = `^${BLANK_CLASS}*$`,\n            NONBLANK = `${BLANK_CLASS}+$`;\n\n        const options = context.options[0] || {},\n            skipBlankLines = options.skipBlankLines || false,\n            ignoreComments = options.ignoreComments || false;\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @param {int[]} location range information\n         * @param {int[]} fixRange Range based on the whole program\n         * @returns {void}\n         */\n        function report(node, location, fixRange) {\n\n            /*\n             * Passing node is a bit dirty, because message data will contain big\n             * text in `source`. But... who cares :) ?\n             * One more kludge will not make worse the bloody wizardry of this\n             * plugin.\n             */\n            context.report({\n                node,\n                loc: location,\n                messageId: \"trailingSpace\",\n                fix(fixer) {\n                    return fixer.removeRange(fixRange);\n                }\n            });\n        }\n\n        /**\n         * Given a list of comment nodes, return the line numbers for those comments.\n         * @param {Array} comments An array of comment nodes.\n         * @returns {number[]} An array of line numbers containing comments.\n         */\n        function getCommentLineNumbers(comments) {\n            const lines = new Set();\n\n            comments.forEach(comment => {\n                const endLine = comment.type === \"Block\"\n                    ? comment.loc.end.line - 1\n                    : comment.loc.end.line;\n\n                for (let i = comment.loc.start.line; i <= endLine; i++) {\n                    lines.add(i);\n                }\n            });\n\n            return lines;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkTrailingSpaces(node) {\n\n                /*\n                 * Let's hack. Since Espree does not return whitespace nodes,\n                 * fetch the source code and do matching via regexps.\n                 */\n\n                const re = new RegExp(NONBLANK, \"u\"),\n                    skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n                    lines = sourceCode.lines,\n                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n                    comments = sourceCode.getAllComments(),\n                    commentLineNumbers = getCommentLineNumbers(comments);\n\n                let totalLength = 0,\n                    fixRange = [];\n\n                for (let i = 0, ii = lines.length; i < ii; i++) {\n                    const lineNumber = i + 1;\n\n                    /*\n                     * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                     * Because during the fix time they also reserve one spot in the array.\n                     * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                     */\n                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                    const lineLength = lines[i].length + linebreakLength;\n\n                    const matches = re.exec(lines[i]);\n\n                    if (matches) {\n                        const location = {\n                            start: {\n                                line: lineNumber,\n                                column: matches.index\n                            },\n                            end: {\n                                line: lineNumber,\n                                column: lineLength - linebreakLength\n                            }\n                        };\n\n                        const rangeStart = totalLength + location.start.column;\n                        const rangeEnd = totalLength + location.end.column;\n                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\n                          rangeStart > containingNode.parent.range[0] &&\n                          rangeEnd < containingNode.parent.range[1]) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        /*\n                         * If the line has only whitespace, and skipBlankLines\n                         * is true, don't report it\n                         */\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        fixRange = [rangeStart, rangeEnd];\n\n                        if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n                            report(node, location, fixRange);\n                        }\n                    }\n\n                    totalLength += lineLength;\n                }\n            }\n\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}