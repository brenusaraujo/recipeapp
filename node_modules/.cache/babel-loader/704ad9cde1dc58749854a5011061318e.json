{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useTween = void 0;\n\nconst react_1 = require(\"react\");\n/**\n * Provides an interpolated value, beginning at 0 and ending at 1, based on a\n * provided duration and animation timing function.\n */\n\n\nconst useTween = (durationMs, easingFunction, // navigationNum is an combination of numbers that are stable when the\n// animation should not be running or should continue running, but change when\n// the animation should start running. In practice, this is a combination of\n// the animation distance and slide index.\nnavigationNum, shouldInterrupt) => {\n  const [normalizedTimeRaw, setNormalizedTime] = (0, react_1.useState)(1);\n  const startTime = (0, react_1.useRef)(Date.now());\n  const rAF = (0, react_1.useRef)();\n  const isFirstRender = (0, react_1.useRef)(true);\n  const lastNavigationNum = (0, react_1.useRef)(null); // Detect on the first render following navigation if the animation should\n  // be running. If we wait for the useEffect, the first render will flash with\n  // the slide in its destination position, before the animation triggers,\n  // sending it back to the position of the first frame of the animation. This\n  // approach is done in place of a useLayoutEffect, which has issues with SSR.\n\n  const normalizedTime = lastNavigationNum.current === null || lastNavigationNum.current === navigationNum || shouldInterrupt ? normalizedTimeRaw : 0; // 0 here indicates the animation has begun\n\n  (0, react_1.useEffect)(() => {\n    lastNavigationNum.current = navigationNum; // Skip the first render as we don't want to trigger the animation right off\n    // the bat\n\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    if (shouldInterrupt) {\n      return;\n    }\n\n    startTime.current = Date.now();\n    setNormalizedTime(0);\n\n    const tick = () => {\n      rAF.current = requestAnimationFrame(() => {\n        const currentTime = Date.now();\n        const normalizedTime = Math.min(1, (currentTime - startTime.current) / durationMs);\n        setNormalizedTime(normalizedTime);\n\n        if (normalizedTime < 1) {\n          tick();\n        } else {\n          // Clean up so we can use this value to determine if the most recent\n          // animation completed\n          rAF.current = undefined;\n        }\n      });\n    };\n\n    tick();\n    return () => {\n      // If the most recent animation did not complete, cut it short and reset\n      // the animation\n      if (rAF.current !== undefined) {\n        cancelAnimationFrame(rAF.current);\n        setNormalizedTime(1);\n      }\n    };\n  }, [navigationNum, durationMs, shouldInterrupt]);\n  return {\n    isAnimating: normalizedTime !== 1,\n    value: easingFunction(normalizedTime)\n  };\n};\n\nexports.useTween = useTween;","map":{"version":3,"sources":["../../src/hooks/use-tween.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,OAAA,CAAA;AAGA;;;AAGG;;;AACI,MAAM,QAAQ,GAAG,CACtB,UADsB,EAEtB,cAFsB,EAGtB;AACA;AACA;AACA;AACA,aAPsB,EAQtB,eARsB,KASpB;EACF,MAAM,CAAC,iBAAD,EAAoB,iBAApB,IAAyC,CAAA,GAAA,OAAA,CAAA,QAAA,EAAS,CAAT,CAA/C;EACA,MAAM,SAAS,GAAG,CAAA,GAAA,OAAA,CAAA,MAAA,EAAO,IAAI,CAAC,GAAL,EAAP,CAAlB;EACA,MAAM,GAAG,GAAG,CAAA,GAAA,OAAA,CAAA,MAAA,GAAZ;EACA,MAAM,aAAa,GAAG,CAAA,GAAA,OAAA,CAAA,MAAA,EAAO,IAAP,CAAtB;EACA,MAAM,iBAAiB,GAAG,CAAA,GAAA,OAAA,CAAA,MAAA,EAAsB,IAAtB,CAA1B,CALE,CAOF;EACA;EACA;EACA;EACA;;EACA,MAAM,cAAc,GAClB,iBAAiB,CAAC,OAAlB,KAA8B,IAA9B,IACA,iBAAiB,CAAC,OAAlB,KAA8B,aAD9B,IAEA,eAFA,GAGI,iBAHJ,GAII,CALN,CAZE,CAiBO;;EAET,CAAA,GAAA,OAAA,CAAA,SAAA,EAAU,MAAK;IACb,iBAAiB,CAAC,OAAlB,GAA4B,aAA5B,CADa,CAGb;IACA;;IACA,IAAI,aAAa,CAAC,OAAlB,EAA2B;MACzB,aAAa,CAAC,OAAd,GAAwB,KAAxB;MACA;IACD;;IAED,IAAI,eAAJ,EAAqB;MACnB;IACD;;IAED,SAAS,CAAC,OAAV,GAAoB,IAAI,CAAC,GAAL,EAApB;IACA,iBAAiB,CAAC,CAAD,CAAjB;;IAEA,MAAM,IAAI,GAAG,MAAK;MAChB,GAAG,CAAC,OAAJ,GAAc,qBAAqB,CAAC,MAAK;QACvC,MAAM,WAAW,GAAG,IAAI,CAAC,GAAL,EAApB;QACA,MAAM,cAAc,GAAG,IAAI,CAAC,GAAL,CACrB,CADqB,EAErB,CAAC,WAAW,GAAG,SAAS,CAAC,OAAzB,IAAoC,UAFf,CAAvB;QAIA,iBAAiB,CAAC,cAAD,CAAjB;;QAEA,IAAI,cAAc,GAAG,CAArB,EAAwB;UACtB,IAAI;QACL,CAFD,MAEO;UACL;UACA;UACA,GAAG,CAAC,OAAJ,GAAc,SAAd;QACD;MACF,CAfkC,CAAnC;IAgBD,CAjBD;;IAkBA,IAAI;IAEJ,OAAO,MAAK;MACV;MACA;MACA,IAAI,GAAG,CAAC,OAAJ,KAAgB,SAApB,EAA+B;QAC7B,oBAAoB,CAAC,GAAG,CAAC,OAAL,CAApB;QACA,iBAAiB,CAAC,CAAD,CAAjB;MACD;IACF,CAPD;EAQD,CA7CD,EA6CG,CAAC,aAAD,EAAgB,UAAhB,EAA4B,eAA5B,CA7CH;EA+CA,OAAO;IACL,WAAW,EAAE,cAAc,KAAK,CAD3B;IAEL,KAAK,EAAE,cAAc,CAAC,cAAD;EAFhB,CAAP;AAID,CA/EM;;AAAM,OAAA,CAAA,QAAA,GAAQ,QAAR","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useTween = void 0;\nconst react_1 = require(\"react\");\n/**\n * Provides an interpolated value, beginning at 0 and ending at 1, based on a\n * provided duration and animation timing function.\n */\nconst useTween = (durationMs, easingFunction, \n// navigationNum is an combination of numbers that are stable when the\n// animation should not be running or should continue running, but change when\n// the animation should start running. In practice, this is a combination of\n// the animation distance and slide index.\nnavigationNum, shouldInterrupt) => {\n    const [normalizedTimeRaw, setNormalizedTime] = (0, react_1.useState)(1);\n    const startTime = (0, react_1.useRef)(Date.now());\n    const rAF = (0, react_1.useRef)();\n    const isFirstRender = (0, react_1.useRef)(true);\n    const lastNavigationNum = (0, react_1.useRef)(null);\n    // Detect on the first render following navigation if the animation should\n    // be running. If we wait for the useEffect, the first render will flash with\n    // the slide in its destination position, before the animation triggers,\n    // sending it back to the position of the first frame of the animation. This\n    // approach is done in place of a useLayoutEffect, which has issues with SSR.\n    const normalizedTime = lastNavigationNum.current === null ||\n        lastNavigationNum.current === navigationNum ||\n        shouldInterrupt\n        ? normalizedTimeRaw\n        : 0; // 0 here indicates the animation has begun\n    (0, react_1.useEffect)(() => {\n        lastNavigationNum.current = navigationNum;\n        // Skip the first render as we don't want to trigger the animation right off\n        // the bat\n        if (isFirstRender.current) {\n            isFirstRender.current = false;\n            return;\n        }\n        if (shouldInterrupt) {\n            return;\n        }\n        startTime.current = Date.now();\n        setNormalizedTime(0);\n        const tick = () => {\n            rAF.current = requestAnimationFrame(() => {\n                const currentTime = Date.now();\n                const normalizedTime = Math.min(1, (currentTime - startTime.current) / durationMs);\n                setNormalizedTime(normalizedTime);\n                if (normalizedTime < 1) {\n                    tick();\n                }\n                else {\n                    // Clean up so we can use this value to determine if the most recent\n                    // animation completed\n                    rAF.current = undefined;\n                }\n            });\n        };\n        tick();\n        return () => {\n            // If the most recent animation did not complete, cut it short and reset\n            // the animation\n            if (rAF.current !== undefined) {\n                cancelAnimationFrame(rAF.current);\n                setNormalizedTime(1);\n            }\n        };\n    }, [navigationNum, durationMs, shouldInterrupt]);\n    return {\n        isAnimating: normalizedTime !== 1,\n        value: easingFunction(normalizedTime),\n    };\n};\nexports.useTween = useTween;\n"]},"metadata":{},"sourceType":"script"}