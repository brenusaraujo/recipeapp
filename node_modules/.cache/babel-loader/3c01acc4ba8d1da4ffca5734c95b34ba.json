{"ast":null,"code":"/**\n * @fileoverview `OverrideTester` class.\n *\n * `OverrideTester` class handles `files` property and `excludedFiles` property\n * of `overrides` config.\n *\n * It provides one method.\n *\n * - `test(filePath)`\n *      Test if a file path matches the pair of `files` property and\n *      `excludedFiles` property. The `filePath` argument must be an absolute\n *      path.\n *\n * `ConfigArrayFactory` creates `OverrideTester` objects when it processes\n * `overrides` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst assert = require(\"assert\");\n\nconst path = require(\"path\");\n\nconst util = require(\"util\");\n\nconst {\n  Minimatch\n} = require(\"minimatch\");\n\nconst minimatchOpts = {\n  dot: true,\n  matchBase: true\n};\n/**\n * @typedef {Object} Pattern\n * @property {InstanceType<Minimatch>[] | null} includes The positive matchers.\n * @property {InstanceType<Minimatch>[] | null} excludes The negative matchers.\n */\n\n/**\n * Normalize a given pattern to an array.\n * @param {string|string[]|undefined} patterns A glob pattern or an array of glob patterns.\n * @returns {string[]|null} Normalized patterns.\n * @private\n */\n\nfunction normalizePatterns(patterns) {\n  if (Array.isArray(patterns)) {\n    return patterns.filter(Boolean);\n  }\n\n  if (typeof patterns === \"string\" && patterns) {\n    return [patterns];\n  }\n\n  return [];\n}\n/**\n * Create the matchers of given patterns.\n * @param {string[]} patterns The patterns.\n * @returns {InstanceType<Minimatch>[] | null} The matchers.\n */\n\n\nfunction toMatcher(patterns) {\n  if (patterns.length === 0) {\n    return null;\n  }\n\n  return patterns.map(pattern => {\n    if (/^\\.[/\\\\]/u.test(pattern)) {\n      return new Minimatch(pattern.slice(2), // `./*.js` should not match with `subdir/foo.js`\n      { ...minimatchOpts,\n        matchBase: false\n      });\n    }\n\n    return new Minimatch(pattern, minimatchOpts);\n  });\n}\n/**\n * Convert a given matcher to string.\n * @param {Pattern} matchers The matchers.\n * @returns {string} The string expression of the matcher.\n */\n\n\nfunction patternToJson(_ref) {\n  let {\n    includes,\n    excludes\n  } = _ref;\n  return {\n    includes: includes && includes.map(m => m.pattern),\n    excludes: excludes && excludes.map(m => m.pattern)\n  };\n}\n/**\n * The class to test given paths are matched by the patterns.\n */\n\n\nclass OverrideTester {\n  /**\n   * Create a tester with given criteria.\n   * If there are no criteria, returns `null`.\n   * @param {string|string[]} files The glob patterns for included files.\n   * @param {string|string[]} excludedFiles The glob patterns for excluded files.\n   * @param {string} basePath The path to the base directory to test paths.\n   * @returns {OverrideTester|null} The created instance or `null`.\n   */\n  static create(files, excludedFiles, basePath) {\n    const includePatterns = normalizePatterns(files);\n    const excludePatterns = normalizePatterns(excludedFiles);\n    let endsWithWildcard = false;\n\n    if (includePatterns.length === 0) {\n      return null;\n    } // Rejects absolute paths or relative paths to parents.\n\n\n    for (const pattern of includePatterns) {\n      if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n        throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n      }\n\n      if (pattern.endsWith(\"*\")) {\n        endsWithWildcard = true;\n      }\n    }\n\n    for (const pattern of excludePatterns) {\n      if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n        throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n      }\n    }\n\n    const includes = toMatcher(includePatterns);\n    const excludes = toMatcher(excludePatterns);\n    return new OverrideTester([{\n      includes,\n      excludes\n    }], basePath, endsWithWildcard);\n  }\n  /**\n   * Combine two testers by logical and.\n   * If either of the testers was `null`, returns the other tester.\n   * The `basePath` property of the two must be the same value.\n   * @param {OverrideTester|null} a A tester.\n   * @param {OverrideTester|null} b Another tester.\n   * @returns {OverrideTester|null} Combined tester.\n   */\n\n\n  static and(a, b) {\n    if (!b) {\n      return a && new OverrideTester(a.patterns, a.basePath, a.endsWithWildcard);\n    }\n\n    if (!a) {\n      return new OverrideTester(b.patterns, b.basePath, b.endsWithWildcard);\n    }\n\n    assert.strictEqual(a.basePath, b.basePath);\n    return new OverrideTester(a.patterns.concat(b.patterns), a.basePath, a.endsWithWildcard || b.endsWithWildcard);\n  }\n  /**\n   * Initialize this instance.\n   * @param {Pattern[]} patterns The matchers.\n   * @param {string} basePath The base path.\n   * @param {boolean} endsWithWildcard If `true` then a pattern ends with `*`.\n   */\n\n\n  constructor(patterns, basePath) {\n    let endsWithWildcard = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    /** @type {Pattern[]} */\n    this.patterns = patterns;\n    /** @type {string} */\n\n    this.basePath = basePath;\n    /** @type {boolean} */\n\n    this.endsWithWildcard = endsWithWildcard;\n  }\n  /**\n   * Test if a given path is matched or not.\n   * @param {string} filePath The absolute path to the target file.\n   * @returns {boolean} `true` if the path was matched.\n   */\n\n\n  test(filePath) {\n    if (typeof filePath !== \"string\" || !path.isAbsolute(filePath)) {\n      throw new Error(`'filePath' should be an absolute path, but got ${filePath}.`);\n    }\n\n    const relativePath = path.relative(this.basePath, filePath);\n    return this.patterns.every(_ref2 => {\n      let {\n        includes,\n        excludes\n      } = _ref2;\n      return (!includes || includes.some(m => m.match(relativePath))) && (!excludes || !excludes.some(m => m.match(relativePath)));\n    });\n  } // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @returns {Object} a JSON compatible object.\n   */\n\n\n  toJSON() {\n    if (this.patterns.length === 1) {\n      return { ...patternToJson(this.patterns[0]),\n        basePath: this.basePath\n      };\n    }\n\n    return {\n      AND: this.patterns.map(patternToJson),\n      basePath: this.basePath\n    };\n  } // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @returns {Object} an object to display by `console.log()`.\n   */\n\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nmodule.exports = {\n  OverrideTester\n};","map":{"version":3,"names":["assert","require","path","util","Minimatch","minimatchOpts","dot","matchBase","normalizePatterns","patterns","Array","isArray","filter","Boolean","toMatcher","length","map","pattern","test","slice","patternToJson","includes","excludes","m","OverrideTester","create","files","excludedFiles","basePath","includePatterns","excludePatterns","endsWithWildcard","isAbsolute","Error","endsWith","and","a","b","strictEqual","concat","constructor","filePath","relativePath","relative","every","some","match","toJSON","AND","inspect","custom","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/@eslint/eslintrc/lib/config-array/override-tester.js"],"sourcesContent":["/**\n * @fileoverview `OverrideTester` class.\n *\n * `OverrideTester` class handles `files` property and `excludedFiles` property\n * of `overrides` config.\n *\n * It provides one method.\n *\n * - `test(filePath)`\n *      Test if a file path matches the pair of `files` property and\n *      `excludedFiles` property. The `filePath` argument must be an absolute\n *      path.\n *\n * `ConfigArrayFactory` creates `OverrideTester` objects when it processes\n * `overrides` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst assert = require(\"assert\");\nconst path = require(\"path\");\nconst util = require(\"util\");\nconst { Minimatch } = require(\"minimatch\");\nconst minimatchOpts = { dot: true, matchBase: true };\n\n/**\n * @typedef {Object} Pattern\n * @property {InstanceType<Minimatch>[] | null} includes The positive matchers.\n * @property {InstanceType<Minimatch>[] | null} excludes The negative matchers.\n */\n\n/**\n * Normalize a given pattern to an array.\n * @param {string|string[]|undefined} patterns A glob pattern or an array of glob patterns.\n * @returns {string[]|null} Normalized patterns.\n * @private\n */\nfunction normalizePatterns(patterns) {\n    if (Array.isArray(patterns)) {\n        return patterns.filter(Boolean);\n    }\n    if (typeof patterns === \"string\" && patterns) {\n        return [patterns];\n    }\n    return [];\n}\n\n/**\n * Create the matchers of given patterns.\n * @param {string[]} patterns The patterns.\n * @returns {InstanceType<Minimatch>[] | null} The matchers.\n */\nfunction toMatcher(patterns) {\n    if (patterns.length === 0) {\n        return null;\n    }\n    return patterns.map(pattern => {\n        if (/^\\.[/\\\\]/u.test(pattern)) {\n            return new Minimatch(\n                pattern.slice(2),\n\n                // `./*.js` should not match with `subdir/foo.js`\n                { ...minimatchOpts, matchBase: false }\n            );\n        }\n        return new Minimatch(pattern, minimatchOpts);\n    });\n}\n\n/**\n * Convert a given matcher to string.\n * @param {Pattern} matchers The matchers.\n * @returns {string} The string expression of the matcher.\n */\nfunction patternToJson({ includes, excludes }) {\n    return {\n        includes: includes && includes.map(m => m.pattern),\n        excludes: excludes && excludes.map(m => m.pattern)\n    };\n}\n\n/**\n * The class to test given paths are matched by the patterns.\n */\nclass OverrideTester {\n\n    /**\n     * Create a tester with given criteria.\n     * If there are no criteria, returns `null`.\n     * @param {string|string[]} files The glob patterns for included files.\n     * @param {string|string[]} excludedFiles The glob patterns for excluded files.\n     * @param {string} basePath The path to the base directory to test paths.\n     * @returns {OverrideTester|null} The created instance or `null`.\n     */\n    static create(files, excludedFiles, basePath) {\n        const includePatterns = normalizePatterns(files);\n        const excludePatterns = normalizePatterns(excludedFiles);\n        let endsWithWildcard = false;\n\n        if (includePatterns.length === 0) {\n            return null;\n        }\n\n        // Rejects absolute paths or relative paths to parents.\n        for (const pattern of includePatterns) {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n            if (pattern.endsWith(\"*\")) {\n                endsWithWildcard = true;\n            }\n        }\n        for (const pattern of excludePatterns) {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n        }\n\n        const includes = toMatcher(includePatterns);\n        const excludes = toMatcher(excludePatterns);\n\n        return new OverrideTester(\n            [{ includes, excludes }],\n            basePath,\n            endsWithWildcard\n        );\n    }\n\n    /**\n     * Combine two testers by logical and.\n     * If either of the testers was `null`, returns the other tester.\n     * The `basePath` property of the two must be the same value.\n     * @param {OverrideTester|null} a A tester.\n     * @param {OverrideTester|null} b Another tester.\n     * @returns {OverrideTester|null} Combined tester.\n     */\n    static and(a, b) {\n        if (!b) {\n            return a && new OverrideTester(\n                a.patterns,\n                a.basePath,\n                a.endsWithWildcard\n            );\n        }\n        if (!a) {\n            return new OverrideTester(\n                b.patterns,\n                b.basePath,\n                b.endsWithWildcard\n            );\n        }\n\n        assert.strictEqual(a.basePath, b.basePath);\n        return new OverrideTester(\n            a.patterns.concat(b.patterns),\n            a.basePath,\n            a.endsWithWildcard || b.endsWithWildcard\n        );\n    }\n\n    /**\n     * Initialize this instance.\n     * @param {Pattern[]} patterns The matchers.\n     * @param {string} basePath The base path.\n     * @param {boolean} endsWithWildcard If `true` then a pattern ends with `*`.\n     */\n    constructor(patterns, basePath, endsWithWildcard = false) {\n\n        /** @type {Pattern[]} */\n        this.patterns = patterns;\n\n        /** @type {string} */\n        this.basePath = basePath;\n\n        /** @type {boolean} */\n        this.endsWithWildcard = endsWithWildcard;\n    }\n\n    /**\n     * Test if a given path is matched or not.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {boolean} `true` if the path was matched.\n     */\n    test(filePath) {\n        if (typeof filePath !== \"string\" || !path.isAbsolute(filePath)) {\n            throw new Error(`'filePath' should be an absolute path, but got ${filePath}.`);\n        }\n        const relativePath = path.relative(this.basePath, filePath);\n\n        return this.patterns.every(({ includes, excludes }) => (\n            (!includes || includes.some(m => m.match(relativePath))) &&\n            (!excludes || !excludes.some(m => m.match(relativePath)))\n        ));\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} a JSON compatible object.\n     */\n    toJSON() {\n        if (this.patterns.length === 1) {\n            return {\n                ...patternToJson(this.patterns[0]),\n                basePath: this.basePath\n            };\n        }\n        return {\n            AND: this.patterns.map(patternToJson),\n            basePath: this.basePath\n        };\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} an object to display by `console.log()`.\n     */\n    [util.inspect.custom]() {\n        return this.toJSON();\n    }\n}\n\nmodule.exports = { OverrideTester };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}