{"ast":null,"code":"/**\n * @fileoverview Rule to disallow useless backreferences in regular expressions\n * @author Milos Djermanovic\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"eslint-utils\");\n\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = require(\"regexpp\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst parser = new RegExpParser();\n/**\n * Finds the path from the given `regexpp` AST node to the root node.\n * @param {regexpp.Node} node Node.\n * @returns {regexpp.Node[]} Array that starts with the given node and ends with the root node.\n */\n\nfunction getPathToRoot(node) {\n  const path = [];\n  let current = node;\n\n  do {\n    path.push(current);\n    current = current.parent;\n  } while (current);\n\n  return path;\n}\n/**\n * Determines whether the given `regexpp` AST node is a lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a lookaround node.\n */\n\n\nfunction isLookaround(node) {\n  return node.type === \"Assertion\" && (node.kind === \"lookahead\" || node.kind === \"lookbehind\");\n}\n/**\n * Determines whether the given `regexpp` AST node is a negative lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a negative lookaround node.\n */\n\n\nfunction isNegativeLookaround(node) {\n  return isLookaround(node) && node.negate;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow useless backreferences in regular expressions\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-backreference\"\n    },\n    schema: [],\n    messages: {\n      nested: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.\",\n      forward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.\",\n      backward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.\",\n      disjunctive: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.\",\n      intoNegativeLookaround: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround.\"\n    }\n  },\n\n  create(context) {\n    /**\n     * Checks and reports useless backreferences in the given regular expression.\n     * @param {ASTNode} node Node that represents regular expression. A regex literal or RegExp constructor call.\n     * @param {string} pattern Regular expression pattern.\n     * @param {string} flags Regular expression flags.\n     * @returns {void}\n     */\n    function checkRegex(node, pattern, flags) {\n      let regExpAST;\n\n      try {\n        regExpAST = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n\n      visitRegExpAST(regExpAST, {\n        onBackreferenceEnter(bref) {\n          const group = bref.resolved,\n                brefPath = getPathToRoot(bref),\n                groupPath = getPathToRoot(group);\n          let messageId = null;\n\n          if (brefPath.includes(group)) {\n            // group is bref's ancestor => bref is nested ('nested reference') => group hasn't matched yet when bref starts to match.\n            messageId = \"nested\";\n          } else {\n            // Start from the root to find the lowest common ancestor.\n            let i = brefPath.length - 1,\n                j = groupPath.length - 1;\n\n            do {\n              i--;\n              j--;\n            } while (brefPath[i] === groupPath[j]);\n\n            const indexOfLowestCommonAncestor = j + 1,\n                  groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),\n                  commonPath = groupPath.slice(indexOfLowestCommonAncestor),\n                  lowestCommonLookaround = commonPath.find(isLookaround),\n                  isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === \"lookbehind\";\n\n            if (!isMatchingBackward && bref.end <= group.start) {\n              // bref is left, group is right ('forward reference') => group hasn't matched yet when bref starts to match.\n              messageId = \"forward\";\n            } else if (isMatchingBackward && group.end <= bref.start) {\n              // the opposite of the previous when the regex is matching backward in a lookbehind context.\n              messageId = \"backward\";\n            } else if (groupCut[groupCut.length - 1].type === \"Alternative\") {\n              // group's and bref's ancestor nodes below the lowest common ancestor are sibling alternatives => they're disjunctive.\n              messageId = \"disjunctive\";\n            } else if (groupCut.some(isNegativeLookaround)) {\n              // group is in a negative lookaround which isn't bref's ancestor => group has already failed when bref starts to match.\n              messageId = \"intoNegativeLookaround\";\n            }\n          }\n\n          if (messageId) {\n            context.report({\n              node,\n              messageId,\n              data: {\n                bref: bref.raw,\n                group: group.raw\n              }\n            });\n          }\n        }\n\n      });\n    }\n\n    return {\n      \"Literal[regex]\"(node) {\n        const {\n          pattern,\n          flags\n        } = node.regex;\n        checkRegex(node, pattern, flags);\n      },\n\n      Program() {\n        const scope = context.getScope(),\n              tracker = new ReferenceTracker(scope),\n              traceMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          const [patternNode, flagsNode] = node.arguments,\n                pattern = getStringIfConstant(patternNode, scope),\n                flags = getStringIfConstant(flagsNode, scope);\n\n          if (typeof pattern === \"string\") {\n            checkRegex(node, pattern, flags || \"\");\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","require","RegExpParser","visitRegExpAST","parser","getPathToRoot","node","path","current","push","parent","isLookaround","type","kind","isNegativeLookaround","negate","module","exports","meta","docs","description","category","recommended","url","schema","messages","nested","forward","backward","disjunctive","intoNegativeLookaround","create","context","checkRegex","pattern","flags","regExpAST","parsePattern","length","includes","onBackreferenceEnter","bref","group","resolved","brefPath","groupPath","messageId","i","j","indexOfLowestCommonAncestor","groupCut","slice","commonPath","lowestCommonLookaround","find","isMatchingBackward","end","start","some","report","data","raw","regex","Program","scope","getScope","tracker","traceMap","RegExp","iterateGlobalReferences","patternNode","flagsNode","arguments"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-useless-backreference.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow useless backreferences in regular expressions\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new RegExpParser();\n\n/**\n * Finds the path from the given `regexpp` AST node to the root node.\n * @param {regexpp.Node} node Node.\n * @returns {regexpp.Node[]} Array that starts with the given node and ends with the root node.\n */\nfunction getPathToRoot(node) {\n    const path = [];\n    let current = node;\n\n    do {\n        path.push(current);\n        current = current.parent;\n    } while (current);\n\n    return path;\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a lookaround node.\n */\nfunction isLookaround(node) {\n    return node.type === \"Assertion\" &&\n        (node.kind === \"lookahead\" || node.kind === \"lookbehind\");\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a negative lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a negative lookaround node.\n */\nfunction isNegativeLookaround(node) {\n    return isLookaround(node) && node.negate;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow useless backreferences in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-backreference\"\n        },\n\n        schema: [],\n\n        messages: {\n            nested: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.\",\n            forward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.\",\n            backward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.\",\n            disjunctive: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.\",\n            intoNegativeLookaround: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Checks and reports useless backreferences in the given regular expression.\n         * @param {ASTNode} node Node that represents regular expression. A regex literal or RegExp constructor call.\n         * @param {string} pattern Regular expression pattern.\n         * @param {string} flags Regular expression flags.\n         * @returns {void}\n         */\n        function checkRegex(node, pattern, flags) {\n            let regExpAST;\n\n            try {\n                regExpAST = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            visitRegExpAST(regExpAST, {\n                onBackreferenceEnter(bref) {\n                    const group = bref.resolved,\n                        brefPath = getPathToRoot(bref),\n                        groupPath = getPathToRoot(group);\n                    let messageId = null;\n\n                    if (brefPath.includes(group)) {\n\n                        // group is bref's ancestor => bref is nested ('nested reference') => group hasn't matched yet when bref starts to match.\n                        messageId = \"nested\";\n                    } else {\n\n                        // Start from the root to find the lowest common ancestor.\n                        let i = brefPath.length - 1,\n                            j = groupPath.length - 1;\n\n                        do {\n                            i--;\n                            j--;\n                        } while (brefPath[i] === groupPath[j]);\n\n                        const indexOfLowestCommonAncestor = j + 1,\n                            groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),\n                            commonPath = groupPath.slice(indexOfLowestCommonAncestor),\n                            lowestCommonLookaround = commonPath.find(isLookaround),\n                            isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === \"lookbehind\";\n\n                        if (!isMatchingBackward && bref.end <= group.start) {\n\n                            // bref is left, group is right ('forward reference') => group hasn't matched yet when bref starts to match.\n                            messageId = \"forward\";\n                        } else if (isMatchingBackward && group.end <= bref.start) {\n\n                            // the opposite of the previous when the regex is matching backward in a lookbehind context.\n                            messageId = \"backward\";\n                        } else if (groupCut[groupCut.length - 1].type === \"Alternative\") {\n\n                            // group's and bref's ancestor nodes below the lowest common ancestor are sibling alternatives => they're disjunctive.\n                            messageId = \"disjunctive\";\n                        } else if (groupCut.some(isNegativeLookaround)) {\n\n                            // group is in a negative lookaround which isn't bref's ancestor => group has already failed when bref starts to match.\n                            messageId = \"intoNegativeLookaround\";\n                        }\n                    }\n\n                    if (messageId) {\n                        context.report({\n                            node,\n                            messageId,\n                            data: {\n                                bref: bref.raw,\n                                group: group.raw\n                            }\n                        });\n                    }\n                }\n            });\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                const { pattern, flags } = node.regex;\n\n                checkRegex(node, pattern, flags);\n            },\n            Program() {\n                const scope = context.getScope(),\n                    tracker = new ReferenceTracker(scope),\n                    traceMap = {\n                        RegExp: {\n                            [CALL]: true,\n                            [CONSTRUCT]: true\n                        }\n                    };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    const [patternNode, flagsNode] = node.arguments,\n                        pattern = getStringIfConstant(patternNode, scope),\n                        flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        checkRegex(node, pattern, flags || \"\");\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAM;EAAEA,IAAF;EAAQC,SAAR;EAAmBC,gBAAnB;EAAqCC;AAArC,IAA6DC,OAAO,CAAC,cAAD,CAA1E;;AACA,MAAM;EAAEC,YAAF;EAAgBC;AAAhB,IAAmCF,OAAO,CAAC,SAAD,CAAhD,C,CAEA;AACA;AACA;;;AAEA,MAAMG,MAAM,GAAG,IAAIF,YAAJ,EAAf;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASG,aAAT,CAAuBC,IAAvB,EAA6B;EACzB,MAAMC,IAAI,GAAG,EAAb;EACA,IAAIC,OAAO,GAAGF,IAAd;;EAEA,GAAG;IACCC,IAAI,CAACE,IAAL,CAAUD,OAAV;IACAA,OAAO,GAAGA,OAAO,CAACE,MAAlB;EACH,CAHD,QAGSF,OAHT;;EAKA,OAAOD,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASI,YAAT,CAAsBL,IAAtB,EAA4B;EACxB,OAAOA,IAAI,CAACM,IAAL,KAAc,WAAd,KACFN,IAAI,CAACO,IAAL,KAAc,WAAd,IAA6BP,IAAI,CAACO,IAAL,KAAc,YADzC,CAAP;AAEH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,oBAAT,CAA8BR,IAA9B,EAAoC;EAChC,OAAOK,YAAY,CAACL,IAAD,CAAZ,IAAsBA,IAAI,CAACS,MAAlC;AACH,C,CAED;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFN,IAAI,EAAE,SADJ;IAGFO,IAAI,EAAE;MACFC,WAAW,EAAE,wDADX;MAEFC,QAAQ,EAAE,iBAFR;MAGFC,WAAW,EAAE,KAHX;MAIFC,GAAG,EAAE;IAJH,CAHJ;IAUFC,MAAM,EAAE,EAVN;IAYFC,QAAQ,EAAE;MACNC,MAAM,EAAE,uGADF;MAENC,OAAO,EAAE,mHAFH;MAGNC,QAAQ,EAAE,4HAHJ;MAINC,WAAW,EAAE,gHAJP;MAKNC,sBAAsB,EAAE;IALlB;EAZR,CADO;;EAsBbC,MAAM,CAACC,OAAD,EAAU;IAEZ;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,UAAT,CAAoB3B,IAApB,EAA0B4B,OAA1B,EAAmCC,KAAnC,EAA0C;MACtC,IAAIC,SAAJ;;MAEA,IAAI;QACAA,SAAS,GAAGhC,MAAM,CAACiC,YAAP,CAAoBH,OAApB,EAA6B,CAA7B,EAAgCA,OAAO,CAACI,MAAxC,EAAgDH,KAAK,CAACI,QAAN,CAAe,GAAf,CAAhD,CAAZ;MACH,CAFD,CAEE,MAAM;QAEJ;QACA;MACH;;MAEDpC,cAAc,CAACiC,SAAD,EAAY;QACtBI,oBAAoB,CAACC,IAAD,EAAO;UACvB,MAAMC,KAAK,GAAGD,IAAI,CAACE,QAAnB;UAAA,MACIC,QAAQ,GAAGvC,aAAa,CAACoC,IAAD,CAD5B;UAAA,MAEII,SAAS,GAAGxC,aAAa,CAACqC,KAAD,CAF7B;UAGA,IAAII,SAAS,GAAG,IAAhB;;UAEA,IAAIF,QAAQ,CAACL,QAAT,CAAkBG,KAAlB,CAAJ,EAA8B;YAE1B;YACAI,SAAS,GAAG,QAAZ;UACH,CAJD,MAIO;YAEH;YACA,IAAIC,CAAC,GAAGH,QAAQ,CAACN,MAAT,GAAkB,CAA1B;YAAA,IACIU,CAAC,GAAGH,SAAS,CAACP,MAAV,GAAmB,CAD3B;;YAGA,GAAG;cACCS,CAAC;cACDC,CAAC;YACJ,CAHD,QAGSJ,QAAQ,CAACG,CAAD,CAAR,KAAgBF,SAAS,CAACG,CAAD,CAHlC;;YAKA,MAAMC,2BAA2B,GAAGD,CAAC,GAAG,CAAxC;YAAA,MACIE,QAAQ,GAAGL,SAAS,CAACM,KAAV,CAAgB,CAAhB,EAAmBF,2BAAnB,CADf;YAAA,MAEIG,UAAU,GAAGP,SAAS,CAACM,KAAV,CAAgBF,2BAAhB,CAFjB;YAAA,MAGII,sBAAsB,GAAGD,UAAU,CAACE,IAAX,CAAgB3C,YAAhB,CAH7B;YAAA,MAII4C,kBAAkB,GAAGF,sBAAsB,IAAIA,sBAAsB,CAACxC,IAAvB,KAAgC,YAJnF;;YAMA,IAAI,CAAC0C,kBAAD,IAAuBd,IAAI,CAACe,GAAL,IAAYd,KAAK,CAACe,KAA7C,EAAoD;cAEhD;cACAX,SAAS,GAAG,SAAZ;YACH,CAJD,MAIO,IAAIS,kBAAkB,IAAIb,KAAK,CAACc,GAAN,IAAaf,IAAI,CAACgB,KAA5C,EAAmD;cAEtD;cACAX,SAAS,GAAG,UAAZ;YACH,CAJM,MAIA,IAAII,QAAQ,CAACA,QAAQ,CAACZ,MAAT,GAAkB,CAAnB,CAAR,CAA8B1B,IAA9B,KAAuC,aAA3C,EAA0D;cAE7D;cACAkC,SAAS,GAAG,aAAZ;YACH,CAJM,MAIA,IAAII,QAAQ,CAACQ,IAAT,CAAc5C,oBAAd,CAAJ,EAAyC;cAE5C;cACAgC,SAAS,GAAG,wBAAZ;YACH;UACJ;;UAED,IAAIA,SAAJ,EAAe;YACXd,OAAO,CAAC2B,MAAR,CAAe;cACXrD,IADW;cAEXwC,SAFW;cAGXc,IAAI,EAAE;gBACFnB,IAAI,EAAEA,IAAI,CAACoB,GADT;gBAEFnB,KAAK,EAAEA,KAAK,CAACmB;cAFX;YAHK,CAAf;UAQH;QACJ;;MAzDqB,CAAZ,CAAd;IA2DH;;IAED,OAAO;MACH,iBAAiBvD,IAAjB,EAAuB;QACnB,MAAM;UAAE4B,OAAF;UAAWC;QAAX,IAAqB7B,IAAI,CAACwD,KAAhC;QAEA7B,UAAU,CAAC3B,IAAD,EAAO4B,OAAP,EAAgBC,KAAhB,CAAV;MACH,CALE;;MAMH4B,OAAO,GAAG;QACN,MAAMC,KAAK,GAAGhC,OAAO,CAACiC,QAAR,EAAd;QAAA,MACIC,OAAO,GAAG,IAAInE,gBAAJ,CAAqBiE,KAArB,CADd;QAAA,MAEIG,QAAQ,GAAG;UACPC,MAAM,EAAE;YACJ,CAACvE,IAAD,GAAQ,IADJ;YAEJ,CAACC,SAAD,GAAa;UAFT;QADD,CAFf;;QASA,KAAK,MAAM;UAAEQ;QAAF,CAAX,IAAuB4D,OAAO,CAACG,uBAAR,CAAgCF,QAAhC,CAAvB,EAAkE;UAC9D,MAAM,CAACG,WAAD,EAAcC,SAAd,IAA2BjE,IAAI,CAACkE,SAAtC;UAAA,MACItC,OAAO,GAAGlC,mBAAmB,CAACsE,WAAD,EAAcN,KAAd,CADjC;UAAA,MAEI7B,KAAK,GAAGnC,mBAAmB,CAACuE,SAAD,EAAYP,KAAZ,CAF/B;;UAIA,IAAI,OAAO9B,OAAP,KAAmB,QAAvB,EAAiC;YAC7BD,UAAU,CAAC3B,IAAD,EAAO4B,OAAP,EAAgBC,KAAK,IAAI,EAAzB,CAAV;UACH;QACJ;MACJ;;IAzBE,CAAP;EA2BH;;AAlIY,CAAjB"},"metadata":{},"sourceType":"script"}