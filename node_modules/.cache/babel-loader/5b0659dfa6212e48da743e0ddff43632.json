{"ast":null,"code":"/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\n\nfunction isReachable(segment) {\n  return segment.reachable;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\n\n\nclass CodePathSegment {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   *   This array includes unreachable segments.\n   * @param {boolean} reachable A flag which shows this is reachable.\n   */\n  constructor(id, allPrevSegments, reachable) {\n    /**\n     * The identifier of this code path.\n     * Rules use it to store additional information of each rule.\n     * @type {string}\n     */\n    this.id = id;\n    /**\n     * An array of the next segments.\n     * @type {CodePathSegment[]}\n     */\n\n    this.nextSegments = [];\n    /**\n     * An array of the previous segments.\n     * @type {CodePathSegment[]}\n     */\n\n    this.prevSegments = allPrevSegments.filter(isReachable);\n    /**\n     * An array of the next segments.\n     * This array includes unreachable segments.\n     * @type {CodePathSegment[]}\n     */\n\n    this.allNextSegments = [];\n    /**\n     * An array of the previous segments.\n     * This array includes unreachable segments.\n     * @type {CodePathSegment[]}\n     */\n\n    this.allPrevSegments = allPrevSegments;\n    /**\n     * A flag which shows this is reachable.\n     * @type {boolean}\n     */\n\n    this.reachable = reachable; // Internal data.\n\n    Object.defineProperty(this, \"internal\", {\n      value: {\n        used: false,\n        loopedPrevSegments: []\n      }\n    });\n    /* istanbul ignore if */\n\n    if (debug.enabled) {\n      this.internal.nodes = [];\n    }\n  }\n  /**\n   * Checks a given previous segment is coming from the end of a loop.\n   * @param {CodePathSegment} segment A previous segment to check.\n   * @returns {boolean} `true` if the segment is coming from the end of a loop.\n   */\n\n\n  isLoopedPrevSegment(segment) {\n    return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n  }\n  /**\n   * Creates the root segment.\n   * @param {string} id An identifier.\n   * @returns {CodePathSegment} The created segment.\n   */\n\n\n  static newRoot(id) {\n    return new CodePathSegment(id, [], true);\n  }\n  /**\n   * Creates a segment that follows given segments.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n\n\n  static newNext(id, allPrevSegments) {\n    return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));\n  }\n  /**\n   * Creates an unreachable segment that follows given segments.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n\n\n  static newUnreachable(id, allPrevSegments) {\n    const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n    /*\n     * In `if (a) return a; foo();` case, the unreachable segment preceded by\n     * the return statement is not used but must not be remove.\n     */\n\n    CodePathSegment.markUsed(segment);\n    return segment;\n  }\n  /**\n   * Creates a segment that follows given segments.\n   * This factory method does not connect with `allPrevSegments`.\n   * But this inherits `reachable` flag.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n\n\n  static newDisconnected(id, allPrevSegments) {\n    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n  }\n  /**\n   * Makes a given segment being used.\n   *\n   * And this function registers the segment into the previous segments as a next.\n   * @param {CodePathSegment} segment A segment to mark.\n   * @returns {void}\n   */\n\n\n  static markUsed(segment) {\n    if (segment.internal.used) {\n      return;\n    }\n\n    segment.internal.used = true;\n    let i;\n\n    if (segment.reachable) {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        const prevSegment = segment.allPrevSegments[i];\n        prevSegment.allNextSegments.push(segment);\n        prevSegment.nextSegments.push(segment);\n      }\n    } else {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        segment.allPrevSegments[i].allNextSegments.push(segment);\n      }\n    }\n  }\n  /**\n   * Marks a previous segment as looped.\n   * @param {CodePathSegment} segment A segment.\n   * @param {CodePathSegment} prevSegment A previous segment to mark.\n   * @returns {void}\n   */\n\n\n  static markPrevSegmentAsLooped(segment, prevSegment) {\n    segment.internal.loopedPrevSegments.push(prevSegment);\n  }\n  /**\n   * Replaces unused segments with the previous segments of each unused segment.\n   * @param {CodePathSegment[]} segments An array of segments to replace.\n   * @returns {CodePathSegment[]} The replaced array.\n   */\n\n\n  static flattenUnusedSegments(segments) {\n    const done = Object.create(null);\n    const retv = [];\n\n    for (let i = 0; i < segments.length; ++i) {\n      const segment = segments[i]; // Ignores duplicated.\n\n      if (done[segment.id]) {\n        continue;\n      } // Use previous segments if unused.\n\n\n      if (!segment.internal.used) {\n        for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n          const prevSegment = segment.allPrevSegments[j];\n\n          if (!done[prevSegment.id]) {\n            done[prevSegment.id] = true;\n            retv.push(prevSegment);\n          }\n        }\n      } else {\n        done[segment.id] = true;\n        retv.push(segment);\n      }\n    }\n\n    return retv;\n  }\n\n}\n\nmodule.exports = CodePathSegment;","map":{"version":3,"names":["debug","require","isReachable","segment","reachable","CodePathSegment","constructor","id","allPrevSegments","nextSegments","prevSegments","filter","allNextSegments","Object","defineProperty","value","used","loopedPrevSegments","enabled","internal","nodes","isLoopedPrevSegment","indexOf","newRoot","newNext","flattenUnusedSegments","some","newUnreachable","markUsed","newDisconnected","i","length","prevSegment","push","markPrevSegmentAsLooped","segments","done","create","retv","j","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js"],"sourcesContent":["/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\nclass CodePathSegment {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of the next segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n                used: false,\n                loopedPrevSegments: []\n            }\n        });\n\n        /* istanbul ignore if */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n        }\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     * @param {CodePathSegment} segment A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n    }\n\n    /**\n     * Creates the root segment.\n     * @param {string} id An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable)\n        );\n    }\n\n    /**\n     * Creates an unreachable segment that follows given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n        /*\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\n         * the return statement is not used but must not be remove.\n         */\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Makes a given segment being used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     * @param {CodePathSegment} segment A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     * @param {CodePathSegment} segment A segment.\n     * @param {CodePathSegment} prevSegment A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n\n    /**\n     * Replaces unused segments with the previous segments of each unused segment.\n     * @param {CodePathSegment[]} segments An array of segments to replace.\n     * @returns {CodePathSegment[]} The replaced array.\n     */\n    static flattenUnusedSegments(segments) {\n        const done = Object.create(null);\n        const retv = [];\n\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            // Ignores duplicated.\n            if (done[segment.id]) {\n                continue;\n            }\n\n            // Use previous segments if unused.\n            if (!segment.internal.used) {\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                    const prevSegment = segment.allPrevSegments[j];\n\n                    if (!done[prevSegment.id]) {\n                        done[prevSegment.id] = true;\n                        retv.push(prevSegment);\n                    }\n                }\n            } else {\n                done[segment.id] = true;\n                retv.push(segment);\n            }\n        }\n\n        return retv;\n    }\n}\n\nmodule.exports = CodePathSegment;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}