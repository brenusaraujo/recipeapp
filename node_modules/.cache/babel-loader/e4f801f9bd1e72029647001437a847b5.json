{"ast":null,"code":"/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst BOM = \"\\uFEFF\";\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\n\nfunction compareMessagesByFixRange(a, b) {\n  return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\n\n\nfunction compareMessagesByLocation(a, b) {\n  return a.line - b.line || a.column - b.column;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\n\n\nfunction SourceCodeFixer() {\n  Object.freeze(this);\n}\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\n\n\nSourceCodeFixer.applyFixes = function (sourceText, messages, shouldFix) {\n  debug(\"Applying fixes\");\n\n  if (shouldFix === false) {\n    debug(\"shouldFix parameter was false, not attempting fixes\");\n    return {\n      fixed: false,\n      messages,\n      output: sourceText\n    };\n  } // clone the array\n\n\n  const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n  let lastPos = Number.NEGATIVE_INFINITY,\n      output = bom;\n  /**\n   * Try to use the 'fix' from a problem.\n   * @param   {Message} problem The message object to apply fixes from\n   * @returns {boolean}         Whether fix was successfully applied\n   */\n\n  function attemptFix(problem) {\n    const fix = problem.fix;\n    const start = fix.range[0];\n    const end = fix.range[1]; // Remain it as a problem if it's overlapped or it's a negative range\n\n    if (lastPos >= start || start > end) {\n      remainingMessages.push(problem);\n      return false;\n    } // Remove BOM.\n\n\n    if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {\n      output = \"\";\n    } // Make output to this fix.\n\n\n    output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n    output += fix.text;\n    lastPos = end;\n    return true;\n  }\n\n  messages.forEach(problem => {\n    if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n      fixes.push(problem);\n    } else {\n      remainingMessages.push(problem);\n    }\n  });\n\n  if (fixes.length) {\n    debug(\"Found fixes to apply\");\n    let fixesWereApplied = false;\n\n    for (const problem of fixes.sort(compareMessagesByFixRange)) {\n      if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n        attemptFix(problem);\n        /*\n         * The only time attemptFix will fail is if a previous fix was\n         * applied which conflicts with it.  So we can mark this as true.\n         */\n\n        fixesWereApplied = true;\n      } else {\n        remainingMessages.push(problem);\n      }\n    }\n\n    output += text.slice(Math.max(0, lastPos));\n    return {\n      fixed: fixesWereApplied,\n      messages: remainingMessages.sort(compareMessagesByLocation),\n      output\n    };\n  }\n\n  debug(\"No fixes to apply\");\n  return {\n    fixed: false,\n    messages,\n    output: bom + text\n  };\n};\n\nmodule.exports = SourceCodeFixer;","map":{"version":3,"names":["debug","require","BOM","compareMessagesByFixRange","a","b","fix","range","compareMessagesByLocation","line","column","SourceCodeFixer","Object","freeze","applyFixes","sourceText","messages","shouldFix","fixed","output","remainingMessages","fixes","bom","startsWith","text","slice","lastPos","Number","NEGATIVE_INFINITY","attemptFix","problem","start","end","push","Math","max","forEach","prototype","hasOwnProperty","call","length","fixesWereApplied","sort","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/linter/source-code-fixer.js"],"sourcesContent":["/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n    Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {\n    debug(\"Applying fixes\");\n\n    if (shouldFix === false) {\n        debug(\"shouldFix parameter was false, not attempting fixes\");\n        return {\n            fixed: false,\n            messages,\n            output: sourceText\n        };\n    }\n\n    // clone the array\n    const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n    let lastPos = Number.NEGATIVE_INFINITY,\n        output = bom;\n\n    /**\n     * Try to use the 'fix' from a problem.\n     * @param   {Message} problem The message object to apply fixes from\n     * @returns {boolean}         Whether fix was successfully applied\n     */\n    function attemptFix(problem) {\n        const fix = problem.fix;\n        const start = fix.range[0];\n        const end = fix.range[1];\n\n        // Remain it as a problem if it's overlapped or it's a negative range\n        if (lastPos >= start || start > end) {\n            remainingMessages.push(problem);\n            return false;\n        }\n\n        // Remove BOM.\n        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\n            output = \"\";\n        }\n\n        // Make output to this fix.\n        output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n        output += fix.text;\n        lastPos = end;\n        return true;\n    }\n\n    messages.forEach(problem => {\n        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n            fixes.push(problem);\n        } else {\n            remainingMessages.push(problem);\n        }\n    });\n\n    if (fixes.length) {\n        debug(\"Found fixes to apply\");\n        let fixesWereApplied = false;\n\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\n            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n                attemptFix(problem);\n\n                /*\n                 * The only time attemptFix will fail is if a previous fix was\n                 * applied which conflicts with it.  So we can mark this as true.\n                 */\n                fixesWereApplied = true;\n            } else {\n                remainingMessages.push(problem);\n            }\n        }\n        output += text.slice(Math.max(0, lastPos));\n\n        return {\n            fixed: fixesWereApplied,\n            messages: remainingMessages.sort(compareMessagesByLocation),\n            output\n        };\n    }\n\n    debug(\"No fixes to apply\");\n    return {\n        fixed: false,\n        messages,\n        output: bom + text\n    };\n\n};\n\nmodule.exports = SourceCodeFixer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}