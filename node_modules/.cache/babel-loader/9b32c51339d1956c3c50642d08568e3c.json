{"ast":null,"code":"/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent comma style\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-style\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"first\", \"last\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n      expectedCommaFirst: \"',' should be placed first.\",\n      expectedCommaLast: \"',' should be placed last.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"last\",\n          sourceCode = context.getSourceCode();\n    const exceptions = {\n      ArrayPattern: true,\n      ArrowFunctionExpression: true,\n      CallExpression: true,\n      FunctionDeclaration: true,\n      FunctionExpression: true,\n      ImportDeclaration: true,\n      ObjectPattern: true,\n      NewExpression: true\n    };\n\n    if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n      const keys = Object.keys(context.options[1].exceptions);\n\n      for (let i = 0; i < keys.length; i++) {\n        exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n      }\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Modified text based on the style\n     * @param {string} styleType Style type\n     * @param {string} text Source code text\n     * @returns {string} modified text\n     * @private\n     */\n\n\n    function getReplacedText(styleType, text) {\n      switch (styleType) {\n        case \"between\":\n          return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n        case \"first\":\n          return `${text},`;\n\n        case \"last\":\n          return `,${text}`;\n\n        default:\n          return \"\";\n      }\n    }\n    /**\n     * Determines the fixer function for a given style.\n     * @param {string} styleType comma style\n     * @param {ASTNode} previousItemToken The token to check.\n     * @param {ASTNode} commaToken The token to check.\n     * @param {ASTNode} currentItemToken The token to check.\n     * @returns {Function} Fixer function\n     * @private\n     */\n\n\n    function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n      const text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n      const range = [previousItemToken.range[1], currentItemToken.range[0]];\n      return function (fixer) {\n        return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n      };\n    }\n    /**\n     * Validates the spacing around single items in lists.\n     * @param {Token} previousItemToken The last token from the previous item.\n     * @param {Token} commaToken The token representing the comma.\n     * @param {Token} currentItemToken The first token of the current item.\n     * @param {Token} reportItem The item to use when reporting an error.\n     * @returns {void}\n     * @private\n     */\n\n\n    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n      // if single line\n      if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {// do nothing.\n      } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n        const comment = sourceCode.getCommentsAfter(commaToken)[0];\n        const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment) ? style : \"between\"; // lone comma\n\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"unexpectedLineBeforeAndAfterComma\",\n          fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"expectedCommaFirst\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"expectedCommaLast\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      }\n    }\n    /**\n     * Checks the comma placement with regards to a declaration/property/element\n     * @param {ASTNode} node The binary expression node to check\n     * @param {string} property The property of the node containing child nodes.\n     * @private\n     * @returns {void}\n     */\n\n\n    function validateComma(node, property) {\n      const items = node[property],\n            arrayLiteral = node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\";\n\n      if (items.length > 1 || arrayLiteral) {\n        // seed as opening [\n        let previousItemToken = sourceCode.getFirstToken(node);\n        items.forEach(item => {\n          const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                reportItem = item || currentItemToken;\n          /*\n           * This works by comparing three token locations:\n           * - previousItemToken is the last token of the previous item\n           * - commaToken is the location of the comma before the current item\n           * - currentItemToken is the first token of the current item\n           *\n           * These values get switched around if item is undefined.\n           * previousItemToken will refer to the last token not belonging\n           * to the current item, which could be a comma or an opening\n           * square bracket. currentItemToken could be a comma.\n           *\n           * All comparisons are done based on these tokens directly, so\n           * they are always valid regardless of an undefined item.\n           */\n\n          if (astUtils.isCommaToken(commaToken)) {\n            validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);\n          }\n\n          if (item) {\n            const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n            previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n          } else {\n            previousItemToken = currentItemToken;\n          }\n        });\n        /*\n         * Special case for array literals that have empty last items, such\n         * as [ 1, 2, ]. These arrays only have two items show up in the\n         * AST, so we need to look at the token to verify that there's no\n         * dangling comma.\n         */\n\n        if (arrayLiteral) {\n          const lastToken = sourceCode.getLastToken(node),\n                nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n          if (astUtils.isCommaToken(nextToLastToken)) {\n            validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);\n          }\n        }\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    const nodes = {};\n\n    if (!exceptions.VariableDeclaration) {\n      nodes.VariableDeclaration = function (node) {\n        validateComma(node, \"declarations\");\n      };\n    }\n\n    if (!exceptions.ObjectExpression) {\n      nodes.ObjectExpression = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n\n    if (!exceptions.ObjectPattern) {\n      nodes.ObjectPattern = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n\n    if (!exceptions.ArrayExpression) {\n      nodes.ArrayExpression = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n\n    if (!exceptions.ArrayPattern) {\n      nodes.ArrayPattern = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n\n    if (!exceptions.FunctionDeclaration) {\n      nodes.FunctionDeclaration = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.FunctionExpression) {\n      nodes.FunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.ArrowFunctionExpression) {\n      nodes.ArrowFunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.CallExpression) {\n      nodes.CallExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n\n    if (!exceptions.ImportDeclaration) {\n      nodes.ImportDeclaration = function (node) {\n        validateComma(node, \"specifiers\");\n      };\n    }\n\n    if (!exceptions.NewExpression) {\n      nodes.NewExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n\n    return nodes;\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","exceptions","additionalProperties","messages","unexpectedLineBeforeAndAfterComma","expectedCommaFirst","expectedCommaLast","create","context","style","options","sourceCode","getSourceCode","ArrayPattern","ArrowFunctionExpression","CallExpression","FunctionDeclaration","FunctionExpression","ImportDeclaration","ObjectPattern","NewExpression","length","Object","prototype","hasOwnProperty","call","keys","i","getReplacedText","styleType","text","replace","LINEBREAK_MATCHER","getFixerFunction","previousItemToken","commaToken","currentItemToken","slice","range","fixer","replaceTextRange","validateCommaItemSpacing","reportItem","isTokenOnSameLine","comment","getCommentsAfter","report","node","loc","messageId","fix","validateComma","property","items","arrayLiteral","getFirstToken","forEach","item","getTokenBefore","getTokenAfter","isCommaToken","tokenAfterItem","isNotClosingParenToken","ast","tokens","lastToken","getLastToken","nextToLastToken","nodes","VariableDeclaration","ObjectExpression","ArrayExpression"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/comma-style.js"],"sourcesContent":["/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent comma style\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-style\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"first\", \"last\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n            expectedCommaFirst: \"',' should be placed first.\",\n            expectedCommaLast: \"',' should be placed last.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"last\",\n            sourceCode = context.getSourceCode();\n        const exceptions = {\n            ArrayPattern: true,\n            ArrowFunctionExpression: true,\n            CallExpression: true,\n            FunctionDeclaration: true,\n            FunctionExpression: true,\n            ImportDeclaration: true,\n            ObjectPattern: true,\n            NewExpression: true\n        };\n\n        if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n            const keys = Object.keys(context.options[1].exceptions);\n\n            for (let i = 0; i < keys.length; i++) {\n                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Modified text based on the style\n         * @param {string} styleType Style type\n         * @param {string} text Source code text\n         * @returns {string} modified text\n         * @private\n         */\n        function getReplacedText(styleType, text) {\n            switch (styleType) {\n                case \"between\":\n                    return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n                case \"first\":\n                    return `${text},`;\n\n                case \"last\":\n                    return `,${text}`;\n\n                default:\n                    return \"\";\n            }\n        }\n\n        /**\n         * Determines the fixer function for a given style.\n         * @param {string} styleType comma style\n         * @param {ASTNode} previousItemToken The token to check.\n         * @param {ASTNode} commaToken The token to check.\n         * @param {ASTNode} currentItemToken The token to check.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n            const text =\n                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +\n                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n            const range = [previousItemToken.range[1], currentItemToken.range[0]];\n\n            return function(fixer) {\n                return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n            };\n        }\n\n        /**\n         * Validates the spacing around single items in lists.\n         * @param {Token} previousItemToken The last token from the previous item.\n         * @param {Token} commaToken The token representing the comma.\n         * @param {Token} currentItemToken The first token of the current item.\n         * @param {Token} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // do nothing.\n\n            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                const comment = sourceCode.getCommentsAfter(commaToken)[0];\n                const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment)\n                    ? style\n                    : \"between\";\n\n                // lone comma\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"unexpectedLineBeforeAndAfterComma\",\n                    fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"expectedCommaFirst\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"expectedCommaLast\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n            }\n        }\n\n        /**\n         * Checks the comma placement with regards to a declaration/property/element\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} property The property of the node containing child nodes.\n         * @private\n         * @returns {void}\n         */\n        function validateComma(node, property) {\n            const items = node[property],\n                arrayLiteral = (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n\n            if (items.length > 1 || arrayLiteral) {\n\n                // seed as opening [\n                let previousItemToken = sourceCode.getFirstToken(node);\n\n                items.forEach(item => {\n                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                        reportItem = item || currentItemToken;\n\n                    /*\n                     * This works by comparing three token locations:\n                     * - previousItemToken is the last token of the previous item\n                     * - commaToken is the location of the comma before the current item\n                     * - currentItemToken is the first token of the current item\n                     *\n                     * These values get switched around if item is undefined.\n                     * previousItemToken will refer to the last token not belonging\n                     * to the current item, which could be a comma or an opening\n                     * square bracket. currentItemToken could be a comma.\n                     *\n                     * All comparisons are done based on these tokens directly, so\n                     * they are always valid regardless of an undefined item.\n                     */\n                    if (astUtils.isCommaToken(commaToken)) {\n                        validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);\n                    }\n\n                    if (item) {\n                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n\n                        previousItemToken = tokenAfterItem\n                            ? sourceCode.getTokenBefore(tokenAfterItem)\n                            : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n                    } else {\n                        previousItemToken = currentItemToken;\n                    }\n                });\n\n                /*\n                 * Special case for array literals that have empty last items, such\n                 * as [ 1, 2, ]. These arrays only have two items show up in the\n                 * AST, so we need to look at the token to verify that there's no\n                 * dangling comma.\n                 */\n                if (arrayLiteral) {\n\n                    const lastToken = sourceCode.getLastToken(node),\n                        nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n                    if (astUtils.isCommaToken(nextToLastToken)) {\n                        validateCommaItemSpacing(\n                            sourceCode.getTokenBefore(nextToLastToken),\n                            nextToLastToken,\n                            lastToken,\n                            lastToken\n                        );\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        const nodes = {};\n\n        if (!exceptions.VariableDeclaration) {\n            nodes.VariableDeclaration = function(node) {\n                validateComma(node, \"declarations\");\n            };\n        }\n        if (!exceptions.ObjectExpression) {\n            nodes.ObjectExpression = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ObjectPattern) {\n            nodes.ObjectPattern = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ArrayExpression) {\n            nodes.ArrayExpression = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.ArrayPattern) {\n            nodes.ArrayPattern = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.FunctionDeclaration) {\n            nodes.FunctionDeclaration = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.FunctionExpression) {\n            nodes.FunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.ArrowFunctionExpression) {\n            nodes.ArrowFunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.CallExpression) {\n            nodes.CallExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n        if (!exceptions.ImportDeclaration) {\n            nodes.ImportDeclaration = function(node) {\n                validateComma(node, \"specifiers\");\n            };\n        }\n        if (!exceptions.NewExpression) {\n            nodes.NewExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n\n        return nodes;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}