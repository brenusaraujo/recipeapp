{"ast":null,"code":"/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst DEFAULT_OPTIONS = Object.freeze({\n  arrays: \"never\",\n  objects: \"never\",\n  imports: \"never\",\n  exports: \"never\",\n  functions: \"never\"\n});\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\n\nfunction isTrailingCommaAllowed(lastItem) {\n  return !(lastItem.type === \"RestElement\" || lastItem.type === \"RestProperty\" || lastItem.type === \"ExperimentalRestProperty\");\n}\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\n\n\nfunction normalizeOptions(optionValue, ecmaVersion) {\n  if (typeof optionValue === \"string\") {\n    return {\n      arrays: optionValue,\n      objects: optionValue,\n      imports: optionValue,\n      exports: optionValue,\n      functions: !ecmaVersion || ecmaVersion < 8 ? \"ignore\" : optionValue\n    };\n  }\n\n  if (typeof optionValue === \"object\" && optionValue !== null) {\n    return {\n      arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n      objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n      imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n      exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n      functions: optionValue.functions || DEFAULT_OPTIONS.functions\n    };\n  }\n\n  return DEFAULT_OPTIONS;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow trailing commas\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-dangle\"\n    },\n    fixable: \"code\",\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always-multiline\", \"always\", \"never\", \"only-multiline\"]\n        },\n        valueWithIgnore: {\n          enum: [\"always-multiline\", \"always\", \"ignore\", \"never\", \"only-multiline\"]\n        }\n      },\n      type: \"array\",\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/value\"\n        }, {\n          type: \"object\",\n          properties: {\n            arrays: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            objects: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            imports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            exports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            functions: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            }\n          },\n          additionalProperties: false\n        }]\n      }]\n    },\n    messages: {\n      unexpected: \"Unexpected trailing comma.\",\n      missing: \"Missing trailing comma.\"\n    }\n  },\n\n  create(context) {\n    const options = normalizeOptions(context.options[0], context.parserOptions.ecmaVersion);\n    const sourceCode = context.getSourceCode();\n    /**\n     * Gets the last item of the given node.\n     * @param {ASTNode} node The node to get.\n     * @returns {ASTNode|null} The last node or null.\n     */\n\n    function getLastItem(node) {\n      /**\n       * Returns the last element of an array\n       * @param {any[]} array The input array\n       * @returns {any} The last element\n       */\n      function last(array) {\n        return array[array.length - 1];\n      }\n\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          return last(node.properties);\n\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          return last(node.elements);\n\n        case \"ImportDeclaration\":\n        case \"ExportNamedDeclaration\":\n          return last(node.specifiers);\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n          return last(node.params);\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return last(node.arguments);\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * Gets the trailing comma token of the given node.\n     * If the trailing comma does not exist, this returns the token which is\n     * the insertion point of the trailing comma token.\n     * @param {ASTNode} node The node to get.\n     * @param {ASTNode} lastItem The last item of the node.\n     * @returns {Token} The trailing comma token or the insertion point.\n     */\n\n\n    function getTrailingToken(node, lastItem) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ArrayExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return sourceCode.getLastToken(node, 1);\n\n        default:\n          {\n            const nextToken = sourceCode.getTokenAfter(lastItem);\n\n            if (astUtils.isCommaToken(nextToken)) {\n              return nextToken;\n            }\n\n            return sourceCode.getLastToken(lastItem);\n          }\n      }\n    }\n    /**\n     * Checks whether or not a given node is multiline.\n     * This rule handles a given node as multiline when the closing parenthesis\n     * and the last element are not on the same line.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is multiline.\n     */\n\n\n    function isMultiline(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem) {\n        return false;\n      }\n\n      const penultimateToken = getTrailingToken(node, lastItem);\n      const lastToken = sourceCode.getTokenAfter(penultimateToken);\n      return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n    }\n    /**\n     * Reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n\n\n    function forbidTrailingComma(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n\n      const trailingToken = getTrailingToken(node, lastItem);\n\n      if (astUtils.isCommaToken(trailingToken)) {\n        context.report({\n          node: lastItem,\n          loc: trailingToken.loc,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            return fixer.remove(trailingToken);\n          }\n\n        });\n      }\n    }\n    /**\n     * Reports the last element of a given node if it does not have a trailing\n     * comma.\n     *\n     * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n     * comma is disallowed, so report if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n\n\n    function forceTrailingComma(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n\n      if (!isTrailingCommaAllowed(lastItem)) {\n        forbidTrailingComma(node);\n        return;\n      }\n\n      const trailingToken = getTrailingToken(node, lastItem);\n\n      if (trailingToken.value !== \",\") {\n        context.report({\n          node: lastItem,\n          loc: {\n            start: trailingToken.loc.end,\n            end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n          },\n          messageId: \"missing\",\n\n          fix(fixer) {\n            return fixer.insertTextAfter(trailingToken, \",\");\n          }\n\n        });\n      }\n    }\n    /**\n     * If a given node is multiline, reports the last element of a given node\n     * when it does not have a trailing comma.\n     * Otherwise, reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n\n\n    function forceTrailingCommaIfMultiline(node) {\n      if (isMultiline(node)) {\n        forceTrailingComma(node);\n      } else {\n        forbidTrailingComma(node);\n      }\n    }\n    /**\n     * Only if a given node is not multiline, reports the last element of a given node\n     * when it does not have a trailing comma.\n     * Otherwise, reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n\n\n    function allowTrailingCommaIfMultiline(node) {\n      if (!isMultiline(node)) {\n        forbidTrailingComma(node);\n      }\n    }\n\n    const predicate = {\n      always: forceTrailingComma,\n      \"always-multiline\": forceTrailingCommaIfMultiline,\n      \"only-multiline\": allowTrailingCommaIfMultiline,\n      never: forbidTrailingComma,\n      ignore: () => {}\n    };\n    return {\n      ObjectExpression: predicate[options.objects],\n      ObjectPattern: predicate[options.objects],\n      ArrayExpression: predicate[options.arrays],\n      ArrayPattern: predicate[options.arrays],\n      ImportDeclaration: predicate[options.imports],\n      ExportNamedDeclaration: predicate[options.exports],\n      FunctionDeclaration: predicate[options.functions],\n      FunctionExpression: predicate[options.functions],\n      ArrowFunctionExpression: predicate[options.functions],\n      CallExpression: predicate[options.functions],\n      NewExpression: predicate[options.functions]\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","DEFAULT_OPTIONS","Object","freeze","arrays","objects","imports","exports","functions","isTrailingCommaAllowed","lastItem","type","normalizeOptions","optionValue","ecmaVersion","module","meta","docs","description","category","recommended","url","fixable","schema","definitions","value","enum","valueWithIgnore","items","oneOf","$ref","properties","additionalProperties","messages","unexpected","missing","create","context","options","parserOptions","sourceCode","getSourceCode","getLastItem","node","last","array","length","elements","specifiers","params","arguments","getTrailingToken","getLastToken","nextToken","getTokenAfter","isCommaToken","isMultiline","penultimateToken","lastToken","loc","end","line","forbidTrailingComma","trailingToken","report","messageId","fix","fixer","remove","forceTrailingComma","start","getNextLocation","insertTextAfter","forceTrailingCommaIfMultiline","allowTrailingCommaIfMultiline","predicate","always","never","ignore","ObjectExpression","ObjectPattern","ArrayExpression","ArrayPattern","ImportDeclaration","ExportNamedDeclaration","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","CallExpression","NewExpression"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/comma-dangle.js"],"sourcesContent":["/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    arrays: \"never\",\n    objects: \"never\",\n    imports: \"never\",\n    exports: \"never\",\n    functions: \"never\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n    return !(\n        lastItem.type === \"RestElement\" ||\n        lastItem.type === \"RestProperty\" ||\n        lastItem.type === \"ExperimentalRestProperty\"\n    );\n}\n\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue, ecmaVersion) {\n    if (typeof optionValue === \"string\") {\n        return {\n            arrays: optionValue,\n            objects: optionValue,\n            imports: optionValue,\n            exports: optionValue,\n            functions: (!ecmaVersion || ecmaVersion < 8) ? \"ignore\" : optionValue\n        };\n    }\n    if (typeof optionValue === \"object\" && optionValue !== null) {\n        return {\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\n        };\n    }\n\n    return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow trailing commas\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-dangle\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                },\n                valueWithIgnore: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"ignore\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                }\n            },\n            type: \"array\",\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/value\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                arrays: { $ref: \"#/definitions/valueWithIgnore\" },\n                                objects: { $ref: \"#/definitions/valueWithIgnore\" },\n                                imports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                exports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                functions: { $ref: \"#/definitions/valueWithIgnore\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unexpected trailing comma.\",\n            missing: \"Missing trailing comma.\"\n        }\n    },\n\n    create(context) {\n        const options = normalizeOptions(context.options[0], context.parserOptions.ecmaVersion);\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the last item of the given node.\n         * @param {ASTNode} node The node to get.\n         * @returns {ASTNode|null} The last node or null.\n         */\n        function getLastItem(node) {\n\n            /**\n             * Returns the last element of an array\n             * @param {any[]} array The input array\n             * @returns {any} The last element\n             */\n            function last(array) {\n                return array[array.length - 1];\n            }\n\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                    return last(node.properties);\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                    return last(node.elements);\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return last(node.specifiers);\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\":\n                case \"ArrowFunctionExpression\":\n                    return last(node.params);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return last(node.arguments);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Gets the trailing comma token of the given node.\n         * If the trailing comma does not exist, this returns the token which is\n         * the insertion point of the trailing comma token.\n         * @param {ASTNode} node The node to get.\n         * @param {ASTNode} lastItem The last item of the node.\n         * @returns {Token} The trailing comma token or the insertion point.\n         */\n        function getTrailingToken(node, lastItem) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return sourceCode.getLastToken(node, 1);\n                default: {\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\n\n                    if (astUtils.isCommaToken(nextToken)) {\n                        return nextToken;\n                    }\n                    return sourceCode.getLastToken(lastItem);\n                }\n            }\n        }\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            const penultimateToken = getTrailingToken(node, lastItem);\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (astUtils.isCommaToken(trailingToken)) {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        return fixer.remove(trailingToken);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: {\n                        start: trailingToken.loc.end,\n                        end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n                    },\n                    messageId: \"missing\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(trailingToken, \",\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        const predicate = {\n            always: forceTrailingComma,\n            \"always-multiline\": forceTrailingCommaIfMultiline,\n            \"only-multiline\": allowTrailingCommaIfMultiline,\n            never: forbidTrailingComma,\n            ignore: () => {}\n        };\n\n        return {\n            ObjectExpression: predicate[options.objects],\n            ObjectPattern: predicate[options.objects],\n\n            ArrayExpression: predicate[options.arrays],\n            ArrayPattern: predicate[options.arrays],\n\n            ImportDeclaration: predicate[options.imports],\n\n            ExportNamedDeclaration: predicate[options.exports],\n\n            FunctionDeclaration: predicate[options.functions],\n            FunctionExpression: predicate[options.functions],\n            ArrowFunctionExpression: predicate[options.functions],\n            CallExpression: predicate[options.functions],\n            NewExpression: predicate[options.functions]\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}