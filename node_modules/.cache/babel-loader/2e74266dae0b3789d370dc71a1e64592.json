{"ast":null,"code":"/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\n\n\nfunction escape(s) {\n  return `(?:${escapeRegExp(s)})`;\n}\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\n\n\nfunction escapeAndRepeat(s) {\n  return `${escape(s)}+`;\n}\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] A marker list.\n * @returns {string[]} A marker list.\n */\n\n\nfunction parseMarkersOption(markers) {\n  // `*` is a marker for JSDoc comments.\n  if (markers.indexOf(\"*\") === -1) {\n    return markers.concat(\"*\");\n  }\n\n  return markers;\n}\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\n\n\nfunction createExceptionsPattern(exceptions) {\n  let pattern = \"\";\n  /*\n   * A space or an exception pattern sequence.\n   * []                 ==> \"\\s\"\n   * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n   * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n   * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n   */\n\n  if (exceptions.length === 0) {\n    // a space.\n    pattern += \"\\\\s\";\n  } else {\n    // a space or...\n    pattern += \"(?:\\\\s|\";\n\n    if (exceptions.length === 1) {\n      // a sequence of the exception pattern.\n      pattern += escapeAndRepeat(exceptions[0]);\n    } else {\n      // a sequence of one of the exception patterns.\n      pattern += \"(?:\";\n      pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n      pattern += \")\";\n    }\n\n    pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n  }\n\n  return pattern;\n}\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n * @param {string[]} markers A marker list.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\n\n\nfunction createAlwaysStylePattern(markers, exceptions) {\n  let pattern = \"^\";\n  /*\n   * A marker or nothing.\n   * [\"*\"]            ==> \"\\*?\"\n   * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n   * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n   */\n\n  if (markers.length === 1) {\n    // the marker.\n    pattern += escape(markers[0]);\n  } else {\n    // one of markers.\n    pattern += \"(?:\";\n    pattern += markers.map(escape).join(\"|\");\n    pattern += \")\";\n  }\n\n  pattern += \"?\"; // or nothing.\n\n  pattern += createExceptionsPattern(exceptions);\n  return new RegExp(pattern, \"u\");\n}\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n * @param {string[]} markers A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\n\n\nfunction createNeverStylePattern(markers) {\n  const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n  return new RegExp(pattern, \"u\");\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/spaced-comment\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        markers: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        line: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            }\n          },\n          additionalProperties: false\n        },\n        block: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            balanced: {\n              type: \"boolean\",\n              default: false\n            }\n          },\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedSpaceAfterMarker: \"Unexpected space or tab after marker ({{refChar}}) in comment.\",\n      expectedExceptionAfter: \"Expected exception block, space or tab after '{{refChar}}' in comment.\",\n      unexpectedSpaceBefore: \"Unexpected space or tab before '*/' in comment.\",\n      unexpectedSpaceAfter: \"Unexpected space or tab after '{{refChar}}' in comment.\",\n      expectedSpaceBefore: \"Expected space or tab before '*/' in comment.\",\n      expectedSpaceAfter: \"Expected space or tab after '{{refChar}}' in comment.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); // Unless the first option is never, require a space\n\n    const requireSpace = context.options[0] !== \"never\";\n    /*\n     * Parse the second options.\n     * If markers don't include `\"*\"`, it's added automatically for JSDoc\n     * comments.\n     */\n\n    const config = context.options[1] || {};\n    const balanced = config.block && config.block.balanced;\n    const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n      const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n      const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n      const endNeverPattern = \"[ \\t]+$\"; // Create RegExp object for valid patterns.\n\n      rule[type] = {\n        beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n        endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\n        hasExceptions: exceptions.length > 0,\n        captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n        markers: new Set(markers)\n      };\n      return rule;\n    }, {});\n    /**\n     * Reports a beginning spacing error with an appropriate message.\n     * @param {ASTNode} node A comment node to check.\n     * @param {string} messageId An error message to report.\n     * @param {Array} match An array of match results for markers.\n     * @param {string} refChar Character used for reference in the error message.\n     * @returns {void}\n     */\n\n    function reportBegin(node, messageId, match, refChar) {\n      const type = node.type.toLowerCase(),\n            commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n      context.report({\n        node,\n\n        fix(fixer) {\n          const start = node.range[0];\n          let end = start + 2;\n\n          if (requireSpace) {\n            if (match) {\n              end += match[0].length;\n            }\n\n            return fixer.insertTextAfterRange([start, end], \" \");\n          }\n\n          end += match[0].length;\n          return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n        },\n\n        messageId,\n        data: {\n          refChar\n        }\n      });\n    }\n    /**\n     * Reports an ending spacing error with an appropriate message.\n     * @param {ASTNode} node A comment node to check.\n     * @param {string} messageId An error message to report.\n     * @param {string} match An array of the matched whitespace characters.\n     * @returns {void}\n     */\n\n\n    function reportEnd(node, messageId, match) {\n      context.report({\n        node,\n\n        fix(fixer) {\n          if (requireSpace) {\n            return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n          }\n\n          const end = node.range[1] - 2,\n                start = end - match[0].length;\n          return fixer.replaceTextRange([start, end], \"\");\n        },\n\n        messageId\n      });\n    }\n    /**\n     * Reports a given comment if it's invalid.\n     * @param {ASTNode} node a comment node to check.\n     * @returns {void}\n     */\n\n\n    function checkCommentForSpace(node) {\n      const type = node.type.toLowerCase(),\n            rule = styleRules[type],\n            commentIdentifier = type === \"block\" ? \"/*\" : \"//\"; // Ignores empty comments and comments that consist only of a marker.\n\n      if (node.value.length === 0 || rule.markers.has(node.value)) {\n        return;\n      }\n\n      const beginMatch = rule.beginRegex.exec(node.value);\n      const endMatch = rule.endRegex.exec(node.value); // Checks.\n\n      if (requireSpace) {\n        if (!beginMatch) {\n          const hasMarker = rule.captureMarker.exec(node.value);\n          const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n          if (rule.hasExceptions) {\n            reportBegin(node, \"expectedExceptionAfter\", hasMarker, marker);\n          } else {\n            reportBegin(node, \"expectedSpaceAfter\", hasMarker, marker);\n          }\n        }\n\n        if (balanced && type === \"block\" && !endMatch) {\n          reportEnd(node, \"expectedSpaceBefore\");\n        }\n      } else {\n        if (beginMatch) {\n          if (!beginMatch[1]) {\n            reportBegin(node, \"unexpectedSpaceAfter\", beginMatch, commentIdentifier);\n          } else {\n            reportBegin(node, \"unexpectedSpaceAfterMarker\", beginMatch, beginMatch[1]);\n          }\n        }\n\n        if (balanced && type === \"block\" && endMatch) {\n          reportEnd(node, \"unexpectedSpaceBefore\", endMatch);\n        }\n      }\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["escapeRegExp","require","astUtils","escape","s","escapeAndRepeat","parseMarkersOption","markers","indexOf","concat","createExceptionsPattern","exceptions","pattern","length","map","join","Array","from","LINEBREAKS","createAlwaysStylePattern","RegExp","createNeverStylePattern","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","items","line","additionalProperties","block","balanced","default","messages","unexpectedSpaceAfterMarker","expectedExceptionAfter","unexpectedSpaceBefore","unexpectedSpaceAfter","expectedSpaceBefore","expectedSpaceAfter","create","context","sourceCode","getSourceCode","requireSpace","options","config","styleRules","reduce","rule","endNeverPattern","beginRegex","endRegex","hasExceptions","captureMarker","Set","reportBegin","node","messageId","match","refChar","toLowerCase","commentIdentifier","report","fix","fixer","start","range","end","insertTextAfterRange","replaceTextRange","data","reportEnd","checkCommentForSpace","value","has","beginMatch","exec","endMatch","hasMarker","marker","Program","comments","getAllComments","filter","token","forEach"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/spaced-comment.js"],"sourcesContent":["/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n    return `(?:${escapeRegExp(s)})`;\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n    return `${escape(s)}+`;\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n\n    // `*` is a marker for JSDoc comments.\n    if (markers.indexOf(\"*\") === -1) {\n        return markers.concat(\"*\");\n    }\n\n    return markers;\n}\n\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\nfunction createExceptionsPattern(exceptions) {\n    let pattern = \"\";\n\n    /*\n     * A space or an exception pattern sequence.\n     * []                 ==> \"\\s\"\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n     */\n    if (exceptions.length === 0) {\n\n        // a space.\n        pattern += \"\\\\s\";\n    } else {\n\n        // a space or...\n        pattern += \"(?:\\\\s|\";\n\n        if (exceptions.length === 1) {\n\n            // a sequence of the exception pattern.\n            pattern += escapeAndRepeat(exceptions[0]);\n        } else {\n\n            // a sequence of one of the exception patterns.\n            pattern += \"(?:\";\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n            pattern += \")\";\n        }\n        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n    }\n\n    return pattern;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n * @param {string[]} markers A marker list.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n    let pattern = \"^\";\n\n    /*\n     * A marker or nothing.\n     * [\"*\"]            ==> \"\\*?\"\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n     */\n    if (markers.length === 1) {\n\n        // the marker.\n        pattern += escape(markers[0]);\n    } else {\n\n        // one of markers.\n        pattern += \"(?:\";\n        pattern += markers.map(escape).join(\"|\");\n        pattern += \")\";\n    }\n\n    pattern += \"?\"; // or nothing.\n    pattern += createExceptionsPattern(exceptions);\n\n    return new RegExp(pattern, \"u\");\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n * @param {string[]} markers A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n    const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n\n    return new RegExp(pattern, \"u\");\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/spaced-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    markers: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    line: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    block: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            balanced: {\n                                type: \"boolean\",\n                                default: false\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedSpaceAfterMarker: \"Unexpected space or tab after marker ({{refChar}}) in comment.\",\n            expectedExceptionAfter: \"Expected exception block, space or tab after '{{refChar}}' in comment.\",\n            unexpectedSpaceBefore: \"Unexpected space or tab before '*/' in comment.\",\n            unexpectedSpaceAfter: \"Unexpected space or tab after '{{refChar}}' in comment.\",\n            expectedSpaceBefore: \"Expected space or tab before '*/' in comment.\",\n            expectedSpaceAfter: \"Expected space or tab after '{{refChar}}' in comment.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        // Unless the first option is never, require a space\n        const requireSpace = context.options[0] !== \"never\";\n\n        /*\n         * Parse the second options.\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\n         * comments.\n         */\n        const config = context.options[1] || {};\n        const balanced = config.block && config.block.balanced;\n\n        const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n            const endNeverPattern = \"[ \\t]+$\";\n\n            // Create RegExp object for valid patterns.\n            rule[type] = {\n                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\n                hasExceptions: exceptions.length > 0,\n                captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n                markers: new Set(markers)\n            };\n\n            return rule;\n        }, {});\n\n        /**\n         * Reports a beginning spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} messageId An error message to report.\n         * @param {Array} match An array of match results for markers.\n         * @param {string} refChar Character used for reference in the error message.\n         * @returns {void}\n         */\n        function reportBegin(node, messageId, match, refChar) {\n            const type = node.type.toLowerCase(),\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            context.report({\n                node,\n                fix(fixer) {\n                    const start = node.range[0];\n                    let end = start + 2;\n\n                    if (requireSpace) {\n                        if (match) {\n                            end += match[0].length;\n                        }\n                        return fixer.insertTextAfterRange([start, end], \" \");\n                    }\n                    end += match[0].length;\n                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n\n                },\n                messageId,\n                data: { refChar }\n            });\n        }\n\n        /**\n         * Reports an ending spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} messageId An error message to report.\n         * @param {string} match An array of the matched whitespace characters.\n         * @returns {void}\n         */\n        function reportEnd(node, messageId, match) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (requireSpace) {\n                        return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n                    }\n                    const end = node.range[1] - 2,\n                        start = end - match[0].length;\n\n                    return fixer.replaceTextRange([start, end], \"\");\n\n                },\n                messageId\n            });\n        }\n\n        /**\n         * Reports a given comment if it's invalid.\n         * @param {ASTNode} node a comment node to check.\n         * @returns {void}\n         */\n        function checkCommentForSpace(node) {\n            const type = node.type.toLowerCase(),\n                rule = styleRules[type],\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            // Ignores empty comments and comments that consist only of a marker.\n            if (node.value.length === 0 || rule.markers.has(node.value)) {\n                return;\n            }\n\n            const beginMatch = rule.beginRegex.exec(node.value);\n            const endMatch = rule.endRegex.exec(node.value);\n\n            // Checks.\n            if (requireSpace) {\n                if (!beginMatch) {\n                    const hasMarker = rule.captureMarker.exec(node.value);\n                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n                    if (rule.hasExceptions) {\n                        reportBegin(node, \"expectedExceptionAfter\", hasMarker, marker);\n                    } else {\n                        reportBegin(node, \"expectedSpaceAfter\", hasMarker, marker);\n                    }\n                }\n\n                if (balanced && type === \"block\" && !endMatch) {\n                    reportEnd(node, \"expectedSpaceBefore\");\n                }\n            } else {\n                if (beginMatch) {\n                    if (!beginMatch[1]) {\n                        reportBegin(node, \"unexpectedSpaceAfter\", beginMatch, commentIdentifier);\n                    } else {\n                        reportBegin(node, \"unexpectedSpaceAfterMarker\", beginMatch, beginMatch[1]);\n                    }\n                }\n\n                if (balanced && type === \"block\" && endMatch) {\n                    reportEnd(node, \"unexpectedSpaceBefore\", endMatch);\n                }\n            }\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}