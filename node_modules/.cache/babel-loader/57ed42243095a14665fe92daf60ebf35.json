{"ast":null,"code":"/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n  isCommentToken\n} = require(\"eslint-utils\"),\n      TokenStore = require(\"./token-store\"),\n      astUtils = require(\"../shared/ast-utils\"),\n      Traverser = require(\"../shared/traverser\"); //------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\n\n\nfunction validate(ast) {\n  if (!ast.tokens) {\n    throw new Error(\"AST is missing the tokens array.\");\n  }\n\n  if (!ast.comments) {\n    throw new Error(\"AST is missing the comments array.\");\n  }\n\n  if (!ast.loc) {\n    throw new Error(\"AST is missing location information.\");\n  }\n\n  if (!ast.range) {\n    throw new Error(\"AST is missing range information\");\n  }\n}\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\n\n\nfunction looksLikeExport(astNode) {\n  return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" || astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\n\n\nfunction sortedMerge(tokens, comments) {\n  const result = [];\n  let tokenIndex = 0;\n  let commentIndex = 0;\n\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n      result.push(tokens[tokenIndex++]);\n    } else {\n      result.push(comments[commentIndex++]);\n    }\n  }\n\n  return result;\n}\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\n\n\nfunction nodesOrTokensOverlap(first, second) {\n  return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];\n}\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\n\n\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n  if (nodesOrTokensOverlap(first, second)) {\n    return false;\n  }\n\n  const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];\n  const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n  const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n  let currentToken = firstToken;\n\n  while (currentToken !== finalToken) {\n    const nextToken = sourceCode.getTokenAfter(currentToken, {\n      includeComments: true\n    });\n\n    if (currentToken.range[1] !== nextToken.range[0] ||\n    /*\n     * For backward compatibility, check spaces in JSXText.\n     * https://github.com/eslint/eslint/issues/12614\n     */\n    checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === \"JSXText\" && /\\s/u.test(nextToken.value)) {\n      return true;\n    }\n\n    currentToken = nextToken;\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nclass SourceCode extends TokenStore {\n  /**\n   * Represents parsed source code.\n   * @param {string|Object} textOrConfig The source code text or config object.\n   * @param {string} textOrConfig.text The source code text.\n   * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n   * @param {Object|null} textOrConfig.parserServices The parser services.\n   * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n   * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n   * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n   */\n  constructor(textOrConfig, astIfNoConfig) {\n    let text, ast, parserServices, scopeManager, visitorKeys; // Process overloading.\n\n    if (typeof textOrConfig === \"string\") {\n      text = textOrConfig;\n      ast = astIfNoConfig;\n    } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n      text = textOrConfig.text;\n      ast = textOrConfig.ast;\n      parserServices = textOrConfig.parserServices;\n      scopeManager = textOrConfig.scopeManager;\n      visitorKeys = textOrConfig.visitorKeys;\n    }\n\n    validate(ast);\n    super(ast.tokens, ast.comments);\n    /**\n     * The flag to indicate that the source code has Unicode BOM.\n     * @type boolean\n     */\n\n    this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n    /**\n     * The original text source code.\n     * BOM was stripped from this text.\n     * @type string\n     */\n\n    this.text = this.hasBOM ? text.slice(1) : text;\n    /**\n     * The parsed AST for the source code.\n     * @type ASTNode\n     */\n\n    this.ast = ast;\n    /**\n     * The parser services of this source code.\n     * @type {Object}\n     */\n\n    this.parserServices = parserServices || {};\n    /**\n     * The scope of this source code.\n     * @type {ScopeManager|null}\n     */\n\n    this.scopeManager = scopeManager || null;\n    /**\n     * The visitor keys to traverse AST.\n     * @type {Object}\n     */\n\n    this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS; // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n\n    const shebangMatched = this.text.match(astUtils.shebangPattern);\n    const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n    if (hasShebang) {\n      ast.comments[0].type = \"Shebang\";\n    }\n\n    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n    /**\n     * The source code split into lines according to ECMA-262 specification.\n     * This is done to avoid each rule needing to do so separately.\n     * @type string[]\n     */\n\n    this.lines = [];\n    this.lineStartIndices = [0];\n    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n    let match;\n    /*\n     * Previously, this was implemented using a regex that\n     * matched a sequence of non-linebreak characters followed by a\n     * linebreak, then adding the lengths of the matches. However,\n     * this caused a catastrophic backtracking issue when the end\n     * of a file contained a large number of non-newline characters.\n     * To avoid this, the current implementation just matches newlines\n     * and uses match.index to get the correct line start indices.\n     */\n\n    while (match = lineEndingPattern.exec(this.text)) {\n      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n      this.lineStartIndices.push(match.index + match[0].length);\n    }\n\n    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1])); // Cache for comments found using getComments().\n\n    this._commentCache = new WeakMap(); // don't allow modification of this object\n\n    Object.freeze(this);\n    Object.freeze(this.lines);\n  }\n  /**\n   * Split the source code into multiple lines based on the line delimiters.\n   * @param {string} text Source code as a string.\n   * @returns {string[]} Array of source code lines.\n   * @public\n   */\n\n\n  static splitLines(text) {\n    return text.split(astUtils.createGlobalLinebreakMatcher());\n  }\n  /**\n   * Gets the source code for the given node.\n   * @param {ASTNode} [node] The AST node to get the text for.\n   * @param {int} [beforeCount] The number of characters before the node to retrieve.\n   * @param {int} [afterCount] The number of characters after the node to retrieve.\n   * @returns {string} The text representing the AST node.\n   * @public\n   */\n\n\n  getText(node, beforeCount, afterCount) {\n    if (node) {\n      return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));\n    }\n\n    return this.text;\n  }\n  /**\n   * Gets the entire source text split into an array of lines.\n   * @returns {Array} The source text as an array of lines.\n   * @public\n   */\n\n\n  getLines() {\n    return this.lines;\n  }\n  /**\n   * Retrieves an array containing all comments in the source code.\n   * @returns {ASTNode[]} An array of comment nodes.\n   * @public\n   */\n\n\n  getAllComments() {\n    return this.ast.comments;\n  }\n  /**\n   * Gets all comments for the given node.\n   * @param {ASTNode} node The AST node to get the comments for.\n   * @returns {Object} An object containing a leading and trailing array\n   *      of comments indexed by their position.\n   * @public\n   * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().\n   */\n\n\n  getComments(node) {\n    if (this._commentCache.has(node)) {\n      return this._commentCache.get(node);\n    }\n\n    const comments = {\n      leading: [],\n      trailing: []\n    };\n    /*\n     * Return all comments as leading comments of the Program node when\n     * there is no executable code.\n     */\n\n    if (node.type === \"Program\") {\n      if (node.body.length === 0) {\n        comments.leading = node.comments;\n      }\n    } else {\n      /*\n       * Return comments as trailing comments of nodes that only contain\n       * comments (to mimic the comment attachment behavior present in Espree).\n       */\n      if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 || node.type === \"ObjectExpression\" && node.properties.length === 0 || node.type === \"ArrayExpression\" && node.elements.length === 0 || node.type === \"SwitchStatement\" && node.cases.length === 0) {\n        comments.trailing = this.getTokens(node, {\n          includeComments: true,\n          filter: isCommentToken\n        });\n      }\n      /*\n       * Iterate over tokens before and after node and collect comment tokens.\n       * Do not include comments that exist outside of the parent node\n       * to avoid duplication.\n       */\n\n\n      let currentToken = this.getTokenBefore(node, {\n        includeComments: true\n      });\n\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.start < node.parent.start) {\n          break;\n        }\n\n        comments.leading.push(currentToken);\n        currentToken = this.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      }\n\n      comments.leading.reverse();\n      currentToken = this.getTokenAfter(node, {\n        includeComments: true\n      });\n\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.end > node.parent.end) {\n          break;\n        }\n\n        comments.trailing.push(currentToken);\n        currentToken = this.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      }\n    }\n\n    this._commentCache.set(node, comments);\n\n    return comments;\n  }\n  /**\n   * Retrieves the JSDoc comment for a given node.\n   * @param {ASTNode} node The AST node to get the comment for.\n   * @returns {Token|null} The Block comment token containing the JSDoc comment\n   *      for the given node or null if not found.\n   * @public\n   * @deprecated\n   */\n\n\n  getJSDocComment(node) {\n    /**\n     * Checks for the presence of a JSDoc comment for the given node and returns it.\n     * @param {ASTNode} astNode The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @private\n     */\n    const findJSDocComment = astNode => {\n      const tokenBefore = this.getTokenBefore(astNode, {\n        includeComments: true\n      });\n\n      if (tokenBefore && isCommentToken(tokenBefore) && tokenBefore.type === \"Block\" && tokenBefore.value.charAt(0) === \"*\" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {\n        return tokenBefore;\n      }\n\n      return null;\n    };\n\n    let parent = node.parent;\n\n    switch (node.type) {\n      case \"ClassDeclaration\":\n      case \"FunctionDeclaration\":\n        return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n      case \"ClassExpression\":\n        return findJSDocComment(parent.parent);\n\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n        if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n          while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== \"MethodDefinition\" && parent.type !== \"Property\") {\n            parent = parent.parent;\n\n            if (!parent) {\n              break;\n            }\n          }\n\n          if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n            return findJSDocComment(parent);\n          }\n        }\n\n        return findJSDocComment(node);\n      // falls through\n\n      default:\n        return null;\n    }\n  }\n  /**\n   * Gets the deepest node containing a range index.\n   * @param {int} index Range index of the desired node.\n   * @returns {ASTNode} The node if found or null if not found.\n   * @public\n   */\n\n\n  getNodeByRangeIndex(index) {\n    let result = null;\n    Traverser.traverse(this.ast, {\n      visitorKeys: this.visitorKeys,\n\n      enter(node) {\n        if (node.range[0] <= index && index < node.range[1]) {\n          result = node;\n        } else {\n          this.skip();\n        }\n      },\n\n      leave(node) {\n        if (node === result) {\n          this.break();\n        }\n      }\n\n    });\n    return result;\n  }\n  /**\n   * Determines if two nodes or tokens have at least one whitespace character\n   * between them. Order does not matter. Returns false if the given nodes or\n   * tokens overlap.\n   * @param {ASTNode|Token} first The first node or token to check between.\n   * @param {ASTNode|Token} second The second node or token to check between.\n   * @returns {boolean} True if there is a whitespace character between\n   * any of the tokens found between the two given nodes or tokens.\n   * @public\n   */\n\n\n  isSpaceBetween(first, second) {\n    return isSpaceBetween(this, first, second, false);\n  }\n  /**\n   * Determines if two nodes or tokens have at least one whitespace character\n   * between them. Order does not matter. Returns false if the given nodes or\n   * tokens overlap.\n   * For backward compatibility, this method returns true if there are\n   * `JSXText` tokens that contain whitespaces between the two.\n   * @param {ASTNode|Token} first The first node or token to check between.\n   * @param {ASTNode|Token} second The second node or token to check between.\n   * @returns {boolean} True if there is a whitespace character between\n   * any of the tokens found between the two given nodes or tokens.\n   * @deprecated in favor of isSpaceBetween().\n   * @public\n   */\n\n\n  isSpaceBetweenTokens(first, second) {\n    return isSpaceBetween(this, first, second, true);\n  }\n  /**\n   * Converts a source text index into a (line, column) pair.\n   * @param {number} index The index of a character in a file\n   * @returns {Object} A {line, column} location object with a 0-indexed column\n   * @public\n   */\n\n\n  getLocFromIndex(index) {\n    if (typeof index !== \"number\") {\n      throw new TypeError(\"Expected `index` to be a number.\");\n    }\n\n    if (index < 0 || index > this.text.length) {\n      throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n    }\n    /*\n     * For an argument of this.text.length, return the location one \"spot\" past the last character\n     * of the file. If the last character is a linebreak, the location will be column 0 of the next\n     * line; otherwise, the location will be in the next column on the same line.\n     *\n     * See getIndexFromLoc for the motivation for this special case.\n     */\n\n\n    if (index === this.text.length) {\n      return {\n        line: this.lines.length,\n        column: this.lines[this.lines.length - 1].length\n      };\n    }\n    /*\n     * To figure out which line index is on, determine the last place at which index could\n     * be inserted into lineStartIndices to keep the list sorted.\n     */\n\n\n    const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1] ? this.lineStartIndices.length : this.lineStartIndices.findIndex(el => index < el);\n    return {\n      line: lineNumber,\n      column: index - this.lineStartIndices[lineNumber - 1]\n    };\n  }\n  /**\n   * Converts a (line, column) pair into a range index.\n   * @param {Object} loc A line/column location\n   * @param {number} loc.line The line number of the location (1-indexed)\n   * @param {number} loc.column The column number of the location (0-indexed)\n   * @returns {number} The range index of the location in the file.\n   * @public\n   */\n\n\n  getIndexFromLoc(loc) {\n    if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n      throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n    }\n\n    if (loc.line <= 0) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n    }\n\n    if (loc.line > this.lineStartIndices.length) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n    }\n\n    const lineStartIndex = this.lineStartIndices[loc.line - 1];\n    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n    const positionIndex = lineStartIndex + loc.column;\n    /*\n     * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n     * the given line, provided that the line number is valid element of this.lines. Since the\n     * last element of this.lines is an empty string for files with trailing newlines, add a\n     * special case where getting the index for the first location after the end of the file\n     * will return the length of the file, rather than throwing an error. This allows rules to\n     * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n     */\n\n    if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {\n      throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n    }\n\n    return positionIndex;\n  }\n\n}\n\nmodule.exports = SourceCode;","map":{"version":3,"names":["isCommentToken","require","TokenStore","astUtils","Traverser","validate","ast","tokens","Error","comments","loc","range","looksLikeExport","astNode","type","sortedMerge","result","tokenIndex","commentIndex","length","push","nodesOrTokensOverlap","first","second","isSpaceBetween","sourceCode","checkInsideOfJSXText","startingNodeOrToken","endingNodeOrToken","firstToken","getLastToken","finalToken","getFirstToken","currentToken","nextToken","getTokenAfter","includeComments","test","value","SourceCode","constructor","textOrConfig","astIfNoConfig","text","parserServices","scopeManager","visitorKeys","hasBOM","charCodeAt","slice","DEFAULT_VISITOR_KEYS","shebangMatched","match","shebangPattern","hasShebang","tokensAndComments","lines","lineStartIndices","lineEndingPattern","createGlobalLinebreakMatcher","exec","index","_commentCache","WeakMap","Object","freeze","splitLines","split","getText","node","beforeCount","afterCount","Math","max","getLines","getAllComments","getComments","has","get","leading","trailing","body","properties","elements","cases","getTokens","filter","getTokenBefore","parent","start","reverse","end","set","getJSDocComment","findJSDocComment","tokenBefore","charAt","line","getCommentsBefore","getNodeByRangeIndex","traverse","enter","skip","leave","break","isSpaceBetweenTokens","getLocFromIndex","TypeError","RangeError","column","lineNumber","findIndex","el","getIndexFromLoc","lineStartIndex","lineEndIndex","positionIndex","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/source-code/source-code.js"],"sourcesContent":["/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    { isCommentToken } = require(\"eslint-utils\"),\n    TokenStore = require(\"./token-store\"),\n    astUtils = require(\"../shared/ast-utils\"),\n    Traverser = require(\"../shared/traverser\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\nfunction sortedMerge(tokens, comments) {\n    const result = [];\n    let tokenIndex = 0;\n    let commentIndex = 0;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n            result.push(tokens[tokenIndex++]);\n        } else {\n            result.push(comments[commentIndex++]);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\nfunction nodesOrTokensOverlap(first, second) {\n    return (first.range[0] <= second.range[0] && first.range[1] >= second.range[0]) ||\n        (second.range[0] <= first.range[0] && second.range[1] >= first.range[0]);\n}\n\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n    if (nodesOrTokensOverlap(first, second)) {\n        return false;\n    }\n\n    const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0]\n        ? [first, second]\n        : [second, first];\n    const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n    const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n    let currentToken = firstToken;\n\n    while (currentToken !== finalToken) {\n        const nextToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n\n        if (\n            currentToken.range[1] !== nextToken.range[0] ||\n\n                /*\n                 * For backward compatibility, check spaces in JSXText.\n                 * https://github.com/eslint/eslint/issues/12614\n                 */\n                (\n                    checkInsideOfJSXText &&\n                    nextToken !== finalToken &&\n                    nextToken.type === \"JSXText\" &&\n                    /\\s/u.test(nextToken.value)\n                )\n        ) {\n            return true;\n        }\n\n        currentToken = nextToken;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass SourceCode extends TokenStore {\n\n    /**\n     * Represents parsed source code.\n     * @param {string|Object} textOrConfig The source code text or config object.\n     * @param {string} textOrConfig.text The source code text.\n     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     * @param {Object|null} textOrConfig.parserServices The parser services.\n     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     */\n    constructor(textOrConfig, astIfNoConfig) {\n        let text, ast, parserServices, scopeManager, visitorKeys;\n\n        // Process overloading.\n        if (typeof textOrConfig === \"string\") {\n            text = textOrConfig;\n            ast = astIfNoConfig;\n        } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n            text = textOrConfig.text;\n            ast = textOrConfig.ast;\n            parserServices = textOrConfig.parserServices;\n            scopeManager = textOrConfig.scopeManager;\n            visitorKeys = textOrConfig.visitorKeys;\n        }\n\n        validate(ast);\n        super(ast.tokens, ast.comments);\n\n        /**\n         * The flag to indicate that the source code has Unicode BOM.\n         * @type boolean\n         */\n        this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\n\n        /**\n         * The original text source code.\n         * BOM was stripped from this text.\n         * @type string\n         */\n        this.text = (this.hasBOM ? text.slice(1) : text);\n\n        /**\n         * The parsed AST for the source code.\n         * @type ASTNode\n         */\n        this.ast = ast;\n\n        /**\n         * The parser services of this source code.\n         * @type {Object}\n         */\n        this.parserServices = parserServices || {};\n\n        /**\n         * The scope of this source code.\n         * @type {ScopeManager|null}\n         */\n        this.scopeManager = scopeManager || null;\n\n        /**\n         * The visitor keys to traverse AST.\n         * @type {Object}\n         */\n        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\n\n        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n        const shebangMatched = this.text.match(astUtils.shebangPattern);\n        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n        if (hasShebang) {\n            ast.comments[0].type = \"Shebang\";\n        }\n\n        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n        /**\n         * The source code split into lines according to ECMA-262 specification.\n         * This is done to avoid each rule needing to do so separately.\n         * @type string[]\n         */\n        this.lines = [];\n        this.lineStartIndices = [0];\n\n        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n\n        /*\n         * Previously, this was implemented using a regex that\n         * matched a sequence of non-linebreak characters followed by a\n         * linebreak, then adding the lengths of the matches. However,\n         * this caused a catastrophic backtracking issue when the end\n         * of a file contained a large number of non-newline characters.\n         * To avoid this, the current implementation just matches newlines\n         * and uses match.index to get the correct line start indices.\n         */\n        while ((match = lineEndingPattern.exec(this.text))) {\n            this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n            this.lineStartIndices.push(match.index + match[0].length);\n        }\n        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n        // Cache for comments found using getComments().\n        this._commentCache = new WeakMap();\n\n        // don't allow modification of this object\n        Object.freeze(this);\n        Object.freeze(this.lines);\n    }\n\n    /**\n     * Split the source code into multiple lines based on the line delimiters.\n     * @param {string} text Source code as a string.\n     * @returns {string[]} Array of source code lines.\n     * @public\n     */\n    static splitLines(text) {\n        return text.split(astUtils.createGlobalLinebreakMatcher());\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode} [node] The AST node to get the text for.\n     * @param {int} [beforeCount] The number of characters before the node to retrieve.\n     * @param {int} [afterCount] The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     * @public\n     */\n    getText(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        }\n        return this.text;\n    }\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     * @public\n     */\n    getLines() {\n        return this.lines;\n    }\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     * @public\n     */\n    getAllComments() {\n        return this.ast.comments;\n    }\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} An object containing a leading and trailing array\n     *      of comments indexed by their position.\n     * @public\n     * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().\n     */\n    getComments(node) {\n        if (this._commentCache.has(node)) {\n            return this._commentCache.get(node);\n        }\n\n        const comments = {\n            leading: [],\n            trailing: []\n        };\n\n        /*\n         * Return all comments as leading comments of the Program node when\n         * there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                comments.leading = node.comments;\n            }\n        } else {\n\n            /*\n             * Return comments as trailing comments of nodes that only contain\n             * comments (to mimic the comment attachment behavior present in Espree).\n             */\n            if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 ||\n                node.type === \"ObjectExpression\" && node.properties.length === 0 ||\n                node.type === \"ArrayExpression\" && node.elements.length === 0 ||\n                node.type === \"SwitchStatement\" && node.cases.length === 0\n            ) {\n                comments.trailing = this.getTokens(node, {\n                    includeComments: true,\n                    filter: isCommentToken\n                });\n            }\n\n            /*\n             * Iterate over tokens before and after node and collect comment tokens.\n             * Do not include comments that exist outside of the parent node\n             * to avoid duplication.\n             */\n            let currentToken = this.getTokenBefore(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && node.parent.type !== \"Program\" && (currentToken.start < node.parent.start)) {\n                    break;\n                }\n                comments.leading.push(currentToken);\n                currentToken = this.getTokenBefore(currentToken, { includeComments: true });\n            }\n\n            comments.leading.reverse();\n\n            currentToken = this.getTokenAfter(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && node.parent.type !== \"Program\" && (currentToken.end > node.parent.end)) {\n                    break;\n                }\n                comments.trailing.push(currentToken);\n                currentToken = this.getTokenAfter(currentToken, { includeComments: true });\n            }\n        }\n\n        this._commentCache.set(node, comments);\n        return comments;\n    }\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @public\n     * @deprecated\n     */\n    getJSDocComment(node) {\n\n        /**\n         * Checks for the presence of a JSDoc comment for the given node and returns it.\n         * @param {ASTNode} astNode The AST node to get the comment for.\n         * @returns {Token|null} The Block comment token containing the JSDoc comment\n         *      for the given node or null if not found.\n         * @private\n         */\n        const findJSDocComment = astNode => {\n            const tokenBefore = this.getTokenBefore(astNode, { includeComments: true });\n\n            if (\n                tokenBefore &&\n                isCommentToken(tokenBefore) &&\n                tokenBefore.type === \"Block\" &&\n                tokenBefore.value.charAt(0) === \"*\" &&\n                astNode.loc.start.line - tokenBefore.loc.end.line <= 1\n            ) {\n                return tokenBefore;\n            }\n\n            return null;\n        };\n        let parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (\n                        !this.getCommentsBefore(parent).length &&\n                        !/Function/u.test(parent.type) &&\n                        parent.type !== \"MethodDefinition\" &&\n                        parent.type !== \"Property\"\n                    ) {\n                        parent = parent.parent;\n\n                        if (!parent) {\n                            break;\n                        }\n                    }\n\n                    if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n                        return findJSDocComment(parent);\n                    }\n                }\n\n                return findJSDocComment(node);\n\n            // falls through\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     * @public\n     */\n    getNodeByRangeIndex(index) {\n        let result = null;\n\n        Traverser.traverse(this.ast, {\n            visitorKeys: this.visitorKeys,\n            enter(node) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                } else {\n                    this.skip();\n                }\n            },\n            leave(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @public\n     */\n    isSpaceBetween(first, second) {\n        return isSpaceBetween(this, first, second, false);\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * For backward compatibility, this method returns true if there are\n     * `JSXText` tokens that contain whitespaces between the two.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @deprecated in favor of isSpaceBetween().\n     * @public\n     */\n    isSpaceBetweenTokens(first, second) {\n        return isSpaceBetween(this, first, second, true);\n    }\n\n    /**\n     * Converts a source text index into a (line, column) pair.\n     * @param {number} index The index of a character in a file\n     * @returns {Object} A {line, column} location object with a 0-indexed column\n     * @public\n     */\n    getLocFromIndex(index) {\n        if (typeof index !== \"number\") {\n            throw new TypeError(\"Expected `index` to be a number.\");\n        }\n\n        if (index < 0 || index > this.text.length) {\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n        }\n\n        /*\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\n         * line; otherwise, the location will be in the next column on the same line.\n         *\n         * See getIndexFromLoc for the motivation for this special case.\n         */\n        if (index === this.text.length) {\n            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };\n        }\n\n        /*\n         * To figure out which line index is on, determine the last place at which index could\n         * be inserted into lineStartIndices to keep the list sorted.\n         */\n        const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1]\n            ? this.lineStartIndices.length\n            : this.lineStartIndices.findIndex(el => index < el);\n\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\n    }\n\n    /**\n     * Converts a (line, column) pair into a range index.\n     * @param {Object} loc A line/column location\n     * @param {number} loc.line The line number of the location (1-indexed)\n     * @param {number} loc.column The column number of the location (0-indexed)\n     * @returns {number} The range index of the location in the file.\n     * @public\n     */\n    getIndexFromLoc(loc) {\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n        }\n\n        if (loc.line <= 0) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n        }\n\n        if (loc.line > this.lineStartIndices.length) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n        }\n\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n        const positionIndex = lineStartIndex + loc.column;\n\n        /*\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n         * the given line, provided that the line number is valid element of this.lines. Since the\n         * last element of this.lines is an empty string for files with trailing newlines, add a\n         * special case where getting the index for the first location after the end of the file\n         * will return the length of the file, rather than throwing an error. This allows rules to\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n         */\n        if (\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\n        ) {\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n        }\n\n        return positionIndex;\n    }\n}\n\nmodule.exports = SourceCode;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MACI;EAAEA;AAAF,IAAqBC,OAAO,CAAC,cAAD,CADhC;AAAA,MAEIC,UAAU,GAAGD,OAAO,CAAC,eAAD,CAFxB;AAAA,MAGIE,QAAQ,GAAGF,OAAO,CAAC,qBAAD,CAHtB;AAAA,MAIIG,SAAS,GAAGH,OAAO,CAAC,qBAAD,CAJvB,C,CAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,QAAT,CAAkBC,GAAlB,EAAuB;EACnB,IAAI,CAACA,GAAG,CAACC,MAAT,EAAiB;IACb,MAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;EACH;;EAED,IAAI,CAACF,GAAG,CAACG,QAAT,EAAmB;IACf,MAAM,IAAID,KAAJ,CAAU,oCAAV,CAAN;EACH;;EAED,IAAI,CAACF,GAAG,CAACI,GAAT,EAAc;IACV,MAAM,IAAIF,KAAJ,CAAU,sCAAV,CAAN;EACH;;EAED,IAAI,CAACF,GAAG,CAACK,KAAT,EAAgB;IACZ,MAAM,IAAIH,KAAJ,CAAU,kCAAV,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,eAAT,CAAyBC,OAAzB,EAAkC;EAC9B,OAAOA,OAAO,CAACC,IAAR,KAAiB,0BAAjB,IAA+CD,OAAO,CAACC,IAAR,KAAiB,wBAAhE,IACHD,OAAO,CAACC,IAAR,KAAiB,sBADd,IACwCD,OAAO,CAACC,IAAR,KAAiB,iBADhE;AAEH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,WAAT,CAAqBR,MAArB,EAA6BE,QAA7B,EAAuC;EACnC,MAAMO,MAAM,GAAG,EAAf;EACA,IAAIC,UAAU,GAAG,CAAjB;EACA,IAAIC,YAAY,GAAG,CAAnB;;EAEA,OAAOD,UAAU,GAAGV,MAAM,CAACY,MAApB,IAA8BD,YAAY,GAAGT,QAAQ,CAACU,MAA7D,EAAqE;IACjE,IAAID,YAAY,IAAIT,QAAQ,CAACU,MAAzB,IAAmCF,UAAU,GAAGV,MAAM,CAACY,MAApB,IAA8BZ,MAAM,CAACU,UAAD,CAAN,CAAmBN,KAAnB,CAAyB,CAAzB,IAA8BF,QAAQ,CAACS,YAAD,CAAR,CAAuBP,KAAvB,CAA6B,CAA7B,CAAnG,EAAoI;MAChIK,MAAM,CAACI,IAAP,CAAYb,MAAM,CAACU,UAAU,EAAX,CAAlB;IACH,CAFD,MAEO;MACHD,MAAM,CAACI,IAAP,CAAYX,QAAQ,CAACS,YAAY,EAAb,CAApB;IACH;EACJ;;EAED,OAAOF,MAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,oBAAT,CAA8BC,KAA9B,EAAqCC,MAArC,EAA6C;EACzC,OAAQD,KAAK,CAACX,KAAN,CAAY,CAAZ,KAAkBY,MAAM,CAACZ,KAAP,CAAa,CAAb,CAAlB,IAAqCW,KAAK,CAACX,KAAN,CAAY,CAAZ,KAAkBY,MAAM,CAACZ,KAAP,CAAa,CAAb,CAAxD,IACFY,MAAM,CAACZ,KAAP,CAAa,CAAb,KAAmBW,KAAK,CAACX,KAAN,CAAY,CAAZ,CAAnB,IAAqCY,MAAM,CAACZ,KAAP,CAAa,CAAb,KAAmBW,KAAK,CAACX,KAAN,CAAY,CAAZ,CAD7D;AAEH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASa,cAAT,CAAwBC,UAAxB,EAAoCH,KAApC,EAA2CC,MAA3C,EAAmDG,oBAAnD,EAAyE;EACrE,IAAIL,oBAAoB,CAACC,KAAD,EAAQC,MAAR,CAAxB,EAAyC;IACrC,OAAO,KAAP;EACH;;EAED,MAAM,CAACI,mBAAD,EAAsBC,iBAAtB,IAA2CN,KAAK,CAACX,KAAN,CAAY,CAAZ,KAAkBY,MAAM,CAACZ,KAAP,CAAa,CAAb,CAAlB,GAC3C,CAACW,KAAD,EAAQC,MAAR,CAD2C,GAE3C,CAACA,MAAD,EAASD,KAAT,CAFN;EAGA,MAAMO,UAAU,GAAGJ,UAAU,CAACK,YAAX,CAAwBH,mBAAxB,KAAgDA,mBAAnE;EACA,MAAMI,UAAU,GAAGN,UAAU,CAACO,aAAX,CAAyBJ,iBAAzB,KAA+CA,iBAAlE;EACA,IAAIK,YAAY,GAAGJ,UAAnB;;EAEA,OAAOI,YAAY,KAAKF,UAAxB,EAAoC;IAChC,MAAMG,SAAS,GAAGT,UAAU,CAACU,aAAX,CAAyBF,YAAzB,EAAuC;MAAEG,eAAe,EAAE;IAAnB,CAAvC,CAAlB;;IAEA,IACIH,YAAY,CAACtB,KAAb,CAAmB,CAAnB,MAA0BuB,SAAS,CAACvB,KAAV,CAAgB,CAAhB,CAA1B;IAEI;AAChB;AACA;AACA;IAEoBe,oBAAoB,IACpBQ,SAAS,KAAKH,UADd,IAEAG,SAAS,CAACpB,IAAV,KAAmB,SAFnB,IAGA,MAAMuB,IAAN,CAAWH,SAAS,CAACI,KAArB,CAXZ,EAaE;MACE,OAAO,IAAP;IACH;;IAEDL,YAAY,GAAGC,SAAf;EACH;;EAED,OAAO,KAAP;AACH,C,CAED;AACA;AACA;;;AAEA,MAAMK,UAAN,SAAyBrC,UAAzB,CAAoC;EAEhC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIsC,WAAW,CAACC,YAAD,EAAeC,aAAf,EAA8B;IACrC,IAAIC,IAAJ,EAAUrC,GAAV,EAAesC,cAAf,EAA+BC,YAA/B,EAA6CC,WAA7C,CADqC,CAGrC;;IACA,IAAI,OAAOL,YAAP,KAAwB,QAA5B,EAAsC;MAClCE,IAAI,GAAGF,YAAP;MACAnC,GAAG,GAAGoC,aAAN;IACH,CAHD,MAGO,IAAI,OAAOD,YAAP,KAAwB,QAAxB,IAAoCA,YAAY,KAAK,IAAzD,EAA+D;MAClEE,IAAI,GAAGF,YAAY,CAACE,IAApB;MACArC,GAAG,GAAGmC,YAAY,CAACnC,GAAnB;MACAsC,cAAc,GAAGH,YAAY,CAACG,cAA9B;MACAC,YAAY,GAAGJ,YAAY,CAACI,YAA5B;MACAC,WAAW,GAAGL,YAAY,CAACK,WAA3B;IACH;;IAEDzC,QAAQ,CAACC,GAAD,CAAR;IACA,MAAMA,GAAG,CAACC,MAAV,EAAkBD,GAAG,CAACG,QAAtB;IAEA;AACR;AACA;AACA;;IACQ,KAAKsC,MAAL,GAAeJ,IAAI,CAACK,UAAL,CAAgB,CAAhB,MAAuB,MAAtC;IAEA;AACR;AACA;AACA;AACA;;IACQ,KAAKL,IAAL,GAAa,KAAKI,MAAL,GAAcJ,IAAI,CAACM,KAAL,CAAW,CAAX,CAAd,GAA8BN,IAA3C;IAEA;AACR;AACA;AACA;;IACQ,KAAKrC,GAAL,GAAWA,GAAX;IAEA;AACR;AACA;AACA;;IACQ,KAAKsC,cAAL,GAAsBA,cAAc,IAAI,EAAxC;IAEA;AACR;AACA;AACA;;IACQ,KAAKC,YAAL,GAAoBA,YAAY,IAAI,IAApC;IAEA;AACR;AACA;AACA;;IACQ,KAAKC,WAAL,GAAmBA,WAAW,IAAI1C,SAAS,CAAC8C,oBAA5C,CArDqC,CAuDrC;;IACA,MAAMC,cAAc,GAAG,KAAKR,IAAL,CAAUS,KAAV,CAAgBjD,QAAQ,CAACkD,cAAzB,CAAvB;IACA,MAAMC,UAAU,GAAGH,cAAc,IAAI7C,GAAG,CAACG,QAAJ,CAAaU,MAA/B,IAAyCb,GAAG,CAACG,QAAJ,CAAa,CAAb,EAAgB6B,KAAhB,KAA0Ba,cAAc,CAAC,CAAD,CAApG;;IAEA,IAAIG,UAAJ,EAAgB;MACZhD,GAAG,CAACG,QAAJ,CAAa,CAAb,EAAgBK,IAAhB,GAAuB,SAAvB;IACH;;IAED,KAAKyC,iBAAL,GAAyBxC,WAAW,CAACT,GAAG,CAACC,MAAL,EAAaD,GAAG,CAACG,QAAjB,CAApC;IAEA;AACR;AACA;AACA;AACA;;IACQ,KAAK+C,KAAL,GAAa,EAAb;IACA,KAAKC,gBAAL,GAAwB,CAAC,CAAD,CAAxB;IAEA,MAAMC,iBAAiB,GAAGvD,QAAQ,CAACwD,4BAAT,EAA1B;IACA,IAAIP,KAAJ;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQ,OAAQA,KAAK,GAAGM,iBAAiB,CAACE,IAAlB,CAAuB,KAAKjB,IAA5B,CAAhB,EAAoD;MAChD,KAAKa,KAAL,CAAWpC,IAAX,CAAgB,KAAKuB,IAAL,CAAUM,KAAV,CAAgB,KAAKQ,gBAAL,CAAsB,KAAKA,gBAAL,CAAsBtC,MAAtB,GAA+B,CAArD,CAAhB,EAAyEiC,KAAK,CAACS,KAA/E,CAAhB;MACA,KAAKJ,gBAAL,CAAsBrC,IAAtB,CAA2BgC,KAAK,CAACS,KAAN,GAAcT,KAAK,CAAC,CAAD,CAAL,CAASjC,MAAlD;IACH;;IACD,KAAKqC,KAAL,CAAWpC,IAAX,CAAgB,KAAKuB,IAAL,CAAUM,KAAV,CAAgB,KAAKQ,gBAAL,CAAsB,KAAKA,gBAAL,CAAsBtC,MAAtB,GAA+B,CAArD,CAAhB,CAAhB,EAzFqC,CA2FrC;;IACA,KAAK2C,aAAL,GAAqB,IAAIC,OAAJ,EAArB,CA5FqC,CA8FrC;;IACAC,MAAM,CAACC,MAAP,CAAc,IAAd;IACAD,MAAM,CAACC,MAAP,CAAc,KAAKT,KAAnB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACqB,OAAVU,UAAU,CAACvB,IAAD,EAAO;IACpB,OAAOA,IAAI,CAACwB,KAAL,CAAWhE,QAAQ,CAACwD,4BAAT,EAAX,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIS,OAAO,CAACC,IAAD,EAAOC,WAAP,EAAoBC,UAApB,EAAgC;IACnC,IAAIF,IAAJ,EAAU;MACN,OAAO,KAAK1B,IAAL,CAAUM,KAAV,CAAgBuB,IAAI,CAACC,GAAL,CAASJ,IAAI,CAAC1D,KAAL,CAAW,CAAX,KAAiB2D,WAAW,IAAI,CAAhC,CAAT,EAA6C,CAA7C,CAAhB,EACHD,IAAI,CAAC1D,KAAL,CAAW,CAAX,KAAiB4D,UAAU,IAAI,CAA/B,CADG,CAAP;IAEH;;IACD,OAAO,KAAK5B,IAAZ;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACI+B,QAAQ,GAAG;IACP,OAAO,KAAKlB,KAAZ;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACImB,cAAc,GAAG;IACb,OAAO,KAAKrE,GAAL,CAASG,QAAhB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACImE,WAAW,CAACP,IAAD,EAAO;IACd,IAAI,KAAKP,aAAL,CAAmBe,GAAnB,CAAuBR,IAAvB,CAAJ,EAAkC;MAC9B,OAAO,KAAKP,aAAL,CAAmBgB,GAAnB,CAAuBT,IAAvB,CAAP;IACH;;IAED,MAAM5D,QAAQ,GAAG;MACbsE,OAAO,EAAE,EADI;MAEbC,QAAQ,EAAE;IAFG,CAAjB;IAKA;AACR;AACA;AACA;;IACQ,IAAIX,IAAI,CAACvD,IAAL,KAAc,SAAlB,EAA6B;MACzB,IAAIuD,IAAI,CAACY,IAAL,CAAU9D,MAAV,KAAqB,CAAzB,EAA4B;QACxBV,QAAQ,CAACsE,OAAT,GAAmBV,IAAI,CAAC5D,QAAxB;MACH;IACJ,CAJD,MAIO;MAEH;AACZ;AACA;AACA;MACY,IAAI,CAAC4D,IAAI,CAACvD,IAAL,KAAc,gBAAd,IAAkCuD,IAAI,CAACvD,IAAL,KAAc,WAAjD,KAAiEuD,IAAI,CAACY,IAAL,CAAU9D,MAAV,KAAqB,CAAtF,IACAkD,IAAI,CAACvD,IAAL,KAAc,kBAAd,IAAoCuD,IAAI,CAACa,UAAL,CAAgB/D,MAAhB,KAA2B,CAD/D,IAEAkD,IAAI,CAACvD,IAAL,KAAc,iBAAd,IAAmCuD,IAAI,CAACc,QAAL,CAAchE,MAAd,KAAyB,CAF5D,IAGAkD,IAAI,CAACvD,IAAL,KAAc,iBAAd,IAAmCuD,IAAI,CAACe,KAAL,CAAWjE,MAAX,KAAsB,CAH7D,EAIE;QACEV,QAAQ,CAACuE,QAAT,GAAoB,KAAKK,SAAL,CAAehB,IAAf,EAAqB;UACrCjC,eAAe,EAAE,IADoB;UAErCkD,MAAM,EAAEtF;QAF6B,CAArB,CAApB;MAIH;MAED;AACZ;AACA;AACA;AACA;;;MACY,IAAIiC,YAAY,GAAG,KAAKsD,cAAL,CAAoBlB,IAApB,EAA0B;QAAEjC,eAAe,EAAE;MAAnB,CAA1B,CAAnB;;MAEA,OAAOH,YAAY,IAAIjC,cAAc,CAACiC,YAAD,CAArC,EAAqD;QACjD,IAAIoC,IAAI,CAACmB,MAAL,IAAenB,IAAI,CAACmB,MAAL,CAAY1E,IAAZ,KAAqB,SAApC,IAAkDmB,YAAY,CAACwD,KAAb,GAAqBpB,IAAI,CAACmB,MAAL,CAAYC,KAAvF,EAA+F;UAC3F;QACH;;QACDhF,QAAQ,CAACsE,OAAT,CAAiB3D,IAAjB,CAAsBa,YAAtB;QACAA,YAAY,GAAG,KAAKsD,cAAL,CAAoBtD,YAApB,EAAkC;UAAEG,eAAe,EAAE;QAAnB,CAAlC,CAAf;MACH;;MAED3B,QAAQ,CAACsE,OAAT,CAAiBW,OAAjB;MAEAzD,YAAY,GAAG,KAAKE,aAAL,CAAmBkC,IAAnB,EAAyB;QAAEjC,eAAe,EAAE;MAAnB,CAAzB,CAAf;;MAEA,OAAOH,YAAY,IAAIjC,cAAc,CAACiC,YAAD,CAArC,EAAqD;QACjD,IAAIoC,IAAI,CAACmB,MAAL,IAAenB,IAAI,CAACmB,MAAL,CAAY1E,IAAZ,KAAqB,SAApC,IAAkDmB,YAAY,CAAC0D,GAAb,GAAmBtB,IAAI,CAACmB,MAAL,CAAYG,GAArF,EAA2F;UACvF;QACH;;QACDlF,QAAQ,CAACuE,QAAT,CAAkB5D,IAAlB,CAAuBa,YAAvB;QACAA,YAAY,GAAG,KAAKE,aAAL,CAAmBF,YAAnB,EAAiC;UAAEG,eAAe,EAAE;QAAnB,CAAjC,CAAf;MACH;IACJ;;IAED,KAAK0B,aAAL,CAAmB8B,GAAnB,CAAuBvB,IAAvB,EAA6B5D,QAA7B;;IACA,OAAOA,QAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIoF,eAAe,CAACxB,IAAD,EAAO;IAElB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,MAAMyB,gBAAgB,GAAGjF,OAAO,IAAI;MAChC,MAAMkF,WAAW,GAAG,KAAKR,cAAL,CAAoB1E,OAApB,EAA6B;QAAEuB,eAAe,EAAE;MAAnB,CAA7B,CAApB;;MAEA,IACI2D,WAAW,IACX/F,cAAc,CAAC+F,WAAD,CADd,IAEAA,WAAW,CAACjF,IAAZ,KAAqB,OAFrB,IAGAiF,WAAW,CAACzD,KAAZ,CAAkB0D,MAAlB,CAAyB,CAAzB,MAAgC,GAHhC,IAIAnF,OAAO,CAACH,GAAR,CAAY+E,KAAZ,CAAkBQ,IAAlB,GAAyBF,WAAW,CAACrF,GAAZ,CAAgBiF,GAAhB,CAAoBM,IAA7C,IAAqD,CALzD,EAME;QACE,OAAOF,WAAP;MACH;;MAED,OAAO,IAAP;IACH,CAdD;;IAeA,IAAIP,MAAM,GAAGnB,IAAI,CAACmB,MAAlB;;IAEA,QAAQnB,IAAI,CAACvD,IAAb;MACI,KAAK,kBAAL;MACA,KAAK,qBAAL;QACI,OAAOgF,gBAAgB,CAAClF,eAAe,CAAC4E,MAAD,CAAf,GAA0BA,MAA1B,GAAmCnB,IAApC,CAAvB;;MAEJ,KAAK,iBAAL;QACI,OAAOyB,gBAAgB,CAACN,MAAM,CAACA,MAAR,CAAvB;;MAEJ,KAAK,yBAAL;MACA,KAAK,oBAAL;QACI,IAAIA,MAAM,CAAC1E,IAAP,KAAgB,gBAAhB,IAAoC0E,MAAM,CAAC1E,IAAP,KAAgB,eAAxD,EAAyE;UACrE,OACI,CAAC,KAAKoF,iBAAL,CAAuBV,MAAvB,EAA+BrE,MAAhC,IACA,CAAC,YAAYkB,IAAZ,CAAiBmD,MAAM,CAAC1E,IAAxB,CADD,IAEA0E,MAAM,CAAC1E,IAAP,KAAgB,kBAFhB,IAGA0E,MAAM,CAAC1E,IAAP,KAAgB,UAJpB,EAKE;YACE0E,MAAM,GAAGA,MAAM,CAACA,MAAhB;;YAEA,IAAI,CAACA,MAAL,EAAa;cACT;YACH;UACJ;;UAED,IAAIA,MAAM,IAAIA,MAAM,CAAC1E,IAAP,KAAgB,qBAA1B,IAAmD0E,MAAM,CAAC1E,IAAP,KAAgB,SAAvE,EAAkF;YAC9E,OAAOgF,gBAAgB,CAACN,MAAD,CAAvB;UACH;QACJ;;QAED,OAAOM,gBAAgB,CAACzB,IAAD,CAAvB;MAEJ;;MACA;QACI,OAAO,IAAP;IAjCR;EAmCH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACI8B,mBAAmB,CAACtC,KAAD,EAAQ;IACvB,IAAI7C,MAAM,GAAG,IAAb;IAEAZ,SAAS,CAACgG,QAAV,CAAmB,KAAK9F,GAAxB,EAA6B;MACzBwC,WAAW,EAAE,KAAKA,WADO;;MAEzBuD,KAAK,CAAChC,IAAD,EAAO;QACR,IAAIA,IAAI,CAAC1D,KAAL,CAAW,CAAX,KAAiBkD,KAAjB,IAA0BA,KAAK,GAAGQ,IAAI,CAAC1D,KAAL,CAAW,CAAX,CAAtC,EAAqD;UACjDK,MAAM,GAAGqD,IAAT;QACH,CAFD,MAEO;UACH,KAAKiC,IAAL;QACH;MACJ,CARwB;;MASzBC,KAAK,CAAClC,IAAD,EAAO;QACR,IAAIA,IAAI,KAAKrD,MAAb,EAAqB;UACjB,KAAKwF,KAAL;QACH;MACJ;;IAbwB,CAA7B;IAgBA,OAAOxF,MAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIQ,cAAc,CAACF,KAAD,EAAQC,MAAR,EAAgB;IAC1B,OAAOC,cAAc,CAAC,IAAD,EAAOF,KAAP,EAAcC,MAAd,EAAsB,KAAtB,CAArB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIkF,oBAAoB,CAACnF,KAAD,EAAQC,MAAR,EAAgB;IAChC,OAAOC,cAAc,CAAC,IAAD,EAAOF,KAAP,EAAcC,MAAd,EAAsB,IAAtB,CAArB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACImF,eAAe,CAAC7C,KAAD,EAAQ;IACnB,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MAC3B,MAAM,IAAI8C,SAAJ,CAAc,kCAAd,CAAN;IACH;;IAED,IAAI9C,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG,KAAKlB,IAAL,CAAUxB,MAAnC,EAA2C;MACvC,MAAM,IAAIyF,UAAJ,CAAgB,uCAAsC/C,KAAM,gCAA+B,KAAKlB,IAAL,CAAUxB,MAAO,IAA5G,CAAN;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,IAAI0C,KAAK,KAAK,KAAKlB,IAAL,CAAUxB,MAAxB,EAAgC;MAC5B,OAAO;QAAE8E,IAAI,EAAE,KAAKzC,KAAL,CAAWrC,MAAnB;QAA2B0F,MAAM,EAAE,KAAKrD,KAAL,CAAW,KAAKA,KAAL,CAAWrC,MAAX,GAAoB,CAA/B,EAAkCA;MAArE,CAAP;IACH;IAED;AACR;AACA;AACA;;;IACQ,MAAM2F,UAAU,GAAGjD,KAAK,IAAI,KAAKJ,gBAAL,CAAsB,KAAKA,gBAAL,CAAsBtC,MAAtB,GAA+B,CAArD,CAAT,GACb,KAAKsC,gBAAL,CAAsBtC,MADT,GAEb,KAAKsC,gBAAL,CAAsBsD,SAAtB,CAAgCC,EAAE,IAAInD,KAAK,GAAGmD,EAA9C,CAFN;IAIA,OAAO;MAAEf,IAAI,EAAEa,UAAR;MAAoBD,MAAM,EAAEhD,KAAK,GAAG,KAAKJ,gBAAL,CAAsBqD,UAAU,GAAG,CAAnC;IAApC,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIG,eAAe,CAACvG,GAAD,EAAM;IACjB,IAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAG,CAACuF,IAAX,KAAoB,QAA/C,IAA2D,OAAOvF,GAAG,CAACmG,MAAX,KAAsB,QAArF,EAA+F;MAC3F,MAAM,IAAIF,SAAJ,CAAc,6EAAd,CAAN;IACH;;IAED,IAAIjG,GAAG,CAACuF,IAAJ,IAAY,CAAhB,EAAmB;MACf,MAAM,IAAIW,UAAJ,CAAgB,kCAAiClG,GAAG,CAACuF,IAAK,8CAA1D,CAAN;IACH;;IAED,IAAIvF,GAAG,CAACuF,IAAJ,GAAW,KAAKxC,gBAAL,CAAsBtC,MAArC,EAA6C;MACzC,MAAM,IAAIyF,UAAJ,CAAgB,kCAAiClG,GAAG,CAACuF,IAAK,wBAAuB,KAAKxC,gBAAL,CAAsBtC,MAAO,kBAA9G,CAAN;IACH;;IAED,MAAM+F,cAAc,GAAG,KAAKzD,gBAAL,CAAsB/C,GAAG,CAACuF,IAAJ,GAAW,CAAjC,CAAvB;IACA,MAAMkB,YAAY,GAAGzG,GAAG,CAACuF,IAAJ,KAAa,KAAKxC,gBAAL,CAAsBtC,MAAnC,GAA4C,KAAKwB,IAAL,CAAUxB,MAAtD,GAA+D,KAAKsC,gBAAL,CAAsB/C,GAAG,CAACuF,IAA1B,CAApF;IACA,MAAMmB,aAAa,GAAGF,cAAc,GAAGxG,GAAG,CAACmG,MAA3C;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;IACQ,IACInG,GAAG,CAACuF,IAAJ,KAAa,KAAKxC,gBAAL,CAAsBtC,MAAnC,IAA6CiG,aAAa,GAAGD,YAA7D,IACAzG,GAAG,CAACuF,IAAJ,GAAW,KAAKxC,gBAAL,CAAsBtC,MAAjC,IAA2CiG,aAAa,IAAID,YAFhE,EAGE;MACE,MAAM,IAAIP,UAAJ,CAAgB,sCAAqClG,GAAG,CAACmG,MAAO,sCAAqCnG,GAAG,CAACuF,IAAK,OAAMkB,YAAY,GAAGD,cAAe,IAAlJ,CAAN;IACH;;IAED,OAAOE,aAAP;EACH;;AAtb+B;;AAybpCC,MAAM,CAACC,OAAP,GAAiB/E,UAAjB"},"metadata":{},"sourceType":"script"}