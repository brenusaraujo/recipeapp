{"ast":null,"code":"/**\n * @fileoverview `CascadingConfigArrayFactory` class.\n *\n * `CascadingConfigArrayFactory` class has a responsibility:\n *\n * 1. Handles cascading of config files.\n *\n * It provides two methods:\n *\n * - `getConfigArrayForFile(filePath)`\n *     Get the corresponded configuration of a given file. This method doesn't\n *     throw even if the given file didn't exist.\n * - `clearCache()`\n *     Clear the internal cache. You have to call this method when\n *     `additionalPluginPool` was updated if `baseConfig` or `cliConfig` depends\n *     on the additional plugins. (`CLIEngine#addPlugin()` method calls this.)\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst ConfigValidator = require(\"./shared/config-validator\");\n\nconst {\n  emitDeprecationWarning\n} = require(\"./shared/deprecation-warnings\");\n\nconst {\n  ConfigArrayFactory\n} = require(\"./config-array-factory\");\n\nconst {\n  ConfigArray,\n  ConfigDependency,\n  IgnorePattern\n} = require(\"./config-array\");\n\nconst debug = require(\"debug\")(\"eslintrc:cascading-config-array-factory\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n// Define types for VSCode IntelliSense.\n\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n\n/** @typedef {ReturnType<ConfigArrayFactory[\"create\"]>} ConfigArray */\n\n/**\n * @typedef {Object} CascadingConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {ConfigData} [baseConfig] The config by `baseConfig` option.\n * @property {ConfigData} [cliConfig] The config by CLI options (`--env`, `--global`, `--ignore-pattern`, `--parser`, `--parser-options`, `--plugin`, and `--rule`). CLI options overwrite the setting in config files.\n * @property {string} [cwd] The base directory to start lookup.\n * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\n * @property {string} [specificConfigPath] The value of `--config` option.\n * @property {boolean} [useEslintrc] if `false` then it doesn't load config files.\n * @property {Function} loadRules The function to use to load rules.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} CascadingConfigArrayFactoryInternalSlots\n * @property {ConfigArray} baseConfigArray The config array of `baseConfig` option.\n * @property {ConfigData} baseConfigData The config data of `baseConfig` option. This is used to reset `baseConfigArray`.\n * @property {ConfigArray} cliConfigArray The config array of CLI options.\n * @property {ConfigData} cliConfigData The config data of CLI options. This is used to reset `cliConfigArray`.\n * @property {ConfigArrayFactory} configArrayFactory The factory for config arrays.\n * @property {Map<string, ConfigArray>} configCache The cache from directory paths to config arrays.\n * @property {string} cwd The base directory to start lookup.\n * @property {WeakMap<ConfigArray, ConfigArray>} finalizeCache The cache from config arrays to finalized config arrays.\n * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.\n * @property {string[]|null} rulePaths The value of `--rulesdir` option. This is used to reset `baseConfigArray`.\n * @property {string|null} specificConfigPath The value of `--config` option. This is used to reset `cliConfigArray`.\n * @property {boolean} useEslintrc if `false` then it doesn't load config files.\n * @property {Function} loadRules The function to use to load rules.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/** @type {WeakMap<CascadingConfigArrayFactory, CascadingConfigArrayFactoryInternalSlots>} */\n\n\nconst internalSlotsMap = new WeakMap();\n/**\n * Create the config array from `baseConfig` and `rulePaths`.\n * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.\n * @returns {ConfigArray} The config array of the base configs.\n */\n\nfunction createBaseConfigArray(_ref) {\n  let {\n    configArrayFactory,\n    baseConfigData,\n    rulePaths,\n    cwd,\n    loadRules\n  } = _ref;\n  const baseConfigArray = configArrayFactory.create(baseConfigData, {\n    name: \"BaseConfig\"\n  });\n  /*\n   * Create the config array element for the default ignore patterns.\n   * This element has `ignorePattern` property that ignores the default\n   * patterns in the current working directory.\n   */\n\n  baseConfigArray.unshift(configArrayFactory.create({\n    ignorePatterns: IgnorePattern.DefaultPatterns\n  }, {\n    name: \"DefaultIgnorePattern\"\n  })[0]);\n  /*\n   * Load rules `--rulesdir` option as a pseudo plugin.\n   * Use a pseudo plugin to define rules of `--rulesdir`, so we can validate\n   * the rule's options with only information in the config array.\n   */\n\n  if (rulePaths && rulePaths.length > 0) {\n    baseConfigArray.push({\n      type: \"config\",\n      name: \"--rulesdir\",\n      filePath: \"\",\n      plugins: {\n        \"\": new ConfigDependency({\n          definition: {\n            rules: rulePaths.reduce((map, rulesPath) => Object.assign(map, loadRules(rulesPath, cwd)), {})\n          },\n          filePath: \"\",\n          id: \"\",\n          importerName: \"--rulesdir\",\n          importerPath: \"\"\n        })\n      }\n    });\n  }\n\n  return baseConfigArray;\n}\n/**\n * Create the config array from CLI options.\n * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.\n * @returns {ConfigArray} The config array of the base configs.\n */\n\n\nfunction createCLIConfigArray(_ref2) {\n  let {\n    cliConfigData,\n    configArrayFactory,\n    cwd,\n    ignorePath,\n    specificConfigPath\n  } = _ref2;\n  const cliConfigArray = configArrayFactory.create(cliConfigData, {\n    name: \"CLIOptions\"\n  });\n  cliConfigArray.unshift(...(ignorePath ? configArrayFactory.loadESLintIgnore(ignorePath) : configArrayFactory.loadDefaultESLintIgnore()));\n\n  if (specificConfigPath) {\n    cliConfigArray.unshift(...configArrayFactory.loadFile(specificConfigPath, {\n      name: \"--config\",\n      basePath: cwd\n    }));\n  }\n\n  return cliConfigArray;\n}\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\n\n\nclass ConfigurationNotFoundError extends Error {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {string} directoryPath The directory path.\n   */\n  constructor(directoryPath) {\n    super(`No ESLint configuration found in ${directoryPath}.`);\n    this.messageTemplate = \"no-config-found\";\n    this.messageData = {\n      directoryPath\n    };\n  }\n\n}\n/**\n * This class provides the functionality that enumerates every file which is\n * matched by given glob patterns and that configuration.\n */\n\n\nclass CascadingConfigArrayFactory {\n  /**\n   * Initialize this enumerator.\n   * @param {CascadingConfigArrayFactoryOptions} options The options.\n   */\n  constructor() {\n    let {\n      additionalPluginPool = new Map(),\n      baseConfig: baseConfigData = null,\n      cliConfig: cliConfigData = null,\n      cwd = process.cwd(),\n      ignorePath,\n      resolvePluginsRelativeTo,\n      rulePaths = [],\n      specificConfigPath = null,\n      useEslintrc = true,\n      builtInRules = new Map(),\n      loadRules,\n      resolver,\n      eslintRecommendedPath,\n      eslintAllPath\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const configArrayFactory = new ConfigArrayFactory({\n      additionalPluginPool,\n      cwd,\n      resolvePluginsRelativeTo,\n      builtInRules,\n      resolver,\n      eslintRecommendedPath,\n      eslintAllPath\n    });\n    internalSlotsMap.set(this, {\n      baseConfigArray: createBaseConfigArray({\n        baseConfigData,\n        configArrayFactory,\n        cwd,\n        rulePaths,\n        loadRules,\n        resolver\n      }),\n      baseConfigData,\n      cliConfigArray: createCLIConfigArray({\n        cliConfigData,\n        configArrayFactory,\n        cwd,\n        ignorePath,\n        specificConfigPath\n      }),\n      cliConfigData,\n      configArrayFactory,\n      configCache: new Map(),\n      cwd,\n      finalizeCache: new WeakMap(),\n      ignorePath,\n      rulePaths,\n      specificConfigPath,\n      useEslintrc,\n      builtInRules,\n      loadRules\n    });\n  }\n  /**\n   * The path to the current working directory.\n   * This is used by tests.\n   * @type {string}\n   */\n\n\n  get cwd() {\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    return cwd;\n  }\n  /**\n   * Get the config array of a given file.\n   * If `filePath` was not given, it returns the config which contains only\n   * `baseConfigData` and `cliConfigData`.\n   * @param {string} [filePath] The file path to a file.\n   * @param {Object} [options] The options.\n   * @param {boolean} [options.ignoreNotFoundError] If `true` then it doesn't throw `ConfigurationNotFoundError`.\n   * @returns {ConfigArray} The config array of the file.\n   */\n\n\n  getConfigArrayForFile(filePath) {\n    let {\n      ignoreNotFoundError = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      baseConfigArray,\n      cliConfigArray,\n      cwd\n    } = internalSlotsMap.get(this);\n\n    if (!filePath) {\n      return new ConfigArray(...baseConfigArray, ...cliConfigArray);\n    }\n\n    const directoryPath = path.dirname(path.resolve(cwd, filePath));\n    debug(`Load config files for ${directoryPath}.`);\n    return this._finalizeConfigArray(this._loadConfigInAncestors(directoryPath), directoryPath, ignoreNotFoundError);\n  }\n  /**\n   * Set the config data to override all configs.\n   * Require to call `clearCache()` method after this method is called.\n   * @param {ConfigData} configData The config data to override all configs.\n   * @returns {void}\n   */\n\n\n  setOverrideConfig(configData) {\n    const slots = internalSlotsMap.get(this);\n    slots.cliConfigData = configData;\n  }\n  /**\n   * Clear config cache.\n   * @returns {void}\n   */\n\n\n  clearCache() {\n    const slots = internalSlotsMap.get(this);\n    slots.baseConfigArray = createBaseConfigArray(slots);\n    slots.cliConfigArray = createCLIConfigArray(slots);\n    slots.configCache.clear();\n  }\n  /**\n   * Load and normalize config files from the ancestor directories.\n   * @param {string} directoryPath The path to a leaf directory.\n   * @param {boolean} configsExistInSubdirs `true` if configurations exist in subdirectories.\n   * @returns {ConfigArray} The loaded config.\n   * @private\n   */\n\n\n  _loadConfigInAncestors(directoryPath) {\n    let configsExistInSubdirs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      baseConfigArray,\n      configArrayFactory,\n      configCache,\n      cwd,\n      useEslintrc\n    } = internalSlotsMap.get(this);\n\n    if (!useEslintrc) {\n      return baseConfigArray;\n    }\n\n    let configArray = configCache.get(directoryPath); // Hit cache.\n\n    if (configArray) {\n      debug(`Cache hit: ${directoryPath}.`);\n      return configArray;\n    }\n\n    debug(`No cache found: ${directoryPath}.`);\n    const homePath = os.homedir(); // Consider this is root.\n\n    if (directoryPath === homePath && cwd !== homePath) {\n      debug(\"Stop traversing because of considered root.\");\n\n      if (configsExistInSubdirs) {\n        const filePath = ConfigArrayFactory.getPathToConfigFileInDirectory(directoryPath);\n\n        if (filePath) {\n          emitDeprecationWarning(filePath, \"ESLINT_PERSONAL_CONFIG_SUPPRESS\");\n        }\n      }\n\n      return this._cacheConfig(directoryPath, baseConfigArray);\n    } // Load the config on this directory.\n\n\n    try {\n      configArray = configArrayFactory.loadInDirectory(directoryPath);\n    } catch (error) {\n      /* istanbul ignore next */\n      if (error.code === \"EACCES\") {\n        debug(\"Stop traversing because of 'EACCES' error.\");\n        return this._cacheConfig(directoryPath, baseConfigArray);\n      }\n\n      throw error;\n    }\n\n    if (configArray.length > 0 && configArray.isRoot()) {\n      debug(\"Stop traversing because of 'root:true'.\");\n      configArray.unshift(...baseConfigArray);\n      return this._cacheConfig(directoryPath, configArray);\n    } // Load from the ancestors and merge it.\n\n\n    const parentPath = path.dirname(directoryPath);\n    const parentConfigArray = parentPath && parentPath !== directoryPath ? this._loadConfigInAncestors(parentPath, configsExistInSubdirs || configArray.length > 0) : baseConfigArray;\n\n    if (configArray.length > 0) {\n      configArray.unshift(...parentConfigArray);\n    } else {\n      configArray = parentConfigArray;\n    } // Cache and return.\n\n\n    return this._cacheConfig(directoryPath, configArray);\n  }\n  /**\n   * Freeze and cache a given config.\n   * @param {string} directoryPath The path to a directory as a cache key.\n   * @param {ConfigArray} configArray The config array as a cache value.\n   * @returns {ConfigArray} The `configArray` (frozen).\n   */\n\n\n  _cacheConfig(directoryPath, configArray) {\n    const {\n      configCache\n    } = internalSlotsMap.get(this);\n    Object.freeze(configArray);\n    configCache.set(directoryPath, configArray);\n    return configArray;\n  }\n  /**\n   * Finalize a given config array.\n   * Concatenate `--config` and other CLI options.\n   * @param {ConfigArray} configArray The parent config array.\n   * @param {string} directoryPath The path to the leaf directory to find config files.\n   * @param {boolean} ignoreNotFoundError If `true` then it doesn't throw `ConfigurationNotFoundError`.\n   * @returns {ConfigArray} The loaded config.\n   * @private\n   */\n\n\n  _finalizeConfigArray(configArray, directoryPath, ignoreNotFoundError) {\n    const {\n      cliConfigArray,\n      configArrayFactory,\n      finalizeCache,\n      useEslintrc,\n      builtInRules\n    } = internalSlotsMap.get(this);\n    let finalConfigArray = finalizeCache.get(configArray);\n\n    if (!finalConfigArray) {\n      finalConfigArray = configArray; // Load the personal config if there are no regular config files.\n\n      if (useEslintrc && configArray.every(c => !c.filePath) && cliConfigArray.every(c => !c.filePath) // `--config` option can be a file.\n      ) {\n        const homePath = os.homedir();\n        debug(\"Loading the config file of the home directory:\", homePath);\n        const personalConfigArray = configArrayFactory.loadInDirectory(homePath, {\n          name: \"PersonalConfig\"\n        });\n\n        if (personalConfigArray.length > 0 && !directoryPath.startsWith(homePath)) {\n          const lastElement = personalConfigArray[personalConfigArray.length - 1];\n          emitDeprecationWarning(lastElement.filePath, \"ESLINT_PERSONAL_CONFIG_LOAD\");\n        }\n\n        finalConfigArray = finalConfigArray.concat(personalConfigArray);\n      } // Apply CLI options.\n\n\n      if (cliConfigArray.length > 0) {\n        finalConfigArray = finalConfigArray.concat(cliConfigArray);\n      } // Validate rule settings and environments.\n\n\n      const validator = new ConfigValidator({\n        builtInRules\n      });\n      validator.validateConfigArray(finalConfigArray); // Cache it.\n\n      Object.freeze(finalConfigArray);\n      finalizeCache.set(configArray, finalConfigArray);\n      debug(\"Configuration was determined: %o on %s\", finalConfigArray, directoryPath);\n    } // At least one element (the default ignore patterns) exists.\n\n\n    if (!ignoreNotFoundError && useEslintrc && finalConfigArray.length <= 1) {\n      throw new ConfigurationNotFoundError(directoryPath);\n    }\n\n    return finalConfigArray;\n  }\n\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  CascadingConfigArrayFactory\n};","map":{"version":3,"names":["os","require","path","ConfigValidator","emitDeprecationWarning","ConfigArrayFactory","ConfigArray","ConfigDependency","IgnorePattern","debug","internalSlotsMap","WeakMap","createBaseConfigArray","configArrayFactory","baseConfigData","rulePaths","cwd","loadRules","baseConfigArray","create","name","unshift","ignorePatterns","DefaultPatterns","length","push","type","filePath","plugins","definition","rules","reduce","map","rulesPath","Object","assign","id","importerName","importerPath","createCLIConfigArray","cliConfigData","ignorePath","specificConfigPath","cliConfigArray","loadESLintIgnore","loadDefaultESLintIgnore","loadFile","basePath","ConfigurationNotFoundError","Error","constructor","directoryPath","messageTemplate","messageData","CascadingConfigArrayFactory","additionalPluginPool","Map","baseConfig","cliConfig","process","resolvePluginsRelativeTo","useEslintrc","builtInRules","resolver","eslintRecommendedPath","eslintAllPath","set","configCache","finalizeCache","get","getConfigArrayForFile","ignoreNotFoundError","dirname","resolve","_finalizeConfigArray","_loadConfigInAncestors","setOverrideConfig","configData","slots","clearCache","clear","configsExistInSubdirs","configArray","homePath","homedir","getPathToConfigFileInDirectory","_cacheConfig","loadInDirectory","error","code","isRoot","parentPath","parentConfigArray","freeze","finalConfigArray","every","c","personalConfigArray","startsWith","lastElement","concat","validator","validateConfigArray","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/@eslint/eslintrc/lib/cascading-config-array-factory.js"],"sourcesContent":["/**\n * @fileoverview `CascadingConfigArrayFactory` class.\n *\n * `CascadingConfigArrayFactory` class has a responsibility:\n *\n * 1. Handles cascading of config files.\n *\n * It provides two methods:\n *\n * - `getConfigArrayForFile(filePath)`\n *     Get the corresponded configuration of a given file. This method doesn't\n *     throw even if the given file didn't exist.\n * - `clearCache()`\n *     Clear the internal cache. You have to call this method when\n *     `additionalPluginPool` was updated if `baseConfig` or `cliConfig` depends\n *     on the additional plugins. (`CLIEngine#addPlugin()` method calls this.)\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst ConfigValidator = require(\"./shared/config-validator\");\nconst { emitDeprecationWarning } = require(\"./shared/deprecation-warnings\");\nconst { ConfigArrayFactory } = require(\"./config-array-factory\");\nconst { ConfigArray, ConfigDependency, IgnorePattern } = require(\"./config-array\");\nconst debug = require(\"debug\")(\"eslintrc:cascading-config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {ReturnType<ConfigArrayFactory[\"create\"]>} ConfigArray */\n\n/**\n * @typedef {Object} CascadingConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {ConfigData} [baseConfig] The config by `baseConfig` option.\n * @property {ConfigData} [cliConfig] The config by CLI options (`--env`, `--global`, `--ignore-pattern`, `--parser`, `--parser-options`, `--plugin`, and `--rule`). CLI options overwrite the setting in config files.\n * @property {string} [cwd] The base directory to start lookup.\n * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\n * @property {string} [specificConfigPath] The value of `--config` option.\n * @property {boolean} [useEslintrc] if `false` then it doesn't load config files.\n * @property {Function} loadRules The function to use to load rules.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} CascadingConfigArrayFactoryInternalSlots\n * @property {ConfigArray} baseConfigArray The config array of `baseConfig` option.\n * @property {ConfigData} baseConfigData The config data of `baseConfig` option. This is used to reset `baseConfigArray`.\n * @property {ConfigArray} cliConfigArray The config array of CLI options.\n * @property {ConfigData} cliConfigData The config data of CLI options. This is used to reset `cliConfigArray`.\n * @property {ConfigArrayFactory} configArrayFactory The factory for config arrays.\n * @property {Map<string, ConfigArray>} configCache The cache from directory paths to config arrays.\n * @property {string} cwd The base directory to start lookup.\n * @property {WeakMap<ConfigArray, ConfigArray>} finalizeCache The cache from config arrays to finalized config arrays.\n * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.\n * @property {string[]|null} rulePaths The value of `--rulesdir` option. This is used to reset `baseConfigArray`.\n * @property {string|null} specificConfigPath The value of `--config` option. This is used to reset `cliConfigArray`.\n * @property {boolean} useEslintrc if `false` then it doesn't load config files.\n * @property {Function} loadRules The function to use to load rules.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/** @type {WeakMap<CascadingConfigArrayFactory, CascadingConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Create the config array from `baseConfig` and `rulePaths`.\n * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.\n * @returns {ConfigArray} The config array of the base configs.\n */\nfunction createBaseConfigArray({\n    configArrayFactory,\n    baseConfigData,\n    rulePaths,\n    cwd,\n    loadRules\n}) {\n    const baseConfigArray = configArrayFactory.create(\n        baseConfigData,\n        { name: \"BaseConfig\" }\n    );\n\n    /*\n     * Create the config array element for the default ignore patterns.\n     * This element has `ignorePattern` property that ignores the default\n     * patterns in the current working directory.\n     */\n    baseConfigArray.unshift(configArrayFactory.create(\n        { ignorePatterns: IgnorePattern.DefaultPatterns },\n        { name: \"DefaultIgnorePattern\" }\n    )[0]);\n\n    /*\n     * Load rules `--rulesdir` option as a pseudo plugin.\n     * Use a pseudo plugin to define rules of `--rulesdir`, so we can validate\n     * the rule's options with only information in the config array.\n     */\n    if (rulePaths && rulePaths.length > 0) {\n        baseConfigArray.push({\n            type: \"config\",\n            name: \"--rulesdir\",\n            filePath: \"\",\n            plugins: {\n                \"\": new ConfigDependency({\n                    definition: {\n                        rules: rulePaths.reduce(\n                            (map, rulesPath) => Object.assign(\n                                map,\n                                loadRules(rulesPath, cwd)\n                            ),\n                            {}\n                        )\n                    },\n                    filePath: \"\",\n                    id: \"\",\n                    importerName: \"--rulesdir\",\n                    importerPath: \"\"\n                })\n            }\n        });\n    }\n\n    return baseConfigArray;\n}\n\n/**\n * Create the config array from CLI options.\n * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.\n * @returns {ConfigArray} The config array of the base configs.\n */\nfunction createCLIConfigArray({\n    cliConfigData,\n    configArrayFactory,\n    cwd,\n    ignorePath,\n    specificConfigPath\n}) {\n    const cliConfigArray = configArrayFactory.create(\n        cliConfigData,\n        { name: \"CLIOptions\" }\n    );\n\n    cliConfigArray.unshift(\n        ...(ignorePath\n            ? configArrayFactory.loadESLintIgnore(ignorePath)\n            : configArrayFactory.loadDefaultESLintIgnore())\n    );\n\n    if (specificConfigPath) {\n        cliConfigArray.unshift(\n            ...configArrayFactory.loadFile(\n                specificConfigPath,\n                { name: \"--config\", basePath: cwd }\n            )\n        );\n    }\n\n    return cliConfigArray;\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass ConfigurationNotFoundError extends Error {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} directoryPath The directory path.\n     */\n    constructor(directoryPath) {\n        super(`No ESLint configuration found in ${directoryPath}.`);\n        this.messageTemplate = \"no-config-found\";\n        this.messageData = { directoryPath };\n    }\n}\n\n/**\n * This class provides the functionality that enumerates every file which is\n * matched by given glob patterns and that configuration.\n */\nclass CascadingConfigArrayFactory {\n\n    /**\n     * Initialize this enumerator.\n     * @param {CascadingConfigArrayFactoryOptions} options The options.\n     */\n    constructor({\n        additionalPluginPool = new Map(),\n        baseConfig: baseConfigData = null,\n        cliConfig: cliConfigData = null,\n        cwd = process.cwd(),\n        ignorePath,\n        resolvePluginsRelativeTo,\n        rulePaths = [],\n        specificConfigPath = null,\n        useEslintrc = true,\n        builtInRules = new Map(),\n        loadRules,\n        resolver,\n        eslintRecommendedPath,\n        eslintAllPath\n    } = {}) {\n        const configArrayFactory = new ConfigArrayFactory({\n            additionalPluginPool,\n            cwd,\n            resolvePluginsRelativeTo,\n            builtInRules,\n            resolver,\n            eslintRecommendedPath,\n            eslintAllPath\n        });\n\n        internalSlotsMap.set(this, {\n            baseConfigArray: createBaseConfigArray({\n                baseConfigData,\n                configArrayFactory,\n                cwd,\n                rulePaths,\n                loadRules,\n                resolver\n            }),\n            baseConfigData,\n            cliConfigArray: createCLIConfigArray({\n                cliConfigData,\n                configArrayFactory,\n                cwd,\n                ignorePath,\n                specificConfigPath\n            }),\n            cliConfigData,\n            configArrayFactory,\n            configCache: new Map(),\n            cwd,\n            finalizeCache: new WeakMap(),\n            ignorePath,\n            rulePaths,\n            specificConfigPath,\n            useEslintrc,\n            builtInRules,\n            loadRules\n        });\n    }\n\n    /**\n     * The path to the current working directory.\n     * This is used by tests.\n     * @type {string}\n     */\n    get cwd() {\n        const { cwd } = internalSlotsMap.get(this);\n\n        return cwd;\n    }\n\n    /**\n     * Get the config array of a given file.\n     * If `filePath` was not given, it returns the config which contains only\n     * `baseConfigData` and `cliConfigData`.\n     * @param {string} [filePath] The file path to a file.\n     * @param {Object} [options] The options.\n     * @param {boolean} [options.ignoreNotFoundError] If `true` then it doesn't throw `ConfigurationNotFoundError`.\n     * @returns {ConfigArray} The config array of the file.\n     */\n    getConfigArrayForFile(filePath, { ignoreNotFoundError = false } = {}) {\n        const {\n            baseConfigArray,\n            cliConfigArray,\n            cwd\n        } = internalSlotsMap.get(this);\n\n        if (!filePath) {\n            return new ConfigArray(...baseConfigArray, ...cliConfigArray);\n        }\n\n        const directoryPath = path.dirname(path.resolve(cwd, filePath));\n\n        debug(`Load config files for ${directoryPath}.`);\n\n        return this._finalizeConfigArray(\n            this._loadConfigInAncestors(directoryPath),\n            directoryPath,\n            ignoreNotFoundError\n        );\n    }\n\n    /**\n     * Set the config data to override all configs.\n     * Require to call `clearCache()` method after this method is called.\n     * @param {ConfigData} configData The config data to override all configs.\n     * @returns {void}\n     */\n    setOverrideConfig(configData) {\n        const slots = internalSlotsMap.get(this);\n\n        slots.cliConfigData = configData;\n    }\n\n    /**\n     * Clear config cache.\n     * @returns {void}\n     */\n    clearCache() {\n        const slots = internalSlotsMap.get(this);\n\n        slots.baseConfigArray = createBaseConfigArray(slots);\n        slots.cliConfigArray = createCLIConfigArray(slots);\n        slots.configCache.clear();\n    }\n\n    /**\n     * Load and normalize config files from the ancestor directories.\n     * @param {string} directoryPath The path to a leaf directory.\n     * @param {boolean} configsExistInSubdirs `true` if configurations exist in subdirectories.\n     * @returns {ConfigArray} The loaded config.\n     * @private\n     */\n    _loadConfigInAncestors(directoryPath, configsExistInSubdirs = false) {\n        const {\n            baseConfigArray,\n            configArrayFactory,\n            configCache,\n            cwd,\n            useEslintrc\n        } = internalSlotsMap.get(this);\n\n        if (!useEslintrc) {\n            return baseConfigArray;\n        }\n\n        let configArray = configCache.get(directoryPath);\n\n        // Hit cache.\n        if (configArray) {\n            debug(`Cache hit: ${directoryPath}.`);\n            return configArray;\n        }\n        debug(`No cache found: ${directoryPath}.`);\n\n        const homePath = os.homedir();\n\n        // Consider this is root.\n        if (directoryPath === homePath && cwd !== homePath) {\n            debug(\"Stop traversing because of considered root.\");\n            if (configsExistInSubdirs) {\n                const filePath = ConfigArrayFactory.getPathToConfigFileInDirectory(directoryPath);\n\n                if (filePath) {\n                    emitDeprecationWarning(\n                        filePath,\n                        \"ESLINT_PERSONAL_CONFIG_SUPPRESS\"\n                    );\n                }\n            }\n            return this._cacheConfig(directoryPath, baseConfigArray);\n        }\n\n        // Load the config on this directory.\n        try {\n            configArray = configArrayFactory.loadInDirectory(directoryPath);\n        } catch (error) {\n            /* istanbul ignore next */\n            if (error.code === \"EACCES\") {\n                debug(\"Stop traversing because of 'EACCES' error.\");\n                return this._cacheConfig(directoryPath, baseConfigArray);\n            }\n            throw error;\n        }\n\n        if (configArray.length > 0 && configArray.isRoot()) {\n            debug(\"Stop traversing because of 'root:true'.\");\n            configArray.unshift(...baseConfigArray);\n            return this._cacheConfig(directoryPath, configArray);\n        }\n\n        // Load from the ancestors and merge it.\n        const parentPath = path.dirname(directoryPath);\n        const parentConfigArray = parentPath && parentPath !== directoryPath\n            ? this._loadConfigInAncestors(\n                parentPath,\n                configsExistInSubdirs || configArray.length > 0\n            )\n            : baseConfigArray;\n\n        if (configArray.length > 0) {\n            configArray.unshift(...parentConfigArray);\n        } else {\n            configArray = parentConfigArray;\n        }\n\n        // Cache and return.\n        return this._cacheConfig(directoryPath, configArray);\n    }\n\n    /**\n     * Freeze and cache a given config.\n     * @param {string} directoryPath The path to a directory as a cache key.\n     * @param {ConfigArray} configArray The config array as a cache value.\n     * @returns {ConfigArray} The `configArray` (frozen).\n     */\n    _cacheConfig(directoryPath, configArray) {\n        const { configCache } = internalSlotsMap.get(this);\n\n        Object.freeze(configArray);\n        configCache.set(directoryPath, configArray);\n\n        return configArray;\n    }\n\n    /**\n     * Finalize a given config array.\n     * Concatenate `--config` and other CLI options.\n     * @param {ConfigArray} configArray The parent config array.\n     * @param {string} directoryPath The path to the leaf directory to find config files.\n     * @param {boolean} ignoreNotFoundError If `true` then it doesn't throw `ConfigurationNotFoundError`.\n     * @returns {ConfigArray} The loaded config.\n     * @private\n     */\n    _finalizeConfigArray(configArray, directoryPath, ignoreNotFoundError) {\n        const {\n            cliConfigArray,\n            configArrayFactory,\n            finalizeCache,\n            useEslintrc,\n            builtInRules\n        } = internalSlotsMap.get(this);\n\n        let finalConfigArray = finalizeCache.get(configArray);\n\n        if (!finalConfigArray) {\n            finalConfigArray = configArray;\n\n            // Load the personal config if there are no regular config files.\n            if (\n                useEslintrc &&\n                configArray.every(c => !c.filePath) &&\n                cliConfigArray.every(c => !c.filePath) // `--config` option can be a file.\n            ) {\n                const homePath = os.homedir();\n\n                debug(\"Loading the config file of the home directory:\", homePath);\n\n                const personalConfigArray = configArrayFactory.loadInDirectory(\n                    homePath,\n                    { name: \"PersonalConfig\" }\n                );\n\n                if (\n                    personalConfigArray.length > 0 &&\n                    !directoryPath.startsWith(homePath)\n                ) {\n                    const lastElement =\n                        personalConfigArray[personalConfigArray.length - 1];\n\n                    emitDeprecationWarning(\n                        lastElement.filePath,\n                        \"ESLINT_PERSONAL_CONFIG_LOAD\"\n                    );\n                }\n\n                finalConfigArray = finalConfigArray.concat(personalConfigArray);\n            }\n\n            // Apply CLI options.\n            if (cliConfigArray.length > 0) {\n                finalConfigArray = finalConfigArray.concat(cliConfigArray);\n            }\n\n            // Validate rule settings and environments.\n            const validator = new ConfigValidator({\n                builtInRules\n            });\n\n            validator.validateConfigArray(finalConfigArray);\n\n            // Cache it.\n            Object.freeze(finalConfigArray);\n            finalizeCache.set(configArray, finalConfigArray);\n\n            debug(\n                \"Configuration was determined: %o on %s\",\n                finalConfigArray,\n                directoryPath\n            );\n        }\n\n        // At least one element (the default ignore patterns) exists.\n        if (!ignoreNotFoundError && useEslintrc && finalConfigArray.length <= 1) {\n            throw new ConfigurationNotFoundError(directoryPath);\n        }\n\n        return finalConfigArray;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = { CascadingConfigArrayFactory };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}