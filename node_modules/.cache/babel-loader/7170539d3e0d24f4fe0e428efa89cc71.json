{"ast":null,"code":"/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\n\nconst validator = new RegExpValidator();\nconst validFlags = /[gimuys]/gu;\nconst undefined1 = void 0; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowConstructorFlags: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      regexMessage: \"{{message}}.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0];\n    let allowedFlags = null;\n\n    if (options && options.allowConstructorFlags) {\n      const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n      if (temp) {\n        allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n      }\n    }\n    /**\n     * Check if node is a string\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if its a string\n     * @private\n     */\n\n\n    function isString(node) {\n      return node && node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n    /**\n     * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\n     * Examples:\n     *     new RegExp(\".\")         // => \"\"\n     *     new RegExp(\".\", \"gu\")   // => \"gu\"\n     *     new RegExp(\".\", flags)  // => null\n     * @param {ASTNode} node `CallExpression` or `NewExpression` node\n     * @returns {string|null} flags if they can be determined, `null` otherwise\n     * @private\n     */\n\n\n    function getFlags(node) {\n      if (node.arguments.length < 2) {\n        return \"\";\n      }\n\n      if (isString(node.arguments[1])) {\n        return node.arguments[1].value;\n      }\n\n      return null;\n    }\n    /**\n     * Check syntax error in a given pattern.\n     * @param {string} pattern The RegExp pattern to validate.\n     * @param {boolean} uFlag The Unicode flag.\n     * @returns {string|null} The syntax error.\n     */\n\n\n    function validateRegExpPattern(pattern, uFlag) {\n      try {\n        validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n        return null;\n      } catch (err) {\n        return err.message;\n      }\n    }\n    /**\n     * Check syntax error in a given flags.\n     * @param {string} flags The RegExp flags to validate.\n     * @returns {string|null} The syntax error.\n     */\n\n\n    function validateRegExpFlags(flags) {\n      try {\n        validator.validateFlags(flags);\n        return null;\n      } catch {\n        return `Invalid flags supplied to RegExp constructor '${flags}'`;\n      }\n    }\n\n    return {\n      \"CallExpression, NewExpression\"(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n          return;\n        }\n\n        const pattern = node.arguments[0].value;\n        let flags = getFlags(node);\n\n        if (flags && allowedFlags) {\n          flags = flags.replace(allowedFlags, \"\");\n        }\n\n        const message = flags && validateRegExpFlags(flags) || ( // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\n        flags === null ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false) : validateRegExpPattern(pattern, flags.includes(\"u\")));\n\n        if (message) {\n          context.report({\n            node,\n            messageId: \"regexMessage\",\n            data: {\n              message\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["RegExpValidator","require","validator","validFlags","undefined1","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowConstructorFlags","items","additionalProperties","messages","regexMessage","create","context","options","allowedFlags","temp","join","replace","RegExp","isString","node","value","getFlags","arguments","length","validateRegExpPattern","pattern","uFlag","validatePattern","err","message","validateRegExpFlags","flags","validateFlags","callee","name","includes","report","messageId","data"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-invalid-regexp.js"],"sourcesContent":["/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\nconst validator = new RegExpValidator();\nconst validFlags = /[gimuys]/gu;\nconst undefined1 = void 0;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowConstructorFlags: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            regexMessage: \"{{message}}.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let allowedFlags = null;\n\n        if (options && options.allowConstructorFlags) {\n            const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n            if (temp) {\n                allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n            }\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\n         * Examples:\n         *     new RegExp(\".\")         // => \"\"\n         *     new RegExp(\".\", \"gu\")   // => \"gu\"\n         *     new RegExp(\".\", flags)  // => null\n         * @param {ASTNode} node `CallExpression` or `NewExpression` node\n         * @returns {string|null} flags if they can be determined, `null` otherwise\n         * @private\n         */\n        function getFlags(node) {\n            if (node.arguments.length < 2) {\n                return \"\";\n            }\n\n            if (isString(node.arguments[1])) {\n                return node.arguments[1].value;\n            }\n\n            return null;\n        }\n\n        /**\n         * Check syntax error in a given pattern.\n         * @param {string} pattern The RegExp pattern to validate.\n         * @param {boolean} uFlag The Unicode flag.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpPattern(pattern, uFlag) {\n            try {\n                validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n                return null;\n            } catch (err) {\n                return err.message;\n            }\n        }\n\n        /**\n         * Check syntax error in a given flags.\n         * @param {string} flags The RegExp flags to validate.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpFlags(flags) {\n            try {\n                validator.validateFlags(flags);\n                return null;\n            } catch {\n                return `Invalid flags supplied to RegExp constructor '${flags}'`;\n            }\n        }\n\n        return {\n            \"CallExpression, NewExpression\"(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n                    return;\n                }\n                const pattern = node.arguments[0].value;\n                let flags = getFlags(node);\n\n                if (flags && allowedFlags) {\n                    flags = flags.replace(allowedFlags, \"\");\n                }\n\n                const message =\n                    (\n                        flags && validateRegExpFlags(flags)\n                    ) ||\n                    (\n\n                        // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\n                        flags === null\n                            ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false)\n                            : validateRegExpPattern(pattern, flags.includes(\"u\"))\n                    );\n\n                if (message) {\n                    context.report({\n                        node,\n                        messageId: \"regexMessage\",\n                        data: { message }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}