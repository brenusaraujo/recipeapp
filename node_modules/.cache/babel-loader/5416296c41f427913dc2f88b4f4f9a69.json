{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\n\n\nfunction isConcatenation(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\n\n\nfunction getTopConcatBinaryExpression(node) {\n  let currentNode = node;\n\n  while (isConcatenation(currentNode.parent)) {\n    currentNode = currentNode.parent;\n  }\n\n  return currentNode;\n}\n/**\n * Checks whether or not a node contains a string literal with an octal or non-octal decimal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if at least one string literal within the node contains\n * an octal or non-octal decimal escape sequence\n */\n\n\nfunction hasOctalOrNonOctalDecimalEscapeSequence(node) {\n  if (isConcatenation(node)) {\n    return hasOctalOrNonOctalDecimalEscapeSequence(node.left) || hasOctalOrNonOctalDecimalEscapeSequence(node.right);\n  } // No need to check TemplateLiterals – would throw parsing error\n\n\n  if (node.type === \"Literal\" && typeof node.value === \"string\") {\n    return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);\n  }\n\n  return false;\n}\n/**\n * Checks whether or not a given binary expression has string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has string literals.\n */\n\n\nfunction hasStringLiteral(node) {\n  if (isConcatenation(node)) {\n    // `left` is deeper than `right` normally.\n    return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n  }\n\n  return astUtils.isStringLiteral(node);\n}\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\n\n\nfunction hasNonStringLiteral(node) {\n  if (isConcatenation(node)) {\n    // `left` is deeper than `right` normally.\n    return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n  }\n\n  return !astUtils.isStringLiteral(node);\n}\n/**\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will start with a template curly.\n */\n\n\nfunction startsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.left);\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n  }\n\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n/**\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will end with a template curly.\n */\n\n\nfunction endsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.right);\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n  }\n\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require template literals instead of string concatenation\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-template\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpectedStringConcatenation: \"Unexpected string concatenation.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let done = Object.create(null);\n    /**\n     * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n     * @param {ASTNode} node1 The first node\n     * @param {ASTNode} node2 The second node\n     * @returns {string} The text between the nodes, excluding other tokens\n     */\n\n    function getTextBetween(node1, node2) {\n      const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n      const sourceText = sourceCode.getText();\n      return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n    }\n    /**\n     * Returns a template literal form of the given node.\n     * @param {ASTNode} currentNode A node that should be converted to a template literal\n     * @param {string} textBeforeNode Text that should appear before the node\n     * @param {string} textAfterNode Text that should appear after the node\n     * @returns {string} A string form of this node, represented as a template literal\n     */\n\n\n    function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n      if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n        /*\n         * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n         * as a template placeholder. However, if the code already contains a backslash before the ${ or `\n         * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n         * an actual backslash character to appear before the dollar sign).\n         */\n        return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n          if (matched.lastIndexOf(\"\\\\\") % 2) {\n            return `\\\\${matched}`;\n          }\n\n          return matched; // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n        }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n      }\n\n      if (currentNode.type === \"TemplateLiteral\") {\n        return sourceCode.getText(currentNode);\n      }\n\n      if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n        const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n        const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n        const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n        const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n        const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n        if (leftEndsWithCurly) {\n          // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n          // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n          return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n        }\n\n        if (rightStartsWithCurly) {\n          // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n          // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n          return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n        }\n        /*\n         * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n         * the text between them.\n         */\n\n\n        return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n      }\n\n      return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n    }\n    /**\n     * Returns a fixer object that converts a non-string binary expression to a template literal\n     * @param {SourceCodeFixer} fixer The fixer object\n     * @param {ASTNode} node A node that should be converted to a template literal\n     * @returns {Object} A fix for this binary expression\n     */\n\n\n    function fixNonStringBinaryExpression(fixer, node) {\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n      if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {\n        return null;\n      }\n\n      return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n    }\n    /**\n     * Reports if a given node is string concatenation with non string literals.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n\n\n    function checkForStringConcat(node) {\n      if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n        return;\n      }\n\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent); // Checks whether or not this node had been checked already.\n\n      if (done[topBinaryExpr.range[0]]) {\n        return;\n      }\n\n      done[topBinaryExpr.range[0]] = true;\n\n      if (hasNonStringLiteral(topBinaryExpr)) {\n        context.report({\n          node: topBinaryExpr,\n          messageId: \"unexpectedStringConcatenation\",\n          fix: fixer => fixNonStringBinaryExpression(fixer, node)\n        });\n      }\n    }\n\n    return {\n      Program() {\n        done = Object.create(null);\n      },\n\n      Literal: checkForStringConcat,\n      TemplateLiteral: checkForStringConcat\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isConcatenation","node","type","operator","getTopConcatBinaryExpression","currentNode","parent","hasOctalOrNonOctalDecimalEscapeSequence","left","right","value","raw","hasStringLiteral","isStringLiteral","hasNonStringLiteral","startsWithTemplateCurly","expressions","length","quasis","range","endsWithTemplateCurly","module","exports","meta","docs","description","category","recommended","url","schema","fixable","messages","unexpectedStringConcatenation","create","context","sourceCode","getSourceCode","done","Object","getTextBetween","node1","node2","allTokens","concat","getTokensBetween","sourceText","getText","slice","reduce","accumulator","token","index","getTemplateLiteral","textBeforeNode","textAfterNode","replace","matched","lastIndexOf","RegExp","plusSign","getFirstTokenBetween","textBeforePlus","textAfterPlus","leftEndsWithCurly","rightStartsWithCurly","fixNonStringBinaryExpression","fixer","topBinaryExpr","replaceText","checkForStringConcat","report","messageId","fix","Program","Literal","TemplateLiteral"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/prefer-template.js"],"sourcesContent":["/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n    let currentNode = node;\n\n    while (isConcatenation(currentNode.parent)) {\n        currentNode = currentNode.parent;\n    }\n    return currentNode;\n}\n\n/**\n * Checks whether or not a node contains a string literal with an octal or non-octal decimal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if at least one string literal within the node contains\n * an octal or non-octal decimal escape sequence\n */\nfunction hasOctalOrNonOctalDecimalEscapeSequence(node) {\n    if (isConcatenation(node)) {\n        return (\n            hasOctalOrNonOctalDecimalEscapeSequence(node.left) ||\n            hasOctalOrNonOctalDecimalEscapeSequence(node.right)\n        );\n    }\n\n    // No need to check TemplateLiterals – would throw parsing error\n    if (node.type === \"Literal\" && typeof node.value === \"string\") {\n        return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given binary expression has string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has string literals.\n */\nfunction hasStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n    }\n    return astUtils.isStringLiteral(node);\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n    }\n    return !astUtils.isStringLiteral(node);\n}\n\n/**\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will start with a template curly.\n */\nfunction startsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.left);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n/**\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will end with a template curly.\n */\nfunction endsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.right);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require template literals instead of string concatenation\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-template\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedStringConcatenation: \"Unexpected string concatenation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let done = Object.create(null);\n\n        /**\n         * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n         * @param {ASTNode} node1 The first node\n         * @param {ASTNode} node2 The second node\n         * @returns {string} The text between the nodes, excluding other tokens\n         */\n        function getTextBetween(node1, node2) {\n            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n            const sourceText = sourceCode.getText();\n\n            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n        }\n\n        /**\n         * Returns a template literal form of the given node.\n         * @param {ASTNode} currentNode A node that should be converted to a template literal\n         * @param {string} textBeforeNode Text that should appear before the node\n         * @param {string} textAfterNode Text that should appear after the node\n         * @returns {string} A string form of this node, represented as a template literal\n         */\n        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n            if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n\n                /*\n                 * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n                 * as a template placeholder. However, if the code already contains a backslash before the ${ or `\n                 * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n                 * an actual backslash character to appear before the dollar sign).\n                 */\n                return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n                    if (matched.lastIndexOf(\"\\\\\") % 2) {\n                        return `\\\\${matched}`;\n                    }\n                    return matched;\n\n                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n                }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n            }\n\n            if (currentNode.type === \"TemplateLiteral\") {\n                return sourceCode.getText(currentNode);\n            }\n\n            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n                const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n                const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n                if (leftEndsWithCurly) {\n\n                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n                }\n                if (rightStartsWithCurly) {\n\n                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n                }\n\n                /*\n                 * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n                 * the text between them.\n                 */\n                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n            }\n\n            return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n        }\n\n        /**\n         * Returns a fixer object that converts a non-string binary expression to a template literal\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A node that should be converted to a template literal\n         * @returns {Object} A fix for this binary expression\n         */\n        function fixNonStringBinaryExpression(fixer, node) {\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {\n                return null;\n            }\n\n            return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n        }\n\n        /**\n         * Reports if a given node is string concatenation with non string literals.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkForStringConcat(node) {\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n                return;\n            }\n\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            // Checks whether or not this node had been checked already.\n            if (done[topBinaryExpr.range[0]]) {\n                return;\n            }\n            done[topBinaryExpr.range[0]] = true;\n\n            if (hasNonStringLiteral(topBinaryExpr)) {\n                context.report({\n                    node: topBinaryExpr,\n                    messageId: \"unexpectedStringConcatenation\",\n                    fix: fixer => fixNonStringBinaryExpression(fixer, node)\n                });\n            }\n        }\n\n        return {\n            Program() {\n                done = Object.create(null);\n            },\n\n            Literal: checkForStringConcat,\n            TemplateLiteral: checkForStringConcat\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}