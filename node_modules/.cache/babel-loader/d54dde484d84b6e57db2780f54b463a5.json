{"ast":null,"code":"/**\n * @fileoverview Rule that warns when identifier names that are\n * specified in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents assignment target in a normal assignment or destructuring.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is assignment target.\n */\n\nfunction isAssignmentTarget(node) {\n  const parent = node.parent;\n  return (// normal assignment\n    parent.type === \"AssignmentExpression\" && parent.left === node || // destructuring\n    parent.type === \"ArrayPattern\" || parent.type === \"RestElement\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"AssignmentPattern\" && parent.left === node\n  );\n}\n/**\n * Checks whether the given node represents an imported name that is renamed in the same import/export specifier.\n *\n * Examples:\n * import { a as b } from 'mod'; // node `a` is renamed import\n * export { a as b } from 'mod'; // node `a` is renamed import\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed import.\n */\n\n\nfunction isRenamedImport(node) {\n  const parent = node.parent;\n  return parent.type === \"ImportSpecifier\" && parent.imported !== parent.local && parent.imported === node || parent.type === \"ExportSpecifier\" && parent.parent.source && // re-export\n  parent.local !== parent.exported && parent.local === node;\n}\n/**\n * Checks whether the given node is a renamed identifier node in an ObjectPattern destructuring.\n *\n * Examples:\n * const { a : b } = foo; // node `a` is renamed node.\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed node in an ObjectPattern destructuring.\n */\n\n\nfunction isRenamedInDestructuring(node) {\n  const parent = node.parent;\n  return !parent.computed && parent.type === \"Property\" && parent.parent.type === \"ObjectPattern\" && parent.value !== node && parent.key === node;\n}\n/**\n * Checks whether the given node represents shorthand definition of a property in an object literal.\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a shorthand property definition.\n */\n\n\nfunction isShorthandPropertyDefinition(node) {\n  const parent = node.parent;\n  return parent.type === \"Property\" && parent.parent.type === \"ObjectExpression\" && parent.shorthand;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [\"id-denylist\"],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified identifiers\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/id-blacklist\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\"\n      },\n      uniqueItems: true\n    },\n    messages: {\n      restricted: \"Identifier '{{name}}' is restricted.\"\n    }\n  },\n\n  create(context) {\n    const denyList = new Set(context.options);\n    const reportedNodes = new Set();\n    let globalScope;\n    /**\n     * Checks whether the given name is restricted.\n     * @param {string} name The name to check.\n     * @returns {boolean} `true` if the name is restricted.\n     * @private\n     */\n\n    function isRestricted(name) {\n      return denyList.has(name);\n    }\n    /**\n     * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n     * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} `true` if the node is a reference to a global variable.\n     */\n\n\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n    /**\n     * Determines whether the given node should be checked.\n     * @param {ASTNode} node `Identifier` node.\n     * @returns {boolean} `true` if the node should be checked.\n     */\n\n\n    function shouldCheck(node) {\n      const parent = node.parent;\n      /*\n       * Member access has special rules for checking property names.\n       * Read access to a property with a restricted name is allowed, because it can be on an object that user has no control over.\n       * Write access isn't allowed, because it potentially creates a new property with a restricted name.\n       */\n\n      if (parent.type === \"MemberExpression\" && parent.property === node && !parent.computed) {\n        return isAssignmentTarget(parent);\n      }\n\n      return parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\" && !isRenamedImport(node) && !isRenamedInDestructuring(node) && !(isReferenceToGlobalVariable(node) && !isShorthandPropertyDefinition(node));\n    }\n    /**\n     * Reports an AST node as a rule violation.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     * @private\n     */\n\n\n    function report(node) {\n      if (!reportedNodes.has(node)) {\n        context.report({\n          node,\n          messageId: \"restricted\",\n          data: {\n            name: node.name\n          }\n        });\n        reportedNodes.add(node);\n      }\n    }\n\n    return {\n      Program() {\n        globalScope = context.getScope();\n      },\n\n      Identifier(node) {\n        if (isRestricted(node.name) && shouldCheck(node)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["isAssignmentTarget","node","parent","type","left","value","isRenamedImport","imported","local","source","exported","isRenamedInDestructuring","computed","key","isShorthandPropertyDefinition","shorthand","module","exports","meta","deprecated","replacedBy","docs","description","category","recommended","url","schema","items","uniqueItems","messages","restricted","create","context","denyList","Set","options","reportedNodes","globalScope","isRestricted","name","has","isReferenceToGlobalVariable","variable","set","get","defs","length","references","some","ref","identifier","shouldCheck","property","report","messageId","data","add","Program","getScope","Identifier"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/id-blacklist.js"],"sourcesContent":["/**\n * @fileoverview Rule that warns when identifier names that are\n * specified in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents assignment target in a normal assignment or destructuring.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is assignment target.\n */\nfunction isAssignmentTarget(node) {\n    const parent = node.parent;\n\n    return (\n\n        // normal assignment\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // destructuring\n        parent.type === \"ArrayPattern\" ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node represents an imported name that is renamed in the same import/export specifier.\n *\n * Examples:\n * import { a as b } from 'mod'; // node `a` is renamed import\n * export { a as b } from 'mod'; // node `a` is renamed import\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed import.\n */\nfunction isRenamedImport(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            parent.type === \"ImportSpecifier\" &&\n            parent.imported !== parent.local &&\n            parent.imported === node\n        ) ||\n        (\n            parent.type === \"ExportSpecifier\" &&\n            parent.parent.source && // re-export\n            parent.local !== parent.exported &&\n            parent.local === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node is a renamed identifier node in an ObjectPattern destructuring.\n *\n * Examples:\n * const { a : b } = foo; // node `a` is renamed node.\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed node in an ObjectPattern destructuring.\n */\nfunction isRenamedInDestructuring(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            !parent.computed &&\n            parent.type === \"Property\" &&\n            parent.parent.type === \"ObjectPattern\" &&\n            parent.value !== node &&\n            parent.key === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node represents shorthand definition of a property in an object literal.\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a shorthand property definition.\n */\nfunction isShorthandPropertyDefinition(node) {\n    const parent = node.parent;\n\n    return (\n        parent.type === \"Property\" &&\n        parent.parent.type === \"ObjectExpression\" &&\n        parent.shorthand\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [\"id-denylist\"],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/id-blacklist\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        messages: {\n            restricted: \"Identifier '{{name}}' is restricted.\"\n        }\n    },\n\n    create(context) {\n\n        const denyList = new Set(context.options);\n        const reportedNodes = new Set();\n\n        let globalScope;\n\n        /**\n         * Checks whether the given name is restricted.\n         * @param {string} name The name to check.\n         * @returns {boolean} `true` if the name is restricted.\n         * @private\n         */\n        function isRestricted(name) {\n            return denyList.has(name);\n        }\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Determines whether the given node should be checked.\n         * @param {ASTNode} node `Identifier` node.\n         * @returns {boolean} `true` if the node should be checked.\n         */\n        function shouldCheck(node) {\n            const parent = node.parent;\n\n            /*\n             * Member access has special rules for checking property names.\n             * Read access to a property with a restricted name is allowed, because it can be on an object that user has no control over.\n             * Write access isn't allowed, because it potentially creates a new property with a restricted name.\n             */\n            if (\n                parent.type === \"MemberExpression\" &&\n                parent.property === node &&\n                !parent.computed\n            ) {\n                return isAssignmentTarget(parent);\n            }\n\n            return (\n                parent.type !== \"CallExpression\" &&\n                parent.type !== \"NewExpression\" &&\n                !isRenamedImport(node) &&\n                !isRenamedInDestructuring(node) &&\n                !(\n                    isReferenceToGlobalVariable(node) &&\n                    !isShorthandPropertyDefinition(node)\n                )\n            );\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (!reportedNodes.has(node)) {\n                context.report({\n                    node,\n                    messageId: \"restricted\",\n                    data: {\n                        name: node.name\n                    }\n                });\n                reportedNodes.add(node);\n            }\n        }\n\n        return {\n\n            Program() {\n                globalScope = context.getScope();\n            },\n\n            Identifier(node) {\n                if (isRestricted(node.name) && shouldCheck(node)) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}