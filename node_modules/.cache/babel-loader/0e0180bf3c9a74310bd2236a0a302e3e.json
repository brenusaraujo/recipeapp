{"ast":null,"code":"/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n/**\n * Checks whether or not a given case has a fallthrough comment.\n * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.\n * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {boolean} `true` if the case has a valid fallthrough comment.\n */\n\nfunction hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\n  const sourceCode = context.getSourceCode();\n\n  if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\n    const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\n    const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\n\n    if (commentInBlock && fallthroughCommentPattern.test(commentInBlock.value)) {\n      return true;\n    }\n  }\n\n  const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\n  return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\n\n\nfunction hasBlankLinesBetween(node, token) {\n  return token.loc.start.line > node.loc.end.line + 1;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow fallthrough of `case` statements\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-fallthrough\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        commentPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      case: \"Expected a 'break' statement before 'case'.\",\n      default: \"Expected a 'break' statement before 'default'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    let currentCodePath = null;\n    const sourceCode = context.getSourceCode();\n    /*\n     * We need to use leading comments of the next SwitchCase node because\n     * trailing comments is wrong if semicolons are omitted.\n     */\n\n    let fallthroughCase = null;\n    let fallthroughCommentPattern = null;\n\n    if (options.commentPattern) {\n      fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n    } else {\n      fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n    }\n\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      SwitchCase(node) {\n        /*\n         * Checks whether or not there is a fallthrough comment.\n         * And reports the previous fallthrough node if that does not exist.\n         */\n        if (fallthroughCase && !hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern)) {\n          context.report({\n            messageId: node.test ? \"case\" : \"default\",\n            node\n          });\n        }\n\n        fallthroughCase = null;\n      },\n\n      \"SwitchCase:exit\"(node) {\n        const nextToken = sourceCode.getTokenAfter(node);\n        /*\n         * `reachable` meant fall through because statements preceded by\n         * `break`, `return`, or `throw` are unreachable.\n         * And allows empty cases and the last case.\n         */\n\n        if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && node.parent.cases[node.parent.cases.length - 1] !== node) {\n          fallthroughCase = node;\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["DEFAULT_FALLTHROUGH_COMMENT","hasFallthroughComment","caseWhichFallsThrough","subsequentCase","context","fallthroughCommentPattern","sourceCode","getSourceCode","consequent","length","type","trailingCloseBrace","getLastToken","commentInBlock","getCommentsBefore","pop","test","value","comment","Boolean","isReachable","segment","reachable","hasBlankLinesBetween","node","token","loc","start","line","end","module","exports","meta","docs","description","category","recommended","url","schema","properties","commentPattern","default","additionalProperties","messages","case","create","options","currentCodePath","fallthroughCase","RegExp","onCodePathStart","codePath","onCodePathEnd","upper","SwitchCase","report","messageId","nextToken","getTokenAfter","currentSegments","some","parent","cases"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-fallthrough.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\n/**\n * Checks whether or not a given case has a fallthrough comment.\n * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.\n * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {boolean} `true` if the case has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\n    const sourceCode = context.getSourceCode();\n\n    if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\n        const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\n        const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\n\n        if (commentInBlock && fallthroughCommentPattern.test(commentInBlock.value)) {\n            return true;\n        }\n    }\n\n    const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\n\n    return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow fallthrough of `case` statements\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-fallthrough\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            case: \"Expected a 'break' statement before 'case'.\",\n            default: \"Expected a 'break' statement before 'default'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        let currentCodePath = null;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        let fallthroughCase = null;\n        let fallthroughCommentPattern = null;\n\n        if (options.commentPattern) {\n            fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n        } else {\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n        }\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            SwitchCase(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n                if (fallthroughCase && !hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern)) {\n                    context.report({\n                        messageId: node.test ? \"case\" : \"default\",\n                        node\n                    });\n                }\n                fallthroughCase = null;\n            },\n\n            \"SwitchCase:exit\"(node) {\n                const nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                if (currentCodePath.currentSegments.some(isReachable) &&\n                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&\n                    node.parent.cases[node.parent.cases.length - 1] !== node) {\n                    fallthroughCase = node;\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}