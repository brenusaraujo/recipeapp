{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSliderListStyles = void 0;\n\nconst default_controls_1 = require(\"./default-controls\");\n\nconst types_1 = require(\"./types\");\n\nconst getSliderListWidth = (slideCount, slidesToShow, wrapAround) => {\n  const visibleSlides = slidesToShow;\n\n  if (wrapAround) {\n    const percentage = slideCount * 100 / visibleSlides;\n    return `${3 * percentage}%`;\n  }\n\n  const percentage = slideCount * 100 / visibleSlides;\n  return `${percentage}%`;\n};\n\nconst getPercentOffsetForSlide = (slideCount, initialValue, currentSlide, cellAlign, wrapAround) => {\n  if (cellAlign === types_1.Alignment.Left) {\n    if (wrapAround) {\n      const slideTransition = 100 / (3 * slideCount);\n      const currentTransition = initialValue - slideTransition * (currentSlide - 1);\n      return currentTransition - slideTransition;\n    }\n\n    const slideTransition = 100 / slideCount * currentSlide;\n    return -(slideTransition + initialValue);\n  } else if (cellAlign === types_1.Alignment.Center) {\n    if (wrapAround) {\n      const slideTransition = 100 / (3 * slideCount);\n      const currentTransition = initialValue - slideTransition * (currentSlide - 1);\n      return currentTransition - slideTransition;\n    }\n\n    const slideTransition = 100 / slideCount * currentSlide;\n    return initialValue - slideTransition;\n  } else if (cellAlign === types_1.Alignment.Right) {\n    if (wrapAround) {\n      const slideTransition = 100 / (3 * slideCount);\n      const currentTransition = initialValue - slideTransition * (currentSlide - 1);\n      return currentTransition - slideTransition;\n    }\n\n    const slideTransition = 100 / slideCount * currentSlide;\n    return initialValue - slideTransition;\n  }\n\n  return initialValue;\n};\n\nconst getPositioning = (cellAlign, slidesToShow, slideCount, currentSlide, wrapAround, draggedOffset, clampIndices) => {\n  // When wrapAround is enabled, we show the slides 3 times\n  const totalCount = wrapAround ? 3 * slideCount : slideCount;\n  const slideSize = 100 / totalCount;\n  let initialValue = wrapAround ? -slideCount * slideSize : 0;\n\n  if (cellAlign === types_1.Alignment.Right && slidesToShow > 1) {\n    const excessSlides = slidesToShow - 1;\n    initialValue += slideSize * excessSlides;\n  }\n\n  if (cellAlign === types_1.Alignment.Center && slidesToShow > 1) {\n    const excessSlides = slidesToShow - 1; // Half of excess is on left and half is on right when centered\n\n    const excessLeftSlides = excessSlides / 2;\n    initialValue += slideSize * excessLeftSlides;\n  }\n\n  const slideBasedOffset = getPercentOffsetForSlide(slideCount, initialValue, currentSlide, cellAlign, wrapAround); // Special-case this. It's better to return undefined rather than a\n  // transform of 0 pixels since transforms can cause flickering in chrome.\n\n  if (draggedOffset === 0 && slideBasedOffset === 0) {\n    return undefined;\n  }\n\n  let clampOffsets = null;\n\n  if (clampIndices) {\n    clampOffsets = clampIndices.map(index => getPercentOffsetForSlide(slideCount, initialValue, index, cellAlign, wrapAround));\n  }\n\n  const clampedDraggedOffset = clampOffsets ? // Offsets are seemingly backwards because the rightmost slide creates\n  // the most negative translate value\n  `clamp(${clampOffsets[1]}%, ${draggedOffset}px, ${clampOffsets[0]}%)` : `${draggedOffset}px`;\n  return `translate3d(${draggedOffset ? clampedDraggedOffset : `${slideBasedOffset}%`}, 0, 0)`;\n};\n\nconst getSliderListStyles = (slideCount, currentSlide, isAnimating, slidesToShow, cellAlign, wrapAround, speed, draggedOffset, slidesToScroll, scrollMode, disableEdgeSwiping, slideAnimation) => {\n  const width = getSliderListWidth(slideCount, slidesToShow, wrapAround); // When disableEdgeSwiping=true, we recycle dot index generation to determine\n  // the leftmost and rightmost indices used, to be used in calculating the\n  // x-translation values we need to limit to.\n\n  let clampIndices = null;\n\n  if (disableEdgeSwiping && !wrapAround) {\n    const dotIndexes = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n    clampIndices = [dotIndexes[0], dotIndexes[dotIndexes.length - 1]];\n  }\n\n  const positioning = getPositioning(cellAlign, slidesToShow, slideCount, currentSlide, wrapAround, draggedOffset, clampIndices);\n  return {\n    width,\n    textAlign: 'left',\n    userSelect: 'auto',\n    transition: draggedOffset === 0 && isAnimating && slideAnimation !== 'fade' ? `${speed}ms cubic-bezier(0.16, 1, 0.3, 1) 0s` : undefined,\n    transform: positioning,\n    display: 'flex'\n  };\n};\n\nexports.getSliderListStyles = getSliderListStyles;","map":{"version":3,"sources":["../src/slider-list.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSliderListStyles = void 0;\nconst default_controls_1 = require(\"./default-controls\");\nconst types_1 = require(\"./types\");\nconst getSliderListWidth = (slideCount, slidesToShow, wrapAround) => {\n    const visibleSlides = slidesToShow;\n    if (wrapAround) {\n        const percentage = (slideCount * 100) / visibleSlides;\n        return `${3 * percentage}%`;\n    }\n    const percentage = (slideCount * 100) / visibleSlides;\n    return `${percentage}%`;\n};\nconst getPercentOffsetForSlide = (slideCount, initialValue, currentSlide, cellAlign, wrapAround) => {\n    if (cellAlign === types_1.Alignment.Left) {\n        if (wrapAround) {\n            const slideTransition = 100 / (3 * slideCount);\n            const currentTransition = initialValue - slideTransition * (currentSlide - 1);\n            return currentTransition - slideTransition;\n        }\n        const slideTransition = (100 / slideCount) * currentSlide;\n        return -(slideTransition + initialValue);\n    }\n    else if (cellAlign === types_1.Alignment.Center) {\n        if (wrapAround) {\n            const slideTransition = 100 / (3 * slideCount);\n            const currentTransition = initialValue - slideTransition * (currentSlide - 1);\n            return currentTransition - slideTransition;\n        }\n        const slideTransition = (100 / slideCount) * currentSlide;\n        return initialValue - slideTransition;\n    }\n    else if (cellAlign === types_1.Alignment.Right) {\n        if (wrapAround) {\n            const slideTransition = 100 / (3 * slideCount);\n            const currentTransition = initialValue - slideTransition * (currentSlide - 1);\n            return currentTransition - slideTransition;\n        }\n        const slideTransition = (100 / slideCount) * currentSlide;\n        return initialValue - slideTransition;\n    }\n    return initialValue;\n};\nconst getPositioning = (cellAlign, slidesToShow, slideCount, currentSlide, wrapAround, draggedOffset, clampIndices) => {\n    // When wrapAround is enabled, we show the slides 3 times\n    const totalCount = wrapAround ? 3 * slideCount : slideCount;\n    const slideSize = 100 / totalCount;\n    let initialValue = wrapAround ? -slideCount * slideSize : 0;\n    if (cellAlign === types_1.Alignment.Right && slidesToShow > 1) {\n        const excessSlides = slidesToShow - 1;\n        initialValue += slideSize * excessSlides;\n    }\n    if (cellAlign === types_1.Alignment.Center && slidesToShow > 1) {\n        const excessSlides = slidesToShow - 1;\n        // Half of excess is on left and half is on right when centered\n        const excessLeftSlides = excessSlides / 2;\n        initialValue += slideSize * excessLeftSlides;\n    }\n    const slideBasedOffset = getPercentOffsetForSlide(slideCount, initialValue, currentSlide, cellAlign, wrapAround);\n    // Special-case this. It's better to return undefined rather than a\n    // transform of 0 pixels since transforms can cause flickering in chrome.\n    if (draggedOffset === 0 && slideBasedOffset === 0) {\n        return undefined;\n    }\n    let clampOffsets = null;\n    if (clampIndices) {\n        clampOffsets = clampIndices.map((index) => getPercentOffsetForSlide(slideCount, initialValue, index, cellAlign, wrapAround));\n    }\n    const clampedDraggedOffset = clampOffsets\n        ? // Offsets are seemingly backwards because the rightmost slide creates\n            // the most negative translate value\n            `clamp(${clampOffsets[1]}%, ${draggedOffset}px, ${clampOffsets[0]}%)`\n        : `${draggedOffset}px`;\n    return `translate3d(${draggedOffset ? clampedDraggedOffset : `${slideBasedOffset}%`}, 0, 0)`;\n};\nconst getSliderListStyles = (slideCount, currentSlide, isAnimating, slidesToShow, cellAlign, wrapAround, speed, draggedOffset, slidesToScroll, scrollMode, disableEdgeSwiping, slideAnimation) => {\n    const width = getSliderListWidth(slideCount, slidesToShow, wrapAround);\n    // When disableEdgeSwiping=true, we recycle dot index generation to determine\n    // the leftmost and rightmost indices used, to be used in calculating the\n    // x-translation values we need to limit to.\n    let clampIndices = null;\n    if (disableEdgeSwiping && !wrapAround) {\n        const dotIndexes = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n        clampIndices = [dotIndexes[0], dotIndexes[dotIndexes.length - 1]];\n    }\n    const positioning = getPositioning(cellAlign, slidesToShow, slideCount, currentSlide, wrapAround, draggedOffset, clampIndices);\n    return {\n        width,\n        textAlign: 'left',\n        userSelect: 'auto',\n        transition: draggedOffset === 0 && isAnimating && slideAnimation !== 'fade'\n            ? `${speed}ms cubic-bezier(0.16, 1, 0.3, 1) 0s`\n            : undefined,\n        transform: positioning,\n        display: 'flex',\n    };\n};\nexports.getSliderListStyles = getSliderListStyles;\n"]},"metadata":{},"sourceType":"script"}