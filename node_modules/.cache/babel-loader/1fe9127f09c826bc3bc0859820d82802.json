{"ast":null,"code":"/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce valid JSDoc comments\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        prefer: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        preferType: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        requireReturn: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        requireReturnDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        matchDescription: {\n          type: \"string\"\n        },\n        requireReturnType: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamType: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n      expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n      use: \"Use @{{name}} instead.\",\n      useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n      syntaxError: \"JSDoc syntax error.\",\n      missingBrace: \"JSDoc type missing brace.\",\n      missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n      missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n      missingReturnType: \"Missing JSDoc return type.\",\n      missingReturnDesc: \"Missing JSDoc return description.\",\n      missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n      missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n      duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n      unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n    },\n    deprecated: true,\n    replacedBy: []\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          prefer = options.prefer || {},\n          sourceCode = context.getSourceCode(),\n          // these both default to true, so you have to explicitly make them false\n    requireReturn = options.requireReturn !== false,\n          requireParamDescription = options.requireParamDescription !== false,\n          requireReturnDescription = options.requireReturnDescription !== false,\n          requireReturnType = options.requireReturnType !== false,\n          requireParamType = options.requireParamType !== false,\n          preferType = options.preferType || {},\n          checkPreferType = Object.keys(preferType).length !== 0; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // Using a stack to store if a function returns or not (handling nested functions)\n\n    const fns = [];\n    /**\n     * Check if node type is a Class\n     * @param {ASTNode} node node to check.\n     * @returns {boolean} True is its a class\n     * @private\n     */\n\n    function isTypeClass(node) {\n      return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n    }\n    /**\n     * When parsing a new function, store it in our function stack.\n     * @param {ASTNode} node A function node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function startFunction(node) {\n      fns.push({\n        returnPresent: node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\" || isTypeClass(node) || node.async\n      });\n    }\n    /**\n     * Indicate that return has been found in the current function.\n     * @param {ASTNode} node The return node.\n     * @returns {void}\n     * @private\n     */\n\n\n    function addReturn(node) {\n      const functionState = fns[fns.length - 1];\n\n      if (functionState && node.argument !== null) {\n        functionState.returnPresent = true;\n      }\n    }\n    /**\n     * Check if return tag type is void or undefined\n     * @param {Object} tag JSDoc tag\n     * @returns {boolean} True if its of type void or undefined\n     * @private\n     */\n\n\n    function isValidReturnType(tag) {\n      return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n    }\n    /**\n     * Check if type should be validated based on some exceptions\n     * @param {Object} type JSDoc tag\n     * @returns {boolean} True if it can be validated\n     * @private\n     */\n\n\n    function canTypeBeValidated(type) {\n      return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n      type !== \"NullLiteral\" && // {null}\n      type !== \"NullableLiteral\" && // {?}\n      type !== \"FunctionType\" && // {function(a)}\n      type !== \"AllLiteral\"; // {*}\n    }\n    /**\n     * Extract the current and expected type based on the input type object\n     * @param {Object} type JSDoc tag\n     * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\n     * the expected name of the annotation\n     * @private\n     */\n\n\n    function getCurrentExpectedTypes(type) {\n      let currentType;\n\n      if (type.name) {\n        currentType = type;\n      } else if (type.expression) {\n        currentType = type.expression;\n      }\n\n      return {\n        currentType,\n        expectedTypeName: currentType && preferType[currentType.name]\n      };\n    }\n    /**\n     * Gets the location of a JSDoc node in a file\n     * @param {Token} jsdocComment The comment that this node is parsed from\n     * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\n     * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\n     */\n\n\n    function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n      return {\n        start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n        end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n      };\n    }\n    /**\n     * Validate type for a given JSDoc node\n     * @param {Object} jsdocNode JSDoc node\n     * @param {Object} type JSDoc tag\n     * @returns {void}\n     * @private\n     */\n\n\n    function validateType(jsdocNode, type) {\n      if (!type || !canTypeBeValidated(type.type)) {\n        return;\n      }\n\n      const typesToCheck = [];\n      let elements = [];\n\n      switch (type.type) {\n        case \"TypeApplication\":\n          // {Array.<String>}\n          elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n          typesToCheck.push(getCurrentExpectedTypes(type));\n          break;\n\n        case \"RecordType\":\n          // {{20:String}}\n          elements = type.fields;\n          break;\n\n        case \"UnionType\": // {String|number|Test}\n\n        case \"ArrayType\":\n          // {[String, number, Test]}\n          elements = type.elements;\n          break;\n\n        case \"FieldType\":\n          // Array.<{count: number, votes: number}>\n          if (type.value) {\n            typesToCheck.push(getCurrentExpectedTypes(type.value));\n          }\n\n          break;\n\n        default:\n          typesToCheck.push(getCurrentExpectedTypes(type));\n      }\n\n      elements.forEach(validateType.bind(null, jsdocNode));\n      typesToCheck.forEach(typeToCheck => {\n        if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n          context.report({\n            node: jsdocNode,\n            messageId: \"useType\",\n            loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n            data: {\n              currentTypeName: typeToCheck.currentType.name,\n              expectedTypeName: typeToCheck.expectedTypeName\n            },\n\n            fix(fixer) {\n              return fixer.replaceTextRange(typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment), typeToCheck.expectedTypeName);\n            }\n\n          });\n        }\n      });\n    }\n    /**\n     * Validate the JSDoc node and output warnings if anything is wrong.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkJSDoc(node) {\n      const jsdocNode = sourceCode.getJSDocComment(node),\n            functionData = fns.pop(),\n            paramTagsByName = Object.create(null),\n            paramTags = [];\n      let hasReturns = false,\n          returnsTag,\n          hasConstructor = false,\n          isInterface = false,\n          isOverride = false,\n          isAbstract = false; // make sure only to validate JSDoc comments\n\n      if (jsdocNode) {\n        let jsdoc;\n\n        try {\n          jsdoc = doctrine.parse(jsdocNode.value, {\n            strict: true,\n            unwrap: true,\n            sloppy: true,\n            range: true\n          });\n        } catch (ex) {\n          if (/braces/iu.test(ex.message)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingBrace\"\n            });\n          } else {\n            context.report({\n              node: jsdocNode,\n              messageId: \"syntaxError\"\n            });\n          }\n\n          return;\n        }\n\n        jsdoc.tags.forEach(tag => {\n          switch (tag.title.toLowerCase()) {\n            case \"param\":\n            case \"arg\":\n            case \"argument\":\n              paramTags.push(tag);\n              break;\n\n            case \"return\":\n            case \"returns\":\n              hasReturns = true;\n              returnsTag = tag;\n              break;\n\n            case \"constructor\":\n            case \"class\":\n              hasConstructor = true;\n              break;\n\n            case \"override\":\n            case \"inheritdoc\":\n              isOverride = true;\n              break;\n\n            case \"abstract\":\n            case \"virtual\":\n              isAbstract = true;\n              break;\n\n            case \"interface\":\n              isInterface = true;\n              break;\n            // no default\n          } // check tag preferences\n\n\n          if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n            const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n            context.report({\n              node: jsdocNode,\n              messageId: \"use\",\n              loc: {\n                start: entireTagRange.start,\n                end: {\n                  line: entireTagRange.start.line,\n                  column: entireTagRange.start.column + `@${tag.title}`.length\n                }\n              },\n              data: {\n                name: prefer[tag.title]\n              },\n\n              fix(fixer) {\n                return fixer.replaceTextRange([jsdocNode.range[0] + tag.range[0] + 3, jsdocNode.range[0] + tag.range[0] + tag.title.length + 3], prefer[tag.title]);\n              }\n\n            });\n          } // validate the types\n\n\n          if (checkPreferType && tag.type) {\n            validateType(jsdocNode, tag.type);\n          }\n        });\n        paramTags.forEach(param => {\n          if (requireParamType && !param.type) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamType\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n\n          if (!param.description && requireParamDescription) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamDesc\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n\n          if (paramTagsByName[param.name]) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"duplicateParam\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          } else if (param.name.indexOf(\".\") === -1) {\n            paramTagsByName[param.name] = param;\n          }\n        });\n\n        if (hasReturns) {\n          if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unexpectedTag\",\n              loc: getAbsoluteRange(jsdocNode, returnsTag),\n              data: {\n                title: returnsTag.title\n              }\n            });\n          } else {\n            if (requireReturnType && !returnsTag.type) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnType\"\n              });\n            }\n\n            if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnDesc\"\n              });\n            }\n          }\n        } // check for functions missing @returns\n\n\n        if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" && node.parent.kind !== \"set\" && !isTypeClass(node)) {\n          if (requireReturn || functionData.returnPresent && !node.async) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingReturn\",\n              data: {\n                returns: prefer.returns || \"returns\"\n              }\n            });\n          }\n        } // check the parameters\n\n\n        const jsdocParamNames = Object.keys(paramTagsByName);\n\n        if (node.params) {\n          node.params.forEach((param, paramsIndex) => {\n            const bindingParam = param.type === \"AssignmentPattern\" ? param.left : param; // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n\n            if (bindingParam.type === \"Identifier\") {\n              const name = bindingParam.name;\n\n              if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"expected\",\n                  loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                  data: {\n                    name,\n                    jsdocName: jsdocParamNames[paramsIndex]\n                  }\n                });\n              } else if (!paramTagsByName[name] && !isOverride) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"missingParam\",\n                  data: {\n                    name\n                  }\n                });\n              }\n            }\n          });\n        }\n\n        if (options.matchDescription) {\n          const regex = new RegExp(options.matchDescription, \"u\");\n\n          if (!regex.test(jsdoc.description)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unsatisfiedDesc\"\n            });\n          }\n        }\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      ArrowFunctionExpression: startFunction,\n      FunctionExpression: startFunction,\n      FunctionDeclaration: startFunction,\n      ClassExpression: startFunction,\n      ClassDeclaration: startFunction,\n      \"ArrowFunctionExpression:exit\": checkJSDoc,\n      \"FunctionExpression:exit\": checkJSDoc,\n      \"FunctionDeclaration:exit\": checkJSDoc,\n      \"ClassExpression:exit\": checkJSDoc,\n      \"ClassDeclaration:exit\": checkJSDoc,\n      ReturnStatement: addReturn\n    };\n  }\n\n};","map":{"version":3,"names":["doctrine","require","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","prefer","additionalProperties","preferType","requireReturn","default","requireParamDescription","requireReturnDescription","matchDescription","requireReturnType","requireParamType","fixable","messages","unexpectedTag","expected","use","useType","syntaxError","missingBrace","missingParamDesc","missingParamType","missingReturnType","missingReturnDesc","missingReturn","missingParam","duplicateParam","unsatisfiedDesc","deprecated","replacedBy","create","context","options","sourceCode","getSourceCode","checkPreferType","Object","keys","length","fns","isTypeClass","node","startFunction","push","returnPresent","body","async","addReturn","functionState","argument","isValidReturnType","tag","name","canTypeBeValidated","getCurrentExpectedTypes","currentType","expression","expectedTypeName","getAbsoluteRange","jsdocComment","parsedJsdocNode","start","getLocFromIndex","range","end","validateType","jsdocNode","typesToCheck","elements","applications","fields","value","forEach","bind","typeToCheck","report","messageId","loc","data","currentTypeName","fix","fixer","replaceTextRange","map","indexInComment","checkJSDoc","getJSDocComment","functionData","pop","paramTagsByName","paramTags","hasReturns","returnsTag","hasConstructor","isInterface","isOverride","isAbstract","jsdoc","parse","strict","unwrap","sloppy","ex","test","message","tags","title","toLowerCase","prototype","hasOwnProperty","call","entireTagRange","line","column","param","indexOf","parent","kind","returns","jsdocParamNames","params","paramsIndex","bindingParam","left","jsdocName","regex","RegExp","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration","ClassExpression","ClassDeclaration","ReturnStatement"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/valid-jsdoc.js"],"sourcesContent":["/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce valid JSDoc comments\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    prefer: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    preferType: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    requireReturn: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireReturnDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    matchDescription: {\n                        type: \"string\"\n                    },\n                    requireReturnType: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamType: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n            expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n            use: \"Use @{{name}} instead.\",\n            useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n            syntaxError: \"JSDoc syntax error.\",\n            missingBrace: \"JSDoc type missing brace.\",\n            missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n            missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n            missingReturnType: \"Missing JSDoc return type.\",\n            missingReturnDesc: \"Missing JSDoc return description.\",\n            missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n            missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n            duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n            unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n        },\n\n        deprecated: true,\n        replacedBy: []\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            prefer = options.prefer || {},\n            sourceCode = context.getSourceCode(),\n\n            // these both default to true, so you have to explicitly make them false\n            requireReturn = options.requireReturn !== false,\n            requireParamDescription = options.requireParamDescription !== false,\n            requireReturnDescription = options.requireReturnDescription !== false,\n            requireReturnType = options.requireReturnType !== false,\n            requireParamType = options.requireParamType !== false,\n            preferType = options.preferType || {},\n            checkPreferType = Object.keys(preferType).length !== 0;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store if a function returns or not (handling nested functions)\n        const fns = [];\n\n        /**\n         * Check if node type is a Class\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True is its a class\n         * @private\n         */\n        function isTypeClass(node) {\n            return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         * @private\n         */\n        function startFunction(node) {\n            fns.push({\n                returnPresent: (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") ||\n                    isTypeClass(node) || node.async\n            });\n        }\n\n        /**\n         * Indicate that return has been found in the current function.\n         * @param {ASTNode} node The return node.\n         * @returns {void}\n         * @private\n         */\n        function addReturn(node) {\n            const functionState = fns[fns.length - 1];\n\n            if (functionState && node.argument !== null) {\n                functionState.returnPresent = true;\n            }\n        }\n\n        /**\n         * Check if return tag type is void or undefined\n         * @param {Object} tag JSDoc tag\n         * @returns {boolean} True if its of type void or undefined\n         * @private\n         */\n        function isValidReturnType(tag) {\n            return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n        }\n\n        /**\n         * Check if type should be validated based on some exceptions\n         * @param {Object} type JSDoc tag\n         * @returns {boolean} True if it can be validated\n         * @private\n         */\n        function canTypeBeValidated(type) {\n            return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n                   type !== \"NullLiteral\" && // {null}\n                   type !== \"NullableLiteral\" && // {?}\n                   type !== \"FunctionType\" && // {function(a)}\n                   type !== \"AllLiteral\"; // {*}\n        }\n\n        /**\n         * Extract the current and expected type based on the input type object\n         * @param {Object} type JSDoc tag\n         * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\n         * the expected name of the annotation\n         * @private\n         */\n        function getCurrentExpectedTypes(type) {\n            let currentType;\n\n            if (type.name) {\n                currentType = type;\n            } else if (type.expression) {\n                currentType = type.expression;\n            }\n\n            return {\n                currentType,\n                expectedTypeName: currentType && preferType[currentType.name]\n            };\n        }\n\n        /**\n         * Gets the location of a JSDoc node in a file\n         * @param {Token} jsdocComment The comment that this node is parsed from\n         * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\n         * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\n         */\n        function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n            return {\n                start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n                end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n            };\n        }\n\n        /**\n         * Validate type for a given JSDoc node\n         * @param {Object} jsdocNode JSDoc node\n         * @param {Object} type JSDoc tag\n         * @returns {void}\n         * @private\n         */\n        function validateType(jsdocNode, type) {\n            if (!type || !canTypeBeValidated(type.type)) {\n                return;\n            }\n\n            const typesToCheck = [];\n            let elements = [];\n\n            switch (type.type) {\n                case \"TypeApplication\": // {Array.<String>}\n                    elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n                    break;\n                case \"RecordType\": // {{20:String}}\n                    elements = type.fields;\n                    break;\n                case \"UnionType\": // {String|number|Test}\n                case \"ArrayType\": // {[String, number, Test]}\n                    elements = type.elements;\n                    break;\n                case \"FieldType\": // Array.<{count: number, votes: number}>\n                    if (type.value) {\n                        typesToCheck.push(getCurrentExpectedTypes(type.value));\n                    }\n                    break;\n                default:\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n            }\n\n            elements.forEach(validateType.bind(null, jsdocNode));\n\n            typesToCheck.forEach(typeToCheck => {\n                if (typeToCheck.expectedTypeName &&\n                    typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n                    context.report({\n                        node: jsdocNode,\n                        messageId: \"useType\",\n                        loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n                        data: {\n                            currentTypeName: typeToCheck.currentType.name,\n                            expectedTypeName: typeToCheck.expectedTypeName\n                        },\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment),\n                                typeToCheck.expectedTypeName\n                            );\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Validate the JSDoc node and output warnings if anything is wrong.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkJSDoc(node) {\n            const jsdocNode = sourceCode.getJSDocComment(node),\n                functionData = fns.pop(),\n                paramTagsByName = Object.create(null),\n                paramTags = [];\n            let hasReturns = false,\n                returnsTag,\n                hasConstructor = false,\n                isInterface = false,\n                isOverride = false,\n                isAbstract = false;\n\n            // make sure only to validate JSDoc comments\n            if (jsdocNode) {\n                let jsdoc;\n\n                try {\n                    jsdoc = doctrine.parse(jsdocNode.value, {\n                        strict: true,\n                        unwrap: true,\n                        sloppy: true,\n                        range: true\n                    });\n                } catch (ex) {\n\n                    if (/braces/iu.test(ex.message)) {\n                        context.report({ node: jsdocNode, messageId: \"missingBrace\" });\n                    } else {\n                        context.report({ node: jsdocNode, messageId: \"syntaxError\" });\n                    }\n\n                    return;\n                }\n\n                jsdoc.tags.forEach(tag => {\n\n                    switch (tag.title.toLowerCase()) {\n\n                        case \"param\":\n                        case \"arg\":\n                        case \"argument\":\n                            paramTags.push(tag);\n                            break;\n\n                        case \"return\":\n                        case \"returns\":\n                            hasReturns = true;\n                            returnsTag = tag;\n                            break;\n\n                        case \"constructor\":\n                        case \"class\":\n                            hasConstructor = true;\n                            break;\n\n                        case \"override\":\n                        case \"inheritdoc\":\n                            isOverride = true;\n                            break;\n\n                        case \"abstract\":\n                        case \"virtual\":\n                            isAbstract = true;\n                            break;\n\n                        case \"interface\":\n                            isInterface = true;\n                            break;\n\n                        // no default\n                    }\n\n                    // check tag preferences\n                    if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n                        const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"use\",\n                            loc: {\n                                start: entireTagRange.start,\n                                end: {\n                                    line: entireTagRange.start.line,\n                                    column: entireTagRange.start.column + `@${tag.title}`.length\n                                }\n                            },\n                            data: { name: prefer[tag.title] },\n                            fix(fixer) {\n                                return fixer.replaceTextRange(\n                                    [\n                                        jsdocNode.range[0] + tag.range[0] + 3,\n                                        jsdocNode.range[0] + tag.range[0] + tag.title.length + 3\n                                    ],\n                                    prefer[tag.title]\n                                );\n                            }\n                        });\n                    }\n\n                    // validate the types\n                    if (checkPreferType && tag.type) {\n                        validateType(jsdocNode, tag.type);\n                    }\n                });\n\n                paramTags.forEach(param => {\n                    if (requireParamType && !param.type) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamType\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (!param.description && requireParamDescription) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamDesc\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (paramTagsByName[param.name]) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"duplicateParam\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    } else if (param.name.indexOf(\".\") === -1) {\n                        paramTagsByName[param.name] = param;\n                    }\n                });\n\n                if (hasReturns) {\n                    if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"unexpectedTag\",\n                            loc: getAbsoluteRange(jsdocNode, returnsTag),\n                            data: {\n                                title: returnsTag.title\n                            }\n                        });\n                    } else {\n                        if (requireReturnType && !returnsTag.type) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnType\" });\n                        }\n\n                        if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnDesc\" });\n                        }\n                    }\n                }\n\n                // check for functions missing @returns\n                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&\n                    node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" &&\n                    node.parent.kind !== \"set\" && !isTypeClass(node)) {\n                    if (requireReturn || (functionData.returnPresent && !node.async)) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingReturn\",\n                            data: {\n                                returns: prefer.returns || \"returns\"\n                            }\n                        });\n                    }\n                }\n\n                // check the parameters\n                const jsdocParamNames = Object.keys(paramTagsByName);\n\n                if (node.params) {\n                    node.params.forEach((param, paramsIndex) => {\n                        const bindingParam = param.type === \"AssignmentPattern\"\n                            ? param.left\n                            : param;\n\n                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n                        if (bindingParam.type === \"Identifier\") {\n                            const name = bindingParam.name;\n\n                            if (jsdocParamNames[paramsIndex] && (name !== jsdocParamNames[paramsIndex])) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"expected\",\n                                    loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                                    data: {\n                                        name,\n                                        jsdocName: jsdocParamNames[paramsIndex]\n                                    }\n                                });\n                            } else if (!paramTagsByName[name] && !isOverride) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"missingParam\",\n                                    data: {\n                                        name\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n\n                if (options.matchDescription) {\n                    const regex = new RegExp(options.matchDescription, \"u\");\n\n                    if (!regex.test(jsdoc.description)) {\n                        context.report({ node: jsdocNode, messageId: \"unsatisfiedDesc\" });\n                    }\n                }\n\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: startFunction,\n            FunctionExpression: startFunction,\n            FunctionDeclaration: startFunction,\n            ClassExpression: startFunction,\n            ClassDeclaration: startFunction,\n            \"ArrowFunctionExpression:exit\": checkJSDoc,\n            \"FunctionExpression:exit\": checkJSDoc,\n            \"FunctionDeclaration:exit\": checkJSDoc,\n            \"ClassExpression:exit\": checkJSDoc,\n            \"ClassDeclaration:exit\": checkJSDoc,\n            ReturnStatement: addReturn\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,YADJ;IAGFC,IAAI,EAAE;MACFC,WAAW,EAAE,8BADX;MAEFC,QAAQ,EAAE,iBAFR;MAGFC,WAAW,EAAE,KAHX;MAIFC,GAAG,EAAE;IAJH,CAHJ;IAUFC,MAAM,EAAE,CACJ;MACIN,IAAI,EAAE,QADV;MAEIO,UAAU,EAAE;QACRC,MAAM,EAAE;UACJR,IAAI,EAAE,QADF;UAEJS,oBAAoB,EAAE;YAClBT,IAAI,EAAE;UADY;QAFlB,CADA;QAORU,UAAU,EAAE;UACRV,IAAI,EAAE,QADE;UAERS,oBAAoB,EAAE;YAClBT,IAAI,EAAE;UADY;QAFd,CAPJ;QAaRW,aAAa,EAAE;UACXX,IAAI,EAAE,SADK;UAEXY,OAAO,EAAE;QAFE,CAbP;QAiBRC,uBAAuB,EAAE;UACrBb,IAAI,EAAE,SADe;UAErBY,OAAO,EAAE;QAFY,CAjBjB;QAqBRE,wBAAwB,EAAE;UACtBd,IAAI,EAAE,SADgB;UAEtBY,OAAO,EAAE;QAFa,CArBlB;QAyBRG,gBAAgB,EAAE;UACdf,IAAI,EAAE;QADQ,CAzBV;QA4BRgB,iBAAiB,EAAE;UACfhB,IAAI,EAAE,SADS;UAEfY,OAAO,EAAE;QAFM,CA5BX;QAgCRK,gBAAgB,EAAE;UACdjB,IAAI,EAAE,SADQ;UAEdY,OAAO,EAAE;QAFK;MAhCV,CAFhB;MAuCIH,oBAAoB,EAAE;IAvC1B,CADI,CAVN;IAsDFS,OAAO,EAAE,MAtDP;IAuDFC,QAAQ,EAAE;MACNC,aAAa,EAAE,8DADT;MAENC,QAAQ,EAAE,0DAFJ;MAGNC,GAAG,EAAE,wBAHC;MAINC,OAAO,EAAE,8DAJH;MAKNC,WAAW,EAAE,qBALP;MAMNC,YAAY,EAAE,2BANR;MAONC,gBAAgB,EAAE,qDAPZ;MAQNC,gBAAgB,EAAE,8CARZ;MASNC,iBAAiB,EAAE,4BATb;MAUNC,iBAAiB,EAAE,mCAVb;MAWNC,aAAa,EAAE,0CAXT;MAYNC,YAAY,EAAE,yCAZR;MAaNC,cAAc,EAAE,uCAbV;MAcNC,eAAe,EAAE;IAdX,CAvDR;IAwEFC,UAAU,EAAE,IAxEV;IAyEFC,UAAU,EAAE;EAzEV,CADO;;EA6EbC,MAAM,CAACC,OAAD,EAAU;IAEZ,MAAMC,OAAO,GAAGD,OAAO,CAACC,OAAR,CAAgB,CAAhB,KAAsB,EAAtC;IAAA,MACI9B,MAAM,GAAG8B,OAAO,CAAC9B,MAAR,IAAkB,EAD/B;IAAA,MAEI+B,UAAU,GAAGF,OAAO,CAACG,aAAR,EAFjB;IAAA,MAII;IACA7B,aAAa,GAAG2B,OAAO,CAAC3B,aAAR,KAA0B,KAL9C;IAAA,MAMIE,uBAAuB,GAAGyB,OAAO,CAACzB,uBAAR,KAAoC,KANlE;IAAA,MAOIC,wBAAwB,GAAGwB,OAAO,CAACxB,wBAAR,KAAqC,KAPpE;IAAA,MAQIE,iBAAiB,GAAGsB,OAAO,CAACtB,iBAAR,KAA8B,KARtD;IAAA,MASIC,gBAAgB,GAAGqB,OAAO,CAACrB,gBAAR,KAA6B,KATpD;IAAA,MAUIP,UAAU,GAAG4B,OAAO,CAAC5B,UAAR,IAAsB,EAVvC;IAAA,MAWI+B,eAAe,GAAGC,MAAM,CAACC,IAAP,CAAYjC,UAAZ,EAAwBkC,MAAxB,KAAmC,CAXzD,CAFY,CAeZ;IACA;IACA;IAEA;;IACA,MAAMC,GAAG,GAAG,EAAZ;IAEA;AACR;AACA;AACA;AACA;AACA;;IACQ,SAASC,WAAT,CAAqBC,IAArB,EAA2B;MACvB,OAAOA,IAAI,CAAC/C,IAAL,KAAc,iBAAd,IAAmC+C,IAAI,CAAC/C,IAAL,KAAc,kBAAxD;IACH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASgD,aAAT,CAAuBD,IAAvB,EAA6B;MACzBF,GAAG,CAACI,IAAJ,CAAS;QACLC,aAAa,EAAGH,IAAI,CAAC/C,IAAL,KAAc,yBAAd,IAA2C+C,IAAI,CAACI,IAAL,CAAUnD,IAAV,KAAmB,gBAA/D,IACX8C,WAAW,CAACC,IAAD,CADA,IACUA,IAAI,CAACK;MAFzB,CAAT;IAIH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASC,SAAT,CAAmBN,IAAnB,EAAyB;MACrB,MAAMO,aAAa,GAAGT,GAAG,CAACA,GAAG,CAACD,MAAJ,GAAa,CAAd,CAAzB;;MAEA,IAAIU,aAAa,IAAIP,IAAI,CAACQ,QAAL,KAAkB,IAAvC,EAA6C;QACzCD,aAAa,CAACJ,aAAd,GAA8B,IAA9B;MACH;IACJ;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASM,iBAAT,CAA2BC,GAA3B,EAAgC;MAC5B,OAAOA,GAAG,CAACzD,IAAJ,KAAa,IAAb,IAAqByD,GAAG,CAACzD,IAAJ,CAAS0D,IAAT,KAAkB,MAAvC,IAAiDD,GAAG,CAACzD,IAAJ,CAASA,IAAT,KAAkB,kBAA1E;IACH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAAS2D,kBAAT,CAA4B3D,IAA5B,EAAkC;MAC9B,OAAOA,IAAI,KAAK,kBAAT,IAA+B;MAC/BA,IAAI,KAAK,aADT,IAC0B;MAC1BA,IAAI,KAAK,iBAFT,IAE8B;MAC9BA,IAAI,KAAK,cAHT,IAG2B;MAC3BA,IAAI,KAAK,YAJhB,CAD8B,CAKA;IACjC;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAAS4D,uBAAT,CAAiC5D,IAAjC,EAAuC;MACnC,IAAI6D,WAAJ;;MAEA,IAAI7D,IAAI,CAAC0D,IAAT,EAAe;QACXG,WAAW,GAAG7D,IAAd;MACH,CAFD,MAEO,IAAIA,IAAI,CAAC8D,UAAT,EAAqB;QACxBD,WAAW,GAAG7D,IAAI,CAAC8D,UAAnB;MACH;;MAED,OAAO;QACHD,WADG;QAEHE,gBAAgB,EAAEF,WAAW,IAAInD,UAAU,CAACmD,WAAW,CAACH,IAAb;MAFxC,CAAP;IAIH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASM,gBAAT,CAA0BC,YAA1B,EAAwCC,eAAxC,EAAyD;MACrD,OAAO;QACHC,KAAK,EAAE5B,UAAU,CAAC6B,eAAX,CAA2BH,YAAY,CAACI,KAAb,CAAmB,CAAnB,IAAwB,CAAxB,GAA4BH,eAAe,CAACG,KAAhB,CAAsB,CAAtB,CAAvD,CADJ;QAEHC,GAAG,EAAE/B,UAAU,CAAC6B,eAAX,CAA2BH,YAAY,CAACI,KAAb,CAAmB,CAAnB,IAAwB,CAAxB,GAA4BH,eAAe,CAACG,KAAhB,CAAsB,CAAtB,CAAvD;MAFF,CAAP;IAIH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASE,YAAT,CAAsBC,SAAtB,EAAiCxE,IAAjC,EAAuC;MACnC,IAAI,CAACA,IAAD,IAAS,CAAC2D,kBAAkB,CAAC3D,IAAI,CAACA,IAAN,CAAhC,EAA6C;QACzC;MACH;;MAED,MAAMyE,YAAY,GAAG,EAArB;MACA,IAAIC,QAAQ,GAAG,EAAf;;MAEA,QAAQ1E,IAAI,CAACA,IAAb;QACI,KAAK,iBAAL;UAAwB;UACpB0E,QAAQ,GAAG1E,IAAI,CAAC2E,YAAL,CAAkB,CAAlB,EAAqB3E,IAArB,KAA8B,WAA9B,GAA4CA,IAAI,CAAC2E,YAAL,CAAkB,CAAlB,EAAqBD,QAAjE,GAA4E1E,IAAI,CAAC2E,YAA5F;UACAF,YAAY,CAACxB,IAAb,CAAkBW,uBAAuB,CAAC5D,IAAD,CAAzC;UACA;;QACJ,KAAK,YAAL;UAAmB;UACf0E,QAAQ,GAAG1E,IAAI,CAAC4E,MAAhB;UACA;;QACJ,KAAK,WAAL,CARJ,CAQsB;;QAClB,KAAK,WAAL;UAAkB;UACdF,QAAQ,GAAG1E,IAAI,CAAC0E,QAAhB;UACA;;QACJ,KAAK,WAAL;UAAkB;UACd,IAAI1E,IAAI,CAAC6E,KAAT,EAAgB;YACZJ,YAAY,CAACxB,IAAb,CAAkBW,uBAAuB,CAAC5D,IAAI,CAAC6E,KAAN,CAAzC;UACH;;UACD;;QACJ;UACIJ,YAAY,CAACxB,IAAb,CAAkBW,uBAAuB,CAAC5D,IAAD,CAAzC;MAlBR;;MAqBA0E,QAAQ,CAACI,OAAT,CAAiBP,YAAY,CAACQ,IAAb,CAAkB,IAAlB,EAAwBP,SAAxB,CAAjB;MAEAC,YAAY,CAACK,OAAb,CAAqBE,WAAW,IAAI;QAChC,IAAIA,WAAW,CAACjB,gBAAZ,IACAiB,WAAW,CAACjB,gBAAZ,KAAiCiB,WAAW,CAACnB,WAAZ,CAAwBH,IAD7D,EACmE;UAC/DrB,OAAO,CAAC4C,MAAR,CAAe;YACXlC,IAAI,EAAEyB,SADK;YAEXU,SAAS,EAAE,SAFA;YAGXC,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYQ,WAAW,CAACnB,WAAxB,CAHV;YAIXuB,IAAI,EAAE;cACFC,eAAe,EAAEL,WAAW,CAACnB,WAAZ,CAAwBH,IADvC;cAEFK,gBAAgB,EAAEiB,WAAW,CAACjB;YAF5B,CAJK;;YAQXuB,GAAG,CAACC,KAAD,EAAQ;cACP,OAAOA,KAAK,CAACC,gBAAN,CACHR,WAAW,CAACnB,WAAZ,CAAwBQ,KAAxB,CAA8BoB,GAA9B,CAAkCC,cAAc,IAAIlB,SAAS,CAACH,KAAV,CAAgB,CAAhB,IAAqB,CAArB,GAAyBqB,cAA7E,CADG,EAEHV,WAAW,CAACjB,gBAFT,CAAP;YAIH;;UAbU,CAAf;QAeH;MACJ,CAnBD;IAoBH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAAS4B,UAAT,CAAoB5C,IAApB,EAA0B;MACtB,MAAMyB,SAAS,GAAGjC,UAAU,CAACqD,eAAX,CAA2B7C,IAA3B,CAAlB;MAAA,MACI8C,YAAY,GAAGhD,GAAG,CAACiD,GAAJ,EADnB;MAAA,MAEIC,eAAe,GAAGrD,MAAM,CAACN,MAAP,CAAc,IAAd,CAFtB;MAAA,MAGI4D,SAAS,GAAG,EAHhB;MAIA,IAAIC,UAAU,GAAG,KAAjB;MAAA,IACIC,UADJ;MAAA,IAEIC,cAAc,GAAG,KAFrB;MAAA,IAGIC,WAAW,GAAG,KAHlB;MAAA,IAIIC,UAAU,GAAG,KAJjB;MAAA,IAKIC,UAAU,GAAG,KALjB,CALsB,CAYtB;;MACA,IAAI9B,SAAJ,EAAe;QACX,IAAI+B,KAAJ;;QAEA,IAAI;UACAA,KAAK,GAAG5G,QAAQ,CAAC6G,KAAT,CAAehC,SAAS,CAACK,KAAzB,EAAgC;YACpC4B,MAAM,EAAE,IAD4B;YAEpCC,MAAM,EAAE,IAF4B;YAGpCC,MAAM,EAAE,IAH4B;YAIpCtC,KAAK,EAAE;UAJ6B,CAAhC,CAAR;QAMH,CAPD,CAOE,OAAOuC,EAAP,EAAW;UAET,IAAI,WAAWC,IAAX,CAAgBD,EAAE,CAACE,OAAnB,CAAJ,EAAiC;YAC7BzE,OAAO,CAAC4C,MAAR,CAAe;cAAElC,IAAI,EAAEyB,SAAR;cAAmBU,SAAS,EAAE;YAA9B,CAAf;UACH,CAFD,MAEO;YACH7C,OAAO,CAAC4C,MAAR,CAAe;cAAElC,IAAI,EAAEyB,SAAR;cAAmBU,SAAS,EAAE;YAA9B,CAAf;UACH;;UAED;QACH;;QAEDqB,KAAK,CAACQ,IAAN,CAAWjC,OAAX,CAAmBrB,GAAG,IAAI;UAEtB,QAAQA,GAAG,CAACuD,KAAJ,CAAUC,WAAV,EAAR;YAEI,KAAK,OAAL;YACA,KAAK,KAAL;YACA,KAAK,UAAL;cACIjB,SAAS,CAAC/C,IAAV,CAAeQ,GAAf;cACA;;YAEJ,KAAK,QAAL;YACA,KAAK,SAAL;cACIwC,UAAU,GAAG,IAAb;cACAC,UAAU,GAAGzC,GAAb;cACA;;YAEJ,KAAK,aAAL;YACA,KAAK,OAAL;cACI0C,cAAc,GAAG,IAAjB;cACA;;YAEJ,KAAK,UAAL;YACA,KAAK,YAAL;cACIE,UAAU,GAAG,IAAb;cACA;;YAEJ,KAAK,UAAL;YACA,KAAK,SAAL;cACIC,UAAU,GAAG,IAAb;cACA;;YAEJ,KAAK,WAAL;cACIF,WAAW,GAAG,IAAd;cACA;YAEJ;UAjCJ,CAFsB,CAsCtB;;;UACA,IAAI1D,MAAM,CAACwE,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC5G,MAArC,EAA6CiD,GAAG,CAACuD,KAAjD,KAA2DvD,GAAG,CAACuD,KAAJ,KAAcxG,MAAM,CAACiD,GAAG,CAACuD,KAAL,CAAnF,EAAgG;YAC5F,MAAMK,cAAc,GAAGrD,gBAAgB,CAACQ,SAAD,EAAYf,GAAZ,CAAvC;YAEApB,OAAO,CAAC4C,MAAR,CAAe;cACXlC,IAAI,EAAEyB,SADK;cAEXU,SAAS,EAAE,KAFA;cAGXC,GAAG,EAAE;gBACDhB,KAAK,EAAEkD,cAAc,CAAClD,KADrB;gBAEDG,GAAG,EAAE;kBACDgD,IAAI,EAAED,cAAc,CAAClD,KAAf,CAAqBmD,IAD1B;kBAEDC,MAAM,EAAEF,cAAc,CAAClD,KAAf,CAAqBoD,MAArB,GAA+B,IAAG9D,GAAG,CAACuD,KAAM,EAAd,CAAgBpE;gBAFrD;cAFJ,CAHM;cAUXwC,IAAI,EAAE;gBAAE1B,IAAI,EAAElD,MAAM,CAACiD,GAAG,CAACuD,KAAL;cAAd,CAVK;;cAWX1B,GAAG,CAACC,KAAD,EAAQ;gBACP,OAAOA,KAAK,CAACC,gBAAN,CACH,CACIhB,SAAS,CAACH,KAAV,CAAgB,CAAhB,IAAqBZ,GAAG,CAACY,KAAJ,CAAU,CAAV,CAArB,GAAoC,CADxC,EAEIG,SAAS,CAACH,KAAV,CAAgB,CAAhB,IAAqBZ,GAAG,CAACY,KAAJ,CAAU,CAAV,CAArB,GAAoCZ,GAAG,CAACuD,KAAJ,CAAUpE,MAA9C,GAAuD,CAF3D,CADG,EAKHpC,MAAM,CAACiD,GAAG,CAACuD,KAAL,CALH,CAAP;cAOH;;YAnBU,CAAf;UAqBH,CA/DqB,CAiEtB;;;UACA,IAAIvE,eAAe,IAAIgB,GAAG,CAACzD,IAA3B,EAAiC;YAC7BuE,YAAY,CAACC,SAAD,EAAYf,GAAG,CAACzD,IAAhB,CAAZ;UACH;QACJ,CArED;QAuEAgG,SAAS,CAAClB,OAAV,CAAkB0C,KAAK,IAAI;UACvB,IAAIvG,gBAAgB,IAAI,CAACuG,KAAK,CAACxH,IAA/B,EAAqC;YACjCqC,OAAO,CAAC4C,MAAR,CAAe;cACXlC,IAAI,EAAEyB,SADK;cAEXU,SAAS,EAAE,kBAFA;cAGXC,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYgD,KAAZ,CAHV;cAIXpC,IAAI,EAAE;gBAAE1B,IAAI,EAAE8D,KAAK,CAAC9D;cAAd;YAJK,CAAf;UAMH;;UACD,IAAI,CAAC8D,KAAK,CAACtH,WAAP,IAAsBW,uBAA1B,EAAmD;YAC/CwB,OAAO,CAAC4C,MAAR,CAAe;cACXlC,IAAI,EAAEyB,SADK;cAEXU,SAAS,EAAE,kBAFA;cAGXC,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYgD,KAAZ,CAHV;cAIXpC,IAAI,EAAE;gBAAE1B,IAAI,EAAE8D,KAAK,CAAC9D;cAAd;YAJK,CAAf;UAMH;;UACD,IAAIqC,eAAe,CAACyB,KAAK,CAAC9D,IAAP,CAAnB,EAAiC;YAC7BrB,OAAO,CAAC4C,MAAR,CAAe;cACXlC,IAAI,EAAEyB,SADK;cAEXU,SAAS,EAAE,gBAFA;cAGXC,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYgD,KAAZ,CAHV;cAIXpC,IAAI,EAAE;gBAAE1B,IAAI,EAAE8D,KAAK,CAAC9D;cAAd;YAJK,CAAf;UAMH,CAPD,MAOO,IAAI8D,KAAK,CAAC9D,IAAN,CAAW+D,OAAX,CAAmB,GAAnB,MAA4B,CAAC,CAAjC,EAAoC;YACvC1B,eAAe,CAACyB,KAAK,CAAC9D,IAAP,CAAf,GAA8B8D,KAA9B;UACH;QACJ,CA3BD;;QA6BA,IAAIvB,UAAJ,EAAgB;UACZ,IAAI,CAACtF,aAAD,IAAkB,CAACkF,YAAY,CAAC3C,aAAhC,KAAkDgD,UAAU,CAAClG,IAAX,KAAoB,IAApB,IAA4B,CAACwD,iBAAiB,CAAC0C,UAAD,CAAhG,KAAiH,CAACI,UAAtH,EAAkI;YAC9HjE,OAAO,CAAC4C,MAAR,CAAe;cACXlC,IAAI,EAAEyB,SADK;cAEXU,SAAS,EAAE,eAFA;cAGXC,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAY0B,UAAZ,CAHV;cAIXd,IAAI,EAAE;gBACF4B,KAAK,EAAEd,UAAU,CAACc;cADhB;YAJK,CAAf;UAQH,CATD,MASO;YACH,IAAIhG,iBAAiB,IAAI,CAACkF,UAAU,CAAClG,IAArC,EAA2C;cACvCqC,OAAO,CAAC4C,MAAR,CAAe;gBAAElC,IAAI,EAAEyB,SAAR;gBAAmBU,SAAS,EAAE;cAA9B,CAAf;YACH;;YAED,IAAI,CAAC1B,iBAAiB,CAAC0C,UAAD,CAAlB,IAAkC,CAACA,UAAU,CAAChG,WAA9C,IAA6DY,wBAAjE,EAA2F;cACvFuB,OAAO,CAAC4C,MAAR,CAAe;gBAAElC,IAAI,EAAEyB,SAAR;gBAAmBU,SAAS,EAAE;cAA9B,CAAf;YACH;UACJ;QACJ,CA5IU,CA8IX;;;QACA,IAAI,CAACmB,UAAD,IAAe,CAACJ,UAAhB,IAA8B,CAACE,cAA/B,IAAiD,CAACC,WAAlD,IACArD,IAAI,CAAC2E,MAAL,CAAYC,IAAZ,KAAqB,KADrB,IAC8B5E,IAAI,CAAC2E,MAAL,CAAYC,IAAZ,KAAqB,aADnD,IAEA5E,IAAI,CAAC2E,MAAL,CAAYC,IAAZ,KAAqB,KAFrB,IAE8B,CAAC7E,WAAW,CAACC,IAAD,CAF9C,EAEsD;UAClD,IAAIpC,aAAa,IAAKkF,YAAY,CAAC3C,aAAb,IAA8B,CAACH,IAAI,CAACK,KAA1D,EAAkE;YAC9Df,OAAO,CAAC4C,MAAR,CAAe;cACXlC,IAAI,EAAEyB,SADK;cAEXU,SAAS,EAAE,eAFA;cAGXE,IAAI,EAAE;gBACFwC,OAAO,EAAEpH,MAAM,CAACoH,OAAP,IAAkB;cADzB;YAHK,CAAf;UAOH;QACJ,CA3JU,CA6JX;;;QACA,MAAMC,eAAe,GAAGnF,MAAM,CAACC,IAAP,CAAYoD,eAAZ,CAAxB;;QAEA,IAAIhD,IAAI,CAAC+E,MAAT,EAAiB;UACb/E,IAAI,CAAC+E,MAAL,CAAYhD,OAAZ,CAAoB,CAAC0C,KAAD,EAAQO,WAAR,KAAwB;YACxC,MAAMC,YAAY,GAAGR,KAAK,CAACxH,IAAN,KAAe,mBAAf,GACfwH,KAAK,CAACS,IADS,GAEfT,KAFN,CADwC,CAKxC;;YACA,IAAIQ,YAAY,CAAChI,IAAb,KAAsB,YAA1B,EAAwC;cACpC,MAAM0D,IAAI,GAAGsE,YAAY,CAACtE,IAA1B;;cAEA,IAAImE,eAAe,CAACE,WAAD,CAAf,IAAiCrE,IAAI,KAAKmE,eAAe,CAACE,WAAD,CAA7D,EAA6E;gBACzE1F,OAAO,CAAC4C,MAAR,CAAe;kBACXlC,IAAI,EAAEyB,SADK;kBAEXU,SAAS,EAAE,UAFA;kBAGXC,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYuB,eAAe,CAAC8B,eAAe,CAACE,WAAD,CAAhB,CAA3B,CAHV;kBAIX3C,IAAI,EAAE;oBACF1B,IADE;oBAEFwE,SAAS,EAAEL,eAAe,CAACE,WAAD;kBAFxB;gBAJK,CAAf;cASH,CAVD,MAUO,IAAI,CAAChC,eAAe,CAACrC,IAAD,CAAhB,IAA0B,CAAC2C,UAA/B,EAA2C;gBAC9ChE,OAAO,CAAC4C,MAAR,CAAe;kBACXlC,IAAI,EAAEyB,SADK;kBAEXU,SAAS,EAAE,cAFA;kBAGXE,IAAI,EAAE;oBACF1B;kBADE;gBAHK,CAAf;cAOH;YACJ;UACJ,CA7BD;QA8BH;;QAED,IAAIpB,OAAO,CAACvB,gBAAZ,EAA8B;UAC1B,MAAMoH,KAAK,GAAG,IAAIC,MAAJ,CAAW9F,OAAO,CAACvB,gBAAnB,EAAqC,GAArC,CAAd;;UAEA,IAAI,CAACoH,KAAK,CAACtB,IAAN,CAAWN,KAAK,CAACrG,WAAjB,CAAL,EAAoC;YAChCmC,OAAO,CAAC4C,MAAR,CAAe;cAAElC,IAAI,EAAEyB,SAAR;cAAmBU,SAAS,EAAE;YAA9B,CAAf;UACH;QACJ;MAEJ;IAEJ,CAhZW,CAkZZ;IACA;IACA;;;IAEA,OAAO;MACHmD,uBAAuB,EAAErF,aADtB;MAEHsF,kBAAkB,EAAEtF,aAFjB;MAGHuF,mBAAmB,EAAEvF,aAHlB;MAIHwF,eAAe,EAAExF,aAJd;MAKHyF,gBAAgB,EAAEzF,aALf;MAMH,gCAAgC2C,UAN7B;MAOH,2BAA2BA,UAPxB;MAQH,4BAA4BA,UARzB;MASH,wBAAwBA,UATrB;MAUH,yBAAyBA,UAVtB;MAWH+C,eAAe,EAAErF;IAXd,CAAP;EAcH;;AAjfY,CAAjB"},"metadata":{},"sourceType":"script"}