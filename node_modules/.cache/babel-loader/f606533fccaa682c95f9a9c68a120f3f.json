{"ast":null,"code":"/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\n\n\nfunction getEmptyLineNums(lines) {\n  const emptyLines = lines.map((line, i) => ({\n    code: line.trim(),\n    num: i + 1\n  })).filter(line => !line.code).map(line => line.num);\n  return emptyLines;\n}\n/**\n * Return an array with with any line numbers that contain comments.\n * @param {Array} comments An array of comment tokens.\n * @returns {Array} An array of line numbers.\n */\n\n\nfunction getCommentLineNums(comments) {\n  const lines = [];\n  comments.forEach(token => {\n    const start = token.loc.start.line;\n    const end = token.loc.end.line;\n    lines.push(start, end);\n  });\n  return lines;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require empty lines around comments\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-around-comment\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        beforeBlockComment: {\n          type: \"boolean\",\n          default: true\n        },\n        afterBlockComment: {\n          type: \"boolean\",\n          default: false\n        },\n        beforeLineComment: {\n          type: \"boolean\",\n          default: false\n        },\n        afterLineComment: {\n          type: \"boolean\",\n          default: false\n        },\n        allowBlockStart: {\n          type: \"boolean\",\n          default: false\n        },\n        allowBlockEnd: {\n          type: \"boolean\",\n          default: false\n        },\n        allowClassStart: {\n          type: \"boolean\"\n        },\n        allowClassEnd: {\n          type: \"boolean\"\n        },\n        allowObjectStart: {\n          type: \"boolean\"\n        },\n        allowObjectEnd: {\n          type: \"boolean\"\n        },\n        allowArrayStart: {\n          type: \"boolean\"\n        },\n        allowArrayEnd: {\n          type: \"boolean\"\n        },\n        ignorePattern: {\n          type: \"string\"\n        },\n        applyDefaultIgnorePatterns: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      after: \"Expected line after comment.\",\n      before: \"Expected line before comment.\"\n    }\n  },\n\n  create(context) {\n    const options = Object.assign({}, context.options[0]);\n    const ignorePattern = options.ignorePattern;\n    const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n    const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n    const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n    options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n    const sourceCode = context.getSourceCode();\n    const lines = sourceCode.lines,\n          numLines = lines.length + 1,\n          comments = sourceCode.getAllComments(),\n          commentLines = getCommentLineNums(comments),\n          emptyLines = getEmptyLineNums(lines),\n          commentAndEmptyLines = commentLines.concat(emptyLines);\n    /**\n     * Returns whether or not comments are on lines starting with or ending with code\n     * @param {token} token The comment token to check.\n     * @returns {boolean} True if the comment is not alone.\n     */\n\n    function codeAroundComment(token) {\n      let currentToken = token;\n\n      do {\n        currentToken = sourceCode.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      } while (currentToken && astUtils.isCommentToken(currentToken));\n\n      if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n        return true;\n      }\n\n      currentToken = token;\n\n      do {\n        currentToken = sourceCode.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      } while (currentToken && astUtils.isCommentToken(currentToken));\n\n      if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Returns whether or not comments are inside a node type or not.\n     * @param {ASTNode} parent The Comment parent node.\n     * @param {string} nodeType The parent type to check against.\n     * @returns {boolean} True if the comment is inside nodeType.\n     */\n\n\n    function isParentNodeType(parent, nodeType) {\n      return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;\n    }\n    /**\n     * Returns the parent node that contains the given token.\n     * @param {token} token The token to check.\n     * @returns {ASTNode} The parent node that contains the given token.\n     */\n\n\n    function getParentNodeOfToken(token) {\n      return sourceCode.getNodeByRangeIndex(token.range[0]);\n    }\n    /**\n     * Returns whether or not comments are at the parent start or not.\n     * @param {token} token The Comment token.\n     * @param {string} nodeType The parent type to check against.\n     * @returns {boolean} True if the comment is at parent start.\n     */\n\n\n    function isCommentAtParentStart(token, nodeType) {\n      const parent = getParentNodeOfToken(token);\n      return parent && isParentNodeType(parent, nodeType) && token.loc.start.line - parent.loc.start.line === 1;\n    }\n    /**\n     * Returns whether or not comments are at the parent end or not.\n     * @param {token} token The Comment token.\n     * @param {string} nodeType The parent type to check against.\n     * @returns {boolean} True if the comment is at parent end.\n     */\n\n\n    function isCommentAtParentEnd(token, nodeType) {\n      const parent = getParentNodeOfToken(token);\n      return parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;\n    }\n    /**\n     * Returns whether or not comments are at the block start or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at block start.\n     */\n\n\n    function isCommentAtBlockStart(token) {\n      return isCommentAtParentStart(token, \"ClassBody\") || isCommentAtParentStart(token, \"BlockStatement\") || isCommentAtParentStart(token, \"SwitchCase\");\n    }\n    /**\n     * Returns whether or not comments are at the block end or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at block end.\n     */\n\n\n    function isCommentAtBlockEnd(token) {\n      return isCommentAtParentEnd(token, \"ClassBody\") || isCommentAtParentEnd(token, \"BlockStatement\") || isCommentAtParentEnd(token, \"SwitchCase\") || isCommentAtParentEnd(token, \"SwitchStatement\");\n    }\n    /**\n     * Returns whether or not comments are at the class start or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at class start.\n     */\n\n\n    function isCommentAtClassStart(token) {\n      return isCommentAtParentStart(token, \"ClassBody\");\n    }\n    /**\n     * Returns whether or not comments are at the class end or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at class end.\n     */\n\n\n    function isCommentAtClassEnd(token) {\n      return isCommentAtParentEnd(token, \"ClassBody\");\n    }\n    /**\n     * Returns whether or not comments are at the object start or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at object start.\n     */\n\n\n    function isCommentAtObjectStart(token) {\n      return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n    }\n    /**\n     * Returns whether or not comments are at the object end or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at object end.\n     */\n\n\n    function isCommentAtObjectEnd(token) {\n      return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n    }\n    /**\n     * Returns whether or not comments are at the array start or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at array start.\n     */\n\n\n    function isCommentAtArrayStart(token) {\n      return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n    }\n    /**\n     * Returns whether or not comments are at the array end or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at array end.\n     */\n\n\n    function isCommentAtArrayEnd(token) {\n      return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n    }\n    /**\n     * Checks if a comment token has lines around it (ignores inline comments)\n     * @param {token} token The Comment token.\n     * @param {Object} opts Options to determine the newline.\n     * @param {boolean} opts.after Should have a newline after this line.\n     * @param {boolean} opts.before Should have a newline before this line.\n     * @returns {void}\n     */\n\n\n    function checkForEmptyLine(token, opts) {\n      if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n        return;\n      }\n\n      if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n        return;\n      }\n\n      let after = opts.after,\n          before = opts.before;\n      const prevLineNum = token.loc.start.line - 1,\n            nextLineNum = token.loc.end.line + 1,\n            commentIsNotAlone = codeAroundComment(token);\n      const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)),\n            blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\n            classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\n            classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\n            objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n            objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n            arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n            arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n      const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;\n      const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed; // ignore top of the file and bottom of the file\n\n      if (prevLineNum < 1) {\n        before = false;\n      }\n\n      if (nextLineNum >= numLines) {\n        after = false;\n      } // we ignore all inline comments\n\n\n      if (commentIsNotAlone) {\n        return;\n      }\n\n      const previousTokenOrComment = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      const nextTokenOrComment = sourceCode.getTokenAfter(token, {\n        includeComments: true\n      }); // check for newline before\n\n      if (!exceptionStartAllowed && before && !commentAndEmptyLines.includes(prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n        const lineStart = token.range[0] - token.loc.start.column;\n        const range = [lineStart, lineStart];\n        context.report({\n          node: token,\n          messageId: \"before\",\n\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\n\");\n          }\n\n        });\n      } // check for newline after\n\n\n      if (!exceptionEndAllowed && after && !commentAndEmptyLines.includes(nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n        context.report({\n          node: token,\n          messageId: \"after\",\n\n          fix(fixer) {\n            return fixer.insertTextAfter(token, \"\\n\");\n          }\n\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program() {\n        comments.forEach(token => {\n          if (token.type === \"Line\") {\n            if (options.beforeLineComment || options.afterLineComment) {\n              checkForEmptyLine(token, {\n                after: options.afterLineComment,\n                before: options.beforeLineComment\n              });\n            }\n          } else if (token.type === \"Block\") {\n            if (options.beforeBlockComment || options.afterBlockComment) {\n              checkForEmptyLine(token, {\n                after: options.afterBlockComment,\n                before: options.beforeBlockComment\n              });\n            }\n          }\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","getEmptyLineNums","lines","emptyLines","map","line","i","code","trim","num","filter","getCommentLineNums","comments","forEach","token","start","loc","end","push","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","beforeBlockComment","default","afterBlockComment","beforeLineComment","afterLineComment","allowBlockStart","allowBlockEnd","allowClassStart","allowClassEnd","allowObjectStart","allowObjectEnd","allowArrayStart","allowArrayEnd","ignorePattern","applyDefaultIgnorePatterns","additionalProperties","messages","after","before","create","context","options","Object","assign","defaultIgnoreRegExp","COMMENTS_IGNORE_PATTERN","customIgnoreRegExp","RegExp","sourceCode","getSourceCode","numLines","length","getAllComments","commentLines","commentAndEmptyLines","concat","codeAroundComment","currentToken","getTokenBefore","includeComments","isCommentToken","isTokenOnSameLine","getTokenAfter","isParentNodeType","parent","nodeType","body","consequent","getParentNodeOfToken","getNodeByRangeIndex","range","isCommentAtParentStart","isCommentAtParentEnd","isCommentAtBlockStart","isCommentAtBlockEnd","isCommentAtClassStart","isCommentAtClassEnd","isCommentAtObjectStart","isCommentAtObjectEnd","isCommentAtArrayStart","isCommentAtArrayEnd","checkForEmptyLine","opts","test","value","prevLineNum","nextLineNum","commentIsNotAlone","blockStartAllowed","blockEndAllowed","classStartAllowed","classEndAllowed","objectStartAllowed","objectEndAllowed","arrayStartAllowed","arrayEndAllowed","exceptionStartAllowed","exceptionEndAllowed","previousTokenOrComment","nextTokenOrComment","includes","lineStart","column","report","node","messageId","fix","fixer","insertTextBeforeRange","insertTextAfter","Program"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/lines-around-comment.js"],"sourcesContent":["/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n    const emptyLines = lines.map((line, i) => ({\n        code: line.trim(),\n        num: i + 1\n    })).filter(line => !line.code).map(line => line.num);\n\n    return emptyLines;\n}\n\n/**\n * Return an array with with any line numbers that contain comments.\n * @param {Array} comments An array of comment tokens.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n    const lines = [];\n\n    comments.forEach(token => {\n        const start = token.loc.start.line;\n        const end = token.loc.end.line;\n\n        lines.push(start, end);\n    });\n    return lines;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require empty lines around comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-around-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    beforeBlockComment: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    afterBlockComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    beforeLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    afterLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockStart: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockEnd: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowClassStart: {\n                        type: \"boolean\"\n                    },\n                    allowClassEnd: {\n                        type: \"boolean\"\n                    },\n                    allowObjectStart: {\n                        type: \"boolean\"\n                    },\n                    allowObjectEnd: {\n                        type: \"boolean\"\n                    },\n                    allowArrayStart: {\n                        type: \"boolean\"\n                    },\n                    allowArrayEnd: {\n                        type: \"boolean\"\n                    },\n                    ignorePattern: {\n                        type: \"string\"\n                    },\n                    applyDefaultIgnorePatterns: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            after: \"Expected line after comment.\",\n            before: \"Expected line before comment.\"\n        }\n    },\n\n    create(context) {\n\n        const options = Object.assign({}, context.options[0]);\n        const ignorePattern = options.ignorePattern;\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n\n        options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n\n        const sourceCode = context.getSourceCode();\n\n        const lines = sourceCode.lines,\n            numLines = lines.length + 1,\n            comments = sourceCode.getAllComments(),\n            commentLines = getCommentLineNums(comments),\n            emptyLines = getEmptyLineNums(lines),\n            commentAndEmptyLines = commentLines.concat(emptyLines);\n\n        /**\n         * Returns whether or not comments are on lines starting with or ending with code\n         * @param {token} token The comment token to check.\n         * @returns {boolean} True if the comment is not alone.\n         */\n        function codeAroundComment(token) {\n            let currentToken = token;\n\n            do {\n                currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n                return true;\n            }\n\n            currentToken = token;\n            do {\n                currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are inside a node type or not.\n         * @param {ASTNode} parent The Comment parent node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is inside nodeType.\n         */\n        function isParentNodeType(parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }\n\n        /**\n         * Returns the parent node that contains the given token.\n         * @param {token} token The token to check.\n         * @returns {ASTNode} The parent node that contains the given token.\n         */\n        function getParentNodeOfToken(token) {\n            return sourceCode.getNodeByRangeIndex(token.range[0]);\n        }\n\n        /**\n         * Returns whether or not comments are at the parent start or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent start.\n         */\n        function isCommentAtParentStart(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return parent && isParentNodeType(parent, nodeType) &&\n                    token.loc.start.line - parent.loc.start.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent end or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent end.\n         */\n        function isCommentAtParentEnd(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return parent && isParentNodeType(parent, nodeType) &&\n                    parent.loc.end.line - token.loc.end.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the block start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block start.\n         */\n        function isCommentAtBlockStart(token) {\n            return isCommentAtParentStart(token, \"ClassBody\") || isCommentAtParentStart(token, \"BlockStatement\") || isCommentAtParentStart(token, \"SwitchCase\");\n        }\n\n        /**\n         * Returns whether or not comments are at the block end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block end.\n         */\n        function isCommentAtBlockEnd(token) {\n            return isCommentAtParentEnd(token, \"ClassBody\") || isCommentAtParentEnd(token, \"BlockStatement\") || isCommentAtParentEnd(token, \"SwitchCase\") || isCommentAtParentEnd(token, \"SwitchStatement\");\n        }\n\n        /**\n         * Returns whether or not comments are at the class start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class start.\n         */\n        function isCommentAtClassStart(token) {\n            return isCommentAtParentStart(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the class end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class end.\n         */\n        function isCommentAtClassEnd(token) {\n            return isCommentAtParentEnd(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object start.\n         */\n        function isCommentAtObjectStart(token) {\n            return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object end.\n         */\n        function isCommentAtObjectEnd(token) {\n            return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array start.\n         */\n        function isCommentAtArrayStart(token) {\n            return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array end.\n         */\n        function isCommentAtArrayEnd(token) {\n            return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Checks if a comment token has lines around it (ignores inline comments)\n         * @param {token} token The Comment token.\n         * @param {Object} opts Options to determine the newline.\n         * @param {boolean} opts.after Should have a newline after this line.\n         * @param {boolean} opts.before Should have a newline before this line.\n         * @returns {void}\n         */\n        function checkForEmptyLine(token, opts) {\n            if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            let after = opts.after,\n                before = opts.before;\n\n            const prevLineNum = token.loc.start.line - 1,\n                nextLineNum = token.loc.end.line + 1,\n                commentIsNotAlone = codeAroundComment(token);\n\n            const blockStartAllowed = options.allowBlockStart &&\n                    isCommentAtBlockStart(token) &&\n                    !(options.allowClassStart === false &&\n                    isCommentAtClassStart(token)),\n                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\n                classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\n                classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\n                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n\n            const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;\n            const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n            // ignore top of the file and bottom of the file\n            if (prevLineNum < 1) {\n                before = false;\n            }\n            if (nextLineNum >= numLines) {\n                after = false;\n            }\n\n            // we ignore all inline comments\n            if (commentIsNotAlone) {\n                return;\n            }\n\n            const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });\n            const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });\n\n            // check for newline before\n            if (!exceptionStartAllowed && before && !commentAndEmptyLines.includes(prevLineNum) &&\n                    !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n                const lineStart = token.range[0] - token.loc.start.column;\n                const range = [lineStart, lineStart];\n\n                context.report({\n                    node: token,\n                    messageId: \"before\",\n                    fix(fixer) {\n                        return fixer.insertTextBeforeRange(range, \"\\n\");\n                    }\n                });\n            }\n\n            // check for newline after\n            if (!exceptionEndAllowed && after && !commentAndEmptyLines.includes(nextLineNum) &&\n                    !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n                context.report({\n                    node: token,\n                    messageId: \"after\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \"\\n\");\n                    }\n                });\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                comments.forEach(token => {\n                    if (token.type === \"Line\") {\n                        if (options.beforeLineComment || options.afterLineComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterLineComment,\n                                before: options.beforeLineComment\n                            });\n                        }\n                    } else if (token.type === \"Block\") {\n                        if (options.beforeBlockComment || options.afterBlockComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterBlockComment,\n                                before: options.beforeBlockComment\n                            });\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}