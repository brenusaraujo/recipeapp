{"ast":null,"code":"/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require the use of `===` and `!==`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eqeqeq\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\"]\n        }, {\n          type: \"object\",\n          properties: {\n            null: {\n              enum: [\"always\", \"never\", \"ignore\"]\n            }\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"smart\", \"allow-null\"]\n        }],\n        additionalItems: false\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || \"always\";\n    const options = context.options[1] || {};\n    const sourceCode = context.getSourceCode();\n    const nullOption = config === \"always\" ? options.null || \"always\" : \"ignore\";\n    const enforceRuleForNull = nullOption === \"always\";\n    const enforceInverseRuleForNull = nullOption === \"never\";\n    /**\n     * Checks if an expression is a typeof expression\n     * @param  {ASTNode} node The node to check\n     * @returns {boolean} if the node is a typeof expression\n     */\n\n    function isTypeOf(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    }\n    /**\n     * Checks if either operand of a binary expression is a typeof operation\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if one of the operands is typeof\n     * @private\n     */\n\n\n    function isTypeOfBinary(node) {\n      return isTypeOf(node.left) || isTypeOf(node.right);\n    }\n    /**\n     * Checks if operands are literals of the same type (via typeof)\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if operands are of same type\n     * @private\n     */\n\n\n    function areLiteralsAndSameType(node) {\n      return node.left.type === \"Literal\" && node.right.type === \"Literal\" && typeof node.left.value === typeof node.right.value;\n    }\n    /**\n     * Checks if one of the operands is a literal null\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if operands are null\n     * @private\n     */\n\n\n    function isNullCheck(node) {\n      return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n    }\n    /**\n     * Reports a message for this rule.\n     * @param {ASTNode} node The binary expression node that was checked\n     * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n     * @returns {void}\n     * @private\n     */\n\n\n    function report(node, expectedOperator) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      context.report({\n        node,\n        loc: operatorToken.loc,\n        messageId: \"unexpected\",\n        data: {\n          expectedOperator,\n          actualOperator: node.operator\n        },\n\n        fix(fixer) {\n          // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n          if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n            return fixer.replaceText(operatorToken, expectedOperator);\n          }\n\n          return null;\n        }\n\n      });\n    }\n\n    return {\n      BinaryExpression(node) {\n        const isNull = isNullCheck(node);\n\n        if (node.operator !== \"==\" && node.operator !== \"!=\") {\n          if (enforceInverseRuleForNull && isNull) {\n            report(node, node.operator.slice(0, -1));\n          }\n\n          return;\n        }\n\n        if (config === \"smart\" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {\n          return;\n        }\n\n        if (!enforceRuleForNull && isNull) {\n          return;\n        }\n\n        report(node, `${node.operator}=`);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","properties","null","additionalProperties","additionalItems","fixable","messages","unexpected","create","context","config","options","sourceCode","getSourceCode","nullOption","enforceRuleForNull","enforceInverseRuleForNull","isTypeOf","node","operator","isTypeOfBinary","left","right","areLiteralsAndSameType","value","isNullCheck","isNullLiteral","report","expectedOperator","operatorToken","getFirstTokenBetween","token","loc","messageId","data","actualOperator","fix","fixer","replaceText","BinaryExpression","isNull","slice"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/eqeqeq.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require the use of `===` and `!==`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eqeqeq\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                null: {\n                                    enum: [\"always\", \"never\", \"ignore\"]\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    additionalItems: false\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"smart\", \"allow-null\"]\n                        }\n                    ],\n                    additionalItems: false\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || \"always\";\n        const options = context.options[1] || {};\n        const sourceCode = context.getSourceCode();\n\n        const nullOption = (config === \"always\")\n            ? options.null || \"always\"\n            : \"ignore\";\n        const enforceRuleForNull = (nullOption === \"always\");\n        const enforceInverseRuleForNull = (nullOption === \"never\");\n\n        /**\n         * Checks if an expression is a typeof expression\n         * @param  {ASTNode} node The node to check\n         * @returns {boolean} if the node is a typeof expression\n         */\n        function isTypeOf(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        /**\n         * Checks if either operand of a binary expression is a typeof operation\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if one of the operands is typeof\n         * @private\n         */\n        function isTypeOfBinary(node) {\n            return isTypeOf(node.left) || isTypeOf(node.right);\n        }\n\n        /**\n         * Checks if operands are literals of the same type (via typeof)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are of same type\n         * @private\n         */\n        function areLiteralsAndSameType(node) {\n            return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\n                    typeof node.left.value === typeof node.right.value;\n        }\n\n        /**\n         * Checks if one of the operands is a literal null\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are null\n         * @private\n         */\n        function isNullCheck(node) {\n            return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n        }\n\n        /**\n         * Reports a message for this rule.\n         * @param {ASTNode} node The binary expression node that was checked\n         * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n         * @returns {void}\n         * @private\n         */\n        function report(node, expectedOperator) {\n            const operatorToken = sourceCode.getFirstTokenBetween(\n                node.left,\n                node.right,\n                token => token.value === node.operator\n            );\n\n            context.report({\n                node,\n                loc: operatorToken.loc,\n                messageId: \"unexpected\",\n                data: { expectedOperator, actualOperator: node.operator },\n                fix(fixer) {\n\n                    // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n                    if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n                        return fixer.replaceText(operatorToken, expectedOperator);\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            BinaryExpression(node) {\n                const isNull = isNullCheck(node);\n\n                if (node.operator !== \"==\" && node.operator !== \"!=\") {\n                    if (enforceInverseRuleForNull && isNull) {\n                        report(node, node.operator.slice(0, -1));\n                    }\n                    return;\n                }\n\n                if (config === \"smart\" && (isTypeOfBinary(node) ||\n                        areLiteralsAndSameType(node) || isNull)) {\n                    return;\n                }\n\n                if (!enforceRuleForNull && isNull) {\n                    return;\n                }\n\n                report(node, `${node.operator}=`);\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}