{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\n\nfunction parseOptions(options) {\n  let functions = true;\n  let classes = true;\n  let variables = true;\n\n  if (typeof options === \"string\") {\n    functions = options !== \"nofunc\";\n  } else if (typeof options === \"object\" && options !== null) {\n    functions = options.functions !== false;\n    classes = options.classes !== false;\n    variables = options.variables !== false;\n  }\n\n  return {\n    functions,\n    classes,\n    variables\n  };\n}\n/**\n * Checks whether or not a given variable is a function declaration.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\n\n\nfunction isFunction(variable) {\n  return variable.defs[0].type === \"FunctionName\";\n}\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\n\n\nfunction isOuterClass(variable, reference) {\n  return variable.defs[0].type === \"ClassName\" && variable.scope.variableScope !== reference.from.variableScope;\n}\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a variable declaration.\n */\n\n\nfunction isOuterVariable(variable, reference) {\n  return variable.defs[0].type === \"Variable\" && variable.scope.variableScope !== reference.from.variableScope;\n}\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\n\n\nfunction isInRange(node, location) {\n  return node && node.range[0] <= location && location <= node.range[1];\n}\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n * @param {Variable} variable A variable to check.\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\n\n\nfunction isInInitializer(variable, reference) {\n  if (variable.scope !== reference.from) {\n    return false;\n  }\n\n  let node = variable.identifiers[0].parent;\n  const location = reference.identifier.range[1];\n\n  while (node) {\n    if (node.type === \"VariableDeclarator\") {\n      if (isInRange(node.init, location)) {\n        return true;\n      }\n\n      if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {\n        return true;\n      }\n\n      break;\n    } else if (node.type === \"AssignmentPattern\") {\n      if (isInRange(node.right, location)) {\n        return true;\n      }\n    } else if (SENTINEL_TYPE.test(node.type)) {\n      break;\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow the use of variables before they are defined\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-use-before-define\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"nofunc\"]\n      }, {\n        type: \"object\",\n        properties: {\n          functions: {\n            type: \"boolean\"\n          },\n          classes: {\n            type: \"boolean\"\n          },\n          variables: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n    }\n  },\n\n  create(context) {\n    const options = parseOptions(context.options[0]);\n    /**\n     * Determines whether a given use-before-define case should be reported according to the options.\n     * @param {eslint-scope.Variable} variable The variable that gets used before being defined\n     * @param {eslint-scope.Reference} reference The reference to the variable\n     * @returns {boolean} `true` if the usage should be reported\n     */\n\n    function isForbidden(variable, reference) {\n      if (isFunction(variable)) {\n        return options.functions;\n      }\n\n      if (isOuterClass(variable, reference)) {\n        return options.classes;\n      }\n\n      if (isOuterVariable(variable, reference)) {\n        return options.variables;\n      }\n\n      return true;\n    }\n    /**\n     * Finds and validates all variables in a given scope.\n     * @param {Scope} scope The scope object.\n     * @returns {void}\n     * @private\n     */\n\n\n    function findVariablesInScope(scope) {\n      scope.references.forEach(reference => {\n        const variable = reference.resolved;\n        /*\n         * Skips when the reference is:\n         * - initialization's.\n         * - referring to an undefined variable.\n         * - referring to a global environment variable (there're no identifiers).\n         * - located preceded by the variable (except in initializers).\n         * - allowed by options.\n         */\n\n        if (reference.init || !variable || variable.identifiers.length === 0 || variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference) || !isForbidden(variable, reference)) {\n          return;\n        } // Reports.\n\n\n        context.report({\n          node: reference.identifier,\n          messageId: \"usedBeforeDefined\",\n          data: reference.identifier\n        });\n      });\n      scope.childScopes.forEach(findVariablesInScope);\n    }\n\n    return {\n      Program() {\n        findVariablesInScope(context.getScope());\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["SENTINEL_TYPE","FOR_IN_OF_TYPE","parseOptions","options","functions","classes","variables","isFunction","variable","defs","type","isOuterClass","reference","scope","variableScope","from","isOuterVariable","isInRange","node","location","range","isInInitializer","identifiers","parent","identifier","init","test","right","module","exports","meta","docs","description","category","recommended","url","schema","oneOf","enum","properties","additionalProperties","messages","usedBeforeDefined","create","context","isForbidden","findVariablesInScope","references","forEach","resolved","length","report","messageId","data","childScopes","Program","getScope"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-use-before-define.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let variables = true;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        variables = options.variables !== false;\n    }\n\n    return { functions, classes, variables };\n}\n\n/**\n * Checks whether or not a given variable is a function declaration.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\nfunction isFunction(variable) {\n    return variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\nfunction isOuterClass(variable, reference) {\n    return (\n        variable.defs[0].type === \"ClassName\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a variable declaration.\n */\nfunction isOuterVariable(variable, reference) {\n    return (\n        variable.defs[0].type === \"Variable\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n * @param {Variable} variable A variable to check.\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\nfunction isInInitializer(variable, reference) {\n    if (variable.scope !== reference.from) {\n        return false;\n    }\n\n    let node = variable.identifiers[0].parent;\n    const location = reference.identifier.range[1];\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow the use of variables before they are defined\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-use-before-define\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n\n        /**\n         * Determines whether a given use-before-define case should be reported according to the options.\n         * @param {eslint-scope.Variable} variable The variable that gets used before being defined\n         * @param {eslint-scope.Reference} reference The reference to the variable\n         * @returns {boolean} `true` if the usage should be reported\n         */\n        function isForbidden(variable, reference) {\n            if (isFunction(variable)) {\n                return options.functions;\n            }\n            if (isOuterClass(variable, reference)) {\n                return options.classes;\n            }\n            if (isOuterVariable(variable, reference)) {\n                return options.variables;\n            }\n            return true;\n        }\n\n        /**\n         * Finds and validates all variables in a given scope.\n         * @param {Scope} scope The scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.references.forEach(reference => {\n                const variable = reference.resolved;\n\n                /*\n                 * Skips when the reference is:\n                 * - initialization's.\n                 * - referring to an undefined variable.\n                 * - referring to a global environment variable (there're no identifiers).\n                 * - located preceded by the variable (except in initializers).\n                 * - allowed by options.\n                 */\n                if (reference.init ||\n                    !variable ||\n                    variable.identifiers.length === 0 ||\n                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||\n                    !isForbidden(variable, reference)\n                ) {\n                    return;\n                }\n\n                // Reports.\n                context.report({\n                    node: reference.identifier,\n                    messageId: \"usedBeforeDefined\",\n                    data: reference.identifier\n                });\n            });\n\n            scope.childScopes.forEach(findVariablesInScope);\n        }\n\n        return {\n            Program() {\n                findVariablesInScope(context.getScope());\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}