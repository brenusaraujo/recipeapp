{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"eslint-utils\");\n\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = require(\"regexpp\");\n\nconst {\n  isCombiningCharacter,\n  isEmojiModifier,\n  isRegionalIndicatorSymbol,\n  isSurrogatePair\n} = require(\"./utils/unicode\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\n\n\nfunction* iterateCharacterSequence(nodes) {\n  let seq = [];\n\n  for (const node of nodes) {\n    switch (node.type) {\n      case \"Character\":\n        seq.push(node.value);\n        break;\n\n      case \"CharacterClassRange\":\n        seq.push(node.min.value);\n        yield seq;\n        seq = [node.max.value];\n        break;\n\n      case \"CharacterSet\":\n        if (seq.length > 0) {\n          yield seq;\n          seq = [];\n        }\n\n        break;\n      // no default\n    }\n  }\n\n  if (seq.length > 0) {\n    yield seq;\n  }\n}\n\nconst hasCharacterSequence = {\n  surrogatePairWithoutUFlag(chars) {\n    return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n  },\n\n  combiningClass(chars) {\n    return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));\n  },\n\n  emojiModifier(chars) {\n    return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));\n  },\n\n  regionalIndicatorSymbol(chars) {\n    return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));\n  },\n\n  zwj(chars) {\n    const lastIndex = chars.length - 1;\n    return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 0x200d && chars[i - 1] !== 0x200d && chars[i + 1] !== 0x200d);\n  }\n\n};\nconst kinds = Object.keys(hasCharacterSequence); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow characters which are made with multiple code points in character class syntax\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n    },\n    schema: [],\n    messages: {\n      surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n      combiningClass: \"Unexpected combined character in character class.\",\n      emojiModifier: \"Unexpected modified Emoji in character class.\",\n      regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n      zwj: \"Unexpected joined character sequence in character class.\"\n    }\n  },\n\n  create(context) {\n    const parser = new RegExpParser();\n    /**\n     * Verify a given regular expression.\n     * @param {Node} node The node to report.\n     * @param {string} pattern The regular expression pattern to verify.\n     * @param {string} flags The flags of the regular expression.\n     * @returns {void}\n     */\n\n    function verify(node, pattern, flags) {\n      const has = {\n        surrogatePairWithoutUFlag: false,\n        combiningClass: false,\n        variationSelector: false,\n        emojiModifier: false,\n        regionalIndicatorSymbol: false,\n        zwj: false\n      };\n      let patternNode;\n\n      try {\n        patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n\n      visitRegExpAST(patternNode, {\n        onCharacterClassEnter(ccNode) {\n          for (const chars of iterateCharacterSequence(ccNode.elements)) {\n            for (const kind of kinds) {\n              has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n            }\n          }\n        }\n\n      });\n\n      for (const kind of kinds) {\n        if (has[kind]) {\n          context.report({\n            node,\n            messageId: kind\n          });\n        }\n      }\n    }\n\n    return {\n      \"Literal[regex]\"(node) {\n        verify(node, node.regex.pattern, node.regex.flags);\n      },\n\n      \"Program\"() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        /*\n         * Iterate calls of RegExp.\n         * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n         *       `const {RegExp: a} = window; new a()`, etc...\n         */\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences({\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        })) {\n          const [patternNode, flagsNode] = node.arguments;\n          const pattern = getStringIfConstant(patternNode, scope);\n          const flags = getStringIfConstant(flagsNode, scope);\n\n          if (typeof pattern === \"string\") {\n            verify(node, pattern, flags || \"\");\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","require","RegExpParser","visitRegExpAST","isCombiningCharacter","isEmojiModifier","isRegionalIndicatorSymbol","isSurrogatePair","iterateCharacterSequence","nodes","seq","node","type","push","value","min","max","length","hasCharacterSequence","surrogatePairWithoutUFlag","chars","some","c","i","combiningClass","emojiModifier","regionalIndicatorSymbol","zwj","lastIndex","kinds","Object","keys","module","exports","meta","docs","description","category","recommended","url","schema","messages","create","context","parser","verify","pattern","flags","has","variationSelector","patternNode","parsePattern","includes","onCharacterClassEnter","ccNode","elements","kind","report","messageId","regex","scope","getScope","tracker","iterateGlobalReferences","RegExp","flagsNode","arguments"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-misleading-character-class.js"],"sourcesContent":["/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\nconst { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require(\"./utils/unicode\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\nfunction *iterateCharacterSequence(nodes) {\n    let seq = [];\n\n    for (const node of nodes) {\n        switch (node.type) {\n            case \"Character\":\n                seq.push(node.value);\n                break;\n\n            case \"CharacterClassRange\":\n                seq.push(node.min.value);\n                yield seq;\n                seq = [node.max.value];\n                break;\n\n            case \"CharacterSet\":\n                if (seq.length > 0) {\n                    yield seq;\n                    seq = [];\n                }\n                break;\n\n            // no default\n        }\n    }\n\n    if (seq.length > 0) {\n        yield seq;\n    }\n}\n\nconst hasCharacterSequence = {\n    surrogatePairWithoutUFlag(chars) {\n        return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n    },\n\n    combiningClass(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isCombiningCharacter(c) &&\n            !isCombiningCharacter(chars[i - 1])\n        ));\n    },\n\n    emojiModifier(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isEmojiModifier(c) &&\n            !isEmojiModifier(chars[i - 1])\n        ));\n    },\n\n    regionalIndicatorSymbol(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isRegionalIndicatorSymbol(c) &&\n            isRegionalIndicatorSymbol(chars[i - 1])\n        ));\n    },\n\n    zwj(chars) {\n        const lastIndex = chars.length - 1;\n\n        return chars.some((c, i) => (\n            i !== 0 &&\n            i !== lastIndex &&\n            c === 0x200d &&\n            chars[i - 1] !== 0x200d &&\n            chars[i + 1] !== 0x200d\n        ));\n    }\n};\n\nconst kinds = Object.keys(hasCharacterSequence);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow characters which are made with multiple code points in character class syntax\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n        },\n\n        schema: [],\n\n        messages: {\n            surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n            combiningClass: \"Unexpected combined character in character class.\",\n            emojiModifier: \"Unexpected modified Emoji in character class.\",\n            regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n            zwj: \"Unexpected joined character sequence in character class.\"\n        }\n    },\n    create(context) {\n        const parser = new RegExpParser();\n\n        /**\n         * Verify a given regular expression.\n         * @param {Node} node The node to report.\n         * @param {string} pattern The regular expression pattern to verify.\n         * @param {string} flags The flags of the regular expression.\n         * @returns {void}\n         */\n        function verify(node, pattern, flags) {\n            const has = {\n                surrogatePairWithoutUFlag: false,\n                combiningClass: false,\n                variationSelector: false,\n                emojiModifier: false,\n                regionalIndicatorSymbol: false,\n                zwj: false\n            };\n            let patternNode;\n\n            try {\n                patternNode = parser.parsePattern(\n                    pattern,\n                    0,\n                    pattern.length,\n                    flags.includes(\"u\")\n                );\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter(ccNode) {\n                    for (const chars of iterateCharacterSequence(ccNode.elements)) {\n                        for (const kind of kinds) {\n                            has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n                        }\n                    }\n                }\n            });\n\n            for (const kind of kinds) {\n                if (has[kind]) {\n                    context.report({ node, messageId: kind });\n                }\n            }\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                verify(node, node.regex.pattern, node.regex.flags);\n            },\n            \"Program\"() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n\n                /*\n                 * Iterate calls of RegExp.\n                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n                 *       `const {RegExp: a} = window; new a()`, etc...\n                 */\n                for (const { node } of tracker.iterateGlobalReferences({\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                })) {\n                    const [patternNode, flagsNode] = node.arguments;\n                    const pattern = getStringIfConstant(patternNode, scope);\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        verify(node, pattern, flags || \"\");\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}