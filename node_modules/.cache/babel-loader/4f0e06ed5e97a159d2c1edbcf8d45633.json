{"ast":null,"code":"/**\n * @fileoverview Disallows or enforces spaces inside of parentheses.\n * @author Jonathan Rajavuori\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing inside parentheses\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-in-parens\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingOpeningSpace: \"There must be a space after this paren.\",\n      missingClosingSpace: \"There must be a space before this paren.\",\n      rejectedOpeningSpace: \"There should be no space after this paren.\",\n      rejectedClosingSpace: \"There should be no space before this paren.\"\n    }\n  },\n\n  create(context) {\n    const ALWAYS = context.options[0] === \"always\",\n          exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [],\n          options = {};\n    let exceptions;\n\n    if (exceptionsArrayOptions.length) {\n      options.braceException = exceptionsArrayOptions.includes(\"{}\");\n      options.bracketException = exceptionsArrayOptions.includes(\"[]\");\n      options.parenException = exceptionsArrayOptions.includes(\"()\");\n      options.empty = exceptionsArrayOptions.includes(\"empty\");\n    }\n    /**\n     * Produces an object with the opener and closer exception values\n     * @returns {Object} `openers` and `closers` exception values\n     * @private\n     */\n\n\n    function getExceptions() {\n      const openers = [],\n            closers = [];\n\n      if (options.braceException) {\n        openers.push(\"{\");\n        closers.push(\"}\");\n      }\n\n      if (options.bracketException) {\n        openers.push(\"[\");\n        closers.push(\"]\");\n      }\n\n      if (options.parenException) {\n        openers.push(\"(\");\n        closers.push(\")\");\n      }\n\n      if (options.empty) {\n        openers.push(\")\");\n        closers.push(\"(\");\n      }\n\n      return {\n        openers,\n        closers\n      };\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n\n    const sourceCode = context.getSourceCode();\n    /**\n     * Determines if a token is one of the exceptions for the opener paren\n     * @param {Object} token The token to check\n     * @returns {boolean} True if the token is one of the exceptions for the opener paren\n     */\n\n    function isOpenerException(token) {\n      return exceptions.openers.includes(token.value);\n    }\n    /**\n     * Determines if a token is one of the exceptions for the closer paren\n     * @param {Object} token The token to check\n     * @returns {boolean} True if the token is one of the exceptions for the closer paren\n     */\n\n\n    function isCloserException(token) {\n      return exceptions.closers.includes(token.value);\n    }\n    /**\n     * Determines if an opening paren is immediately followed by a required space\n     * @param {Object} openingParenToken The paren token\n     * @param {Object} tokenAfterOpeningParen The token after it\n     * @returns {boolean} True if the opening paren is missing a required space\n     */\n\n\n    function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {\n      if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return !isOpenerException(tokenAfterOpeningParen);\n      }\n\n      return isOpenerException(tokenAfterOpeningParen);\n    }\n    /**\n     * Determines if an opening paren is immediately followed by a disallowed space\n     * @param {Object} openingParenToken The paren token\n     * @param {Object} tokenAfterOpeningParen The token after it\n     * @returns {boolean} True if the opening paren has a disallowed space\n     */\n\n\n    function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {\n      if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (tokenAfterOpeningParen.type === \"Line\") {\n        return false;\n      }\n\n      if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return isOpenerException(tokenAfterOpeningParen);\n      }\n\n      return !isOpenerException(tokenAfterOpeningParen);\n    }\n    /**\n     * Determines if a closing paren is immediately preceded by a required space\n     * @param {Object} tokenBeforeClosingParen The token before the paren\n     * @param {Object} closingParenToken The paren token\n     * @returns {boolean} True if the closing paren is missing a required space\n     */\n\n\n    function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {\n      if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n\n      if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return !isCloserException(tokenBeforeClosingParen);\n      }\n\n      return isCloserException(tokenBeforeClosingParen);\n    }\n    /**\n     * Determines if a closer paren is immediately preceded by a disallowed space\n     * @param {Object} tokenBeforeClosingParen The token before the paren\n     * @param {Object} closingParenToken The paren token\n     * @returns {boolean} True if the closing paren has a disallowed space\n     */\n\n\n    function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {\n      if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n\n      if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return isCloserException(tokenBeforeClosingParen);\n      }\n\n      return !isCloserException(tokenBeforeClosingParen);\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: function checkParenSpaces(node) {\n        exceptions = getExceptions();\n        const tokens = sourceCode.tokensAndComments;\n        tokens.forEach((token, i) => {\n          const prevToken = tokens[i - 1];\n          const nextToken = tokens[i + 1]; // if token is not an opening or closing paren token, do nothing\n\n          if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n            return;\n          } // if token is an opening paren and is not followed by a required space\n\n\n          if (token.value === \"(\" && openerMissingSpace(token, nextToken)) {\n            context.report({\n              node,\n              loc: token.loc,\n              messageId: \"missingOpeningSpace\",\n\n              fix(fixer) {\n                return fixer.insertTextAfter(token, \" \");\n              }\n\n            });\n          } // if token is an opening paren and is followed by a disallowed space\n\n\n          if (token.value === \"(\" && openerRejectsSpace(token, nextToken)) {\n            context.report({\n              node,\n              loc: {\n                start: token.loc.end,\n                end: nextToken.loc.start\n              },\n              messageId: \"rejectedOpeningSpace\",\n\n              fix(fixer) {\n                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n              }\n\n            });\n          } // if token is a closing paren and is not preceded by a required space\n\n\n          if (token.value === \")\" && closerMissingSpace(prevToken, token)) {\n            context.report({\n              node,\n              loc: token.loc,\n              messageId: \"missingClosingSpace\",\n\n              fix(fixer) {\n                return fixer.insertTextBefore(token, \" \");\n              }\n\n            });\n          } // if token is a closing paren and is preceded by a disallowed space\n\n\n          if (token.value === \")\" && closerRejectsSpace(prevToken, token)) {\n            context.report({\n              node,\n              loc: {\n                start: prevToken.loc.end,\n                end: token.loc.start\n              },\n              messageId: \"rejectedClosingSpace\",\n\n              fix(fixer) {\n                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n              }\n\n            });\n          }\n        });\n      }\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","exceptions","items","uniqueItems","additionalProperties","messages","missingOpeningSpace","missingClosingSpace","rejectedOpeningSpace","rejectedClosingSpace","create","context","ALWAYS","options","exceptionsArrayOptions","length","braceException","includes","bracketException","parenException","empty","getExceptions","openers","closers","push","sourceCode","getSourceCode","isOpenerException","token","value","isCloserException","openerMissingSpace","openingParenToken","tokenAfterOpeningParen","isSpaceBetweenTokens","isClosingParenToken","openerRejectsSpace","isTokenOnSameLine","closerMissingSpace","tokenBeforeClosingParen","closingParenToken","isOpeningParenToken","closerRejectsSpace","Program","checkParenSpaces","node","tokens","tokensAndComments","forEach","i","prevToken","nextToken","report","loc","messageId","fix","fixer","insertTextAfter","start","end","removeRange","range","insertTextBefore"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/space-in-parens.js"],"sourcesContent":["/**\n * @fileoverview Disallows or enforces spaces inside of parentheses.\n * @author Jonathan Rajavuori\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-in-parens\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            missingOpeningSpace: \"There must be a space after this paren.\",\n            missingClosingSpace: \"There must be a space before this paren.\",\n            rejectedOpeningSpace: \"There should be no space after this paren.\",\n            rejectedClosingSpace: \"There should be no space before this paren.\"\n        }\n    },\n\n    create(context) {\n        const ALWAYS = context.options[0] === \"always\",\n            exceptionsArrayOptions = (context.options[1] && context.options[1].exceptions) || [],\n            options = {};\n\n        let exceptions;\n\n        if (exceptionsArrayOptions.length) {\n            options.braceException = exceptionsArrayOptions.includes(\"{}\");\n            options.bracketException = exceptionsArrayOptions.includes(\"[]\");\n            options.parenException = exceptionsArrayOptions.includes(\"()\");\n            options.empty = exceptionsArrayOptions.includes(\"empty\");\n        }\n\n        /**\n         * Produces an object with the opener and closer exception values\n         * @returns {Object} `openers` and `closers` exception values\n         * @private\n         */\n        function getExceptions() {\n            const openers = [],\n                closers = [];\n\n            if (options.braceException) {\n                openers.push(\"{\");\n                closers.push(\"}\");\n            }\n\n            if (options.bracketException) {\n                openers.push(\"[\");\n                closers.push(\"]\");\n            }\n\n            if (options.parenException) {\n                openers.push(\"(\");\n                closers.push(\")\");\n            }\n\n            if (options.empty) {\n                openers.push(\")\");\n                closers.push(\"(\");\n            }\n\n            return {\n                openers,\n                closers\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines if a token is one of the exceptions for the opener paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the opener paren\n         */\n        function isOpenerException(token) {\n            return exceptions.openers.includes(token.value);\n        }\n\n        /**\n         * Determines if a token is one of the exceptions for the closer paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the closer paren\n         */\n        function isCloserException(token) {\n            return exceptions.closers.includes(token.value);\n        }\n\n        /**\n         * Determines if an opening paren is immediately followed by a required space\n         * @param {Object} openingParenToken The paren token\n         * @param {Object} tokenAfterOpeningParen The token after it\n         * @returns {boolean} True if the opening paren is missing a required space\n         */\n        function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {\n            if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return !isOpenerException(tokenAfterOpeningParen);\n            }\n            return isOpenerException(tokenAfterOpeningParen);\n        }\n\n        /**\n         * Determines if an opening paren is immediately followed by a disallowed space\n         * @param {Object} openingParenToken The paren token\n         * @param {Object} tokenAfterOpeningParen The token after it\n         * @returns {boolean} True if the opening paren has a disallowed space\n         */\n        function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {\n            if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (tokenAfterOpeningParen.type === \"Line\") {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isOpenerException(tokenAfterOpeningParen);\n            }\n            return !isOpenerException(tokenAfterOpeningParen);\n        }\n\n        /**\n         * Determines if a closing paren is immediately preceded by a required space\n         * @param {Object} tokenBeforeClosingParen The token before the paren\n         * @param {Object} closingParenToken The paren token\n         * @returns {boolean} True if the closing paren is missing a required space\n         */\n        function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {\n            if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n                return false;\n            }\n\n            if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return !isCloserException(tokenBeforeClosingParen);\n            }\n            return isCloserException(tokenBeforeClosingParen);\n        }\n\n        /**\n         * Determines if a closer paren is immediately preceded by a disallowed space\n         * @param {Object} tokenBeforeClosingParen The token before the paren\n         * @param {Object} closingParenToken The paren token\n         * @returns {boolean} True if the closing paren has a disallowed space\n         */\n        function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {\n            if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isCloserException(tokenBeforeClosingParen);\n            }\n            return !isCloserException(tokenBeforeClosingParen);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkParenSpaces(node) {\n                exceptions = getExceptions();\n                const tokens = sourceCode.tokensAndComments;\n\n                tokens.forEach((token, i) => {\n                    const prevToken = tokens[i - 1];\n                    const nextToken = tokens[i + 1];\n\n                    // if token is not an opening or closing paren token, do nothing\n                    if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n                        return;\n                    }\n\n                    // if token is an opening paren and is not followed by a required space\n                    if (token.value === \"(\" && openerMissingSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: token.loc,\n                            messageId: \"missingOpeningSpace\",\n                            fix(fixer) {\n                                return fixer.insertTextAfter(token, \" \");\n                            }\n                        });\n                    }\n\n                    // if token is an opening paren and is followed by a disallowed space\n                    if (token.value === \"(\" && openerRejectsSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: { start: token.loc.end, end: nextToken.loc.start },\n                            messageId: \"rejectedOpeningSpace\",\n                            fix(fixer) {\n                                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                            }\n                        });\n                    }\n\n                    // if token is a closing paren and is not preceded by a required space\n                    if (token.value === \")\" && closerMissingSpace(prevToken, token)) {\n                        context.report({\n                            node,\n                            loc: token.loc,\n                            messageId: \"missingClosingSpace\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n\n                    // if token is a closing paren and is preceded by a disallowed space\n                    if (token.value === \")\" && closerRejectsSpace(prevToken, token)) {\n                        context.report({\n                            node,\n                            loc: { start: prevToken.loc.end, end: token.loc.start },\n                            messageId: \"rejectedClosingSpace\",\n                            fix(fixer) {\n                                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                });\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}