{"ast":null,"code":"/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newlines around directives\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-around-directive\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          before: {\n            enum: [\"always\", \"never\"]\n          },\n          after: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 2\n      }]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n      unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const config = context.options[0] || \"always\";\n    const expectLineBefore = typeof config === \"string\" ? config : config.before;\n    const expectLineAfter = typeof config === \"string\" ? config : config.after; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Check if node is preceded by a blank newline.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n     */\n\n    function hasNewlineBefore(node) {\n      const tokenBefore = sourceCode.getTokenBefore(node, {\n        includeComments: true\n      });\n      const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n      return node.loc.start.line - tokenLineBefore >= 2;\n    }\n    /**\n     * Gets the last token of a node that is on the same line as the rest of the node.\n     * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n     * semicolon on a different line.\n     * @param {ASTNode} node A directive node\n     * @returns {Token} The last token of the node on the line\n     */\n\n\n    function getLastTokenOnLine(node) {\n      const lastToken = sourceCode.getLastToken(node);\n      const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n      return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;\n    }\n    /**\n     * Check if node is followed by a blank newline.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n     */\n\n\n    function hasNewlineAfter(node) {\n      const lastToken = getLastTokenOnLine(node);\n      const tokenAfter = sourceCode.getTokenAfter(lastToken, {\n        includeComments: true\n      });\n      return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n    }\n    /**\n     * Report errors for newlines around directives.\n     * @param {ASTNode} node Node to check.\n     * @param {string} location Whether the error was found before or after the directive.\n     * @param {boolean} expected Whether or not a newline was expected or unexpected.\n     * @returns {void}\n     */\n\n\n    function reportError(node, location, expected) {\n      context.report({\n        node,\n        messageId: expected ? \"expected\" : \"unexpected\",\n        data: {\n          value: node.expression.value,\n          location\n        },\n\n        fix(fixer) {\n          const lastToken = getLastTokenOnLine(node);\n\n          if (expected) {\n            return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n          }\n\n          return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n        }\n\n      });\n    }\n    /**\n     * Check lines around directives in node\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n\n\n    function checkDirectives(node) {\n      const directives = astUtils.getDirectivePrologue(node);\n\n      if (!directives.length) {\n        return;\n      }\n\n      const firstDirective = directives[0];\n      const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n      /*\n       * Only check before the first directive if it is preceded by a comment or if it is at the top of\n       * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n       * the file if there are no comments as well as for compatibility with padded-blocks.\n       */\n\n      if (leadingComments.length) {\n        if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", true);\n        }\n\n        if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", false);\n        }\n      } else if (node.type === \"Program\" && expectLineBefore === \"never\" && !leadingComments.length && hasNewlineBefore(firstDirective)) {\n        reportError(firstDirective, \"before\", false);\n      }\n\n      const lastDirective = directives[directives.length - 1];\n      const statements = node.type === \"Program\" ? node.body : node.body.body;\n      /*\n       * Do not check after the last directive if the body only\n       * contains a directive prologue and isn't followed by a comment to ensure\n       * this rule behaves well with padded-blocks.\n       */\n\n      if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n        return;\n      }\n\n      if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", true);\n      }\n\n      if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", false);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: checkDirectives,\n      FunctionDeclaration: checkDirectives,\n      FunctionExpression: checkDirectives,\n      ArrowFunctionExpression: checkDirectives\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","enum","properties","before","after","additionalProperties","minProperties","fixable","messages","expected","unexpected","deprecated","replacedBy","create","context","sourceCode","getSourceCode","config","options","expectLineBefore","expectLineAfter","hasNewlineBefore","node","tokenBefore","getTokenBefore","includeComments","tokenLineBefore","loc","end","line","start","getLastTokenOnLine","lastToken","getLastToken","secondToLastToken","isSemicolonToken","hasNewlineAfter","tokenAfter","getTokenAfter","reportError","location","report","messageId","data","value","expression","fix","fixer","insertTextBefore","insertTextAfter","removeRange","range","checkDirectives","directives","getDirectivePrologue","length","firstDirective","leadingComments","getCommentsBefore","lastDirective","statements","body","trailingComments","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/lines-around-directive.js"],"sourcesContent":["/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newlines around directives\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-around-directive\"\n        },\n\n        schema: [{\n            oneOf: [\n                {\n                    enum: [\"always\", \"never\"]\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        before: {\n                            enum: [\"always\", \"never\"]\n                        },\n                        after: {\n                            enum: [\"always\", \"never\"]\n                        }\n                    },\n                    additionalProperties: false,\n                    minProperties: 2\n                }\n            ]\n        }],\n\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n            unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n        },\n        deprecated: true,\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const config = context.options[0] || \"always\";\n        const expectLineBefore = typeof config === \"string\" ? config : config.before;\n        const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if node is preceded by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n         */\n        function hasNewlineBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n\n            return node.loc.start.line - tokenLineBefore >= 2;\n        }\n\n        /**\n         * Gets the last token of a node that is on the same line as the rest of the node.\n         * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n         * semicolon on a different line.\n         * @param {ASTNode} node A directive node\n         * @returns {Token} The last token of the node on the line\n         */\n        function getLastTokenOnLine(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n\n            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line\n                ? secondToLastToken\n                : lastToken;\n        }\n\n        /**\n         * Check if node is followed by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n         */\n        function hasNewlineAfter(node) {\n            const lastToken = getLastTokenOnLine(node);\n            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });\n\n            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n        }\n\n        /**\n         * Report errors for newlines around directives.\n         * @param {ASTNode} node Node to check.\n         * @param {string} location Whether the error was found before or after the directive.\n         * @param {boolean} expected Whether or not a newline was expected or unexpected.\n         * @returns {void}\n         */\n        function reportError(node, location, expected) {\n            context.report({\n                node,\n                messageId: expected ? \"expected\" : \"unexpected\",\n                data: {\n                    value: node.expression.value,\n                    location\n                },\n                fix(fixer) {\n                    const lastToken = getLastTokenOnLine(node);\n\n                    if (expected) {\n                        return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n                    }\n                    return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n                }\n            });\n        }\n\n        /**\n         * Check lines around directives in node\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkDirectives(node) {\n            const directives = astUtils.getDirectivePrologue(node);\n\n            if (!directives.length) {\n                return;\n            }\n\n            const firstDirective = directives[0];\n            const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n\n            /*\n             * Only check before the first directive if it is preceded by a comment or if it is at the top of\n             * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n             * the file if there are no comments as well as for compatibility with padded-blocks.\n             */\n            if (leadingComments.length) {\n                if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", true);\n                }\n\n                if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", false);\n                }\n            } else if (\n                node.type === \"Program\" &&\n                expectLineBefore === \"never\" &&\n                !leadingComments.length &&\n                hasNewlineBefore(firstDirective)\n            ) {\n                reportError(firstDirective, \"before\", false);\n            }\n\n            const lastDirective = directives[directives.length - 1];\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            /*\n             * Do not check after the last directive if the body only\n             * contains a directive prologue and isn't followed by a comment to ensure\n             * this rule behaves well with padded-blocks.\n             */\n            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n                return;\n            }\n\n            if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", true);\n            }\n\n            if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", false);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkDirectives,\n            FunctionDeclaration: checkDirectives,\n            FunctionExpression: checkDirectives,\n            ArrowFunctionExpression: checkDirectives\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}