{"ast":null,"code":"/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils.js\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst COALESCE_OPERATOR = [\"??\"];\nconst ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS, TERNARY_OPERATOR, COALESCE_OPERATOR);\nconst DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n/**\n * Normalizes options.\n * @param {Object|undefined} options A options object to normalize.\n * @returns {Object} Normalized option object.\n */\n\nfunction normalizeOptions() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const hasGroups = options.groups && options.groups.length > 0;\n  const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n  const allowSamePrecedence = options.allowSamePrecedence !== false;\n  return {\n    groups,\n    allowSamePrecedence\n  };\n}\n/**\n * Checks whether any group which includes both given operator exists or not.\n * @param {Array.<string[]>} groups A list of groups to check.\n * @param {string} left An operator.\n * @param {string} right Another operator.\n * @returns {boolean} `true` if such group existed.\n */\n\n\nfunction includesBothInAGroup(groups, left, right) {\n  return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n/**\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\n * This parent node can be BinaryExpression, LogicalExpression\n *      , or a ConditionalExpression node\n * @returns {ASTNode} node the appropriate node(left or test).\n */\n\n\nfunction getChildNode(node) {\n  return node.type === \"ConditionalExpression\" ? node.test : node.left;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow mixed binary operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        groups: {\n          type: \"array\",\n          items: {\n            type: \"array\",\n            items: {\n              enum: ALL_OPERATORS\n            },\n            minItems: 2,\n            uniqueItems: true\n          },\n          uniqueItems: true\n        },\n        allowSamePrecedence: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedMixedOperator: \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = normalizeOptions(context.options[0]);\n    /**\n     * Checks whether a given node should be ignored by options or not.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node. This parent node is one of\n     *      them, too.\n     * @returns {boolean} `true` if the node should be ignored.\n     */\n\n    function shouldIgnore(node) {\n      const a = node;\n      const b = node.parent;\n      return !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);\n    }\n    /**\n     * Checks whether the operator of a given node is mixed with parent\n     * node's operator or not.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node. This parent node is one of\n     *      them, too.\n     * @returns {boolean} `true` if the node was mixed.\n     */\n\n\n    function isMixedWithParent(node) {\n      return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);\n    }\n    /**\n     * Gets the operator token of a given node.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node.\n     * @returns {Token} The operator token of the node.\n     */\n\n\n    function getOperatorToken(node) {\n      return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n    }\n    /**\n     * Reports both the operator of a given node and the operator of the\n     * parent node.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node. This parent node is one of\n     *      them, too.\n     * @returns {void}\n     */\n\n\n    function reportBothOperators(node) {\n      const parent = node.parent;\n      const left = getChildNode(parent) === node ? node : parent;\n      const right = getChildNode(parent) !== node ? node : parent;\n      const data = {\n        leftOperator: left.operator || \"?:\",\n        rightOperator: right.operator || \"?:\"\n      };\n      context.report({\n        node: left,\n        loc: getOperatorToken(left).loc,\n        messageId: \"unexpectedMixedOperator\",\n        data\n      });\n      context.report({\n        node: right,\n        loc: getOperatorToken(right).loc,\n        messageId: \"unexpectedMixedOperator\",\n        data\n      });\n    }\n    /**\n     * Checks between the operator of this node and the operator of the\n     * parent node.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n\n\n    function check(node) {\n      if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {\n        reportBothOperators(node);\n      }\n    }\n\n    return {\n      BinaryExpression: check,\n      LogicalExpression: check\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","ARITHMETIC_OPERATORS","BITWISE_OPERATORS","COMPARISON_OPERATORS","LOGICAL_OPERATORS","RELATIONAL_OPERATORS","TERNARY_OPERATOR","COALESCE_OPERATOR","ALL_OPERATORS","concat","DEFAULT_GROUPS","TARGET_NODE_TYPE","normalizeOptions","options","hasGroups","groups","length","allowSamePrecedence","includesBothInAGroup","left","right","some","group","indexOf","getChildNode","node","type","test","module","exports","meta","docs","description","category","recommended","url","schema","properties","items","enum","minItems","uniqueItems","default","additionalProperties","messages","unexpectedMixedOperator","create","context","sourceCode","getSourceCode","shouldIgnore","a","b","parent","operator","getPrecedence","isMixedWithParent","isParenthesised","getOperatorToken","getTokenAfter","isNotClosingParenToken","reportBothOperators","data","leftOperator","rightOperator","report","loc","messageId","check","BinaryExpression","LogicalExpression"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-mixed-operators.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst COALESCE_OPERATOR = [\"??\"];\nconst ALL_OPERATORS = [].concat(\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS,\n    TERNARY_OPERATOR,\n    COALESCE_OPERATOR\n);\nconst DEFAULT_GROUPS = [\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n\n/**\n * Normalizes options.\n * @param {Object|undefined} options A options object to normalize.\n * @returns {Object} Normalized option object.\n */\nfunction normalizeOptions(options = {}) {\n    const hasGroups = options.groups && options.groups.length > 0;\n    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n    const allowSamePrecedence = options.allowSamePrecedence !== false;\n\n    return {\n        groups,\n        allowSamePrecedence\n    };\n}\n\n/**\n * Checks whether any group which includes both given operator exists or not.\n * @param {Array.<string[]>} groups A list of groups to check.\n * @param {string} left An operator.\n * @param {string} right Another operator.\n * @returns {boolean} `true` if such group existed.\n */\nfunction includesBothInAGroup(groups, left, right) {\n    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n\n/**\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\n * This parent node can be BinaryExpression, LogicalExpression\n *      , or a ConditionalExpression node\n * @returns {ASTNode} node the appropriate node(left or test).\n */\nfunction getChildNode(node) {\n    return node.type === \"ConditionalExpression\" ? node.test : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow mixed binary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    groups: {\n                        type: \"array\",\n                        items: {\n                            type: \"array\",\n                            items: { enum: ALL_OPERATORS },\n                            minItems: 2,\n                            uniqueItems: true\n                        },\n                        uniqueItems: true\n                    },\n                    allowSamePrecedence: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedMixedOperator: \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = normalizeOptions(context.options[0]);\n\n        /**\n         * Checks whether a given node should be ignored by options or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node should be ignored.\n         */\n        function shouldIgnore(node) {\n            const a = node;\n            const b = node.parent;\n\n            return (\n                !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) ||\n                (\n                    options.allowSamePrecedence &&\n                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)\n                )\n            );\n        }\n\n        /**\n         * Checks whether the operator of a given node is mixed with parent\n         * node's operator or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node was mixed.\n         */\n        function isMixedWithParent(node) {\n\n            return (\n                node.operator !== node.parent.operator &&\n                !astUtils.isParenthesised(sourceCode, node)\n            );\n        }\n\n        /**\n         * Gets the operator token of a given node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node.\n         * @returns {Token} The operator token of the node.\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n        }\n\n        /**\n         * Reports both the operator of a given node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {void}\n         */\n        function reportBothOperators(node) {\n            const parent = node.parent;\n            const left = (getChildNode(parent) === node) ? node : parent;\n            const right = (getChildNode(parent) !== node) ? node : parent;\n            const data = {\n                leftOperator: left.operator || \"?:\",\n                rightOperator: right.operator || \"?:\"\n            };\n\n            context.report({\n                node: left,\n                loc: getOperatorToken(left).loc,\n                messageId: \"unexpectedMixedOperator\",\n                data\n            });\n            context.report({\n                node: right,\n                loc: getOperatorToken(right).loc,\n                messageId: \"unexpectedMixedOperator\",\n                data\n            });\n        }\n\n        /**\n         * Checks between the operator of this node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (\n                TARGET_NODE_TYPE.test(node.parent.type) &&\n                isMixedWithParent(node) &&\n                !shouldIgnore(node)\n            ) {\n                reportBothOperators(node);\n            }\n        }\n\n        return {\n            BinaryExpression: check,\n            LogicalExpression: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}