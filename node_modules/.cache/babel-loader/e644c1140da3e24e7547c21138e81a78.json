{"ast":null,"code":"/**\n * @fileoverview Rule to flag references to the undefined variable.\n * @author Michael Ficarra\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `undefined` as an identifier\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-undefined\"\n    },\n    schema: [],\n    messages: {\n      unexpectedUndefined: \"Unexpected use of undefined.\"\n    }\n  },\n\n  create(context) {\n    /**\n     * Report an invalid \"undefined\" identifier node.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     */\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"unexpectedUndefined\"\n      });\n    }\n    /**\n     * Checks the given scope for references to `undefined` and reports\n     * all references found.\n     * @param {eslint-scope.Scope} scope The scope to check.\n     * @returns {void}\n     */\n\n\n    function checkScope(scope) {\n      const undefinedVar = scope.set.get(\"undefined\");\n\n      if (!undefinedVar) {\n        return;\n      }\n\n      const references = undefinedVar.references;\n      const defs = undefinedVar.defs; // Report non-initializing references (those are covered in defs below)\n\n      references.filter(ref => !ref.init).forEach(ref => report(ref.identifier));\n      defs.forEach(def => report(def.name));\n    }\n\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        const stack = [globalScope];\n\n        while (stack.length) {\n          const scope = stack.pop();\n          stack.push(...scope.childScopes);\n          checkScope(scope);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","messages","unexpectedUndefined","create","context","report","node","messageId","checkScope","scope","undefinedVar","set","get","references","defs","filter","ref","init","forEach","identifier","def","name","globalScope","getScope","stack","length","pop","push","childScopes"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-undefined.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag references to the undefined variable.\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `undefined` as an identifier\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-undefined\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedUndefined: \"Unexpected use of undefined.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Report an invalid \"undefined\" identifier node.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"unexpectedUndefined\"\n            });\n        }\n\n        /**\n         * Checks the given scope for references to `undefined` and reports\n         * all references found.\n         * @param {eslint-scope.Scope} scope The scope to check.\n         * @returns {void}\n         */\n        function checkScope(scope) {\n            const undefinedVar = scope.set.get(\"undefined\");\n\n            if (!undefinedVar) {\n                return;\n            }\n\n            const references = undefinedVar.references;\n\n            const defs = undefinedVar.defs;\n\n            // Report non-initializing references (those are covered in defs below)\n            references\n                .filter(ref => !ref.init)\n                .forEach(ref => report(ref.identifier));\n\n            defs.forEach(def => report(def.name));\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                const stack = [globalScope];\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push(...scope.childScopes);\n                    checkScope(scope);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,YADJ;IAGFC,IAAI,EAAE;MACFC,WAAW,EAAE,kDADX;MAEFC,QAAQ,EAAE,WAFR;MAGFC,WAAW,EAAE,KAHX;MAIFC,GAAG,EAAE;IAJH,CAHJ;IAUFC,MAAM,EAAE,EAVN;IAYFC,QAAQ,EAAE;MACNC,mBAAmB,EAAE;IADf;EAZR,CADO;;EAkBbC,MAAM,CAACC,OAAD,EAAU;IAEZ;AACR;AACA;AACA;AACA;IACQ,SAASC,MAAT,CAAgBC,IAAhB,EAAsB;MAClBF,OAAO,CAACC,MAAR,CAAe;QACXC,IADW;QAEXC,SAAS,EAAE;MAFA,CAAf;IAIH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASC,UAAT,CAAoBC,KAApB,EAA2B;MACvB,MAAMC,YAAY,GAAGD,KAAK,CAACE,GAAN,CAAUC,GAAV,CAAc,WAAd,CAArB;;MAEA,IAAI,CAACF,YAAL,EAAmB;QACf;MACH;;MAED,MAAMG,UAAU,GAAGH,YAAY,CAACG,UAAhC;MAEA,MAAMC,IAAI,GAAGJ,YAAY,CAACI,IAA1B,CATuB,CAWvB;;MACAD,UAAU,CACLE,MADL,CACYC,GAAG,IAAI,CAACA,GAAG,CAACC,IADxB,EAEKC,OAFL,CAEaF,GAAG,IAAIX,MAAM,CAACW,GAAG,CAACG,UAAL,CAF1B;MAIAL,IAAI,CAACI,OAAL,CAAaE,GAAG,IAAIf,MAAM,CAACe,GAAG,CAACC,IAAL,CAA1B;IACH;;IAED,OAAO;MACH,iBAAiB;QACb,MAAMC,WAAW,GAAGlB,OAAO,CAACmB,QAAR,EAApB;QAEA,MAAMC,KAAK,GAAG,CAACF,WAAD,CAAd;;QAEA,OAAOE,KAAK,CAACC,MAAb,EAAqB;UACjB,MAAMhB,KAAK,GAAGe,KAAK,CAACE,GAAN,EAAd;UAEAF,KAAK,CAACG,IAAN,CAAW,GAAGlB,KAAK,CAACmB,WAApB;UACApB,UAAU,CAACC,KAAD,CAAV;QACH;MACJ;;IAZE,CAAP;EAeH;;AAxEY,CAAjB"},"metadata":{},"sourceType":"script"}