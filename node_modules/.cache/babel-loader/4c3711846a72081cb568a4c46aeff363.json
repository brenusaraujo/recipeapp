{"ast":null,"code":"/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); // Maximum array length by the ECMAScript Specification.\n\n\nconst MAX_ARRAY_LENGTH = 2 ** 32 - 1; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Convert the value to bigint if it's a string. Otherwise return the value as-is.\n * @param {bigint|number|string} x The value to normalize.\n * @returns {bigint|number} The normalized value.\n */\n\nfunction normalizeIgnoreValue(x) {\n  if (typeof x === \"string\") {\n    return BigInt(x.slice(0, -1));\n  }\n\n  return x;\n}\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow magic numbers\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-magic-numbers\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        detectObjects: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceConst: {\n          type: \"boolean\",\n          default: false\n        },\n        ignore: {\n          type: \"array\",\n          items: {\n            anyOf: [{\n              type: \"number\"\n            }, {\n              type: \"string\",\n              pattern: \"^[+-]?(?:0|[1-9][0-9]*)n$\"\n            }]\n          },\n          uniqueItems: true\n        },\n        ignoreArrayIndexes: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreDefaultValues: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useConst: \"Number constants declarations must use 'const'.\",\n      noMagic: \"No magic number: {{raw}}.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {},\n          detectObjects = !!config.detectObjects,\n          enforceConst = !!config.enforceConst,\n          ignore = (config.ignore || []).map(normalizeIgnoreValue),\n          ignoreArrayIndexes = !!config.ignoreArrayIndexes,\n          ignoreDefaultValues = !!config.ignoreDefaultValues;\n    const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n    /**\n     * Returns whether the rule is configured to ignore the given value\n     * @param {bigint|number} value The value to check\n     * @returns {boolean} true if the value is ignored\n     */\n\n    function isIgnoredValue(value) {\n      return ignore.indexOf(value) !== -1;\n    }\n    /**\n     * Returns whether the number is a default value assignment.\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the number is a default value\n     */\n\n\n    function isDefaultValue(fullNumberNode) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"AssignmentPattern\" && parent.right === fullNumberNode;\n    }\n    /**\n     * Returns whether the given node is used as a radix within parseInt() or Number.parseInt()\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the node is radix\n     */\n\n\n    function isParseIntRadix(fullNumberNode) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"CallExpression\" && fullNumberNode === parent.arguments[1] && (astUtils.isSpecificId(parent.callee, \"parseInt\") || astUtils.isSpecificMemberAccess(parent.callee, \"Number\", \"parseInt\"));\n    }\n    /**\n     * Returns whether the given node is a direct child of a JSX node.\n     * In particular, it aims to detect numbers used as prop values in JSX tags.\n     * Example: <input maxLength={10} />\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the node is a JSX number\n     */\n\n\n    function isJSXNumber(fullNumberNode) {\n      return fullNumberNode.parent.type.indexOf(\"JSX\") === 0;\n    }\n    /**\n     * Returns whether the given node is used as an array index.\n     * Value must coerce to a valid array index name: \"0\", \"1\", \"2\" ... \"4294967294\".\n     *\n     * All other values, like \"-1\", \"2.5\", or \"4294967295\", are just \"normal\" object properties,\n     * which can be created and accessed on an array in addition to the array index properties,\n     * but they don't affect array's length and are not considered by methods such as .map(), .forEach() etc.\n     *\n     * The maximum array length by the specification is 2 ** 32 - 1 = 4294967295,\n     * thus the maximum valid index is 2 ** 32 - 2 = 4294967294.\n     *\n     * All notations are allowed, as long as the value coerces to one of \"0\", \"1\", \"2\" ... \"4294967294\".\n     *\n     * Valid examples:\n     * a[0], a[1], a[1.2e1], a[0xAB], a[0n], a[1n]\n     * a[-0] (same as a[0] because -0 coerces to \"0\")\n     * a[-0n] (-0n evaluates to 0n)\n     *\n     * Invalid examples:\n     * a[-1], a[-0xAB], a[-1n], a[2.5], a[1.23e1], a[12e-1]\n     * a[4294967295] (above the max index, it's an access to a regular property a[\"4294967295\"])\n     * a[999999999999999999999] (even if it wasn't above the max index, it would be a[\"1e+21\"])\n     * a[1e310] (same as a[\"Infinity\"])\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @param {bigint|number} value Value expressed by the fullNumberNode\n     * @returns {boolean} true if the node is a valid array index\n     */\n\n\n    function isArrayIndex(fullNumberNode, value) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"MemberExpression\" && parent.property === fullNumberNode && (Number.isInteger(value) || typeof value === \"bigint\") && value >= 0 && value < MAX_ARRAY_LENGTH;\n    }\n\n    return {\n      Literal(node) {\n        if (!astUtils.isNumericLiteral(node)) {\n          return;\n        }\n\n        let fullNumberNode;\n        let value;\n        let raw; // Treat unary minus as a part of the number\n\n        if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n          fullNumberNode = node.parent;\n          value = -node.value;\n          raw = `-${node.raw}`;\n        } else {\n          fullNumberNode = node;\n          value = node.value;\n          raw = node.raw;\n        }\n\n        const parent = fullNumberNode.parent; // Always allow radix arguments and JSX props\n\n        if (isIgnoredValue(value) || ignoreDefaultValues && isDefaultValue(fullNumberNode) || isParseIntRadix(fullNumberNode) || isJSXNumber(fullNumberNode) || ignoreArrayIndexes && isArrayIndex(fullNumberNode, value)) {\n          return;\n        }\n\n        if (parent.type === \"VariableDeclarator\") {\n          if (enforceConst && parent.parent.kind !== \"const\") {\n            context.report({\n              node: fullNumberNode,\n              messageId: \"useConst\"\n            });\n          }\n        } else if (okTypes.indexOf(parent.type) === -1 || parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\") {\n          context.report({\n            node: fullNumberNode,\n            messageId: \"noMagic\",\n            data: {\n              raw\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","MAX_ARRAY_LENGTH","normalizeIgnoreValue","x","BigInt","slice","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","detectObjects","default","enforceConst","ignore","items","anyOf","pattern","uniqueItems","ignoreArrayIndexes","ignoreDefaultValues","additionalProperties","messages","useConst","noMagic","create","context","config","options","map","okTypes","isIgnoredValue","value","indexOf","isDefaultValue","fullNumberNode","parent","right","isParseIntRadix","arguments","isSpecificId","callee","isSpecificMemberAccess","isJSXNumber","isArrayIndex","property","Number","isInteger","Literal","node","isNumericLiteral","raw","operator","kind","report","messageId","left","data"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-magic-numbers.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Maximum array length by the ECMAScript Specification.\nconst MAX_ARRAY_LENGTH = 2 ** 32 - 1;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Convert the value to bigint if it's a string. Otherwise return the value as-is.\n * @param {bigint|number|string} x The value to normalize.\n * @returns {bigint|number} The normalized value.\n */\nfunction normalizeIgnoreValue(x) {\n    if (typeof x === \"string\") {\n        return BigInt(x.slice(0, -1));\n    }\n    return x;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow magic numbers\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-magic-numbers\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                detectObjects: {\n                    type: \"boolean\",\n                    default: false\n                },\n                enforceConst: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        anyOf: [\n                            { type: \"number\" },\n                            { type: \"string\", pattern: \"^[+-]?(?:0|[1-9][0-9]*)n$\" }\n                        ]\n                    },\n                    uniqueItems: true\n                },\n                ignoreArrayIndexes: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignoreDefaultValues: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useConst: \"Number constants declarations must use 'const'.\",\n            noMagic: \"No magic number: {{raw}}.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            detectObjects = !!config.detectObjects,\n            enforceConst = !!config.enforceConst,\n            ignore = (config.ignore || []).map(normalizeIgnoreValue),\n            ignoreArrayIndexes = !!config.ignoreArrayIndexes,\n            ignoreDefaultValues = !!config.ignoreDefaultValues;\n\n        const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n        /**\n         * Returns whether the rule is configured to ignore the given value\n         * @param {bigint|number} value The value to check\n         * @returns {boolean} true if the value is ignored\n         */\n        function isIgnoredValue(value) {\n            return ignore.indexOf(value) !== -1;\n        }\n\n        /**\n         * Returns whether the number is a default value assignment.\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the number is a default value\n         */\n        function isDefaultValue(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"AssignmentPattern\" && parent.right === fullNumberNode;\n        }\n\n        /**\n         * Returns whether the given node is used as a radix within parseInt() or Number.parseInt()\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is radix\n         */\n        function isParseIntRadix(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"CallExpression\" && fullNumberNode === parent.arguments[1] &&\n                (\n                    astUtils.isSpecificId(parent.callee, \"parseInt\") ||\n                    astUtils.isSpecificMemberAccess(parent.callee, \"Number\", \"parseInt\")\n                );\n        }\n\n        /**\n         * Returns whether the given node is a direct child of a JSX node.\n         * In particular, it aims to detect numbers used as prop values in JSX tags.\n         * Example: <input maxLength={10} />\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is a JSX number\n         */\n        function isJSXNumber(fullNumberNode) {\n            return fullNumberNode.parent.type.indexOf(\"JSX\") === 0;\n        }\n\n        /**\n         * Returns whether the given node is used as an array index.\n         * Value must coerce to a valid array index name: \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * All other values, like \"-1\", \"2.5\", or \"4294967295\", are just \"normal\" object properties,\n         * which can be created and accessed on an array in addition to the array index properties,\n         * but they don't affect array's length and are not considered by methods such as .map(), .forEach() etc.\n         *\n         * The maximum array length by the specification is 2 ** 32 - 1 = 4294967295,\n         * thus the maximum valid index is 2 ** 32 - 2 = 4294967294.\n         *\n         * All notations are allowed, as long as the value coerces to one of \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * Valid examples:\n         * a[0], a[1], a[1.2e1], a[0xAB], a[0n], a[1n]\n         * a[-0] (same as a[0] because -0 coerces to \"0\")\n         * a[-0n] (-0n evaluates to 0n)\n         *\n         * Invalid examples:\n         * a[-1], a[-0xAB], a[-1n], a[2.5], a[1.23e1], a[12e-1]\n         * a[4294967295] (above the max index, it's an access to a regular property a[\"4294967295\"])\n         * a[999999999999999999999] (even if it wasn't above the max index, it would be a[\"1e+21\"])\n         * a[1e310] (same as a[\"Infinity\"])\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @param {bigint|number} value Value expressed by the fullNumberNode\n         * @returns {boolean} true if the node is a valid array index\n         */\n        function isArrayIndex(fullNumberNode, value) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"MemberExpression\" && parent.property === fullNumberNode &&\n                (Number.isInteger(value) || typeof value === \"bigint\") &&\n                value >= 0 && value < MAX_ARRAY_LENGTH;\n        }\n\n        return {\n            Literal(node) {\n                if (!astUtils.isNumericLiteral(node)) {\n                    return;\n                }\n\n                let fullNumberNode;\n                let value;\n                let raw;\n\n                // Treat unary minus as a part of the number\n                if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n                    fullNumberNode = node.parent;\n                    value = -node.value;\n                    raw = `-${node.raw}`;\n                } else {\n                    fullNumberNode = node;\n                    value = node.value;\n                    raw = node.raw;\n                }\n\n                const parent = fullNumberNode.parent;\n\n                // Always allow radix arguments and JSX props\n                if (\n                    isIgnoredValue(value) ||\n                    (ignoreDefaultValues && isDefaultValue(fullNumberNode)) ||\n                    isParseIntRadix(fullNumberNode) ||\n                    isJSXNumber(fullNumberNode) ||\n                    (ignoreArrayIndexes && isArrayIndex(fullNumberNode, value))\n                ) {\n                    return;\n                }\n\n                if (parent.type === \"VariableDeclarator\") {\n                    if (enforceConst && parent.parent.kind !== \"const\") {\n                        context.report({\n                            node: fullNumberNode,\n                            messageId: \"useConst\"\n                        });\n                    }\n                } else if (\n                    okTypes.indexOf(parent.type) === -1 ||\n                    (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\")\n                ) {\n                    context.report({\n                        node: fullNumberNode,\n                        messageId: \"noMagic\",\n                        data: {\n                            raw\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}