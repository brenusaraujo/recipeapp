{"ast":null,"code":"/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"require `return` statements after callbacks\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/callback-return\"\n    },\n    schema: [{\n      type: \"array\",\n      items: {\n        type: \"string\"\n      }\n    }],\n    messages: {\n      missingReturn: \"Expected return with your callback function.\"\n    }\n  },\n\n  create(context) {\n    const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n          sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Find the closest parent matching a list of types.\n     * @param {ASTNode} node The node whose parents we are searching\n     * @param {Array} types The node types to match\n     * @returns {ASTNode} The matched node or undefined.\n     */\n\n    function findClosestParentOfType(node, types) {\n      if (!node.parent) {\n        return null;\n      }\n\n      if (types.indexOf(node.parent.type) === -1) {\n        return findClosestParentOfType(node.parent, types);\n      }\n\n      return node.parent;\n    }\n    /**\n     * Check to see if a node contains only identifiers\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} Whether or not the node contains only identifiers\n     */\n\n\n    function containsOnlyIdentifiers(node) {\n      if (node.type === \"Identifier\") {\n        return true;\n      }\n\n      if (node.type === \"MemberExpression\") {\n        if (node.object.type === \"Identifier\") {\n          return true;\n        }\n\n        if (node.object.type === \"MemberExpression\") {\n          return containsOnlyIdentifiers(node.object);\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Check to see if a CallExpression is in our callback list.\n     * @param {ASTNode} node The node to check against our callback names list.\n     * @returns {boolean} Whether or not this function matches our callback name.\n     */\n\n\n    function isCallback(node) {\n      return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n    }\n    /**\n     * Determines whether or not the callback is part of a callback expression.\n     * @param {ASTNode} node The callback node\n     * @param {ASTNode} parentNode The expression node\n     * @returns {boolean} Whether or not this is part of a callback expression\n     */\n\n\n    function isCallbackExpression(node, parentNode) {\n      // ensure the parent node exists and is an expression\n      if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n        return false;\n      } // cb()\n\n\n      if (parentNode.expression === node) {\n        return true;\n      } // special case for cb && cb() and similar\n\n\n      if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n        if (parentNode.expression.right === node) {\n          return true;\n        }\n      }\n\n      return false;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      CallExpression(node) {\n        // if we're not a callback we can return\n        if (!isCallback(node)) {\n          return;\n        } // find the closest block, return or loop\n\n\n        const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {}; // if our parent is a return we know we're ok\n\n        if (closestBlock.type === \"ReturnStatement\") {\n          return;\n        } // arrow functions don't always have blocks and implicitly return\n\n\n        if (closestBlock.type === \"ArrowFunctionExpression\") {\n          return;\n        } // block statements are part of functions and most if statements\n\n\n        if (closestBlock.type === \"BlockStatement\") {\n          // find the last item in the block\n          const lastItem = closestBlock.body[closestBlock.body.length - 1]; // if the callback is the last thing in a block that might be ok\n\n          if (isCallbackExpression(node, lastItem)) {\n            const parentType = closestBlock.parent.type; // but only if the block is part of a function\n\n            if (parentType === \"FunctionExpression\" || parentType === \"FunctionDeclaration\" || parentType === \"ArrowFunctionExpression\") {\n              return;\n            }\n          } // ending a block with a return is also ok\n\n\n          if (lastItem.type === \"ReturnStatement\") {\n            // but only if the callback is immediately before\n            if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n              return;\n            }\n          }\n        } // as long as you're the child of a function at this point you should be asked to return\n\n\n        if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          context.report({\n            node,\n            messageId: \"missingReturn\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","deprecated","replacedBy","type","docs","description","category","recommended","url","schema","items","messages","missingReturn","create","context","callbacks","options","sourceCode","getSourceCode","findClosestParentOfType","node","types","parent","indexOf","containsOnlyIdentifiers","object","isCallback","callee","getText","isCallbackExpression","parentNode","expression","right","CallExpression","closestBlock","lastItem","body","length","parentType","report","messageId"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/callback-return.js"],"sourcesContent":["/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `return` statements after callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/callback-return\"\n        },\n\n        schema: [{\n            type: \"array\",\n            items: { type: \"string\" }\n        }],\n\n        messages: {\n            missingReturn: \"Expected return with your callback function.\"\n        }\n    },\n\n    create(context) {\n\n        const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Find the closest parent matching a list of types.\n         * @param {ASTNode} node The node whose parents we are searching\n         * @param {Array} types The node types to match\n         * @returns {ASTNode} The matched node or undefined.\n         */\n        function findClosestParentOfType(node, types) {\n            if (!node.parent) {\n                return null;\n            }\n            if (types.indexOf(node.parent.type) === -1) {\n                return findClosestParentOfType(node.parent, types);\n            }\n            return node.parent;\n        }\n\n        /**\n         * Check to see if a node contains only identifiers\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the node contains only identifiers\n         */\n        function containsOnlyIdentifiers(node) {\n            if (node.type === \"Identifier\") {\n                return true;\n            }\n\n            if (node.type === \"MemberExpression\") {\n                if (node.object.type === \"Identifier\") {\n                    return true;\n                }\n                if (node.object.type === \"MemberExpression\") {\n                    return containsOnlyIdentifiers(node.object);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if a CallExpression is in our callback list.\n         * @param {ASTNode} node The node to check against our callback names list.\n         * @returns {boolean} Whether or not this function matches our callback name.\n         */\n        function isCallback(node) {\n            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n        }\n\n        /**\n         * Determines whether or not the callback is part of a callback expression.\n         * @param {ASTNode} node The callback node\n         * @param {ASTNode} parentNode The expression node\n         * @returns {boolean} Whether or not this is part of a callback expression\n         */\n        function isCallbackExpression(node, parentNode) {\n\n            // ensure the parent node exists and is an expression\n            if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n                return false;\n            }\n\n            // cb()\n            if (parentNode.expression === node) {\n                return true;\n            }\n\n            // special case for cb && cb() and similar\n            if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n                if (parentNode.expression.right === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n\n                // if we're not a callback we can return\n                if (!isCallback(node)) {\n                    return;\n                }\n\n                // find the closest block, return or loop\n                const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\n\n                // if our parent is a return we know we're ok\n                if (closestBlock.type === \"ReturnStatement\") {\n                    return;\n                }\n\n                // arrow functions don't always have blocks and implicitly return\n                if (closestBlock.type === \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                // block statements are part of functions and most if statements\n                if (closestBlock.type === \"BlockStatement\") {\n\n                    // find the last item in the block\n                    const lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n                    // if the callback is the last thing in a block that might be ok\n                    if (isCallbackExpression(node, lastItem)) {\n\n                        const parentType = closestBlock.parent.type;\n\n                        // but only if the block is part of a function\n                        if (parentType === \"FunctionExpression\" ||\n                            parentType === \"FunctionDeclaration\" ||\n                            parentType === \"ArrowFunctionExpression\"\n                        ) {\n                            return;\n                        }\n\n                    }\n\n                    // ending a block with a return is also ok\n                    if (lastItem.type === \"ReturnStatement\") {\n\n                        // but only if the callback is immediately before\n                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n                            return;\n                        }\n                    }\n\n                }\n\n                // as long as you're the child of a function at this point you should be asked to return\n                if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    context.report({ node, messageId: \"missingReturn\" });\n                }\n\n            }\n\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}