{"ast":null,"code":"/**\n * @fileoverview Rule to define spacing before/after arrow function's arrow.\n * @author Jxck\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after the arrow in arrow functions\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: true\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedBefore: \"Missing space before =>.\",\n      unexpectedBefore: \"Unexpected space before =>.\",\n      expectedAfter: \"Missing space after =>.\",\n      unexpectedAfter: \"Unexpected space after =>.\"\n    }\n  },\n\n  create(context) {\n    // merge rules with default\n    const rule = Object.assign({}, context.options[0]);\n    rule.before = rule.before !== false;\n    rule.after = rule.after !== false;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Get tokens of arrow(`=>`) and before/after arrow.\n     * @param {ASTNode} node The arrow function node.\n     * @returns {Object} Tokens of arrow and before/after arrow.\n     */\n\n    function getTokens(node) {\n      const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n      return {\n        before: sourceCode.getTokenBefore(arrow),\n        arrow,\n        after: sourceCode.getTokenAfter(arrow)\n      };\n    }\n    /**\n     * Count spaces before/after arrow(`=>`) token.\n     * @param {Object} tokens Tokens before/after arrow.\n     * @returns {Object} count of space before/after arrow.\n     */\n\n\n    function countSpaces(tokens) {\n      const before = tokens.arrow.range[0] - tokens.before.range[1];\n      const after = tokens.after.range[0] - tokens.arrow.range[1];\n      return {\n        before,\n        after\n      };\n    }\n    /**\n     * Determines whether space(s) before after arrow(`=>`) is satisfy rule.\n     * if before/after value is `true`, there should be space(s).\n     * if before/after value is `false`, there should be no space.\n     * @param {ASTNode} node The arrow function node.\n     * @returns {void}\n     */\n\n\n    function spaces(node) {\n      const tokens = getTokens(node);\n      const countSpace = countSpaces(tokens);\n\n      if (rule.before) {\n        // should be space(s) before arrow\n        if (countSpace.before === 0) {\n          context.report({\n            node: tokens.before,\n            messageId: \"expectedBefore\",\n\n            fix(fixer) {\n              return fixer.insertTextBefore(tokens.arrow, \" \");\n            }\n\n          });\n        }\n      } else {\n        // should be no space before arrow\n        if (countSpace.before > 0) {\n          context.report({\n            node: tokens.before,\n            messageId: \"unexpectedBefore\",\n\n            fix(fixer) {\n              return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);\n            }\n\n          });\n        }\n      }\n\n      if (rule.after) {\n        // should be space(s) after arrow\n        if (countSpace.after === 0) {\n          context.report({\n            node: tokens.after,\n            messageId: \"expectedAfter\",\n\n            fix(fixer) {\n              return fixer.insertTextAfter(tokens.arrow, \" \");\n            }\n\n          });\n        }\n      } else {\n        // should be no space after arrow\n        if (countSpace.after > 0) {\n          context.report({\n            node: tokens.after,\n            messageId: \"unexpectedAfter\",\n\n            fix(fixer) {\n              return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: spaces\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","before","default","after","additionalProperties","messages","expectedBefore","unexpectedBefore","expectedAfter","unexpectedAfter","create","context","rule","Object","assign","options","sourceCode","getSourceCode","getTokens","node","arrow","getTokenBefore","body","isArrowToken","getTokenAfter","countSpaces","tokens","range","spaces","countSpace","report","messageId","fix","fixer","insertTextBefore","removeRange","insertTextAfter","ArrowFunctionExpression"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/arrow-spacing.js"],"sourcesContent":["/**\n * @fileoverview Rule to define spacing before/after arrow function's arrow.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after the arrow in arrow functions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedBefore: \"Missing space before =>.\",\n            unexpectedBefore: \"Unexpected space before =>.\",\n\n            expectedAfter: \"Missing space after =>.\",\n            unexpectedAfter: \"Unexpected space after =>.\"\n        }\n    },\n\n    create(context) {\n\n        // merge rules with default\n        const rule = Object.assign({}, context.options[0]);\n\n        rule.before = rule.before !== false;\n        rule.after = rule.after !== false;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get tokens of arrow(`=>`) and before/after arrow.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {Object} Tokens of arrow and before/after arrow.\n         */\n        function getTokens(node) {\n            const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n\n            return {\n                before: sourceCode.getTokenBefore(arrow),\n                arrow,\n                after: sourceCode.getTokenAfter(arrow)\n            };\n        }\n\n        /**\n         * Count spaces before/after arrow(`=>`) token.\n         * @param {Object} tokens Tokens before/after arrow.\n         * @returns {Object} count of space before/after arrow.\n         */\n        function countSpaces(tokens) {\n            const before = tokens.arrow.range[0] - tokens.before.range[1];\n            const after = tokens.after.range[0] - tokens.arrow.range[1];\n\n            return { before, after };\n        }\n\n        /**\n         * Determines whether space(s) before after arrow(`=>`) is satisfy rule.\n         * if before/after value is `true`, there should be space(s).\n         * if before/after value is `false`, there should be no space.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function spaces(node) {\n            const tokens = getTokens(node);\n            const countSpace = countSpaces(tokens);\n\n            if (rule.before) {\n\n                // should be space(s) before arrow\n                if (countSpace.before === 0) {\n                    context.report({\n                        node: tokens.before,\n                        messageId: \"expectedBefore\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space before arrow\n                if (countSpace.before > 0) {\n                    context.report({\n                        node: tokens.before,\n                        messageId: \"unexpectedBefore\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);\n                        }\n                    });\n                }\n            }\n\n            if (rule.after) {\n\n                // should be space(s) after arrow\n                if (countSpace.after === 0) {\n                    context.report({\n                        node: tokens.after,\n                        messageId: \"expectedAfter\",\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space after arrow\n                if (countSpace.after > 0) {\n                    context.report({\n                        node: tokens.after,\n                        messageId: \"unexpectedAfter\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: spaces\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}