{"ast":null,"code":"/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow multiple empty lines\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        max: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxEOF: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxBOF: {\n          type: \"integer\",\n          minimum: 0\n        }\n      },\n      required: [\"max\"],\n      additionalProperties: false\n    }],\n    messages: {\n      blankBeginningOfFile: \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\",\n      blankEndOfFile: \"Too many blank lines at the end of file. Max of {{max}} allowed.\",\n      consecutiveBlank: \"More than {{max}} blank {{pluralizedLines}} not allowed.\"\n    }\n  },\n\n  create(context) {\n    // Use options.max or 2 as default\n    let max = 2,\n        maxEOF = max,\n        maxBOF = max;\n\n    if (context.options.length) {\n      max = context.options[0].max;\n      maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n      maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n    }\n\n    const sourceCode = context.getSourceCode(); // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n\n    const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n    const templateLiteralLines = new Set(); //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      TemplateLiteral(node) {\n        node.quasis.forEach(literalPart => {\n          // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n          for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n            templateLiteralLines.add(ignoredLine);\n          }\n        });\n      },\n\n      \"Program:exit\"(node) {\n        return allLines // Given a list of lines, first get a list of line numbers that are non-empty.\n        .reduce((nonEmptyLineNumbers, line, index) => {\n          if (line.trim() || templateLiteralLines.has(index + 1)) {\n            nonEmptyLineNumbers.push(index + 1);\n          }\n\n          return nonEmptyLineNumbers;\n        }, []) // Add a value at the end to allow trailing empty lines to be checked.\n        .concat(allLines.length + 1) // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n        .reduce((lastLineNumber, lineNumber) => {\n          let messageId, maxAllowed;\n\n          if (lastLineNumber === 0) {\n            messageId = \"blankBeginningOfFile\";\n            maxAllowed = maxBOF;\n          } else if (lineNumber === allLines.length + 1) {\n            messageId = \"blankEndOfFile\";\n            maxAllowed = maxEOF;\n          } else {\n            messageId = \"consecutiveBlank\";\n            maxAllowed = max;\n          }\n\n          if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n            context.report({\n              node,\n              loc: {\n                start: {\n                  line: lastLineNumber + maxAllowed + 1,\n                  column: 0\n                },\n                end: {\n                  line: lineNumber,\n                  column: 0\n                }\n              },\n              messageId,\n              data: {\n                max: maxAllowed,\n                pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\"\n              },\n\n              fix(fixer) {\n                const rangeStart = sourceCode.getIndexFromLoc({\n                  line: lastLineNumber + 1,\n                  column: 0\n                });\n                /*\n                 * The end of the removal range is usually the start index of the next line.\n                 * However, at the end of the file there is no next line, so the end of the\n                 * range is just the length of the text.\n                 */\n\n                const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({\n                  line: lineNumberAfterRemovedLines,\n                  column: 0\n                }) : sourceCode.text.length;\n                return fixer.removeRange([rangeStart, rangeEnd]);\n              }\n\n            });\n          }\n\n          return lineNumber;\n        }, 0);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","max","minimum","maxEOF","maxBOF","required","additionalProperties","messages","blankBeginningOfFile","blankEndOfFile","consecutiveBlank","create","context","options","length","sourceCode","getSourceCode","allLines","lines","slice","templateLiteralLines","Set","TemplateLiteral","node","quasis","forEach","literalPart","ignoredLine","loc","start","line","end","add","reduce","nonEmptyLineNumbers","index","trim","has","push","concat","lastLineNumber","lineNumber","messageId","maxAllowed","report","column","data","pluralizedLines","fix","fixer","rangeStart","getIndexFromLoc","lineNumberAfterRemovedLines","rangeEnd","text","removeRange"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-multiple-empty-lines.js"],"sourcesContent":["/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow multiple empty lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxEOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxBOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                required: [\"max\"],\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            blankBeginningOfFile: \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\",\n            blankEndOfFile: \"Too many blank lines at the end of file. Max of {{max}} allowed.\",\n            consecutiveBlank: \"More than {{max}} blank {{pluralizedLines}} not allowed.\"\n        }\n    },\n\n    create(context) {\n\n        // Use options.max or 2 as default\n        let max = 2,\n            maxEOF = max,\n            maxBOF = max;\n\n        if (context.options.length) {\n            max = context.options[0].max;\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n        const templateLiteralLines = new Set();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            TemplateLiteral(node) {\n                node.quasis.forEach(literalPart => {\n\n                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n                        templateLiteralLines.add(ignoredLine);\n                    }\n                });\n            },\n            \"Program:exit\"(node) {\n                return allLines\n\n                    // Given a list of lines, first get a list of line numbers that are non-empty.\n                    .reduce((nonEmptyLineNumbers, line, index) => {\n                        if (line.trim() || templateLiteralLines.has(index + 1)) {\n                            nonEmptyLineNumbers.push(index + 1);\n                        }\n                        return nonEmptyLineNumbers;\n                    }, [])\n\n                    // Add a value at the end to allow trailing empty lines to be checked.\n                    .concat(allLines.length + 1)\n\n                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n                    .reduce((lastLineNumber, lineNumber) => {\n                        let messageId, maxAllowed;\n\n                        if (lastLineNumber === 0) {\n                            messageId = \"blankBeginningOfFile\";\n                            maxAllowed = maxBOF;\n                        } else if (lineNumber === allLines.length + 1) {\n                            messageId = \"blankEndOfFile\";\n                            maxAllowed = maxEOF;\n                        } else {\n                            messageId = \"consecutiveBlank\";\n                            maxAllowed = max;\n                        }\n\n                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n                            context.report({\n                                node,\n                                loc: {\n                                    start: { line: lastLineNumber + maxAllowed + 1, column: 0 },\n                                    end: { line: lineNumber, column: 0 }\n                                },\n                                messageId,\n                                data: {\n                                    max: maxAllowed,\n                                    pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\"\n                                },\n                                fix(fixer) {\n                                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });\n\n                                    /*\n                                     * The end of the removal range is usually the start index of the next line.\n                                     * However, at the end of the file there is no next line, so the end of the\n                                     * range is just the length of the text.\n                                     */\n                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length\n                                        ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 })\n                                        : sourceCode.text.length;\n\n                                    return fixer.removeRange([rangeStart, rangeEnd]);\n                                }\n                            });\n                        }\n\n                        return lineNumber;\n                    }, 0);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}