{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`, \"u\");\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n/**\n * Creates tester which check if a node starts with specific keyword.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\n\nfunction newKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword\n  };\n}\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\n\n\nfunction newSinglelineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\n\n\nfunction newMultilineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n/**\n * Creates tester which check if a node is specific type.\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\n\n\nfunction newNodeTypeTester(type) {\n  return {\n    test: node => node.type === type\n  };\n}\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\n\n\nfunction isIIFEStatement(node) {\n  if (node.type === \"ExpressionStatement\") {\n    let call = astUtils.skipChainExpression(node.expression);\n\n    if (call.type === \"UnaryExpression\") {\n      call = astUtils.skipChainExpression(call.argument);\n    }\n\n    return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n  }\n\n  return false;\n}\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\n\n\nfunction isBlockLikeStatement(sourceCode, node) {\n  // do-while with a block is a block-like statement.\n  if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n    return true;\n  }\n  /*\n   * IIFE is a block-like statement specially from\n   * JSCS#disallowPaddingNewLinesAfterBlocks.\n   */\n\n\n  if (isIIFEStatement(node)) {\n    return true;\n  } // Checks the last token is a closing brace of blocks.\n\n\n  const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n  const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;\n  return Boolean(belongingNode) && (belongingNode.type === \"BlockStatement\" || belongingNode.type === \"SwitchStatement\");\n}\n/**\n * Check whether the given node is a directive or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a directive.\n */\n\n\nfunction isDirective(node, sourceCode) {\n  return node.type === \"ExpressionStatement\" && (node.parent.type === \"Program\" || node.parent.type === \"BlockStatement\" && astUtils.isFunction(node.parent.parent)) && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\" && !astUtils.isParenthesised(sourceCode, node.expression);\n}\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\n\n\nfunction isDirectivePrologue(node, sourceCode) {\n  if (isDirective(node, sourceCode)) {\n    for (const sibling of node.parent.body) {\n      if (sibling === node) {\n        break;\n      }\n\n      if (!isDirective(sibling, sourceCode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\n\n\nfunction getActualLastToken(sourceCode, node) {\n  const semiToken = sourceCode.getLastToken(node);\n  const prevToken = sourceCode.getTokenBefore(semiToken);\n  const nextToken = sourceCode.getTokenAfter(semiToken);\n  const isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);\n  return isSemicolonLessStyle ? prevToken : semiToken;\n}\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\n\n\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n  return trailingSpaces + indentSpaces;\n}\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n * @returns {void}\n * @private\n */\n\n\nfunction verifyForAny() {}\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\n\n\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n  if (paddingLines.length === 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    messageId: \"unexpectedBlankLine\",\n\n    fix(fixer) {\n      if (paddingLines.length >= 2) {\n        return null;\n      }\n\n      const prevToken = paddingLines[0][0];\n      const nextToken = paddingLines[0][1];\n      const start = prevToken.range[1];\n      const end = nextToken.range[0];\n      const text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n      return fixer.replaceTextRange([start, end], text);\n    }\n\n  });\n}\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\n\n\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n  if (paddingLines.length > 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    messageId: \"expectedBlankLine\",\n\n    fix(fixer) {\n      const sourceCode = context.getSourceCode();\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {\n        includeComments: true,\n\n        /**\n         * Skip the trailing comments of the previous node.\n         * This inserts a blank line after the last trailing comment.\n         *\n         * For example:\n         *\n         *     foo(); // trailing comment.\n         *     // comment.\n         *     bar();\n         *\n         * Get fixed to:\n         *\n         *     foo(); // trailing comment.\n         *\n         *     // comment.\n         *     bar();\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is not a trailing comment.\n         * @private\n         */\n        filter(token) {\n          if (astUtils.isTokenOnSameLine(prevToken, token)) {\n            prevToken = token;\n            return false;\n          }\n\n          return true;\n        }\n\n      }) || nextNode;\n      const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? \"\\n\\n\" : \"\\n\";\n      return fixer.insertTextAfter(prevToken, insertText);\n    }\n\n  });\n}\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\n\n\nconst PaddingTypes = {\n  any: {\n    verify: verifyForAny\n  },\n  never: {\n    verify: verifyForNever\n  },\n  always: {\n    verify: verifyForAlways\n  }\n};\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\n\nconst StatementTypes = {\n  \"*\": {\n    test: () => true\n  },\n  \"block-like\": {\n    test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n  },\n  \"cjs-export\": {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && node.expression.type === \"AssignmentExpression\" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n  },\n  \"cjs-import\": {\n    test: (node, sourceCode) => node.type === \"VariableDeclaration\" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n  },\n  directive: {\n    test: isDirectivePrologue\n  },\n  expression: {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  iife: {\n    test: isIIFEStatement\n  },\n  \"multiline-block-like\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)\n  },\n  \"multiline-expression\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  \"multiline-const\": newMultilineKeywordTester(\"const\"),\n  \"multiline-let\": newMultilineKeywordTester(\"let\"),\n  \"multiline-var\": newMultilineKeywordTester(\"var\"),\n  \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n  \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n  \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n  block: newNodeTypeTester(\"BlockStatement\"),\n  empty: newNodeTypeTester(\"EmptyStatement\"),\n  function: newNodeTypeTester(\"FunctionDeclaration\"),\n  break: newKeywordTester(\"break\"),\n  case: newKeywordTester(\"case\"),\n  class: newKeywordTester(\"class\"),\n  const: newKeywordTester(\"const\"),\n  continue: newKeywordTester(\"continue\"),\n  debugger: newKeywordTester(\"debugger\"),\n  default: newKeywordTester(\"default\"),\n  do: newKeywordTester(\"do\"),\n  export: newKeywordTester(\"export\"),\n  for: newKeywordTester(\"for\"),\n  if: newKeywordTester(\"if\"),\n  import: newKeywordTester(\"import\"),\n  let: newKeywordTester(\"let\"),\n  return: newKeywordTester(\"return\"),\n  switch: newKeywordTester(\"switch\"),\n  throw: newKeywordTester(\"throw\"),\n  try: newKeywordTester(\"try\"),\n  var: newKeywordTester(\"var\"),\n  while: newKeywordTester(\"while\"),\n  with: newKeywordTester(\"with\")\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding lines between statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        paddingType: {\n          enum: Object.keys(PaddingTypes)\n        },\n        statementType: {\n          anyOf: [{\n            enum: Object.keys(StatementTypes)\n          }, {\n            type: \"array\",\n            items: {\n              enum: Object.keys(StatementTypes)\n            },\n            minItems: 1,\n            uniqueItems: true,\n            additionalItems: false\n          }]\n        }\n      },\n      type: \"array\",\n      items: {\n        type: \"object\",\n        properties: {\n          blankLine: {\n            $ref: \"#/definitions/paddingType\"\n          },\n          prev: {\n            $ref: \"#/definitions/statementType\"\n          },\n          next: {\n            $ref: \"#/definitions/statementType\"\n          }\n        },\n        additionalProperties: false,\n        required: [\"blankLine\", \"prev\", \"next\"]\n      },\n      additionalItems: false\n    },\n    messages: {\n      unexpectedBlankLine: \"Unexpected blank line before this statement.\",\n      expectedBlankLine: \"Expected blank line before this statement.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const configureList = context.options || [];\n    let scopeInfo = null;\n    /**\n     * Processes to enter to new scope.\n     * This manages the current previous statement.\n     * @returns {void}\n     * @private\n     */\n\n    function enterScope() {\n      scopeInfo = {\n        upper: scopeInfo,\n        prevNode: null\n      };\n    }\n    /**\n     * Processes to exit from the current scope.\n     * @returns {void}\n     * @private\n     */\n\n\n    function exitScope() {\n      scopeInfo = scopeInfo.upper;\n    }\n    /**\n     * Checks whether the given node matches the given type.\n     * @param {ASTNode} node The statement node to check.\n     * @param {string|string[]} type The statement type to check.\n     * @returns {boolean} `true` if the statement node matched the type.\n     * @private\n     */\n\n\n    function match(node, type) {\n      let innerStatementNode = node;\n\n      while (innerStatementNode.type === \"LabeledStatement\") {\n        innerStatementNode = innerStatementNode.body;\n      }\n\n      if (Array.isArray(type)) {\n        return type.some(match.bind(null, innerStatementNode));\n      }\n\n      return StatementTypes[type].test(innerStatementNode, sourceCode);\n    }\n    /**\n     * Finds the last matched configure from configureList.\n     * @param {ASTNode} prevNode The previous statement to match.\n     * @param {ASTNode} nextNode The current statement to match.\n     * @returns {Object} The tester of the last matched configure.\n     * @private\n     */\n\n\n    function getPaddingType(prevNode, nextNode) {\n      for (let i = configureList.length - 1; i >= 0; --i) {\n        const configure = configureList[i];\n        const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);\n\n        if (matched) {\n          return PaddingTypes[configure.blankLine];\n        }\n      }\n\n      return PaddingTypes.any;\n    }\n    /**\n     * Gets padding line sequences between the given 2 statements.\n     * Comments are separators of the padding line sequences.\n     * @param {ASTNode} prevNode The previous statement to count.\n     * @param {ASTNode} nextNode The current statement to count.\n     * @returns {Array<Token[]>} The array of token pairs.\n     * @private\n     */\n\n\n    function getPaddingLineSequences(prevNode, nextNode) {\n      const pairs = [];\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n\n      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n        do {\n          const token = sourceCode.getTokenAfter(prevToken, {\n            includeComments: true\n          });\n\n          if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n            pairs.push([prevToken, token]);\n          }\n\n          prevToken = token;\n        } while (prevToken.range[0] < nextNode.range[0]);\n      }\n\n      return pairs;\n    }\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * @param {ASTNode} node The node to verify.\n     * @returns {void}\n     * @private\n     */\n\n\n    function verify(node) {\n      const parentType = node.parent.type;\n      const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === \"SwitchStatement\";\n\n      if (!validParent) {\n        return;\n      } // Save this node as the current previous statement.\n\n\n      const prevNode = scopeInfo.prevNode; // Verify.\n\n      if (prevNode) {\n        const type = getPaddingType(prevNode, node);\n        const paddingLines = getPaddingLineSequences(prevNode, node);\n        type.verify(context, prevNode, node, paddingLines);\n      }\n\n      scopeInfo.prevNode = node;\n    }\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * Then process to enter to new scope.\n     * @param {ASTNode} node The node to verify.\n     * @returns {void}\n     * @private\n     */\n\n\n    function verifyThenEnterScope(node) {\n      verify(node);\n      enterScope();\n    }\n\n    return {\n      Program: enterScope,\n      BlockStatement: enterScope,\n      SwitchStatement: enterScope,\n      \"Program:exit\": exitScope,\n      \"BlockStatement:exit\": exitScope,\n      \"SwitchStatement:exit\": exitScope,\n      \":statement\": verify,\n      SwitchCase: verifyThenEnterScope,\n      \"SwitchCase:exit\": exitScope\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","LT","Array","from","LINEBREAKS","join","PADDING_LINE_SEQUENCE","RegExp","String","raw","CJS_EXPORT","CJS_IMPORT","newKeywordTester","keyword","test","node","sourceCode","getFirstToken","value","newSinglelineKeywordTester","loc","start","line","end","newMultilineKeywordTester","newNodeTypeTester","type","isIIFEStatement","call","skipChainExpression","expression","argument","isFunction","callee","isBlockLikeStatement","body","lastToken","getLastToken","isNotSemicolonToken","belongingNode","isClosingBraceToken","getNodeByRangeIndex","range","Boolean","isDirective","parent","isParenthesised","isDirectivePrologue","sibling","getActualLastToken","semiToken","prevToken","getTokenBefore","nextToken","getTokenAfter","isSemicolonLessStyle","isSemicolonToken","replacerToRemovePaddingLines","_","trailingSpaces","indentSpaces","verifyForAny","verifyForNever","context","nextNode","paddingLines","length","report","messageId","fix","fixer","text","getSourceCode","slice","replace","replaceTextRange","verifyForAlways","prevNode","getFirstTokenBetween","includeComments","filter","token","isTokenOnSameLine","insertText","insertTextAfter","PaddingTypes","any","verify","never","always","StatementTypes","getText","left","declarations","init","directive","iife","block","empty","function","break","case","class","const","continue","debugger","default","do","export","for","if","import","let","return","switch","throw","try","var","while","with","module","exports","meta","docs","description","category","recommended","url","fixable","schema","definitions","paddingType","enum","Object","keys","statementType","anyOf","items","minItems","uniqueItems","additionalItems","properties","blankLine","$ref","prev","next","additionalProperties","required","messages","unexpectedBlankLine","expectedBlankLine","create","configureList","options","scopeInfo","enterScope","upper","exitScope","match","innerStatementNode","isArray","some","bind","getPaddingType","i","configure","matched","getPaddingLineSequences","pairs","push","parentType","validParent","STATEMENT_LIST_PARENTS","has","verifyThenEnterScope","Program","BlockStatement","SwitchStatement","SwitchCase"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/padding-line-between-statements.js"],"sourcesContent":["/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(\n    String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`,\n    \"u\"\n);\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n\n/**\n * Creates tester which check if a node starts with specific keyword.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newSinglelineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line === node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newMultilineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node is specific type.\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n    return {\n        test: node =>\n            node.type === type\n    };\n}\n\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n    if (node.type === \"ExpressionStatement\") {\n        let call = astUtils.skipChainExpression(node.expression);\n\n        if (call.type === \"UnaryExpression\") {\n            call = astUtils.skipChainExpression(call.argument);\n        }\n        return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n    }\n    return false;\n}\n\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(sourceCode, node) {\n\n    // do-while with a block is a block-like statement.\n    if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n        return true;\n    }\n\n    /*\n     * IIFE is a block-like statement specially from\n     * JSCS#disallowPaddingNewLinesAfterBlocks.\n     */\n    if (isIIFEStatement(node)) {\n        return true;\n    }\n\n    // Checks the last token is a closing brace of blocks.\n    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)\n        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])\n        : null;\n\n    return Boolean(belongingNode) && (\n        belongingNode.type === \"BlockStatement\" ||\n        belongingNode.type === \"SwitchStatement\"\n    );\n}\n\n/**\n * Check whether the given node is a directive or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a directive.\n */\nfunction isDirective(node, sourceCode) {\n    return (\n        node.type === \"ExpressionStatement\" &&\n        (\n            node.parent.type === \"Program\" ||\n            (\n                node.parent.type === \"BlockStatement\" &&\n                astUtils.isFunction(node.parent.parent)\n            )\n        ) &&\n        node.expression.type === \"Literal\" &&\n        typeof node.expression.value === \"string\" &&\n        !astUtils.isParenthesised(sourceCode, node.expression)\n    );\n}\n\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\nfunction isDirectivePrologue(node, sourceCode) {\n    if (isDirective(node, sourceCode)) {\n        for (const sibling of node.parent.body) {\n            if (sibling === node) {\n                break;\n            }\n            if (!isDirective(sibling, sourceCode)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\nfunction getActualLastToken(sourceCode, node) {\n    const semiToken = sourceCode.getLastToken(node);\n    const prevToken = sourceCode.getTokenBefore(semiToken);\n    const nextToken = sourceCode.getTokenAfter(semiToken);\n    const isSemicolonLessStyle = Boolean(\n        prevToken &&\n        nextToken &&\n        prevToken.range[0] >= node.range[0] &&\n        astUtils.isSemicolonToken(semiToken) &&\n        semiToken.loc.start.line !== prevToken.loc.end.line &&\n        semiToken.loc.end.line === nextToken.loc.start.line\n    );\n\n    return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n    return trailingSpaces + indentSpaces;\n}\n\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n * @returns {void}\n * @private\n */\nfunction verifyForAny() {\n}\n\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n    if (paddingLines.length === 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        messageId: \"unexpectedBlankLine\",\n        fix(fixer) {\n            if (paddingLines.length >= 2) {\n                return null;\n            }\n\n            const prevToken = paddingLines[0][0];\n            const nextToken = paddingLines[0][1];\n            const start = prevToken.range[1];\n            const end = nextToken.range[0];\n            const text = context.getSourceCode().text\n                .slice(start, end)\n                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n\n            return fixer.replaceTextRange([start, end], text);\n        }\n    });\n}\n\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n    if (paddingLines.length > 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        messageId: \"expectedBlankLine\",\n        fix(fixer) {\n            const sourceCode = context.getSourceCode();\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n            const nextToken = sourceCode.getFirstTokenBetween(\n                prevToken,\n                nextNode,\n                {\n                    includeComments: true,\n\n                    /**\n                     * Skip the trailing comments of the previous node.\n                     * This inserts a blank line after the last trailing comment.\n                     *\n                     * For example:\n                     *\n                     *     foo(); // trailing comment.\n                     *     // comment.\n                     *     bar();\n                     *\n                     * Get fixed to:\n                     *\n                     *     foo(); // trailing comment.\n                     *\n                     *     // comment.\n                     *     bar();\n                     * @param {Token} token The token to check.\n                     * @returns {boolean} `true` if the token is not a trailing comment.\n                     * @private\n                     */\n                    filter(token) {\n                        if (astUtils.isTokenOnSameLine(prevToken, token)) {\n                            prevToken = token;\n                            return false;\n                        }\n                        return true;\n                    }\n                }\n            ) || nextNode;\n            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)\n                ? \"\\n\\n\"\n                : \"\\n\";\n\n            return fixer.insertTextAfter(prevToken, insertText);\n        }\n    });\n}\n\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n    any: { verify: verifyForAny },\n    never: { verify: verifyForNever },\n    always: { verify: verifyForAlways }\n};\n\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n    \"*\": { test: () => true },\n    \"block-like\": {\n        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n    },\n    \"cjs-export\": {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            node.expression.type === \"AssignmentExpression\" &&\n            CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n    },\n    \"cjs-import\": {\n        test: (node, sourceCode) =>\n            node.type === \"VariableDeclaration\" &&\n            node.declarations.length > 0 &&\n            Boolean(node.declarations[0].init) &&\n            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n    },\n    directive: {\n        test: isDirectivePrologue\n    },\n    expression: {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n    iife: {\n        test: isIIFEStatement\n    },\n    \"multiline-block-like\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            isBlockLikeStatement(sourceCode, node)\n    },\n    \"multiline-expression\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n\n    \"multiline-const\": newMultilineKeywordTester(\"const\"),\n    \"multiline-let\": newMultilineKeywordTester(\"let\"),\n    \"multiline-var\": newMultilineKeywordTester(\"var\"),\n    \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n    \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n    \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n\n    block: newNodeTypeTester(\"BlockStatement\"),\n    empty: newNodeTypeTester(\"EmptyStatement\"),\n    function: newNodeTypeTester(\"FunctionDeclaration\"),\n\n    break: newKeywordTester(\"break\"),\n    case: newKeywordTester(\"case\"),\n    class: newKeywordTester(\"class\"),\n    const: newKeywordTester(\"const\"),\n    continue: newKeywordTester(\"continue\"),\n    debugger: newKeywordTester(\"debugger\"),\n    default: newKeywordTester(\"default\"),\n    do: newKeywordTester(\"do\"),\n    export: newKeywordTester(\"export\"),\n    for: newKeywordTester(\"for\"),\n    if: newKeywordTester(\"if\"),\n    import: newKeywordTester(\"import\"),\n    let: newKeywordTester(\"let\"),\n    return: newKeywordTester(\"return\"),\n    switch: newKeywordTester(\"switch\"),\n    throw: newKeywordTester(\"throw\"),\n    try: newKeywordTester(\"try\"),\n    var: newKeywordTester(\"var\"),\n    while: newKeywordTester(\"while\"),\n    with: newKeywordTester(\"with\")\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding lines between statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                paddingType: {\n                    enum: Object.keys(PaddingTypes)\n                },\n                statementType: {\n                    anyOf: [\n                        { enum: Object.keys(StatementTypes) },\n                        {\n                            type: \"array\",\n                            items: { enum: Object.keys(StatementTypes) },\n                            minItems: 1,\n                            uniqueItems: true,\n                            additionalItems: false\n                        }\n                    ]\n                }\n            },\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    blankLine: { $ref: \"#/definitions/paddingType\" },\n                    prev: { $ref: \"#/definitions/statementType\" },\n                    next: { $ref: \"#/definitions/statementType\" }\n                },\n                additionalProperties: false,\n                required: [\"blankLine\", \"prev\", \"next\"]\n            },\n            additionalItems: false\n        },\n\n        messages: {\n            unexpectedBlankLine: \"Unexpected blank line before this statement.\",\n            expectedBlankLine: \"Expected blank line before this statement.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const configureList = context.options || [];\n        let scopeInfo = null;\n\n        /**\n         * Processes to enter to new scope.\n         * This manages the current previous statement.\n         * @returns {void}\n         * @private\n         */\n        function enterScope() {\n            scopeInfo = {\n                upper: scopeInfo,\n                prevNode: null\n            };\n        }\n\n        /**\n         * Processes to exit from the current scope.\n         * @returns {void}\n         * @private\n         */\n        function exitScope() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Checks whether the given node matches the given type.\n         * @param {ASTNode} node The statement node to check.\n         * @param {string|string[]} type The statement type to check.\n         * @returns {boolean} `true` if the statement node matched the type.\n         * @private\n         */\n        function match(node, type) {\n            let innerStatementNode = node;\n\n            while (innerStatementNode.type === \"LabeledStatement\") {\n                innerStatementNode = innerStatementNode.body;\n            }\n            if (Array.isArray(type)) {\n                return type.some(match.bind(null, innerStatementNode));\n            }\n            return StatementTypes[type].test(innerStatementNode, sourceCode);\n        }\n\n        /**\n         * Finds the last matched configure from configureList.\n         * @param {ASTNode} prevNode The previous statement to match.\n         * @param {ASTNode} nextNode The current statement to match.\n         * @returns {Object} The tester of the last matched configure.\n         * @private\n         */\n        function getPaddingType(prevNode, nextNode) {\n            for (let i = configureList.length - 1; i >= 0; --i) {\n                const configure = configureList[i];\n                const matched =\n                    match(prevNode, configure.prev) &&\n                    match(nextNode, configure.next);\n\n                if (matched) {\n                    return PaddingTypes[configure.blankLine];\n                }\n            }\n            return PaddingTypes.any;\n        }\n\n        /**\n         * Gets padding line sequences between the given 2 statements.\n         * Comments are separators of the padding line sequences.\n         * @param {ASTNode} prevNode The previous statement to count.\n         * @param {ASTNode} nextNode The current statement to count.\n         * @returns {Array<Token[]>} The array of token pairs.\n         * @private\n         */\n        function getPaddingLineSequences(prevNode, nextNode) {\n            const pairs = [];\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n\n            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n                do {\n                    const token = sourceCode.getTokenAfter(\n                        prevToken,\n                        { includeComments: true }\n                    );\n\n                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n                        pairs.push([prevToken, token]);\n                    }\n                    prevToken = token;\n\n                } while (prevToken.range[0] < nextNode.range[0]);\n            }\n\n            return pairs;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verify(node) {\n            const parentType = node.parent.type;\n            const validParent =\n                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||\n                parentType === \"SwitchStatement\";\n\n            if (!validParent) {\n                return;\n            }\n\n            // Save this node as the current previous statement.\n            const prevNode = scopeInfo.prevNode;\n\n            // Verify.\n            if (prevNode) {\n                const type = getPaddingType(prevNode, node);\n                const paddingLines = getPaddingLineSequences(prevNode, node);\n\n                type.verify(context, prevNode, node, paddingLines);\n            }\n\n            scopeInfo.prevNode = node;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * Then process to enter to new scope.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verifyThenEnterScope(node) {\n            verify(node);\n            enterScope();\n        }\n\n        return {\n            Program: enterScope,\n            BlockStatement: enterScope,\n            SwitchStatement: enterScope,\n            \"Program:exit\": exitScope,\n            \"BlockStatement:exit\": exitScope,\n            \"SwitchStatement:exit\": exitScope,\n\n            \":statement\": verify,\n\n            SwitchCase: verifyThenEnterScope,\n            \"SwitchCase:exit\": exitScope\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEA,MAAMC,EAAE,GAAI,IAAGC,KAAK,CAACC,IAAN,CAAWJ,QAAQ,CAACK,UAApB,EAAgCC,IAAhC,CAAqC,EAArC,CAAyC,GAAxD;AACA,MAAMC,qBAAqB,GAAG,IAAIC,MAAJ,CAC1BC,MAAM,CAACC,GAAI,SAAQR,EAAG,OAAMA,EAAG,UADL,EAE1B,GAF0B,CAA9B;AAIA,MAAMS,UAAU,GAAG,+CAAnB;AACA,MAAMC,UAAU,GAAG,aAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,gBAAT,CAA0BC,OAA1B,EAAmC;EAC/B,OAAO;IACHC,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFA,UAAU,CAACC,aAAX,CAAyBF,IAAzB,EAA+BG,KAA/B,KAAyCL;EAF1C,CAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,0BAAT,CAAoCN,OAApC,EAA6C;EACzC,OAAO;IACHC,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAN,UAAU,CAACC,aAAX,CAAyBF,IAAzB,EAA+BG,KAA/B,KAAyCL;EAH1C,CAAP;AAKH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASW,yBAAT,CAAmCX,OAAnC,EAA4C;EACxC,OAAO;IACHC,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAN,UAAU,CAACC,aAAX,CAAyBF,IAAzB,EAA+BG,KAA/B,KAAyCL;EAH1C,CAAP;AAKH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASY,iBAAT,CAA2BC,IAA3B,EAAiC;EAC7B,OAAO;IACHZ,IAAI,EAAEC,IAAI,IACNA,IAAI,CAACW,IAAL,KAAcA;EAFf,CAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,eAAT,CAAyBZ,IAAzB,EAA+B;EAC3B,IAAIA,IAAI,CAACW,IAAL,KAAc,qBAAlB,EAAyC;IACrC,IAAIE,IAAI,GAAG7B,QAAQ,CAAC8B,mBAAT,CAA6Bd,IAAI,CAACe,UAAlC,CAAX;;IAEA,IAAIF,IAAI,CAACF,IAAL,KAAc,iBAAlB,EAAqC;MACjCE,IAAI,GAAG7B,QAAQ,CAAC8B,mBAAT,CAA6BD,IAAI,CAACG,QAAlC,CAAP;IACH;;IACD,OAAOH,IAAI,CAACF,IAAL,KAAc,gBAAd,IAAkC3B,QAAQ,CAACiC,UAAT,CAAoBJ,IAAI,CAACK,MAAzB,CAAzC;EACH;;EACD,OAAO,KAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,oBAAT,CAA8BlB,UAA9B,EAA0CD,IAA1C,EAAgD;EAE5C;EACA,IAAIA,IAAI,CAACW,IAAL,KAAc,kBAAd,IAAoCX,IAAI,CAACoB,IAAL,CAAUT,IAAV,KAAmB,gBAA3D,EAA6E;IACzE,OAAO,IAAP;EACH;EAED;AACJ;AACA;AACA;;;EACI,IAAIC,eAAe,CAACZ,IAAD,CAAnB,EAA2B;IACvB,OAAO,IAAP;EACH,CAb2C,CAe5C;;;EACA,MAAMqB,SAAS,GAAGpB,UAAU,CAACqB,YAAX,CAAwBtB,IAAxB,EAA8BhB,QAAQ,CAACuC,mBAAvC,CAAlB;EACA,MAAMC,aAAa,GAAGH,SAAS,IAAIrC,QAAQ,CAACyC,mBAAT,CAA6BJ,SAA7B,CAAb,GAChBpB,UAAU,CAACyB,mBAAX,CAA+BL,SAAS,CAACM,KAAV,CAAgB,CAAhB,CAA/B,CADgB,GAEhB,IAFN;EAIA,OAAOC,OAAO,CAACJ,aAAD,CAAP,KACHA,aAAa,CAACb,IAAd,KAAuB,gBAAvB,IACAa,aAAa,CAACb,IAAd,KAAuB,iBAFpB,CAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASkB,WAAT,CAAqB7B,IAArB,EAA2BC,UAA3B,EAAuC;EACnC,OACID,IAAI,CAACW,IAAL,KAAc,qBAAd,KAEIX,IAAI,CAAC8B,MAAL,CAAYnB,IAAZ,KAAqB,SAArB,IAEIX,IAAI,CAAC8B,MAAL,CAAYnB,IAAZ,KAAqB,gBAArB,IACA3B,QAAQ,CAACiC,UAAT,CAAoBjB,IAAI,CAAC8B,MAAL,CAAYA,MAAhC,CALR,KAQA9B,IAAI,CAACe,UAAL,CAAgBJ,IAAhB,KAAyB,SARzB,IASA,OAAOX,IAAI,CAACe,UAAL,CAAgBZ,KAAvB,KAAiC,QATjC,IAUA,CAACnB,QAAQ,CAAC+C,eAAT,CAAyB9B,UAAzB,EAAqCD,IAAI,CAACe,UAA1C,CAXL;AAaH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiB,mBAAT,CAA6BhC,IAA7B,EAAmCC,UAAnC,EAA+C;EAC3C,IAAI4B,WAAW,CAAC7B,IAAD,EAAOC,UAAP,CAAf,EAAmC;IAC/B,KAAK,MAAMgC,OAAX,IAAsBjC,IAAI,CAAC8B,MAAL,CAAYV,IAAlC,EAAwC;MACpC,IAAIa,OAAO,KAAKjC,IAAhB,EAAsB;QAClB;MACH;;MACD,IAAI,CAAC6B,WAAW,CAACI,OAAD,EAAUhC,UAAV,CAAhB,EAAuC;QACnC,OAAO,KAAP;MACH;IACJ;;IACD,OAAO,IAAP;EACH;;EACD,OAAO,KAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiC,kBAAT,CAA4BjC,UAA5B,EAAwCD,IAAxC,EAA8C;EAC1C,MAAMmC,SAAS,GAAGlC,UAAU,CAACqB,YAAX,CAAwBtB,IAAxB,CAAlB;EACA,MAAMoC,SAAS,GAAGnC,UAAU,CAACoC,cAAX,CAA0BF,SAA1B,CAAlB;EACA,MAAMG,SAAS,GAAGrC,UAAU,CAACsC,aAAX,CAAyBJ,SAAzB,CAAlB;EACA,MAAMK,oBAAoB,GAAGZ,OAAO,CAChCQ,SAAS,IACTE,SADA,IAEAF,SAAS,CAACT,KAAV,CAAgB,CAAhB,KAAsB3B,IAAI,CAAC2B,KAAL,CAAW,CAAX,CAFtB,IAGA3C,QAAQ,CAACyD,gBAAT,CAA0BN,SAA1B,CAHA,IAIAA,SAAS,CAAC9B,GAAV,CAAcC,KAAd,CAAoBC,IAApB,KAA6B6B,SAAS,CAAC/B,GAAV,CAAcG,GAAd,CAAkBD,IAJ/C,IAKA4B,SAAS,CAAC9B,GAAV,CAAcG,GAAd,CAAkBD,IAAlB,KAA2B+B,SAAS,CAACjC,GAAV,CAAcC,KAAd,CAAoBC,IANf,CAApC;EASA,OAAOiC,oBAAoB,GAAGJ,SAAH,GAAeD,SAA1C;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,4BAAT,CAAsCC,CAAtC,EAAyCC,cAAzC,EAAyDC,YAAzD,EAAuE;EACnE,OAAOD,cAAc,GAAGC,YAAxB;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,YAAT,GAAwB,CACvB;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBC,OAAxB,EAAiCL,CAAjC,EAAoCM,QAApC,EAA8CC,YAA9C,EAA4D;EACxD,IAAIA,YAAY,CAACC,MAAb,KAAwB,CAA5B,EAA+B;IAC3B;EACH;;EAEDH,OAAO,CAACI,MAAR,CAAe;IACXpD,IAAI,EAAEiD,QADK;IAEXI,SAAS,EAAE,qBAFA;;IAGXC,GAAG,CAACC,KAAD,EAAQ;MACP,IAAIL,YAAY,CAACC,MAAb,IAAuB,CAA3B,EAA8B;QAC1B,OAAO,IAAP;MACH;;MAED,MAAMf,SAAS,GAAGc,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,CAAlB;MACA,MAAMZ,SAAS,GAAGY,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,CAAlB;MACA,MAAM5C,KAAK,GAAG8B,SAAS,CAACT,KAAV,CAAgB,CAAhB,CAAd;MACA,MAAMnB,GAAG,GAAG8B,SAAS,CAACX,KAAV,CAAgB,CAAhB,CAAZ;MACA,MAAM6B,IAAI,GAAGR,OAAO,CAACS,aAAR,GAAwBD,IAAxB,CACRE,KADQ,CACFpD,KADE,EACKE,GADL,EAERmD,OAFQ,CAEApE,qBAFA,EAEuBmD,4BAFvB,CAAb;MAIA,OAAOa,KAAK,CAACK,gBAAN,CAAuB,CAACtD,KAAD,EAAQE,GAAR,CAAvB,EAAqCgD,IAArC,CAAP;IACH;;EAjBU,CAAf;AAmBH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,eAAT,CAAyBb,OAAzB,EAAkCc,QAAlC,EAA4Cb,QAA5C,EAAsDC,YAAtD,EAAoE;EAChE,IAAIA,YAAY,CAACC,MAAb,GAAsB,CAA1B,EAA6B;IACzB;EACH;;EAEDH,OAAO,CAACI,MAAR,CAAe;IACXpD,IAAI,EAAEiD,QADK;IAEXI,SAAS,EAAE,mBAFA;;IAGXC,GAAG,CAACC,KAAD,EAAQ;MACP,MAAMtD,UAAU,GAAG+C,OAAO,CAACS,aAAR,EAAnB;MACA,IAAIrB,SAAS,GAAGF,kBAAkB,CAACjC,UAAD,EAAa6D,QAAb,CAAlC;MACA,MAAMxB,SAAS,GAAGrC,UAAU,CAAC8D,oBAAX,CACd3B,SADc,EAEda,QAFc,EAGd;QACIe,eAAe,EAAE,IADrB;;QAGI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACoBC,MAAM,CAACC,KAAD,EAAQ;UACV,IAAIlF,QAAQ,CAACmF,iBAAT,CAA2B/B,SAA3B,EAAsC8B,KAAtC,CAAJ,EAAkD;YAC9C9B,SAAS,GAAG8B,KAAZ;YACA,OAAO,KAAP;UACH;;UACD,OAAO,IAAP;QACH;;MA7BL,CAHc,KAkCbjB,QAlCL;MAmCA,MAAMmB,UAAU,GAAGpF,QAAQ,CAACmF,iBAAT,CAA2B/B,SAA3B,EAAsCE,SAAtC,IACb,MADa,GAEb,IAFN;MAIA,OAAOiB,KAAK,CAACc,eAAN,CAAsBjC,SAAtB,EAAiCgC,UAAjC,CAAP;IACH;;EA9CU,CAAf;AAgDH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,YAAY,GAAG;EACjBC,GAAG,EAAE;IAAEC,MAAM,EAAE1B;EAAV,CADY;EAEjB2B,KAAK,EAAE;IAAED,MAAM,EAAEzB;EAAV,CAFU;EAGjB2B,MAAM,EAAE;IAAEF,MAAM,EAAEX;EAAV;AAHS,CAArB;AAMA;AACA;AACA;AACA;AACA;;AACA,MAAMc,cAAc,GAAG;EACnB,KAAK;IAAE5E,IAAI,EAAE,MAAM;EAAd,CADc;EAEnB,cAAc;IACVA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KAAsBkB,oBAAoB,CAAClB,UAAD,EAAaD,IAAb;EADtC,CAFK;EAKnB,cAAc;IACVD,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACW,IAAL,KAAc,qBAAd,IACAX,IAAI,CAACe,UAAL,CAAgBJ,IAAhB,KAAyB,sBADzB,IAEAhB,UAAU,CAACI,IAAX,CAAgBE,UAAU,CAAC2E,OAAX,CAAmB5E,IAAI,CAACe,UAAL,CAAgB8D,IAAnC,CAAhB;EAJM,CALK;EAWnB,cAAc;IACV9E,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACW,IAAL,KAAc,qBAAd,IACAX,IAAI,CAAC8E,YAAL,CAAkB3B,MAAlB,GAA2B,CAD3B,IAEAvB,OAAO,CAAC5B,IAAI,CAAC8E,YAAL,CAAkB,CAAlB,EAAqBC,IAAtB,CAFP,IAGAnF,UAAU,CAACG,IAAX,CAAgBE,UAAU,CAAC2E,OAAX,CAAmB5E,IAAI,CAAC8E,YAAL,CAAkB,CAAlB,EAAqBC,IAAxC,CAAhB;EALM,CAXK;EAkBnBC,SAAS,EAAE;IACPjF,IAAI,EAAEiC;EADC,CAlBQ;EAqBnBjB,UAAU,EAAE;IACRhB,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACW,IAAL,KAAc,qBAAd,IACA,CAACqB,mBAAmB,CAAChC,IAAD,EAAOC,UAAP;EAHhB,CArBO;EA0BnBgF,IAAI,EAAE;IACFlF,IAAI,EAAEa;EADJ,CA1Ba;EA6BnB,wBAAwB;IACpBb,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAY,oBAAoB,CAAClB,UAAD,EAAaD,IAAb;EAHJ,CA7BL;EAkCnB,wBAAwB;IACpBD,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAP,IAAI,CAACW,IAAL,KAAc,qBADd,IAEA,CAACqB,mBAAmB,CAAChC,IAAD,EAAOC,UAAP;EAJJ,CAlCL;EAyCnB,mBAAmBQ,yBAAyB,CAAC,OAAD,CAzCzB;EA0CnB,iBAAiBA,yBAAyB,CAAC,KAAD,CA1CvB;EA2CnB,iBAAiBA,yBAAyB,CAAC,KAAD,CA3CvB;EA4CnB,oBAAoBL,0BAA0B,CAAC,OAAD,CA5C3B;EA6CnB,kBAAkBA,0BAA0B,CAAC,KAAD,CA7CzB;EA8CnB,kBAAkBA,0BAA0B,CAAC,KAAD,CA9CzB;EAgDnB8E,KAAK,EAAExE,iBAAiB,CAAC,gBAAD,CAhDL;EAiDnByE,KAAK,EAAEzE,iBAAiB,CAAC,gBAAD,CAjDL;EAkDnB0E,QAAQ,EAAE1E,iBAAiB,CAAC,qBAAD,CAlDR;EAoDnB2E,KAAK,EAAExF,gBAAgB,CAAC,OAAD,CApDJ;EAqDnByF,IAAI,EAAEzF,gBAAgB,CAAC,MAAD,CArDH;EAsDnB0F,KAAK,EAAE1F,gBAAgB,CAAC,OAAD,CAtDJ;EAuDnB2F,KAAK,EAAE3F,gBAAgB,CAAC,OAAD,CAvDJ;EAwDnB4F,QAAQ,EAAE5F,gBAAgB,CAAC,UAAD,CAxDP;EAyDnB6F,QAAQ,EAAE7F,gBAAgB,CAAC,UAAD,CAzDP;EA0DnB8F,OAAO,EAAE9F,gBAAgB,CAAC,SAAD,CA1DN;EA2DnB+F,EAAE,EAAE/F,gBAAgB,CAAC,IAAD,CA3DD;EA4DnBgG,MAAM,EAAEhG,gBAAgB,CAAC,QAAD,CA5DL;EA6DnBiG,GAAG,EAAEjG,gBAAgB,CAAC,KAAD,CA7DF;EA8DnBkG,EAAE,EAAElG,gBAAgB,CAAC,IAAD,CA9DD;EA+DnBmG,MAAM,EAAEnG,gBAAgB,CAAC,QAAD,CA/DL;EAgEnBoG,GAAG,EAAEpG,gBAAgB,CAAC,KAAD,CAhEF;EAiEnBqG,MAAM,EAAErG,gBAAgB,CAAC,QAAD,CAjEL;EAkEnBsG,MAAM,EAAEtG,gBAAgB,CAAC,QAAD,CAlEL;EAmEnBuG,KAAK,EAAEvG,gBAAgB,CAAC,OAAD,CAnEJ;EAoEnBwG,GAAG,EAAExG,gBAAgB,CAAC,KAAD,CApEF;EAqEnByG,GAAG,EAAEzG,gBAAgB,CAAC,KAAD,CArEF;EAsEnB0G,KAAK,EAAE1G,gBAAgB,CAAC,OAAD,CAtEJ;EAuEnB2G,IAAI,EAAE3G,gBAAgB,CAAC,MAAD;AAvEH,CAAvB,C,CA0EA;AACA;AACA;;AAEA4G,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFhG,IAAI,EAAE,QADJ;IAGFiG,IAAI,EAAE;MACFC,WAAW,EAAE,sDADX;MAEFC,QAAQ,EAAE,kBAFR;MAGFC,WAAW,EAAE,KAHX;MAIFC,GAAG,EAAE;IAJH,CAHJ;IAUFC,OAAO,EAAE,YAVP;IAYFC,MAAM,EAAE;MACJC,WAAW,EAAE;QACTC,WAAW,EAAE;UACTC,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAYjD,YAAZ;QADG,CADJ;QAITkD,aAAa,EAAE;UACXC,KAAK,EAAE,CACH;YAAEJ,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAY5C,cAAZ;UAAR,CADG,EAEH;YACIhE,IAAI,EAAE,OADV;YAEI+G,KAAK,EAAE;cAAEL,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAY5C,cAAZ;YAAR,CAFX;YAGIgD,QAAQ,EAAE,CAHd;YAIIC,WAAW,EAAE,IAJjB;YAKIC,eAAe,EAAE;UALrB,CAFG;QADI;MAJN,CADT;MAkBJlH,IAAI,EAAE,OAlBF;MAmBJ+G,KAAK,EAAE;QACH/G,IAAI,EAAE,QADH;QAEHmH,UAAU,EAAE;UACRC,SAAS,EAAE;YAAEC,IAAI,EAAE;UAAR,CADH;UAERC,IAAI,EAAE;YAAED,IAAI,EAAE;UAAR,CAFE;UAGRE,IAAI,EAAE;YAAEF,IAAI,EAAE;UAAR;QAHE,CAFT;QAOHG,oBAAoB,EAAE,KAPnB;QAQHC,QAAQ,EAAE,CAAC,WAAD,EAAc,MAAd,EAAsB,MAAtB;MARP,CAnBH;MA6BJP,eAAe,EAAE;IA7Bb,CAZN;IA4CFQ,QAAQ,EAAE;MACNC,mBAAmB,EAAE,8CADf;MAENC,iBAAiB,EAAE;IAFb;EA5CR,CADO;;EAmDbC,MAAM,CAACxF,OAAD,EAAU;IACZ,MAAM/C,UAAU,GAAG+C,OAAO,CAACS,aAAR,EAAnB;IACA,MAAMgF,aAAa,GAAGzF,OAAO,CAAC0F,OAAR,IAAmB,EAAzC;IACA,IAAIC,SAAS,GAAG,IAAhB;IAEA;AACR;AACA;AACA;AACA;AACA;;IACQ,SAASC,UAAT,GAAsB;MAClBD,SAAS,GAAG;QACRE,KAAK,EAAEF,SADC;QAER7E,QAAQ,EAAE;MAFF,CAAZ;IAIH;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASgF,SAAT,GAAqB;MACjBH,SAAS,GAAGA,SAAS,CAACE,KAAtB;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASE,KAAT,CAAe/I,IAAf,EAAqBW,IAArB,EAA2B;MACvB,IAAIqI,kBAAkB,GAAGhJ,IAAzB;;MAEA,OAAOgJ,kBAAkB,CAACrI,IAAnB,KAA4B,kBAAnC,EAAuD;QACnDqI,kBAAkB,GAAGA,kBAAkB,CAAC5H,IAAxC;MACH;;MACD,IAAIjC,KAAK,CAAC8J,OAAN,CAActI,IAAd,CAAJ,EAAyB;QACrB,OAAOA,IAAI,CAACuI,IAAL,CAAUH,KAAK,CAACI,IAAN,CAAW,IAAX,EAAiBH,kBAAjB,CAAV,CAAP;MACH;;MACD,OAAOrE,cAAc,CAAChE,IAAD,CAAd,CAAqBZ,IAArB,CAA0BiJ,kBAA1B,EAA8C/I,UAA9C,CAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASmJ,cAAT,CAAwBtF,QAAxB,EAAkCb,QAAlC,EAA4C;MACxC,KAAK,IAAIoG,CAAC,GAAGZ,aAAa,CAACtF,MAAd,GAAuB,CAApC,EAAuCkG,CAAC,IAAI,CAA5C,EAA+C,EAAEA,CAAjD,EAAoD;QAChD,MAAMC,SAAS,GAAGb,aAAa,CAACY,CAAD,CAA/B;QACA,MAAME,OAAO,GACTR,KAAK,CAACjF,QAAD,EAAWwF,SAAS,CAACrB,IAArB,CAAL,IACAc,KAAK,CAAC9F,QAAD,EAAWqG,SAAS,CAACpB,IAArB,CAFT;;QAIA,IAAIqB,OAAJ,EAAa;UACT,OAAOjF,YAAY,CAACgF,SAAS,CAACvB,SAAX,CAAnB;QACH;MACJ;;MACD,OAAOzD,YAAY,CAACC,GAApB;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASiF,uBAAT,CAAiC1F,QAAjC,EAA2Cb,QAA3C,EAAqD;MACjD,MAAMwG,KAAK,GAAG,EAAd;MACA,IAAIrH,SAAS,GAAGF,kBAAkB,CAACjC,UAAD,EAAa6D,QAAb,CAAlC;;MAEA,IAAIb,QAAQ,CAAC5C,GAAT,CAAaC,KAAb,CAAmBC,IAAnB,GAA0B6B,SAAS,CAAC/B,GAAV,CAAcG,GAAd,CAAkBD,IAA5C,IAAoD,CAAxD,EAA2D;QACvD,GAAG;UACC,MAAM2D,KAAK,GAAGjE,UAAU,CAACsC,aAAX,CACVH,SADU,EAEV;YAAE4B,eAAe,EAAE;UAAnB,CAFU,CAAd;;UAKA,IAAIE,KAAK,CAAC7D,GAAN,CAAUC,KAAV,CAAgBC,IAAhB,GAAuB6B,SAAS,CAAC/B,GAAV,CAAcG,GAAd,CAAkBD,IAAzC,IAAiD,CAArD,EAAwD;YACpDkJ,KAAK,CAACC,IAAN,CAAW,CAACtH,SAAD,EAAY8B,KAAZ,CAAX;UACH;;UACD9B,SAAS,GAAG8B,KAAZ;QAEH,CAXD,QAWS9B,SAAS,CAACT,KAAV,CAAgB,CAAhB,IAAqBsB,QAAQ,CAACtB,KAAT,CAAe,CAAf,CAX9B;MAYH;;MAED,OAAO8H,KAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASjF,MAAT,CAAgBxE,IAAhB,EAAsB;MAClB,MAAM2J,UAAU,GAAG3J,IAAI,CAAC8B,MAAL,CAAYnB,IAA/B;MACA,MAAMiJ,WAAW,GACb5K,QAAQ,CAAC6K,sBAAT,CAAgCC,GAAhC,CAAoCH,UAApC,KACAA,UAAU,KAAK,iBAFnB;;MAIA,IAAI,CAACC,WAAL,EAAkB;QACd;MACH,CARiB,CAUlB;;;MACA,MAAM9F,QAAQ,GAAG6E,SAAS,CAAC7E,QAA3B,CAXkB,CAalB;;MACA,IAAIA,QAAJ,EAAc;QACV,MAAMnD,IAAI,GAAGyI,cAAc,CAACtF,QAAD,EAAW9D,IAAX,CAA3B;QACA,MAAMkD,YAAY,GAAGsG,uBAAuB,CAAC1F,QAAD,EAAW9D,IAAX,CAA5C;QAEAW,IAAI,CAAC6D,MAAL,CAAYxB,OAAZ,EAAqBc,QAArB,EAA+B9D,IAA/B,EAAqCkD,YAArC;MACH;;MAEDyF,SAAS,CAAC7E,QAAV,GAAqB9D,IAArB;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAAS+J,oBAAT,CAA8B/J,IAA9B,EAAoC;MAChCwE,MAAM,CAACxE,IAAD,CAAN;MACA4I,UAAU;IACb;;IAED,OAAO;MACHoB,OAAO,EAAEpB,UADN;MAEHqB,cAAc,EAAErB,UAFb;MAGHsB,eAAe,EAAEtB,UAHd;MAIH,gBAAgBE,SAJb;MAKH,uBAAuBA,SALpB;MAMH,wBAAwBA,SANrB;MAQH,cAActE,MARX;MAUH2F,UAAU,EAAEJ,oBAVT;MAWH,mBAAmBjB;IAXhB,CAAP;EAaH;;AA3MY,CAAjB"},"metadata":{},"sourceType":"script"}