{"ast":null,"code":"/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst CHAR_LIMIT = 40; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified warning terms in comments\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-warning-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        terms: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        location: {\n          enum: [\"start\", \"anywhere\"]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          configuration = context.options[0] || {},\n          warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n          location = configuration.location || \"start\",\n          selfConfigRegEx = /\\bno-warning-comments\\b/u;\n    /**\n     * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n     * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n     * require word boundaries on that side.\n     * @param {string} term A term to convert to a RegExp\n     * @returns {RegExp} The term converted to a RegExp\n     */\n\n    function convertToRegExp(term) {\n      const escaped = escapeRegExp(term);\n      const wordBoundary = \"\\\\b\";\n      const eitherOrWordBoundary = `|${wordBoundary}`;\n      let prefix;\n      /*\n       * If the term ends in a word character (a-z0-9_), ensure a word\n       * boundary at the end, so that substrings do not get falsely\n       * matched. eg \"todo\" in a string such as \"mastodon\".\n       * If the term ends in a non-word character, then \\b won't match on\n       * the boundary to the next non-word character, which would likely\n       * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n       * In these cases, use no bounding match. Same applies for the\n       * prefix, handled below.\n       */\n\n      const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n\n      if (location === \"start\") {\n        /*\n         * When matching at the start, ignore leading whitespace, and\n         * there's no need to worry about word boundaries.\n         */\n        prefix = \"^\\\\s*\";\n      } else if (/^\\w/u.test(term)) {\n        prefix = wordBoundary;\n      } else {\n        prefix = \"\";\n      }\n\n      if (location === \"start\") {\n        /*\n         * For location \"start\" the regex should be\n         * ^\\s*TERM\\b.  This checks the word boundary\n         * at the beginning of the comment.\n         */\n        return new RegExp(prefix + escaped + suffix, \"iu\");\n      }\n      /*\n       * For location \"anywhere\" the regex should be\n       * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\n       * for the term.\n       */\n\n\n      return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, \"iu\");\n    }\n\n    const warningRegExps = warningTerms.map(convertToRegExp);\n    /**\n     * Checks the specified comment for matches of the configured warning terms and returns the matches.\n     * @param {string} comment The comment which is checked.\n     * @returns {Array} All matched warning terms for this comment.\n     */\n\n    function commentContainsWarningTerm(comment) {\n      const matches = [];\n      warningRegExps.forEach((regex, index) => {\n        if (regex.test(comment)) {\n          matches.push(warningTerms[index]);\n        }\n      });\n      return matches;\n    }\n    /**\n     * Checks the specified node for matching warning comments and reports them.\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {void} undefined.\n     */\n\n\n    function checkComment(node) {\n      const comment = node.value;\n\n      if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(comment)) {\n        return;\n      }\n\n      const matches = commentContainsWarningTerm(comment);\n      matches.forEach(matchedTerm => {\n        let commentToDisplay = \"\";\n        let truncated = false;\n\n        for (const c of comment.trim().split(/\\s+/u)) {\n          const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n          if (tmp.length <= CHAR_LIMIT) {\n            commentToDisplay = tmp;\n          } else {\n            truncated = true;\n            break;\n          }\n        }\n\n        context.report({\n          node,\n          messageId: \"unexpectedComment\",\n          data: {\n            matchedTerm,\n            comment: `${commentToDisplay}${truncated ? \"...\" : \"\"}`\n          }\n        });\n      });\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["escapeRegExp","require","astUtils","CHAR_LIMIT","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","terms","items","location","enum","additionalProperties","messages","unexpectedComment","create","context","sourceCode","getSourceCode","configuration","options","warningTerms","selfConfigRegEx","convertToRegExp","term","escaped","wordBoundary","eitherOrWordBoundary","prefix","suffix","test","RegExp","warningRegExps","map","commentContainsWarningTerm","comment","matches","forEach","regex","index","push","checkComment","node","value","isDirectiveComment","matchedTerm","commentToDisplay","truncated","c","trim","split","tmp","length","report","messageId","data","Program","comments","getAllComments","filter","token"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-warning-comments.js"],"sourcesContent":["/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst CHAR_LIMIT = 40;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified warning terms in comments\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-warning-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = escapeRegExp(term);\n            const wordBoundary = \"\\\\b\";\n            const eitherOrWordBoundary = `|${wordBoundary}`;\n            let prefix;\n\n            /*\n             * If the term ends in a word character (a-z0-9_), ensure a word\n             * boundary at the end, so that substrings do not get falsely\n             * matched. eg \"todo\" in a string such as \"mastodon\".\n             * If the term ends in a non-word character, then \\b won't match on\n             * the boundary to the next non-word character, which would likely\n             * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n             * In these cases, use no bounding match. Same applies for the\n             * prefix, handled below.\n             */\n            const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n\n            if (location === \"start\") {\n\n                /*\n                 * When matching at the start, ignore leading whitespace, and\n                 * there's no need to worry about word boundaries.\n                 */\n                prefix = \"^\\\\s*\";\n            } else if (/^\\w/u.test(term)) {\n                prefix = wordBoundary;\n            } else {\n                prefix = \"\";\n            }\n\n            if (location === \"start\") {\n\n                /*\n                 * For location \"start\" the regex should be\n                 * ^\\s*TERM\\b.  This checks the word boundary\n                 * at the beginning of the comment.\n                 */\n                return new RegExp(prefix + escaped + suffix, \"iu\");\n            }\n\n            /*\n             * For location \"anywhere\" the regex should be\n             * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\n             * for the term.\n             */\n            return new RegExp(\n                prefix +\n                    escaped +\n                    suffix +\n                    eitherOrWordBoundary +\n                    term +\n                    wordBoundary,\n                \"iu\"\n            );\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            const comment = node.value;\n\n            if (\n                astUtils.isDirectiveComment(node) &&\n                selfConfigRegEx.test(comment)\n            ) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(comment);\n\n            matches.forEach(matchedTerm => {\n                let commentToDisplay = \"\";\n                let truncated = false;\n\n                for (const c of comment.trim().split(/\\s+/u)) {\n                    const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n                    if (tmp.length <= CHAR_LIMIT) {\n                        commentToDisplay = tmp;\n                    } else {\n                        truncated = true;\n                        break;\n                    }\n                }\n\n                context.report({\n                    node,\n                    messageId: \"unexpectedComment\",\n                    data: {\n                        matchedTerm,\n                        comment: `${commentToDisplay}${\n                            truncated ? \"...\" : \"\"\n                        }`\n                    }\n                });\n            });\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments\n                    .filter(token => token.type !== \"Shebang\")\n                    .forEach(checkComment);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}