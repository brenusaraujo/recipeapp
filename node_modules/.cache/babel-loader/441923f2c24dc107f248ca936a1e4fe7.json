{"ast":null,"code":"/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto Rodríguez\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require braces around arrow function bodies\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-body-style\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"never\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            requireReturnForObjectLiteral: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n      unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n      unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n      unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n      expectedBlock: \"Expected block statement surrounding arrow body.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options;\n    const always = options[0] === \"always\";\n    const asNeeded = !options[0] || options[0] === \"as-needed\";\n    const never = options[0] === \"never\";\n    const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n    const sourceCode = context.getSourceCode();\n    let funcInfo = null;\n    /**\n     * Checks whether the given node has ASI problem or not.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n     */\n\n    function hasASIProblem(token) {\n      return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n    }\n    /**\n     * Gets the closing parenthesis by the given node.\n     * @param {ASTNode} node first node after an opening parenthesis.\n     * @returns {Token} The found closing parenthesis token.\n     */\n\n\n    function findClosingParen(node) {\n      let nodeToCheck = node;\n\n      while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {\n        nodeToCheck = nodeToCheck.parent;\n      }\n\n      return sourceCode.getTokenAfter(nodeToCheck);\n    }\n    /**\n     * Check whether the node is inside of a for loop's init\n     * @param {ASTNode} node node is inside for loop\n     * @returns {boolean} `true` if the node is inside of a for loop, else `false`\n     */\n\n\n    function isInsideForLoopInitializer(node) {\n      if (node && node.parent) {\n        if (node.parent.type === \"ForStatement\" && node.parent.init === node) {\n          return true;\n        }\n\n        return isInsideForLoopInitializer(node.parent);\n      }\n\n      return false;\n    }\n    /**\n     * Determines whether a arrow function body needs braces\n     * @param {ASTNode} node The arrow function node.\n     * @returns {void}\n     */\n\n\n    function validate(node) {\n      const arrowBody = node.body;\n\n      if (arrowBody.type === \"BlockStatement\") {\n        const blockBody = arrowBody.body;\n\n        if (blockBody.length !== 1 && !never) {\n          return;\n        }\n\n        if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" && blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n          return;\n        }\n\n        if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n          let messageId;\n\n          if (blockBody.length === 0) {\n            messageId = \"unexpectedEmptyBlock\";\n          } else if (blockBody.length > 1) {\n            messageId = \"unexpectedOtherBlock\";\n          } else if (blockBody[0].argument === null) {\n            messageId = \"unexpectedSingleBlock\";\n          } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], {\n            skip: 1\n          }))) {\n            messageId = \"unexpectedObjectBlock\";\n          } else {\n            messageId = \"unexpectedSingleBlock\";\n          }\n\n          context.report({\n            node,\n            loc: arrowBody.loc,\n            messageId,\n\n            fix(fixer) {\n              const fixes = [];\n\n              if (blockBody.length !== 1 || blockBody[0].type !== \"ReturnStatement\" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {\n                return fixes;\n              }\n\n              const openingBrace = sourceCode.getFirstToken(arrowBody);\n              const closingBrace = sourceCode.getLastToken(arrowBody);\n              const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n              const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n              const commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n              /*\n               * Remove tokens around the return value.\n               * If comments don't exist, remove extra spaces as well.\n               */\n\n              if (commentsExist) {\n                fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                );\n              } else {\n                fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));\n              }\n              /*\n               * If the first token of the return value is `{` or the return value is a sequence expression,\n               * enclose the return value by parentheses to avoid syntax error.\n               */\n\n\n              if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\" || funcInfo.hasInOperator && isInsideForLoopInitializer(node)) {\n                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {\n                  fixes.push(fixer.insertTextBefore(firstValueToken, \"(\"), fixer.insertTextAfter(lastValueToken, \")\"));\n                }\n              }\n              /*\n               * If the last token of the return statement is semicolon, remove it.\n               * Non-block arrow body is an expression, not a statement.\n               */\n\n\n              if (astUtils.isSemicolonToken(lastValueToken)) {\n                fixes.push(fixer.remove(lastValueToken));\n              }\n\n              return fixes;\n            }\n\n          });\n        }\n      } else {\n        if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\") {\n          context.report({\n            node,\n            loc: arrowBody.loc,\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              const fixes = [];\n              const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n              const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, {\n                count: 2\n              });\n              const lastToken = sourceCode.getLastToken(node);\n              let parenthesisedObjectLiteral = null;\n\n              if (astUtils.isOpeningParenToken(firstTokenAfterArrow) && astUtils.isOpeningBraceToken(secondTokenAfterArrow)) {\n                const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);\n\n                if (braceNode.type === \"ObjectExpression\") {\n                  parenthesisedObjectLiteral = braceNode;\n                }\n              } // If the value is object literal, remove parentheses which were forced by syntax.\n\n\n              if (parenthesisedObjectLiteral) {\n                const openingParenToken = firstTokenAfterArrow;\n                const openingBraceToken = secondTokenAfterArrow;\n\n                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {\n                  fixes.push(fixer.replaceText(openingParenToken, \"{return \"));\n                } else {\n                  // Avoid ASI\n                  fixes.push(fixer.replaceText(openingParenToken, \"{\"), fixer.insertTextBefore(openingBraceToken, \"return \"));\n                } // Closing paren for the object doesn't have to be lastToken, e.g.: () => ({}).foo()\n\n\n                fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));\n                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n              } else {\n                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, \"{return \"));\n                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n              }\n\n              return fixes;\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      \"BinaryExpression[operator='in']\"() {\n        let info = funcInfo;\n\n        while (info) {\n          info.hasInOperator = true;\n          info = info.upper;\n        }\n      },\n\n      ArrowFunctionExpression() {\n        funcInfo = {\n          upper: funcInfo,\n          hasInOperator: false\n        };\n      },\n\n      \"ArrowFunctionExpression:exit\"(node) {\n        validate(node);\n        funcInfo = funcInfo.upper;\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","minItems","maxItems","properties","requireReturnForObjectLiteral","additionalProperties","fixable","messages","unexpectedOtherBlock","unexpectedEmptyBlock","unexpectedObjectBlock","unexpectedSingleBlock","expectedBlock","create","context","options","always","asNeeded","never","sourceCode","getSourceCode","funcInfo","hasASIProblem","token","test","value","findClosingParen","node","nodeToCheck","isParenthesised","parent","getTokenAfter","isInsideForLoopInitializer","init","validate","arrowBody","body","blockBody","length","argument","messageId","isOpeningBraceToken","getFirstToken","skip","report","loc","fix","fixer","fixes","openingBrace","closingBrace","getLastToken","firstValueToken","lastValueToken","commentsExist","commentsExistBetween","push","remove","removeRange","range","hasInOperator","insertTextBefore","insertTextAfter","isSemicolonToken","arrowToken","getTokenBefore","isArrowToken","firstTokenAfterArrow","secondTokenAfterArrow","getTokensAfter","count","lastToken","parenthesisedObjectLiteral","isOpeningParenToken","braceNode","getNodeByRangeIndex","openingParenToken","openingBraceToken","isTokenOnSameLine","replaceText","info","upper","ArrowFunctionExpression"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/arrow-body-style.js"],"sourcesContent":["/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require braces around arrow function bodies\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-body-style\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                requireReturnForObjectLiteral: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n            unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n            unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n            unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n            expectedBlock: \"Expected block statement surrounding arrow body.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options;\n        const always = options[0] === \"always\";\n        const asNeeded = !options[0] || options[0] === \"as-needed\";\n        const never = options[0] === \"never\";\n        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Checks whether the given node has ASI problem or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n         */\n        function hasASIProblem(token) {\n            return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n        }\n\n        /**\n         * Gets the closing parenthesis by the given node.\n         * @param {ASTNode} node first node after an opening parenthesis.\n         * @returns {Token} The found closing parenthesis token.\n         */\n        function findClosingParen(node) {\n            let nodeToCheck = node;\n\n            while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {\n                nodeToCheck = nodeToCheck.parent;\n            }\n            return sourceCode.getTokenAfter(nodeToCheck);\n        }\n\n        /**\n         * Check whether the node is inside of a for loop's init\n         * @param {ASTNode} node node is inside for loop\n         * @returns {boolean} `true` if the node is inside of a for loop, else `false`\n         */\n        function isInsideForLoopInitializer(node) {\n            if (node && node.parent) {\n                if (node.parent.type === \"ForStatement\" && node.parent.init === node) {\n                    return true;\n                }\n                return isInsideForLoopInitializer(node.parent);\n            }\n            return false;\n        }\n\n        /**\n         * Determines whether a arrow function body needs braces\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function validate(node) {\n            const arrowBody = node.body;\n\n            if (arrowBody.type === \"BlockStatement\") {\n                const blockBody = arrowBody.body;\n\n                if (blockBody.length !== 1 && !never) {\n                    return;\n                }\n\n                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" &&\n                    blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n                    return;\n                }\n\n                if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n                    let messageId;\n\n                    if (blockBody.length === 0) {\n                        messageId = \"unexpectedEmptyBlock\";\n                    } else if (blockBody.length > 1) {\n                        messageId = \"unexpectedOtherBlock\";\n                    } else if (blockBody[0].argument === null) {\n                        messageId = \"unexpectedSingleBlock\";\n                    } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], { skip: 1 }))) {\n                        messageId = \"unexpectedObjectBlock\";\n                    } else {\n                        messageId = \"unexpectedSingleBlock\";\n                    }\n\n                    context.report({\n                        node,\n                        loc: arrowBody.loc,\n                        messageId,\n                        fix(fixer) {\n                            const fixes = [];\n\n                            if (blockBody.length !== 1 ||\n                                blockBody[0].type !== \"ReturnStatement\" ||\n                                !blockBody[0].argument ||\n                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))\n                            ) {\n                                return fixes;\n                            }\n\n                            const openingBrace = sourceCode.getFirstToken(arrowBody);\n                            const closingBrace = sourceCode.getLastToken(arrowBody);\n                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n                            const commentsExist =\n                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||\n                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n\n                            /*\n                             * Remove tokens around the return value.\n                             * If comments don't exist, remove extra spaces as well.\n                             */\n                            if (commentsExist) {\n                                fixes.push(\n                                    fixer.remove(openingBrace),\n                                    fixer.remove(closingBrace),\n                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                                );\n                            } else {\n                                fixes.push(\n                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),\n                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])\n                                );\n                            }\n\n                            /*\n                             * If the first token of the return value is `{` or the return value is a sequence expression,\n                             * enclose the return value by parentheses to avoid syntax error.\n                             */\n                            if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\" || (funcInfo.hasInOperator && isInsideForLoopInitializer(node))) {\n                                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {\n                                    fixes.push(\n                                        fixer.insertTextBefore(firstValueToken, \"(\"),\n                                        fixer.insertTextAfter(lastValueToken, \")\")\n                                    );\n                                }\n                            }\n\n                            /*\n                             * If the last token of the return statement is semicolon, remove it.\n                             * Non-block arrow body is an expression, not a statement.\n                             */\n                            if (astUtils.isSemicolonToken(lastValueToken)) {\n                                fixes.push(fixer.remove(lastValueToken));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            } else {\n                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\")) {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc,\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const fixes = [];\n                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n                            const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, { count: 2 });\n                            const lastToken = sourceCode.getLastToken(node);\n\n                            let parenthesisedObjectLiteral = null;\n\n                            if (\n                                astUtils.isOpeningParenToken(firstTokenAfterArrow) &&\n                                astUtils.isOpeningBraceToken(secondTokenAfterArrow)\n                            ) {\n                                const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);\n\n                                if (braceNode.type === \"ObjectExpression\") {\n                                    parenthesisedObjectLiteral = braceNode;\n                                }\n                            }\n\n                            // If the value is object literal, remove parentheses which were forced by syntax.\n                            if (parenthesisedObjectLiteral) {\n                                const openingParenToken = firstTokenAfterArrow;\n                                const openingBraceToken = secondTokenAfterArrow;\n\n                                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {\n                                    fixes.push(fixer.replaceText(openingParenToken, \"{return \"));\n                                } else {\n\n                                    // Avoid ASI\n                                    fixes.push(\n                                        fixer.replaceText(openingParenToken, \"{\"),\n                                        fixer.insertTextBefore(openingBraceToken, \"return \")\n                                    );\n                                }\n\n                                // Closing paren for the object doesn't have to be lastToken, e.g.: () => ({}).foo()\n                                fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n\n                            } else {\n                                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, \"{return \"));\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            \"BinaryExpression[operator='in']\"() {\n                let info = funcInfo;\n\n                while (info) {\n                    info.hasInOperator = true;\n                    info = info.upper;\n                }\n            },\n            ArrowFunctionExpression() {\n                funcInfo = {\n                    upper: funcInfo,\n                    hasInOperator: false\n                };\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                validate(node);\n                funcInfo = funcInfo.upper;\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}