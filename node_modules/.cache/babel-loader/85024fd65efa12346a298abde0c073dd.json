{"ast":null,"code":"/**\n * @fileoverview enforce consistent line breaks inside function parentheses\n * @author Teddy Katz\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent line breaks inside function parentheses\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-paren-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\n      }, {\n        type: \"object\",\n        properties: {\n          minItems: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      expectedBefore: \"Expected newline before ')'.\",\n      expectedAfter: \"Expected newline after '('.\",\n      expectedBetween: \"Expected newline between arguments/params.\",\n      unexpectedBefore: \"Unexpected newline before ')'.\",\n      unexpectedAfter: \"Unexpected newline after '('.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const rawOption = context.options[0] || \"multiline\";\n    const multilineOption = rawOption === \"multiline\";\n    const multilineArgumentsOption = rawOption === \"multiline-arguments\";\n    const consistentOption = rawOption === \"consistent\";\n    let minItems;\n\n    if (typeof rawOption === \"object\") {\n      minItems = rawOption.minItems;\n    } else if (rawOption === \"always\") {\n      minItems = 0;\n    } else if (rawOption === \"never\") {\n      minItems = Infinity;\n    } else {\n      minItems = null;\n    } //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Determines whether there should be newlines inside function parens\n     * @param {ASTNode[]} elements The arguments or parameters in the list\n     * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\n     * @returns {boolean} `true` if there should be newlines inside the function parens\n     */\n\n\n    function shouldHaveNewlines(elements, hasLeftNewline) {\n      if (multilineArgumentsOption && elements.length === 1) {\n        return hasLeftNewline;\n      }\n\n      if (multilineOption || multilineArgumentsOption) {\n        return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n      }\n\n      if (consistentOption) {\n        return hasLeftNewline;\n      }\n\n      return elements.length >= minItems;\n    }\n    /**\n     * Validates parens\n     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n     * @param {ASTNode[]} elements The arguments or parameters in the list\n     * @returns {void}\n     */\n\n\n    function validateParens(parens, elements) {\n      const leftParen = parens.leftParen;\n      const rightParen = parens.rightParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n      if (hasLeftNewline && !needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"unexpectedAfter\",\n\n          fix(fixer) {\n            return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim() // If there is a comment between the ( and the first element, don't do a fix.\n            ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n          }\n\n        });\n      } else if (!hasLeftNewline && needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"expectedAfter\",\n          fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n        });\n      }\n\n      if (hasRightNewline && !needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"unexpectedBefore\",\n\n          fix(fixer) {\n            return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim() // If there is a comment between the last element and the ), don't do a fix.\n            ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n          }\n\n        });\n      } else if (!hasRightNewline && needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"expectedBefore\",\n          fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n        });\n      }\n    }\n    /**\n     * Validates a list of arguments or parameters\n     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n     * @param {ASTNode[]} elements The arguments or parameters in the list\n     * @returns {void}\n     */\n\n\n    function validateArguments(parens, elements) {\n      const leftParen = parens.leftParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n      for (let i = 0; i <= elements.length - 2; i++) {\n        const currentElement = elements[i];\n        const nextElement = elements[i + 1];\n        const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\n\n        if (!hasNewLine && needsNewlines) {\n          context.report({\n            node: currentElement,\n            messageId: \"expectedBetween\",\n            fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\n          });\n        }\n      }\n    }\n    /**\n     * Gets the left paren and right paren tokens of a node.\n     * @param {ASTNode} node The node with parens\n     * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\n     * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\n     * with a single parameter)\n     */\n\n\n    function getParenTokens(node) {\n      switch (node.type) {\n        case \"NewExpression\":\n          if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, {\n            skip: 1\n          })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {\n            // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n            return null;\n          }\n\n        // falls through\n\n        case \"CallExpression\":\n          return {\n            leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n            rightParen: sourceCode.getLastToken(node)\n          };\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n\n        case \"ArrowFunctionExpression\":\n          {\n            const firstToken = sourceCode.getFirstToken(node, {\n              skip: node.async ? 1 : 0\n            });\n\n            if (!astUtils.isOpeningParenToken(firstToken)) {\n              // If the ArrowFunctionExpression has a single param without parens, return null.\n              return null;\n            }\n\n            return {\n              leftParen: firstToken,\n              rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n            };\n          }\n\n        case \"ImportExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, 1);\n            const rightParen = sourceCode.getLastToken(node);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n\n        default:\n          throw new TypeError(`unexpected node with type ${node.type}`);\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      [[\"ArrowFunctionExpression\", \"CallExpression\", \"FunctionDeclaration\", \"FunctionExpression\", \"ImportExpression\", \"NewExpression\"]](node) {\n        const parens = getParenTokens(node);\n        let params;\n\n        if (node.type === \"ImportExpression\") {\n          params = [node.source];\n        } else if (astUtils.isFunction(node)) {\n          params = node.params;\n        } else {\n          params = node.arguments;\n        }\n\n        if (parens) {\n          validateParens(parens, params);\n\n          if (multilineArgumentsOption) {\n            validateArguments(parens, params);\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","minItems","minimum","additionalProperties","messages","expectedBefore","expectedAfter","expectedBetween","unexpectedBefore","unexpectedAfter","create","context","sourceCode","getSourceCode","rawOption","options","multilineOption","multilineArgumentsOption","consistentOption","Infinity","shouldHaveNewlines","elements","hasLeftNewline","length","some","element","index","loc","end","line","start","validateParens","parens","leftParen","rightParen","tokenAfterLeftParen","getTokenAfter","tokenBeforeRightParen","getTokenBefore","isTokenOnSameLine","hasRightNewline","needsNewlines","report","node","messageId","fix","fixer","getText","slice","range","trim","removeRange","insertTextAfter","insertTextBefore","validateArguments","i","currentElement","nextElement","hasNewLine","getParenTokens","arguments","isOpeningParenToken","getLastToken","skip","isClosingParenToken","callee","getFirstToken","params","firstToken","async","body","TypeError","source","isFunction"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/function-paren-newline.js"],"sourcesContent":["/**\n * @fileoverview enforce consistent line breaks inside function parentheses\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks inside function parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/function-paren-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            minItems: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            expectedBefore: \"Expected newline before ')'.\",\n            expectedAfter: \"Expected newline after '('.\",\n            expectedBetween: \"Expected newline between arguments/params.\",\n            unexpectedBefore: \"Unexpected newline before ')'.\",\n            unexpectedAfter: \"Unexpected newline after '('.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const rawOption = context.options[0] || \"multiline\";\n        const multilineOption = rawOption === \"multiline\";\n        const multilineArgumentsOption = rawOption === \"multiline-arguments\";\n        const consistentOption = rawOption === \"consistent\";\n        let minItems;\n\n        if (typeof rawOption === \"object\") {\n            minItems = rawOption.minItems;\n        } else if (rawOption === \"always\") {\n            minItems = 0;\n        } else if (rawOption === \"never\") {\n            minItems = Infinity;\n        } else {\n            minItems = null;\n        }\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Determines whether there should be newlines inside function parens\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\n         * @returns {boolean} `true` if there should be newlines inside the function parens\n         */\n        function shouldHaveNewlines(elements, hasLeftNewline) {\n            if (multilineArgumentsOption && elements.length === 1) {\n                return hasLeftNewline;\n            }\n            if (multilineOption || multilineArgumentsOption) {\n                return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n            }\n            if (consistentOption) {\n                return hasLeftNewline;\n            }\n            return elements.length >= minItems;\n        }\n\n        /**\n         * Validates parens\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateParens(parens, elements) {\n            const leftParen = parens.leftParen;\n            const rightParen = parens.rightParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            if (hasLeftNewline && !needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"unexpectedAfter\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()\n\n                            // If there is a comment between the ( and the first element, don't do a fix.\n                            ? null\n                            : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n                    }\n                });\n            } else if (!hasLeftNewline && needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"expectedAfter\",\n                    fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n                });\n            }\n\n            if (hasRightNewline && !needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"unexpectedBefore\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()\n\n                            // If there is a comment between the last element and the ), don't do a fix.\n                            ? null\n                            : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n                    }\n                });\n            } else if (!hasRightNewline && needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"expectedBefore\",\n                    fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates a list of arguments or parameters\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateArguments(parens, elements) {\n            const leftParen = parens.leftParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            for (let i = 0; i <= elements.length - 2; i++) {\n                const currentElement = elements[i];\n                const nextElement = elements[i + 1];\n                const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\n\n                if (!hasNewLine && needsNewlines) {\n                    context.report({\n                        node: currentElement,\n                        messageId: \"expectedBetween\",\n                        fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\n                    });\n                }\n            }\n        }\n\n        /**\n         * Gets the left paren and right paren tokens of a node.\n         * @param {ASTNode} node The node with parens\n         * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\n         * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\n         * with a single parameter)\n         */\n        function getParenTokens(node) {\n            switch (node.type) {\n                case \"NewExpression\":\n                    if (!node.arguments.length && !(\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) &&\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node))\n                    )) {\n\n                        // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n                        return null;\n                    }\n\n                    // falls through\n\n                case \"CallExpression\":\n                    return {\n                        leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n                        rightParen: sourceCode.getLastToken(node)\n                    };\n\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n                    const rightParen = node.params.length\n                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)\n                        : sourceCode.getTokenAfter(leftParen);\n\n                    return { leftParen, rightParen };\n                }\n\n                case \"ArrowFunctionExpression\": {\n                    const firstToken = sourceCode.getFirstToken(node, { skip: (node.async ? 1 : 0) });\n\n                    if (!astUtils.isOpeningParenToken(firstToken)) {\n\n                        // If the ArrowFunctionExpression has a single param without parens, return null.\n                        return null;\n                    }\n\n                    return {\n                        leftParen: firstToken,\n                        rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n                    };\n                }\n\n                case \"ImportExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, 1);\n                    const rightParen = sourceCode.getLastToken(node);\n\n                    return { leftParen, rightParen };\n                }\n\n                default:\n                    throw new TypeError(`unexpected node with type ${node.type}`);\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            [[\n                \"ArrowFunctionExpression\",\n                \"CallExpression\",\n                \"FunctionDeclaration\",\n                \"FunctionExpression\",\n                \"ImportExpression\",\n                \"NewExpression\"\n            ]](node) {\n                const parens = getParenTokens(node);\n                let params;\n\n                if (node.type === \"ImportExpression\") {\n                    params = [node.source];\n                } else if (astUtils.isFunction(node)) {\n                    params = node.params;\n                } else {\n                    params = node.arguments;\n                }\n\n                if (parens) {\n                    validateParens(parens, params);\n\n                    if (multilineArgumentsOption) {\n                        validateArguments(parens, params);\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}