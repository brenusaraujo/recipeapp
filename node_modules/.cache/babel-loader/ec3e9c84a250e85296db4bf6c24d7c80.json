{"ast":null,"code":"/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent brace style for all control statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/curly\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"all\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n        }, {\n          enum: [\"consistent\"]\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      missingCurlyAfter: \"Expected { after '{{name}}'.\",\n      missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n      unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n      unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n    }\n  },\n\n  create(context) {\n    const multiOnly = context.options[0] === \"multi\";\n    const multiLine = context.options[0] === \"multi-line\";\n    const multiOrNest = context.options[0] === \"multi-or-nest\";\n    const consistent = context.options[1] === \"consistent\";\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n     * @private\n     */\n\n    function isCollapsedOneLiner(node) {\n      const before = sourceCode.getTokenBefore(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n    /**\n     * Determines if a given node is a one-liner.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if the node is a one-liner.\n     * @private\n     */\n\n\n    function isOneLiner(node) {\n      if (node.type === \"EmptyStatement\") {\n        return true;\n      }\n\n      const first = sourceCode.getFirstToken(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n    /**\n     * Determines if the given node is a lexical declaration (let, const, function, or class)\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} True if the node is a lexical declaration\n     * @private\n     */\n\n\n    function isLexicalDeclaration(node) {\n      if (node.type === \"VariableDeclaration\") {\n        return node.kind === \"const\" || node.kind === \"let\";\n      }\n\n      return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\n    }\n    /**\n     * Checks if the given token is an `else` token or not.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if the token is an `else` token.\n     */\n\n\n    function isElseKeywordToken(token) {\n      return token.value === \"else\" && token.type === \"Keyword\";\n    }\n    /**\n     * Determines whether the given node has an `else` keyword token as the first token after.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is followed by an `else` keyword token.\n     */\n\n\n    function isFollowedByElseKeyword(node) {\n      const nextToken = sourceCode.getTokenAfter(node);\n      return Boolean(nextToken) && isElseKeywordToken(nextToken);\n    }\n    /**\n     * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n     * @param {Token} closingBracket The } token\n     * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n     */\n\n\n    function needsSemicolon(closingBracket) {\n      const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n      const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n      const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n      if (astUtils.isSemicolonToken(tokenBefore)) {\n        // If the last statement already has a semicolon, don't add another one.\n        return false;\n      }\n\n      if (!tokenAfter) {\n        // If there are no statements after this block, there is no need to add a semicolon.\n        return false;\n      }\n\n      if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n        /*\n         * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n         * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n         * a SyntaxError if it was followed by `else`.\n         */\n        return false;\n      }\n\n      if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n        // If the next token is on the same line, insert a semicolon.\n        return true;\n      }\n\n      if (/^[([/`+-]/u.test(tokenAfter.value)) {\n        // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n        return true;\n      }\n\n      if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n        // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n        return true;\n      } // Otherwise, do not insert a semicolon.\n\n\n      return false;\n    }\n    /**\n     * Determines whether the code represented by the given node contains an `if` statement\n     * that would become associated with an `else` keyword directly appended to that code.\n     *\n     * Examples where it returns `true`:\n     *\n     *    if (a)\n     *        foo();\n     *\n     *    if (a) {\n     *        foo();\n     *    }\n     *\n     *    if (a)\n     *        foo();\n     *    else if (b)\n     *        bar();\n     *\n     *    while (a)\n     *        if (b)\n     *            if(c)\n     *                foo();\n     *            else\n     *                bar();\n     *\n     * Examples where it returns `false`:\n     *\n     *    if (a)\n     *        foo();\n     *    else\n     *        bar();\n     *\n     *    while (a) {\n     *        if (b)\n     *            if(c)\n     *                foo();\n     *            else\n     *                bar();\n     *    }\n     *\n     *    while (a)\n     *        if (b) {\n     *            if(c)\n     *                foo();\n     *        }\n     *        else\n     *            bar();\n     * @param {ASTNode} node Node representing the code to check.\n     * @returns {boolean} `true` if an `if` statement within the code would become associated with an `else` appended to that code.\n     */\n\n\n    function hasUnsafeIf(node) {\n      switch (node.type) {\n        case \"IfStatement\":\n          if (!node.alternate) {\n            return true;\n          }\n\n          return hasUnsafeIf(node.alternate);\n\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n        case \"LabeledStatement\":\n        case \"WithStatement\":\n        case \"WhileStatement\":\n          return hasUnsafeIf(node.body);\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * Determines whether the existing curly braces around the single statement are necessary to preserve the semantics of the code.\n     * The braces, which make the given block body, are necessary in either of the following situations:\n     *\n     * 1. The statement is a lexical declaration.\n     * 2. Without the braces, an `if` within the statement would become associated with an `else` after the closing brace:\n     *\n     *     if (a) {\n     *         if (b)\n     *             foo();\n     *     }\n     *     else\n     *         bar();\n     *\n     *     if (a)\n     *         while (b)\n     *             while (c) {\n     *                 while (d)\n     *                     if (e)\n     *                         while(f)\n     *                             foo();\n     *            }\n     *     else\n     *         bar();\n     * @param {ASTNode} node `BlockStatement` body with exactly one statement directly inside. The statement can have its own nested statements.\n     * @returns {boolean} `true` if the braces are necessary - removing them (replacing the given `BlockStatement` body with its single statement content)\n     * would change the semantics of the code or produce a syntax error.\n     */\n\n\n    function areBracesNecessary(node) {\n      const statement = node.body[0];\n      return isLexicalDeclaration(statement) || hasUnsafeIf(statement) && isFollowedByElseKeyword(node);\n    }\n    /**\n     * Prepares to check the body of a node to see if it's a block statement.\n     * @param {ASTNode} node The node to report if there's a problem.\n     * @param {ASTNode} body The body node to check for blocks.\n     * @param {string} name The name to report if there's a problem.\n     * @param {{ condition: boolean }} opts Options to pass to the report functions\n     * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n     *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n     *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n     *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n     *   the final behavior of \"check\".\n     *   \"check\" will be a function reporting appropriate problems depending on the other\n     *   properties.\n     */\n\n\n    function prepareCheck(node, body, name, opts) {\n      const hasBlock = body.type === \"BlockStatement\";\n      let expected = null;\n\n      if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {\n        expected = true;\n      } else if (multiOnly) {\n        expected = false;\n      } else if (multiLine) {\n        if (!isCollapsedOneLiner(body)) {\n          expected = true;\n        } // otherwise, the body is allowed to have braces or not to have braces\n\n      } else if (multiOrNest) {\n        if (hasBlock) {\n          const statement = body.body[0];\n          const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);\n          expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;\n        } else {\n          expected = !isOneLiner(body);\n        }\n      } else {\n        // default \"all\"\n        expected = true;\n      }\n\n      return {\n        actual: hasBlock,\n        expected,\n\n        check() {\n          if (this.expected !== null && this.expected !== this.actual) {\n            if (this.expected) {\n              context.report({\n                node,\n                loc: body.loc,\n                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                data: {\n                  name\n                },\n                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n              });\n            } else {\n              context.report({\n                node,\n                loc: body.loc,\n                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                data: {\n                  name\n                },\n\n                fix(fixer) {\n                  /*\n                   * `do while` expressions sometimes need a space to be inserted after `do`.\n                   * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                   */\n                  const needsPrecedingSpace = node.type === \"DoWhileStatement\" && sourceCode.getTokenBefore(body).range[1] === body.range[0] && !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, {\n                    skip: 1\n                  }));\n                  const openingBracket = sourceCode.getFirstToken(body);\n                  const closingBracket = sourceCode.getLastToken(body);\n                  const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                  if (needsSemicolon(closingBracket)) {\n                    /*\n                     * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                     * change the semantics of the code due to ASI), don't perform a fix.\n                     */\n                    return null;\n                  }\n\n                  const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n                  return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                }\n\n              });\n            }\n          }\n        }\n\n      };\n    }\n    /**\n     * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n     * @param {ASTNode} node The first IfStatement node of the chain.\n     * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n     *   information.\n     */\n\n\n    function prepareIfChecks(node) {\n      const preparedChecks = [];\n\n      for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n        preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", {\n          condition: true\n        }));\n\n        if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n          preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n          break;\n        }\n      }\n\n      if (consistent) {\n        /*\n         * If any node should have or already have braces, make sure they\n         * all have braces.\n         * If all nodes shouldn't have braces, make sure they don't.\n         */\n        const expected = preparedChecks.some(preparedCheck => {\n          if (preparedCheck.expected !== null) {\n            return preparedCheck.expected;\n          }\n\n          return preparedCheck.actual;\n        });\n        preparedChecks.forEach(preparedCheck => {\n          preparedCheck.expected = expected;\n        });\n      }\n\n      return preparedChecks;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      IfStatement(node) {\n        const parent = node.parent;\n        const isElseIf = parent.type === \"IfStatement\" && parent.alternate === node;\n\n        if (!isElseIf) {\n          // This is a top `if`, check the whole `if-else-if` chain\n          prepareIfChecks(node).forEach(preparedCheck => {\n            preparedCheck.check();\n          });\n        } // Skip `else if`, it's already checked (when the top `if` was visited)\n\n      },\n\n      WhileStatement(node) {\n        prepareCheck(node, node.body, \"while\", {\n          condition: true\n        }).check();\n      },\n\n      DoWhileStatement(node) {\n        prepareCheck(node, node.body, \"do\").check();\n      },\n\n      ForStatement(node) {\n        prepareCheck(node, node.body, \"for\", {\n          condition: true\n        }).check();\n      },\n\n      ForInStatement(node) {\n        prepareCheck(node, node.body, \"for-in\").check();\n      },\n\n      ForOfStatement(node) {\n        prepareCheck(node, node.body, \"for-of\").check();\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","minItems","maxItems","fixable","messages","missingCurlyAfter","missingCurlyAfterCondition","unexpectedCurlyAfter","unexpectedCurlyAfterCondition","create","context","multiOnly","options","multiLine","multiOrNest","consistent","sourceCode","getSourceCode","isCollapsedOneLiner","node","before","getTokenBefore","last","getLastToken","lastExcludingSemicolon","isSemicolonToken","loc","start","line","end","isOneLiner","first","getFirstToken","isLexicalDeclaration","kind","isElseKeywordToken","token","value","isFollowedByElseKeyword","nextToken","getTokenAfter","Boolean","needsSemicolon","closingBracket","tokenBefore","tokenAfter","lastBlockNode","getNodeByRangeIndex","range","parent","test","hasUnsafeIf","alternate","body","areBracesNecessary","statement","prepareCheck","name","opts","hasBlock","expected","length","leadingCommentsInBlock","getCommentsBefore","actual","check","report","messageId","condition","data","fix","fixer","replaceText","getText","needsPrecedingSpace","canTokensBeAdjacent","skip","openingBracket","lastTokenInBlock","resultingBodyText","slice","prepareIfChecks","preparedChecks","currentNode","push","consequent","some","preparedCheck","forEach","IfStatement","isElseIf","WhileStatement","DoWhileStatement","ForStatement","ForInStatement","ForOfStatement"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/curly.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent brace style for all control statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/curly\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n                        },\n                        {\n                            enum: [\"consistent\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            missingCurlyAfter: \"Expected { after '{{name}}'.\",\n            missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n            unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n            unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n        }\n    },\n\n    create(context) {\n\n        const multiOnly = (context.options[0] === \"multi\");\n        const multiLine = (context.options[0] === \"multi-line\");\n        const multiOrNest = (context.options[0] === \"multi-or-nest\");\n        const consistent = (context.options[1] === \"consistent\");\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n         * @private\n         */\n        function isCollapsedOneLiner(node) {\n            const before = sourceCode.getTokenBefore(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if a given node is a one-liner.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner.\n         * @private\n         */\n        function isOneLiner(node) {\n            if (node.type === \"EmptyStatement\") {\n                return true;\n            }\n\n            const first = sourceCode.getFirstToken(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if the given node is a lexical declaration (let, const, function, or class)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lexical declaration\n         * @private\n         */\n        function isLexicalDeclaration(node) {\n            if (node.type === \"VariableDeclaration\") {\n                return node.kind === \"const\" || node.kind === \"let\";\n            }\n\n            return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * Checks if the given token is an `else` token or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is an `else` token.\n         */\n        function isElseKeywordToken(token) {\n            return token.value === \"else\" && token.type === \"Keyword\";\n        }\n\n        /**\n         * Determines whether the given node has an `else` keyword token as the first token after.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is followed by an `else` keyword token.\n         */\n        function isFollowedByElseKeyword(node) {\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            return Boolean(nextToken) && isElseKeywordToken(nextToken);\n        }\n\n        /**\n         * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n         * @param {Token} closingBracket The } token\n         * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n         */\n        function needsSemicolon(closingBracket) {\n            const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n            const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n            if (astUtils.isSemicolonToken(tokenBefore)) {\n\n                // If the last statement already has a semicolon, don't add another one.\n                return false;\n            }\n\n            if (!tokenAfter) {\n\n                // If there are no statements after this block, there is no need to add a semicolon.\n                return false;\n            }\n\n            if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n\n                /*\n                 * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n                 * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n                 * a SyntaxError if it was followed by `else`.\n                 */\n                return false;\n            }\n\n            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n\n                // If the next token is on the same line, insert a semicolon.\n                return true;\n            }\n\n            if (/^[([/`+-]/u.test(tokenAfter.value)) {\n\n                // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n                return true;\n            }\n\n            if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n\n                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n                return true;\n            }\n\n            // Otherwise, do not insert a semicolon.\n            return false;\n        }\n\n        /**\n         * Determines whether the code represented by the given node contains an `if` statement\n         * that would become associated with an `else` keyword directly appended to that code.\n         *\n         * Examples where it returns `true`:\n         *\n         *    if (a)\n         *        foo();\n         *\n         *    if (a) {\n         *        foo();\n         *    }\n         *\n         *    if (a)\n         *        foo();\n         *    else if (b)\n         *        bar();\n         *\n         *    while (a)\n         *        if (b)\n         *            if(c)\n         *                foo();\n         *            else\n         *                bar();\n         *\n         * Examples where it returns `false`:\n         *\n         *    if (a)\n         *        foo();\n         *    else\n         *        bar();\n         *\n         *    while (a) {\n         *        if (b)\n         *            if(c)\n         *                foo();\n         *            else\n         *                bar();\n         *    }\n         *\n         *    while (a)\n         *        if (b) {\n         *            if(c)\n         *                foo();\n         *        }\n         *        else\n         *            bar();\n         * @param {ASTNode} node Node representing the code to check.\n         * @returns {boolean} `true` if an `if` statement within the code would become associated with an `else` appended to that code.\n         */\n        function hasUnsafeIf(node) {\n            switch (node.type) {\n                case \"IfStatement\":\n                    if (!node.alternate) {\n                        return true;\n                    }\n                    return hasUnsafeIf(node.alternate);\n                case \"ForStatement\":\n                case \"ForInStatement\":\n                case \"ForOfStatement\":\n                case \"LabeledStatement\":\n                case \"WithStatement\":\n                case \"WhileStatement\":\n                    return hasUnsafeIf(node.body);\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Determines whether the existing curly braces around the single statement are necessary to preserve the semantics of the code.\n         * The braces, which make the given block body, are necessary in either of the following situations:\n         *\n         * 1. The statement is a lexical declaration.\n         * 2. Without the braces, an `if` within the statement would become associated with an `else` after the closing brace:\n         *\n         *     if (a) {\n         *         if (b)\n         *             foo();\n         *     }\n         *     else\n         *         bar();\n         *\n         *     if (a)\n         *         while (b)\n         *             while (c) {\n         *                 while (d)\n         *                     if (e)\n         *                         while(f)\n         *                             foo();\n         *            }\n         *     else\n         *         bar();\n         * @param {ASTNode} node `BlockStatement` body with exactly one statement directly inside. The statement can have its own nested statements.\n         * @returns {boolean} `true` if the braces are necessary - removing them (replacing the given `BlockStatement` body with its single statement content)\n         * would change the semantics of the code or produce a syntax error.\n         */\n        function areBracesNecessary(node) {\n            const statement = node.body[0];\n\n            return isLexicalDeclaration(statement) ||\n                hasUnsafeIf(statement) && isFollowedByElseKeyword(node);\n        }\n\n        /**\n         * Prepares to check the body of a node to see if it's a block statement.\n         * @param {ASTNode} node The node to report if there's a problem.\n         * @param {ASTNode} body The body node to check for blocks.\n         * @param {string} name The name to report if there's a problem.\n         * @param {{ condition: boolean }} opts Options to pass to the report functions\n         * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n         *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n         *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n         *   the final behavior of \"check\".\n         *   \"check\" will be a function reporting appropriate problems depending on the other\n         *   properties.\n         */\n        function prepareCheck(node, body, name, opts) {\n            const hasBlock = (body.type === \"BlockStatement\");\n            let expected = null;\n\n            if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {\n                expected = true;\n            } else if (multiOnly) {\n                expected = false;\n            } else if (multiLine) {\n                if (!isCollapsedOneLiner(body)) {\n                    expected = true;\n                }\n\n                // otherwise, the body is allowed to have braces or not to have braces\n\n            } else if (multiOrNest) {\n                if (hasBlock) {\n                    const statement = body.body[0];\n                    const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);\n\n                    expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;\n                } else {\n                    expected = !isOneLiner(body);\n                }\n            } else {\n\n                // default \"all\"\n                expected = true;\n            }\n\n            return {\n                actual: hasBlock,\n                expected,\n                check() {\n                    if (this.expected !== null && this.expected !== this.actual) {\n                        if (this.expected) {\n                            context.report({\n                                node,\n                                loc: body.loc,\n                                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n                            });\n                        } else {\n                            context.report({\n                                node,\n                                loc: body.loc,\n                                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix(fixer) {\n\n                                    /*\n                                     * `do while` expressions sometimes need a space to be inserted after `do`.\n                                     * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                                     */\n                                    const needsPrecedingSpace = node.type === \"DoWhileStatement\" &&\n                                        sourceCode.getTokenBefore(body).range[1] === body.range[0] &&\n                                        !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, { skip: 1 }));\n\n                                    const openingBracket = sourceCode.getFirstToken(body);\n                                    const closingBracket = sourceCode.getLastToken(body);\n                                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                                    if (needsSemicolon(closingBracket)) {\n\n                                        /*\n                                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                                         * change the semantics of the code due to ASI), don't perform a fix.\n                                         */\n                                        return null;\n                                    }\n\n                                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +\n                                        sourceCode.getText(lastTokenInBlock) +\n                                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n\n                                    return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                                }\n                            });\n                        }\n                    }\n                }\n            };\n        }\n\n        /**\n         * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n         * @param {ASTNode} node The first IfStatement node of the chain.\n         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n         *   information.\n         */\n        function prepareIfChecks(node) {\n            const preparedChecks = [];\n\n            for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n                preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", { condition: true }));\n                if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n                    preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n                    break;\n                }\n            }\n\n            if (consistent) {\n\n                /*\n                 * If any node should have or already have braces, make sure they\n                 * all have braces.\n                 * If all nodes shouldn't have braces, make sure they don't.\n                 */\n                const expected = preparedChecks.some(preparedCheck => {\n                    if (preparedCheck.expected !== null) {\n                        return preparedCheck.expected;\n                    }\n                    return preparedCheck.actual;\n                });\n\n                preparedChecks.forEach(preparedCheck => {\n                    preparedCheck.expected = expected;\n                });\n            }\n\n            return preparedChecks;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                const parent = node.parent;\n                const isElseIf = parent.type === \"IfStatement\" && parent.alternate === node;\n\n                if (!isElseIf) {\n\n                    // This is a top `if`, check the whole `if-else-if` chain\n                    prepareIfChecks(node).forEach(preparedCheck => {\n                        preparedCheck.check();\n                    });\n                }\n\n                // Skip `else if`, it's already checked (when the top `if` was visited)\n            },\n\n            WhileStatement(node) {\n                prepareCheck(node, node.body, \"while\", { condition: true }).check();\n            },\n\n            DoWhileStatement(node) {\n                prepareCheck(node, node.body, \"do\").check();\n            },\n\n            ForStatement(node) {\n                prepareCheck(node, node.body, \"for\", { condition: true }).check();\n            },\n\n            ForInStatement(node) {\n                prepareCheck(node, node.body, \"for-in\").check();\n            },\n\n            ForOfStatement(node) {\n                prepareCheck(node, node.body, \"for-of\").check();\n            }\n        };\n    }\n};\n"],"mappings":"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A3CmC,CA6CpC;;;MACA,OAAO,KAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASc,WAAT,CAAqBhC,IAArB,EAA2B;MACvB,QAAQA,IAAI,CAAC5B,IAAb;QACI,KAAK,aAAL;UACI,IAAI,CAAC4B,IAAI,CAACiC,SAAV,EAAqB;YACjB,OAAO,IAAP;UACH;;UACD,OAAOD,WAAW,CAAChC,IAAI,CAACiC,SAAN,CAAlB;;QACJ,KAAK,cAAL;QACA,KAAK,gBAAL;QACA,KAAK,gBAAL;QACA,KAAK,kBAAL;QACA,KAAK,eAAL;QACA,KAAK,gBAAL;UACI,OAAOD,WAAW,CAAChC,IAAI,CAACkC,IAAN,CAAlB;;QACJ;UACI,OAAO,KAAP;MAdR;IAgBH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASC,kBAAT,CAA4BnC,IAA5B,EAAkC;MAC9B,MAAMoC,SAAS,GAAGpC,IAAI,CAACkC,IAAL,CAAU,CAAV,CAAlB;MAEA,OAAOpB,oBAAoB,CAACsB,SAAD,CAApB,IACHJ,WAAW,CAACI,SAAD,CAAX,IAA0BjB,uBAAuB,CAACnB,IAAD,CADrD;IAEH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASqC,YAAT,CAAsBrC,IAAtB,EAA4BkC,IAA5B,EAAkCI,IAAlC,EAAwCC,IAAxC,EAA8C;MAC1C,MAAMC,QAAQ,GAAIN,IAAI,CAAC9D,IAAL,KAAc,gBAAhC;MACA,IAAIqE,QAAQ,GAAG,IAAf;;MAEA,IAAID,QAAQ,KAAKN,IAAI,CAACA,IAAL,CAAUQ,MAAV,KAAqB,CAArB,IAA0BP,kBAAkB,CAACD,IAAD,CAAjD,CAAZ,EAAsE;QAClEO,QAAQ,GAAG,IAAX;MACH,CAFD,MAEO,IAAIjD,SAAJ,EAAe;QAClBiD,QAAQ,GAAG,KAAX;MACH,CAFM,MAEA,IAAI/C,SAAJ,EAAe;QAClB,IAAI,CAACK,mBAAmB,CAACmC,IAAD,CAAxB,EAAgC;UAC5BO,QAAQ,GAAG,IAAX;QACH,CAHiB,CAKlB;;MAEH,CAPM,MAOA,IAAI9C,WAAJ,EAAiB;QACpB,IAAI6C,QAAJ,EAAc;UACV,MAAMJ,SAAS,GAAGF,IAAI,CAACA,IAAL,CAAU,CAAV,CAAlB;UACA,MAAMS,sBAAsB,GAAG9C,UAAU,CAAC+C,iBAAX,CAA6BR,SAA7B,CAA/B;UAEAK,QAAQ,GAAG,CAAC9B,UAAU,CAACyB,SAAD,CAAX,IAA0BO,sBAAsB,CAACD,MAAvB,GAAgC,CAArE;QACH,CALD,MAKO;UACHD,QAAQ,GAAG,CAAC9B,UAAU,CAACuB,IAAD,CAAtB;QACH;MACJ,CATM,MASA;QAEH;QACAO,QAAQ,GAAG,IAAX;MACH;;MAED,OAAO;QACHI,MAAM,EAAEL,QADL;QAEHC,QAFG;;QAGHK,KAAK,GAAG;UACJ,IAAI,KAAKL,QAAL,KAAkB,IAAlB,IAA0B,KAAKA,QAAL,KAAkB,KAAKI,MAArD,EAA6D;YACzD,IAAI,KAAKJ,QAAT,EAAmB;cACflD,OAAO,CAACwD,MAAR,CAAe;gBACX/C,IADW;gBAEXO,GAAG,EAAE2B,IAAI,CAAC3B,GAFC;gBAGXyC,SAAS,EAAET,IAAI,IAAIA,IAAI,CAACU,SAAb,GAAyB,4BAAzB,GAAwD,mBAHxD;gBAIXC,IAAI,EAAE;kBACFZ;gBADE,CAJK;gBAOXa,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAN,CAAkBnB,IAAlB,EAAyB,IAAGrC,UAAU,CAACyD,OAAX,CAAmBpB,IAAnB,CAAyB,GAArD;cAPH,CAAf;YASH,CAVD,MAUO;cACH3C,OAAO,CAACwD,MAAR,CAAe;gBACX/C,IADW;gBAEXO,GAAG,EAAE2B,IAAI,CAAC3B,GAFC;gBAGXyC,SAAS,EAAET,IAAI,IAAIA,IAAI,CAACU,SAAb,GAAyB,+BAAzB,GAA2D,sBAH3D;gBAIXC,IAAI,EAAE;kBACFZ;gBADE,CAJK;;gBAOXa,GAAG,CAACC,KAAD,EAAQ;kBAEP;AACpC;AACA;AACA;kBACoC,MAAMG,mBAAmB,GAAGvD,IAAI,CAAC5B,IAAL,KAAc,kBAAd,IACxByB,UAAU,CAACK,cAAX,CAA0BgC,IAA1B,EAAgCL,KAAhC,CAAsC,CAAtC,MAA6CK,IAAI,CAACL,KAAL,CAAW,CAAX,CADrB,IAExB,CAAC9D,QAAQ,CAACyF,mBAAT,CAA6B,IAA7B,EAAmC3D,UAAU,CAACgB,aAAX,CAAyBqB,IAAzB,EAA+B;oBAAEuB,IAAI,EAAE;kBAAR,CAA/B,CAAnC,CAFL;kBAIA,MAAMC,cAAc,GAAG7D,UAAU,CAACgB,aAAX,CAAyBqB,IAAzB,CAAvB;kBACA,MAAMV,cAAc,GAAG3B,UAAU,CAACO,YAAX,CAAwB8B,IAAxB,CAAvB;kBACA,MAAMyB,gBAAgB,GAAG9D,UAAU,CAACK,cAAX,CAA0BsB,cAA1B,CAAzB;;kBAEA,IAAID,cAAc,CAACC,cAAD,CAAlB,EAAoC;oBAEhC;AACxC;AACA;AACA;oBACwC,OAAO,IAAP;kBACH;;kBAED,MAAMoC,iBAAiB,GAAG/D,UAAU,CAACyD,OAAX,GAAqBO,KAArB,CAA2BH,cAAc,CAAC7B,KAAf,CAAqB,CAArB,CAA3B,EAAoD8B,gBAAgB,CAAC9B,KAAjB,CAAuB,CAAvB,CAApD,IACtBhC,UAAU,CAACyD,OAAX,CAAmBK,gBAAnB,CADsB,GAEtB9D,UAAU,CAACyD,OAAX,GAAqBO,KAArB,CAA2BF,gBAAgB,CAAC9B,KAAjB,CAAuB,CAAvB,CAA3B,EAAsDL,cAAc,CAACK,KAAf,CAAqB,CAArB,CAAtD,CAFJ;kBAIA,OAAOuB,KAAK,CAACC,WAAN,CAAkBnB,IAAlB,EAAwB,CAACqB,mBAAmB,GAAG,GAAH,GAAS,EAA7B,IAAmCK,iBAA3D,CAAP;gBACH;;cAnCU,CAAf;YAqCH;UACJ;QACJ;;MAvDE,CAAP;IAyDH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASE,eAAT,CAAyB9D,IAAzB,EAA+B;MAC3B,MAAM+D,cAAc,GAAG,EAAvB;;MAEA,KAAK,IAAIC,WAAW,GAAGhE,IAAvB,EAA6BgE,WAA7B,EAA0CA,WAAW,GAAGA,WAAW,CAAC/B,SAApE,EAA+E;QAC3E8B,cAAc,CAACE,IAAf,CAAoB5B,YAAY,CAAC2B,WAAD,EAAcA,WAAW,CAACE,UAA1B,EAAsC,IAAtC,EAA4C;UAAEjB,SAAS,EAAE;QAAb,CAA5C,CAAhC;;QACA,IAAIe,WAAW,CAAC/B,SAAZ,IAAyB+B,WAAW,CAAC/B,SAAZ,CAAsB7D,IAAtB,KAA+B,aAA5D,EAA2E;UACvE2F,cAAc,CAACE,IAAf,CAAoB5B,YAAY,CAAC2B,WAAD,EAAcA,WAAW,CAAC/B,SAA1B,EAAqC,MAArC,CAAhC;UACA;QACH;MACJ;;MAED,IAAIrC,UAAJ,EAAgB;QAEZ;AAChB;AACA;AACA;AACA;QACgB,MAAM6C,QAAQ,GAAGsB,cAAc,CAACI,IAAf,CAAoBC,aAAa,IAAI;UAClD,IAAIA,aAAa,CAAC3B,QAAd,KAA2B,IAA/B,EAAqC;YACjC,OAAO2B,aAAa,CAAC3B,QAArB;UACH;;UACD,OAAO2B,aAAa,CAACvB,MAArB;QACH,CALgB,CAAjB;QAOAkB,cAAc,CAACM,OAAf,CAAuBD,aAAa,IAAI;UACpCA,aAAa,CAAC3B,QAAd,GAAyBA,QAAzB;QACH,CAFD;MAGH;;MAED,OAAOsB,cAAP;IACH,CAzXW,CA2XZ;IACA;IACA;;;IAEA,OAAO;MACHO,WAAW,CAACtE,IAAD,EAAO;QACd,MAAM8B,MAAM,GAAG9B,IAAI,CAAC8B,MAApB;QACA,MAAMyC,QAAQ,GAAGzC,MAAM,CAAC1D,IAAP,KAAgB,aAAhB,IAAiC0D,MAAM,CAACG,SAAP,KAAqBjC,IAAvE;;QAEA,IAAI,CAACuE,QAAL,EAAe;UAEX;UACAT,eAAe,CAAC9D,IAAD,CAAf,CAAsBqE,OAAtB,CAA8BD,aAAa,IAAI;YAC3CA,aAAa,CAACtB,KAAd;UACH,CAFD;QAGH,CAVa,CAYd;;MACH,CAdE;;MAgBH0B,cAAc,CAACxE,IAAD,EAAO;QACjBqC,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,OAAlB,EAA2B;UAAEe,SAAS,EAAE;QAAb,CAA3B,CAAZ,CAA4DH,KAA5D;MACH,CAlBE;;MAoBH2B,gBAAgB,CAACzE,IAAD,EAAO;QACnBqC,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,IAAlB,CAAZ,CAAoCY,KAApC;MACH,CAtBE;;MAwBH4B,YAAY,CAAC1E,IAAD,EAAO;QACfqC,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,KAAlB,EAAyB;UAAEe,SAAS,EAAE;QAAb,CAAzB,CAAZ,CAA0DH,KAA1D;MACH,CA1BE;;MA4BH6B,cAAc,CAAC3E,IAAD,EAAO;QACjBqC,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,QAAlB,CAAZ,CAAwCY,KAAxC;MACH,CA9BE;;MAgCH8B,cAAc,CAAC5E,IAAD,EAAO;QACjBqC,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,QAAlB,CAAZ,CAAwCY,KAAxC;MACH;;IAlCE,CAAP;EAoCH;;AApdY,CAAjB"},"metadata":{},"sourceType":"script"}