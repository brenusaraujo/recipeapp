{"ast":null,"code":"var path = require('path');\n\nvar fs = require('fs');\n\nvar utils = require('./utils');\n\nvar del = require('./del');\n\nvar writeJSON = utils.writeJSON;\nvar cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function (docId, cacheDir) {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n\n    if (fs.existsSync(me._pathToFile)) {\n      me._persisted = utils.tryParse(me._pathToFile, {});\n    }\n  },\n\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function (pathToFile) {\n    var me = this;\n    var dir = path.dirname(pathToFile);\n    var fName = path.basename(pathToFile);\n    me.load(fName, dir);\n  },\n\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n  keys: function () {\n    return Object.keys(this._persisted);\n  },\n\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function (key, value) {\n    this._visited[key] = true;\n    this._persisted[key] = value;\n  },\n\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function (key) {\n    delete this._visited[key]; // esfmt-ignore-line\n\n    delete this._persisted[key]; // esfmt-ignore-line\n  },\n\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function (key) {\n    this._visited[key] = true;\n    return this._persisted[key];\n  },\n\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    var me = this;\n    var obj = {};\n    var keys = Object.keys(me._visited); // no keys visited for either get or set value\n\n    if (keys.length === 0) {\n      return;\n    }\n\n    keys.forEach(function (key) {\n      obj[key] = me._persisted[key];\n    });\n    me._visited = {};\n    me._persisted = obj;\n  },\n\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function (noPrune) {\n    var me = this;\n    !noPrune && me._prune();\n    writeJSON(me._pathToFile, me._persisted);\n  },\n\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del(this._pathToFile);\n  },\n\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n    me.removeCacheFile();\n  }\n};\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function (docId, cacheDir) {\n    return this.create(docId, cacheDir);\n  },\n\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage.\n   *\n   * @method create\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  create: function (docId, cacheDir) {\n    var obj = Object.create(cache);\n    obj.load(docId, cacheDir);\n    return obj;\n  },\n  createFromFile: function (filePath) {\n    var obj = Object.create(cache);\n    obj.loadFile(filePath);\n    return obj;\n  },\n\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function (docId, cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    return del(filePath);\n  },\n\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function (cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, '../.cache/');\n    return del(filePath);\n  }\n};","map":{"version":3,"names":["path","require","fs","utils","del","writeJSON","cache","load","docId","cacheDir","me","_visited","_persisted","_pathToFile","resolve","__dirname","existsSync","tryParse","loadFile","pathToFile","dir","dirname","fName","basename","all","keys","Object","setKey","key","value","removeKey","getKey","_prune","obj","length","forEach","save","noPrune","removeCacheFile","destroy","module","exports","create","createFromFile","filePath","clearCacheById","clearAll"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/node_modules/flat-cache/src/cache.js"],"sourcesContent":["var path = require('path');\nvar fs = require('fs');\nvar utils = require('./utils');\nvar del = require('./del');\nvar writeJSON = utils.writeJSON;\n\nvar cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function (docId, cacheDir) {\n    var me = this;\n\n    me._visited = {};\n    me._persisted = {};\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n\n    if (fs.existsSync(me._pathToFile)) {\n      me._persisted = utils.tryParse(me._pathToFile, {});\n    }\n  },\n\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function (pathToFile) {\n    var me = this;\n    var dir = path.dirname(pathToFile);\n    var fName = path.basename(pathToFile);\n\n    me.load(fName, dir);\n  },\n\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n\n  keys: function () {\n    return Object.keys(this._persisted);\n  },\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function (key, value) {\n    this._visited[key] = true;\n    this._persisted[key] = value;\n  },\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function (key) {\n    delete this._visited[key]; // esfmt-ignore-line\n    delete this._persisted[key]; // esfmt-ignore-line\n  },\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function (key) {\n    this._visited[key] = true;\n    return this._persisted[key];\n  },\n\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    var me = this;\n    var obj = {};\n\n    var keys = Object.keys(me._visited);\n\n    // no keys visited for either get or set value\n    if (keys.length === 0) {\n      return;\n    }\n\n    keys.forEach(function (key) {\n      obj[key] = me._persisted[key];\n    });\n\n    me._visited = {};\n    me._persisted = obj;\n  },\n\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function (noPrune) {\n    var me = this;\n\n    !noPrune && me._prune();\n    writeJSON(me._pathToFile, me._persisted);\n  },\n\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del(this._pathToFile);\n  },\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n\n    me.removeCacheFile();\n  },\n};\n\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function (docId, cacheDir) {\n    return this.create(docId, cacheDir);\n  },\n\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage.\n   *\n   * @method create\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  create: function (docId, cacheDir) {\n    var obj = Object.create(cache);\n    obj.load(docId, cacheDir);\n    return obj;\n  },\n\n  createFromFile: function (filePath) {\n    var obj = Object.create(cache);\n    obj.loadFile(filePath);\n    return obj;\n  },\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function (docId, cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    return del(filePath);\n  },\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function (cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, '../.cache/');\n    return del(filePath);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}