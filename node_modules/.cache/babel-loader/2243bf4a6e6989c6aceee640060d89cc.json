{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SliderList = exports.getPercentOffsetForSlide = void 0;\n\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\n\nconst react_1 = __importDefault(require(\"react\"));\n\nconst default_controls_1 = require(\"./default-controls\");\n\nconst use_tween_1 = require(\"./hooks/use-tween\");\n\nconst getPercentOffsetForSlide = (currentSlide, slideCount, slidesToShow, cellAlign, wrapAround) => {\n  // When wrapAround is enabled, we show the slides 3 times\n  const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n  const singleSlidePercentOfWhole = 100 / renderedSlideCount; // When wrap is on, -33.33% puts us right on the center, true set of slides\n  // (the left and right sets are clones meant to avoid visual gaps)\n\n  let slide0Offset = wrapAround ? -100 / 3 : 0;\n\n  if (cellAlign === 'right' && slidesToShow > 1) {\n    const excessSlides = slidesToShow - 1;\n    slide0Offset += singleSlidePercentOfWhole * excessSlides;\n  }\n\n  if (cellAlign === 'center' && slidesToShow > 1) {\n    const excessSlides = slidesToShow - 1; // Half of excess is on left and half is on right when centered\n\n    const excessLeftSlides = excessSlides / 2;\n    slide0Offset += singleSlidePercentOfWhole * excessLeftSlides;\n  }\n\n  const currentSlideOffsetFrom0 = 100 / renderedSlideCount * currentSlide;\n  return slide0Offset - currentSlideOffsetFrom0;\n};\n\nexports.getPercentOffsetForSlide = getPercentOffsetForSlide;\nexports.SliderList = react_1.default.forwardRef((_ref, forwardedRef) => {\n  let {\n    animation,\n    animationDistance,\n    cellAlign,\n    children,\n    currentSlide,\n    disableAnimation,\n    disableEdgeSwiping,\n    draggedOffset,\n    easing,\n    edgeEasing,\n    isDragging,\n    scrollMode,\n    slideCount,\n    slidesToScroll,\n    slidesToShow,\n    speed,\n    wrapAround\n  } = _ref;\n  // When wrapAround is enabled, we show the slides 3 times\n  const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n  const listVisibleWidth = `${renderedSlideCount * 100 / slidesToShow}%`;\n  const percentOffsetForSlideProps = [slideCount, slidesToShow, cellAlign, wrapAround]; // We recycle dot index generation to determine the leftmost and rightmost\n  // indices used, to be used in calculating the x-translation values we need\n  // to limit to or when edgeEasing should be used.\n\n  const dotIndexes = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n  let clampedDraggedOffset = `${draggedOffset}px`;\n\n  if (isDragging && disableEdgeSwiping && !wrapAround) {\n    const clampOffsets = [dotIndexes[0], dotIndexes[dotIndexes.length - 1]].map(index => (0, exports.getPercentOffsetForSlide)(index, ...percentOffsetForSlideProps)); // Offsets are seemingly backwards because the rightmost slide creates\n    // the most negative translate value\n\n    clampedDraggedOffset = `clamp(${clampOffsets[1]}%, ${draggedOffset}px, ${clampOffsets[0]}%)`;\n  }\n\n  const slideBasedOffset = (0, exports.getPercentOffsetForSlide)(currentSlide, ...percentOffsetForSlideProps);\n  const isEdgeEasing = !disableEdgeSwiping && !wrapAround && (currentSlide === dotIndexes[0] && animationDistance < 0 || currentSlide === dotIndexes[dotIndexes.length - 1] && animationDistance > 0);\n  const {\n    value: transition,\n    isAnimating\n  } = (0, use_tween_1.useTween)(speed, !isEdgeEasing ? easing : edgeEasing, // animationDistance is assumed to be unique enough that it can be used to\n  // detect when a new animation should start. This is used in addition to\n  // currentSlide because some animations, such as those with edgeEasing, do\n  // not occur due to a change in value of currentSlide\n  currentSlide + animationDistance, isDragging || disableAnimation || animation === 'fade'); // Return undefined if the transform would be 0 pixels since transforms can\n  // cause flickering in chrome.\n\n  let positioning;\n\n  if (isDragging || slideBasedOffset !== 0 || isAnimating) {\n    if (isDragging) {\n      positioning = `translateX(${clampedDraggedOffset})`;\n    } else {\n      const transitionOffset = isAnimating ? (1 - transition) * animationDistance : 0;\n      positioning = `translateX(calc(${slideBasedOffset}% - ${transitionOffset}px))`;\n    }\n  }\n\n  return (0, jsx_runtime_1.jsx)(\"div\", Object.assign({\n    ref: forwardedRef,\n    className: \"slider-list\",\n    style: {\n      width: listVisibleWidth,\n      textAlign: 'left',\n      userSelect: 'auto',\n      transform: positioning,\n      display: 'flex'\n    }\n  }, {\n    children: children\n  }));\n});\nexports.SliderList.displayName = 'SliderList';","map":{"version":3,"sources":["../src/slider-list.tsx"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SliderList = exports.getPercentOffsetForSlide = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst react_1 = __importDefault(require(\"react\"));\nconst default_controls_1 = require(\"./default-controls\");\nconst use_tween_1 = require(\"./hooks/use-tween\");\nconst getPercentOffsetForSlide = (currentSlide, slideCount, slidesToShow, cellAlign, wrapAround) => {\n    // When wrapAround is enabled, we show the slides 3 times\n    const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n    const singleSlidePercentOfWhole = 100 / renderedSlideCount;\n    // When wrap is on, -33.33% puts us right on the center, true set of slides\n    // (the left and right sets are clones meant to avoid visual gaps)\n    let slide0Offset = wrapAround ? -100 / 3 : 0;\n    if (cellAlign === 'right' && slidesToShow > 1) {\n        const excessSlides = slidesToShow - 1;\n        slide0Offset += singleSlidePercentOfWhole * excessSlides;\n    }\n    if (cellAlign === 'center' && slidesToShow > 1) {\n        const excessSlides = slidesToShow - 1;\n        // Half of excess is on left and half is on right when centered\n        const excessLeftSlides = excessSlides / 2;\n        slide0Offset += singleSlidePercentOfWhole * excessLeftSlides;\n    }\n    const currentSlideOffsetFrom0 = (100 / renderedSlideCount) * currentSlide;\n    return slide0Offset - currentSlideOffsetFrom0;\n};\nexports.getPercentOffsetForSlide = getPercentOffsetForSlide;\nexports.SliderList = react_1.default.forwardRef(({ animation, animationDistance, cellAlign, children, currentSlide, disableAnimation, disableEdgeSwiping, draggedOffset, easing, edgeEasing, isDragging, scrollMode, slideCount, slidesToScroll, slidesToShow, speed, wrapAround, }, forwardedRef) => {\n    // When wrapAround is enabled, we show the slides 3 times\n    const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n    const listVisibleWidth = `${(renderedSlideCount * 100) / slidesToShow}%`;\n    const percentOffsetForSlideProps = [\n        slideCount,\n        slidesToShow,\n        cellAlign,\n        wrapAround,\n    ];\n    // We recycle dot index generation to determine the leftmost and rightmost\n    // indices used, to be used in calculating the x-translation values we need\n    // to limit to or when edgeEasing should be used.\n    const dotIndexes = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n    let clampedDraggedOffset = `${draggedOffset}px`;\n    if (isDragging && disableEdgeSwiping && !wrapAround) {\n        const clampOffsets = [\n            dotIndexes[0],\n            dotIndexes[dotIndexes.length - 1],\n        ].map((index) => (0, exports.getPercentOffsetForSlide)(index, ...percentOffsetForSlideProps));\n        // Offsets are seemingly backwards because the rightmost slide creates\n        // the most negative translate value\n        clampedDraggedOffset = `clamp(${clampOffsets[1]}%, ${draggedOffset}px, ${clampOffsets[0]}%)`;\n    }\n    const slideBasedOffset = (0, exports.getPercentOffsetForSlide)(currentSlide, ...percentOffsetForSlideProps);\n    const isEdgeEasing = !disableEdgeSwiping &&\n        !wrapAround &&\n        ((currentSlide === dotIndexes[0] && animationDistance < 0) ||\n            (currentSlide === dotIndexes[dotIndexes.length - 1] &&\n                animationDistance > 0));\n    const { value: transition, isAnimating } = (0, use_tween_1.useTween)(speed, !isEdgeEasing ? easing : edgeEasing, \n    // animationDistance is assumed to be unique enough that it can be used to\n    // detect when a new animation should start. This is used in addition to\n    // currentSlide because some animations, such as those with edgeEasing, do\n    // not occur due to a change in value of currentSlide\n    currentSlide + animationDistance, isDragging || disableAnimation || animation === 'fade');\n    // Return undefined if the transform would be 0 pixels since transforms can\n    // cause flickering in chrome.\n    let positioning;\n    if (isDragging || slideBasedOffset !== 0 || isAnimating) {\n        if (isDragging) {\n            positioning = `translateX(${clampedDraggedOffset})`;\n        }\n        else {\n            const transitionOffset = isAnimating\n                ? (1 - transition) * animationDistance\n                : 0;\n            positioning = `translateX(calc(${slideBasedOffset}% - ${transitionOffset}px))`;\n        }\n    }\n    return ((0, jsx_runtime_1.jsx)(\"div\", Object.assign({ ref: forwardedRef, className: \"slider-list\", style: {\n            width: listVisibleWidth,\n            textAlign: 'left',\n            userSelect: 'auto',\n            transform: positioning,\n            display: 'flex',\n        } }, { children: children })));\n});\nexports.SliderList.displayName = 'SliderList';\n"]},"metadata":{},"sourceType":"script"}