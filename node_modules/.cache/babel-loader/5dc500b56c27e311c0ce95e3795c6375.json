{"ast":null,"code":"/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"./utils/patterns/letters\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n      WHITESPACE = /\\s/gu,\n      MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\n\nconst SCHEMA_BODY = {\n  type: \"object\",\n  properties: {\n    ignorePattern: {\n      type: \"string\"\n    },\n    ignoreInlineComments: {\n      type: \"boolean\"\n    },\n    ignoreConsecutiveComments: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst DEFAULTS = {\n  ignorePattern: \"\",\n  ignoreInlineComments: false,\n  ignoreConsecutiveComments: false\n};\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\n\nfunction getNormalizedOptions(rawOptions, which) {\n  return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n/**\n * Get normalized options for block and line comments.\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\n\n\nfunction getAllNormalizedOptions() {\n  let rawOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    Line: getNormalizedOptions(rawOptions, \"line\"),\n    Block: getNormalizedOptions(rawOptions, \"block\")\n  };\n}\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\n\n\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n  Object.keys(normalizedOptions).forEach(key => {\n    const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n    if (ignorePatternStr) {\n      const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\n      normalizedOptions[key].ignorePatternRegExp = regExp;\n    }\n  });\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce or disallow capitalization of the first letter of a comment\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/capitalized-comments\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      oneOf: [SCHEMA_BODY, {\n        type: \"object\",\n        properties: {\n          line: SCHEMA_BODY,\n          block: SCHEMA_BODY\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n      unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n    }\n  },\n\n  create(context) {\n    const capitalize = context.options[0] || \"always\",\n          normalizedOptions = getAllNormalizedOptions(context.options[1]),\n          sourceCode = context.getSourceCode();\n    createRegExpForIgnorePatterns(normalizedOptions); //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Checks whether a comment is an inline comment.\n     *\n     * For the purpose of this rule, a comment is inline if:\n     * 1. The comment is preceded by a token on the same line; and\n     * 2. The command is followed by a token on the same line.\n     *\n     * Note that the comment itself need not be single-line!\n     *\n     * Also, it follows from this definition that only block comments can\n     * be considered as possibly inline. This is because line comments\n     * would consume any following tokens on the same line as the comment.\n     * @param {ASTNode} comment The comment node to check.\n     * @returns {boolean} True if the comment is an inline comment, false\n     * otherwise.\n     */\n\n    function isInlineComment(comment) {\n      const previousToken = sourceCode.getTokenBefore(comment, {\n        includeComments: true\n      }),\n            nextToken = sourceCode.getTokenAfter(comment, {\n        includeComments: true\n      });\n      return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);\n    }\n    /**\n     * Determine if a comment follows another comment.\n     * @param {ASTNode} comment The comment to check.\n     * @returns {boolean} True if the comment follows a valid comment.\n     */\n\n\n    function isConsecutiveComment(comment) {\n      const previousTokenOrComment = sourceCode.getTokenBefore(comment, {\n        includeComments: true\n      });\n      return Boolean(previousTokenOrComment && [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1);\n    }\n    /**\n     * Check a comment to determine if it is valid for this rule.\n     * @param {ASTNode} comment The comment node to process.\n     * @param {Object} options The options for checking this comment.\n     * @returns {boolean} True if the comment is valid, false otherwise.\n     */\n\n\n    function isCommentValid(comment, options) {\n      // 1. Check for default ignore pattern.\n      if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n        return true;\n      } // 2. Check for custom ignore pattern.\n\n\n      const commentWithoutAsterisks = comment.value.replace(/\\*/gu, \"\");\n\n      if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n        return true;\n      } // 3. Check for inline comments.\n\n\n      if (options.ignoreInlineComments && isInlineComment(comment)) {\n        return true;\n      } // 4. Is this a consecutive comment (and are we tolerating those)?\n\n\n      if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n        return true;\n      } // 5. Does the comment start with a possible URL?\n\n\n      if (MAYBE_URL.test(commentWithoutAsterisks)) {\n        return true;\n      } // 6. Is the initial word character a letter?\n\n\n      const commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, \"\");\n\n      if (commentWordCharsOnly.length === 0) {\n        return true;\n      }\n\n      const firstWordChar = commentWordCharsOnly[0];\n\n      if (!LETTER_PATTERN.test(firstWordChar)) {\n        return true;\n      } // 7. Check the case of the initial word character.\n\n\n      const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n            isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n      if (capitalize === \"always\" && isLowercase) {\n        return false;\n      }\n\n      if (capitalize === \"never\" && isUppercase) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Process a comment to determine if it needs to be reported.\n     * @param {ASTNode} comment The comment node to process.\n     * @returns {void}\n     */\n\n\n    function processComment(comment) {\n      const options = normalizedOptions[comment.type],\n            commentValid = isCommentValid(comment, options);\n\n      if (!commentValid) {\n        const messageId = capitalize === \"always\" ? \"unexpectedLowercaseComment\" : \"unexpectedUppercaseComment\";\n        context.report({\n          node: null,\n          // Intentionally using loc instead\n          loc: comment.loc,\n          messageId,\n\n          fix(fixer) {\n            const match = comment.value.match(LETTER_PATTERN);\n            return fixer.replaceTextRange( // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());\n          }\n\n        });\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["LETTER_PATTERN","require","astUtils","DEFAULT_IGNORE_PATTERN","COMMENTS_IGNORE_PATTERN","WHITESPACE","MAYBE_URL","SCHEMA_BODY","type","properties","ignorePattern","ignoreInlineComments","ignoreConsecutiveComments","additionalProperties","DEFAULTS","getNormalizedOptions","rawOptions","which","Object","assign","getAllNormalizedOptions","Line","Block","createRegExpForIgnorePatterns","normalizedOptions","keys","forEach","key","ignorePatternStr","regExp","RegExp","ignorePatternRegExp","module","exports","meta","docs","description","category","recommended","url","fixable","schema","enum","oneOf","line","block","messages","unexpectedLowercaseComment","unexpectedUppercaseComment","create","context","capitalize","options","sourceCode","getSourceCode","isInlineComment","comment","previousToken","getTokenBefore","includeComments","nextToken","getTokenAfter","Boolean","loc","start","end","isConsecutiveComment","previousTokenOrComment","indexOf","isCommentValid","test","value","commentWithoutAsterisks","replace","commentWordCharsOnly","length","firstWordChar","isUppercase","toLocaleLowerCase","isLowercase","toLocaleUpperCase","processComment","commentValid","messageId","report","node","fix","fixer","match","replaceTextRange","range","index","Program","comments","getAllComments","filter","token"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/capitalized-comments.js"],"sourcesContent":["/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"./utils/patterns/letters\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n    WHITESPACE = /\\s/gu,\n    MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\nconst SCHEMA_BODY = {\n    type: \"object\",\n    properties: {\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreInlineComments: {\n            type: \"boolean\"\n        },\n        ignoreConsecutiveComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\nconst DEFAULTS = {\n    ignorePattern: \"\",\n    ignoreInlineComments: false,\n    ignoreConsecutiveComments: false\n};\n\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\nfunction getNormalizedOptions(rawOptions, which) {\n    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n\n/**\n * Get normalized options for block and line comments.\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\nfunction getAllNormalizedOptions(rawOptions = {}) {\n    return {\n        Line: getNormalizedOptions(rawOptions, \"line\"),\n        Block: getNormalizedOptions(rawOptions, \"block\")\n    };\n}\n\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n    Object.keys(normalizedOptions).forEach(key => {\n        const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n        if (ignorePatternStr) {\n            const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\n\n            normalizedOptions[key].ignorePatternRegExp = regExp;\n        }\n    });\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce or disallow capitalization of the first letter of a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/capitalized-comments\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] },\n            {\n                oneOf: [\n                    SCHEMA_BODY,\n                    {\n                        type: \"object\",\n                        properties: {\n                            line: SCHEMA_BODY,\n                            block: SCHEMA_BODY\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n            unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n        }\n    },\n\n    create(context) {\n\n        const capitalize = context.options[0] || \"always\",\n            normalizedOptions = getAllNormalizedOptions(context.options[1]),\n            sourceCode = context.getSourceCode();\n\n        createRegExpForIgnorePatterns(normalizedOptions);\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks whether a comment is an inline comment.\n         *\n         * For the purpose of this rule, a comment is inline if:\n         * 1. The comment is preceded by a token on the same line; and\n         * 2. The command is followed by a token on the same line.\n         *\n         * Note that the comment itself need not be single-line!\n         *\n         * Also, it follows from this definition that only block comments can\n         * be considered as possibly inline. This is because line comments\n         * would consume any following tokens on the same line as the comment.\n         * @param {ASTNode} comment The comment node to check.\n         * @returns {boolean} True if the comment is an inline comment, false\n         * otherwise.\n         */\n        function isInlineComment(comment) {\n            const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),\n                nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });\n\n            return Boolean(\n                previousToken &&\n                nextToken &&\n                comment.loc.start.line === previousToken.loc.end.line &&\n                comment.loc.end.line === nextToken.loc.start.line\n            );\n        }\n\n        /**\n         * Determine if a comment follows another comment.\n         * @param {ASTNode} comment The comment to check.\n         * @returns {boolean} True if the comment follows a valid comment.\n         */\n        function isConsecutiveComment(comment) {\n            const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n            return Boolean(\n                previousTokenOrComment &&\n                [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1\n            );\n        }\n\n        /**\n         * Check a comment to determine if it is valid for this rule.\n         * @param {ASTNode} comment The comment node to process.\n         * @param {Object} options The options for checking this comment.\n         * @returns {boolean} True if the comment is valid, false otherwise.\n         */\n        function isCommentValid(comment, options) {\n\n            // 1. Check for default ignore pattern.\n            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n                return true;\n            }\n\n            // 2. Check for custom ignore pattern.\n            const commentWithoutAsterisks = comment.value\n                .replace(/\\*/gu, \"\");\n\n            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 3. Check for inline comments.\n            if (options.ignoreInlineComments && isInlineComment(comment)) {\n                return true;\n            }\n\n            // 4. Is this a consecutive comment (and are we tolerating those)?\n            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n                return true;\n            }\n\n            // 5. Does the comment start with a possible URL?\n            if (MAYBE_URL.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 6. Is the initial word character a letter?\n            const commentWordCharsOnly = commentWithoutAsterisks\n                .replace(WHITESPACE, \"\");\n\n            if (commentWordCharsOnly.length === 0) {\n                return true;\n            }\n\n            const firstWordChar = commentWordCharsOnly[0];\n\n            if (!LETTER_PATTERN.test(firstWordChar)) {\n                return true;\n            }\n\n            // 7. Check the case of the initial word character.\n            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n            if (capitalize === \"always\" && isLowercase) {\n                return false;\n            }\n            if (capitalize === \"never\" && isUppercase) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Process a comment to determine if it needs to be reported.\n         * @param {ASTNode} comment The comment node to process.\n         * @returns {void}\n         */\n        function processComment(comment) {\n            const options = normalizedOptions[comment.type],\n                commentValid = isCommentValid(comment, options);\n\n            if (!commentValid) {\n                const messageId = capitalize === \"always\"\n                    ? \"unexpectedLowercaseComment\"\n                    : \"unexpectedUppercaseComment\";\n\n                context.report({\n                    node: null, // Intentionally using loc instead\n                    loc: comment.loc,\n                    messageId,\n                    fix(fixer) {\n                        const match = comment.value.match(LETTER_PATTERN);\n\n                        return fixer.replaceTextRange(\n\n                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],\n                            capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()\n                        );\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}