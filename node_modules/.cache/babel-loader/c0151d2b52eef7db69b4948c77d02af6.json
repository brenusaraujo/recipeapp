{"ast":null,"code":"/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding within blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padded-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          blocks: {\n            enum: [\"always\", \"never\"]\n          },\n          switches: {\n            enum: [\"always\", \"never\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLineBlocks: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      alwaysPadBlock: \"Block must be padded by blank lines.\",\n      neverPadBlock: \"Block must not be padded by blank lines.\"\n    }\n  },\n\n  create(context) {\n    const options = {};\n    const typeOptions = context.options[0] || \"always\";\n    const exceptOptions = context.options[1] || {};\n\n    if (typeof typeOptions === \"string\") {\n      const shouldHavePadding = typeOptions === \"always\";\n      options.blocks = shouldHavePadding;\n      options.switches = shouldHavePadding;\n      options.classes = shouldHavePadding;\n    } else {\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n        options.blocks = typeOptions.blocks === \"always\";\n      }\n\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n        options.switches = typeOptions.switches === \"always\";\n      }\n\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n        options.classes = typeOptions.classes === \"always\";\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n      options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n    }\n\n    const sourceCode = context.getSourceCode();\n    /**\n     * Gets the open brace token from a given node.\n     * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\n     * @returns {Token} The token of the open brace.\n     */\n\n    function getOpenBrace(node) {\n      if (node.type === \"SwitchStatement\") {\n        return sourceCode.getTokenBefore(node.cases[0]);\n      }\n\n      return sourceCode.getFirstToken(node);\n    }\n    /**\n     * Checks if the given parameter is a comment node\n     * @param {ASTNode|Token} node An AST node or token\n     * @returns {boolean} True if node is a comment\n     */\n\n\n    function isComment(node) {\n      return node.type === \"Line\" || node.type === \"Block\";\n    }\n    /**\n     * Checks if there is padding between two tokens\n     * @param {Token} first The first token\n     * @param {Token} second The second token\n     * @returns {boolean} True if there is at least a line between the tokens\n     */\n\n\n    function isPaddingBetweenTokens(first, second) {\n      return second.loc.start.line - first.loc.end.line >= 2;\n    }\n    /**\n     * Checks if the given token has a blank line after it.\n     * @param {Token} token The token to check.\n     * @returns {boolean} Whether or not the token is followed by a blank line.\n     */\n\n\n    function getFirstBlockToken(token) {\n      let prev,\n          first = token;\n\n      do {\n        prev = first;\n        first = sourceCode.getTokenAfter(first, {\n          includeComments: true\n        });\n      } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n      return first;\n    }\n    /**\n     * Checks if the given token is preceded by a blank line.\n     * @param {Token} token The token to check\n     * @returns {boolean} Whether or not the token is preceded by a blank line\n     */\n\n\n    function getLastBlockToken(token) {\n      let last = token,\n          next;\n\n      do {\n        next = last;\n        last = sourceCode.getTokenBefore(last, {\n          includeComments: true\n        });\n      } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n      return last;\n    }\n    /**\n     * Checks if a node should be padded, according to the rule config.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {boolean} True if the node should be padded, false otherwise.\n     */\n\n\n    function requirePaddingFor(node) {\n      switch (node.type) {\n        case \"BlockStatement\":\n          return options.blocks;\n\n        case \"SwitchStatement\":\n          return options.switches;\n\n        case \"ClassBody\":\n          return options.classes;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n    }\n    /**\n     * Checks the given BlockStatement node to be padded if the block is not empty.\n     * @param {ASTNode} node The AST node of a BlockStatement.\n     * @returns {void} undefined.\n     */\n\n\n    function checkPadding(node) {\n      const openBrace = getOpenBrace(node),\n            firstBlockToken = getFirstBlockToken(openBrace),\n            tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, {\n        includeComments: true\n      }),\n            closeBrace = sourceCode.getLastToken(node),\n            lastBlockToken = getLastBlockToken(closeBrace),\n            tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, {\n        includeComments: true\n      }),\n            blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n            blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n      if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n        return;\n      }\n\n      if (requirePaddingFor(node)) {\n        if (!blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              start: tokenBeforeFirst.loc.start,\n              end: firstBlockToken.loc.start\n            },\n\n            fix(fixer) {\n              return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n            },\n\n            messageId: \"alwaysPadBlock\"\n          });\n        }\n\n        if (!blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              end: tokenAfterLast.loc.start,\n              start: lastBlockToken.loc.end\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n            },\n\n            messageId: \"alwaysPadBlock\"\n          });\n        }\n      } else {\n        if (blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              start: tokenBeforeFirst.loc.start,\n              end: firstBlockToken.loc.start\n            },\n\n            fix(fixer) {\n              return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n            },\n\n            messageId: \"neverPadBlock\"\n          });\n        }\n\n        if (blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              end: tokenAfterLast.loc.start,\n              start: lastBlockToken.loc.end\n            },\n            messageId: \"neverPadBlock\",\n\n            fix(fixer) {\n              return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n            }\n\n          });\n        }\n      }\n    }\n\n    const rule = {};\n\n    if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n      rule.SwitchStatement = function (node) {\n        if (node.cases.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n      rule.BlockStatement = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n      rule.ClassBody = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    return rule;\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","blocks","switches","classes","additionalProperties","minProperties","allowSingleLineBlocks","messages","alwaysPadBlock","neverPadBlock","create","context","options","typeOptions","exceptOptions","shouldHavePadding","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","getOpenBrace","node","getTokenBefore","cases","getFirstToken","isComment","isPaddingBetweenTokens","first","second","loc","start","line","end","getFirstBlockToken","token","prev","getTokenAfter","includeComments","getLastBlockToken","last","next","requirePaddingFor","Error","checkPadding","openBrace","firstBlockToken","tokenBeforeFirst","closeBrace","getLastToken","lastBlockToken","tokenAfterLast","blockHasTopPadding","blockHasBottomPadding","isTokenOnSameLine","report","fix","fixer","insertTextAfter","messageId","insertTextBefore","replaceTextRange","range","column","rule","SwitchStatement","length","BlockStatement","body","ClassBody"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/padded-blocks.js"],"sourcesContent":["/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding within blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padded-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            blocks: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            switches: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLineBlocks: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            alwaysPadBlock: \"Block must be padded by blank lines.\",\n            neverPadBlock: \"Block must not be padded by blank lines.\"\n        }\n    },\n\n    create(context) {\n        const options = {};\n        const typeOptions = context.options[0] || \"always\";\n        const exceptOptions = context.options[1] || {};\n\n        if (typeof typeOptions === \"string\") {\n            const shouldHavePadding = typeOptions === \"always\";\n\n            options.blocks = shouldHavePadding;\n            options.switches = shouldHavePadding;\n            options.classes = shouldHavePadding;\n        } else {\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n                options.blocks = typeOptions.blocks === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n                options.switches = typeOptions.switches === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n                options.classes = typeOptions.classes === \"always\";\n            }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n            options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                return sourceCode.getTokenBefore(node.cases[0]);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks if the given parameter is a comment node\n         * @param {ASTNode|Token} node An AST node or token\n         * @returns {boolean} True if node is a comment\n         */\n        function isComment(node) {\n            return node.type === \"Line\" || node.type === \"Block\";\n        }\n\n        /**\n         * Checks if there is padding between two tokens\n         * @param {Token} first The first token\n         * @param {Token} second The second token\n         * @returns {boolean} True if there is at least a line between the tokens\n         */\n        function isPaddingBetweenTokens(first, second) {\n            return second.loc.start.line - first.loc.end.line >= 2;\n        }\n\n\n        /**\n         * Checks if the given token has a blank line after it.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is followed by a blank line.\n         */\n        function getFirstBlockToken(token) {\n            let prev,\n                first = token;\n\n            do {\n                prev = first;\n                first = sourceCode.getTokenAfter(first, { includeComments: true });\n            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n            return first;\n        }\n\n        /**\n         * Checks if the given token is preceded by a blank line.\n         * @param {Token} token The token to check\n         * @returns {boolean} Whether or not the token is preceded by a blank line\n         */\n        function getLastBlockToken(token) {\n            let last = token,\n                next;\n\n            do {\n                next = last;\n                last = sourceCode.getTokenBefore(last, { includeComments: true });\n            } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n            return last;\n        }\n\n        /**\n         * Checks if a node should be padded, according to the rule config.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} True if the node should be padded, false otherwise.\n         */\n        function requirePaddingFor(node) {\n            switch (node.type) {\n                case \"BlockStatement\":\n                    return options.blocks;\n                case \"SwitchStatement\":\n                    return options.switches;\n                case \"ClassBody\":\n                    return options.classes;\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(\"unreachable\");\n            }\n        }\n\n        /**\n         * Checks the given BlockStatement node to be padded if the block is not empty.\n         * @param {ASTNode} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPadding(node) {\n            const openBrace = getOpenBrace(node),\n                firstBlockToken = getFirstBlockToken(openBrace),\n                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),\n                closeBrace = sourceCode.getLastToken(node),\n                lastBlockToken = getLastBlockToken(closeBrace),\n                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),\n                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n            if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n                return;\n            }\n\n            if (requirePaddingFor(node)) {\n\n                if (!blockHasTopPadding) {\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBeforeFirst.loc.start,\n                            end: firstBlockToken.loc.start\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n                        },\n                        messageId: \"alwaysPadBlock\"\n                    });\n                }\n                if (!blockHasBottomPadding) {\n                    context.report({\n                        node,\n                        loc: {\n                            end: tokenAfterLast.loc.start,\n                            start: lastBlockToken.loc.end\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n                        },\n                        messageId: \"alwaysPadBlock\"\n                    });\n                }\n            } else {\n                if (blockHasTopPadding) {\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBeforeFirst.loc.start,\n                            end: firstBlockToken.loc.start\n                        },\n                        fix(fixer) {\n                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n                        },\n                        messageId: \"neverPadBlock\"\n                    });\n                }\n\n                if (blockHasBottomPadding) {\n\n                    context.report({\n                        node,\n                        loc: {\n                            end: tokenAfterLast.loc.start,\n                            start: lastBlockToken.loc.end\n                        },\n                        messageId: \"neverPadBlock\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n                        }\n                    });\n                }\n            }\n        }\n\n        const rule = {};\n\n        if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n            rule.SwitchStatement = function(node) {\n                if (node.cases.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n            rule.BlockStatement = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n            rule.ClassBody = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        return rule;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}