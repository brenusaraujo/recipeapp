{"ast":null,"code":"/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\n\n\nfunction containsLineTerminator(str) {\n  return astUtils.LINEBREAK_MATCHER.test(str);\n}\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\n\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\n\n\nfunction isSingleLine(node) {\n  return node.loc.end.line === node.loc.start.line;\n}\n/**\n * Checks whether the properties on a single line.\n * @param {ASTNode[]} properties List of Property AST nodes.\n * @returns {boolean} True if all properties is on a single line.\n */\n\n\nfunction isSingleLineProperties(properties) {\n  const [firstProp] = properties,\n        lastProp = last(properties);\n  return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\n\n\nfunction initOptionProperty(toOptions, fromOptions) {\n  toOptions.mode = fromOptions.mode || \"strict\"; // Set value of beforeColon\n\n  if (typeof fromOptions.beforeColon !== \"undefined\") {\n    toOptions.beforeColon = +fromOptions.beforeColon;\n  } else {\n    toOptions.beforeColon = 0;\n  } // Set value of afterColon\n\n\n  if (typeof fromOptions.afterColon !== \"undefined\") {\n    toOptions.afterColon = +fromOptions.afterColon;\n  } else {\n    toOptions.afterColon = 1;\n  } // Set align if exists\n\n\n  if (typeof fromOptions.align !== \"undefined\") {\n    if (typeof fromOptions.align === \"object\") {\n      toOptions.align = fromOptions.align;\n    } else {\n      // \"string\"\n      toOptions.align = {\n        on: fromOptions.align,\n        mode: toOptions.mode,\n        beforeColon: toOptions.beforeColon,\n        afterColon: toOptions.afterColon\n      };\n    }\n  }\n\n  return toOptions;\n}\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\n\n\nfunction initOptions(toOptions, fromOptions) {\n  if (typeof fromOptions.align === \"object\") {\n    // Initialize the alignment configuration\n    toOptions.align = initOptionProperty({}, fromOptions.align);\n    toOptions.align.on = fromOptions.align.on || \"colon\";\n    toOptions.align.mode = fromOptions.align.mode || \"strict\";\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);\n  } else {\n    // string or undefined\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions); // If alignment options are defined in multiLine, pull them out into the general align configuration\n\n    if (toOptions.multiLine.align) {\n      toOptions.align = {\n        on: toOptions.multiLine.align.on,\n        mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n        beforeColon: toOptions.multiLine.align.beforeColon,\n        afterColon: toOptions.multiLine.align.afterColon\n      };\n    }\n  }\n\n  return toOptions;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing between keys and values in object literal properties\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/key-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      anyOf: [{\n        type: \"object\",\n        properties: {\n          align: {\n            anyOf: [{\n              enum: [\"colon\", \"value\"]\n            }, {\n              type: \"object\",\n              properties: {\n                mode: {\n                  enum: [\"strict\", \"minimum\"]\n                },\n                on: {\n                  enum: [\"colon\", \"value\"]\n                },\n                beforeColon: {\n                  type: \"boolean\"\n                },\n                afterColon: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            }]\n          },\n          mode: {\n            enum: [\"strict\", \"minimum\"]\n          },\n          beforeColon: {\n            type: \"boolean\"\n          },\n          afterColon: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              align: {\n                anyOf: [{\n                  enum: [\"colon\", \"value\"]\n                }, {\n                  type: \"object\",\n                  properties: {\n                    mode: {\n                      enum: [\"strict\", \"minimum\"]\n                    },\n                    on: {\n                      enum: [\"colon\", \"value\"]\n                    },\n                    beforeColon: {\n                      type: \"boolean\"\n                    },\n                    afterColon: {\n                      type: \"boolean\"\n                    }\n                  },\n                  additionalProperties: false\n                }]\n              },\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          align: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              on: {\n                enum: [\"colon\", \"value\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n      extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n      missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n      missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n    }\n  },\n\n  create(context) {\n    /**\n     * OPTIONS\n     * \"key-spacing\": [2, {\n     *     beforeColon: false,\n     *     afterColon: true,\n     *     align: \"colon\" // Optional, or \"value\"\n     * }\n     */\n    const options = context.options[0] || {},\n          ruleOptions = initOptions({}, options),\n          multiLineOptions = ruleOptions.multiLine,\n          singleLineOptions = ruleOptions.singleLine,\n          alignmentOptions = ruleOptions.align || null;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Checks whether a property is a member of the property group it follows.\n     * @param {ASTNode} lastMember The last Property known to be in the group.\n     * @param {ASTNode} candidate The next Property that might be in the group.\n     * @returns {boolean} True if the candidate property is part of the group.\n     */\n\n    function continuesPropertyGroup(lastMember, candidate) {\n      const groupEndLine = lastMember.loc.start.line,\n            candidateStartLine = candidate.loc.start.line;\n\n      if (candidateStartLine - groupEndLine <= 1) {\n        return true;\n      }\n      /*\n       * Check that the first comment is adjacent to the end of the group, the\n       * last comment is adjacent to the candidate property, and that successive\n       * comments are adjacent to each other.\n       */\n\n\n      const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {\n        for (let i = 1; i < leadingComments.length; i++) {\n          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Determines if the given property is key-value property.\n     * @param {ASTNode} property Property node to check.\n     * @returns {boolean} Whether the property is a key-value property.\n     */\n\n\n    function isKeyValueProperty(property) {\n      return !(property.method || property.shorthand || property.kind !== \"init\" || property.type !== \"Property\" // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n      );\n    }\n    /**\n     * Starting from the given a node (a property.key node here) looks forward\n     * until it finds the last token before a colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The last token before a colon punctuator.\n     */\n\n\n    function getLastTokenBeforeColon(node) {\n      const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n      return sourceCode.getTokenBefore(colonToken);\n    }\n    /**\n     * Starting from the given a node (a property.key node here) looks forward\n     * until it finds the colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The colon punctuator.\n     */\n\n\n    function getNextColon(node) {\n      return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n    }\n    /**\n     * Gets an object literal property's key as the identifier name or string value.\n     * @param {ASTNode} property Property node whose key to retrieve.\n     * @returns {string} The property's key.\n     */\n\n\n    function getKey(property) {\n      const key = property.key;\n\n      if (property.computed) {\n        return sourceCode.getText().slice(key.range[0], key.range[1]);\n      }\n\n      return astUtils.getStaticPropertyName(property);\n    }\n    /**\n     * Reports an appropriately-formatted error if spacing is incorrect on one\n     * side of the colon.\n     * @param {ASTNode} property Key-value pair in an object literal.\n     * @param {string} side Side being verified - either \"key\" or \"value\".\n     * @param {string} whitespace Actual whitespace string.\n     * @param {int} expected Expected whitespace length.\n     * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n     * @returns {void}\n     */\n\n\n    function report(property, side, whitespace, expected, mode) {\n      const diff = whitespace.length - expected,\n            nextColon = getNextColon(property.key),\n            tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {\n        includeComments: true\n      }),\n            tokenAfterColon = sourceCode.getTokenAfter(nextColon, {\n        includeComments: true\n      }),\n            isKeySide = side === \"key\",\n            isExtra = diff > 0,\n            diffAbs = Math.abs(diff),\n            spaces = Array(diffAbs + 1).join(\" \");\n      const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\n      const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\n      const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\n      const loc = isExtra ? {\n        start: locStart,\n        end: locEnd\n      } : missingLoc;\n\n      if ((diff && mode === \"strict\" || diff < 0 && mode === \"minimum\" || diff > 0 && !expected && mode === \"minimum\") && !(expected && containsLineTerminator(whitespace))) {\n        let fix;\n\n        if (isExtra) {\n          let range; // Remove whitespace\n\n          if (isKeySide) {\n            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n          } else {\n            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n          }\n\n          fix = function (fixer) {\n            return fixer.removeRange(range);\n          };\n        } else {\n          // Add whitespace\n          if (isKeySide) {\n            fix = function (fixer) {\n              return fixer.insertTextAfter(tokenBeforeColon, spaces);\n            };\n          } else {\n            fix = function (fixer) {\n              return fixer.insertTextBefore(tokenAfterColon, spaces);\n            };\n          }\n        }\n\n        let messageId = \"\";\n\n        if (isExtra) {\n          messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n        } else {\n          messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n        }\n\n        context.report({\n          node: property[side],\n          loc,\n          messageId,\n          data: {\n            computed: property.computed ? \"computed \" : \"\",\n            key: getKey(property)\n          },\n          fix\n        });\n      }\n    }\n    /**\n     * Gets the number of characters in a key, including quotes around string\n     * keys and braces around computed property keys.\n     * @param {ASTNode} property Property of on object literal.\n     * @returns {int} Width of the key.\n     */\n\n\n    function getKeyWidth(property) {\n      const startToken = sourceCode.getFirstToken(property);\n      const endToken = getLastTokenBeforeColon(property.key);\n      return endToken.range[1] - startToken.range[0];\n    }\n    /**\n     * Gets the whitespace around the colon in an object literal property.\n     * @param {ASTNode} property Property node from an object literal.\n     * @returns {Object} Whitespace before and after the property's colon.\n     */\n\n\n    function getPropertyWhitespace(property) {\n      const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));\n\n      if (whitespace) {\n        return {\n          beforeColon: whitespace[1],\n          afterColon: whitespace[2]\n        };\n      }\n\n      return null;\n    }\n    /**\n     * Creates groups of properties.\n     * @param  {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n     */\n\n\n    function createGroups(node) {\n      if (node.properties.length === 1) {\n        return [node.properties];\n      }\n\n      return node.properties.reduce((groups, property) => {\n        const currentGroup = last(groups),\n              prev = last(currentGroup);\n\n        if (!prev || continuesPropertyGroup(prev, property)) {\n          currentGroup.push(property);\n        } else {\n          groups.push([property]);\n        }\n\n        return groups;\n      }, [[]]);\n    }\n    /**\n     * Verifies correct vertical alignment of a group of properties.\n     * @param {ASTNode[]} properties List of Property AST nodes.\n     * @returns {void}\n     */\n\n\n    function verifyGroupAlignment(properties) {\n      const length = properties.length,\n            widths = properties.map(getKeyWidth),\n            // Width of keys, including quotes\n      align = alignmentOptions.on; // \"value\" or \"colon\"\n\n      let targetWidth = Math.max(...widths),\n          beforeColon,\n          afterColon,\n          mode;\n\n      if (alignmentOptions && length > 1) {\n        // When aligning values within a group, use the alignment configuration.\n        beforeColon = alignmentOptions.beforeColon;\n        afterColon = alignmentOptions.afterColon;\n        mode = alignmentOptions.mode;\n      } else {\n        beforeColon = multiLineOptions.beforeColon;\n        afterColon = multiLineOptions.afterColon;\n        mode = alignmentOptions.mode;\n      } // Conditionally include one space before or after colon\n\n\n      targetWidth += align === \"colon\" ? beforeColon : afterColon;\n\n      for (let i = 0; i < length; i++) {\n        const property = properties[i];\n        const whitespace = getPropertyWhitespace(property);\n\n        if (whitespace) {\n          // Object literal getters/setters lack a colon\n          const width = widths[i];\n\n          if (align === \"value\") {\n            report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n            report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n          } else {\n            // align = \"colon\"\n            report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n            report(property, \"value\", whitespace.afterColon, afterColon, mode);\n          }\n        }\n      }\n    }\n    /**\n     * Verifies spacing of property conforms to specified options.\n     * @param  {ASTNode} node Property node being evaluated.\n     * @param {Object} lineOptions Configured singleLine or multiLine options\n     * @returns {void}\n     */\n\n\n    function verifySpacing(node, lineOptions) {\n      const actual = getPropertyWhitespace(node);\n\n      if (actual) {\n        // Object literal getters/setters lack colons\n        report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n        report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n      }\n    }\n    /**\n     * Verifies spacing of each property in a list.\n     * @param {ASTNode[]} properties List of Property AST nodes.\n     * @param {Object} lineOptions Configured singleLine or multiLine options\n     * @returns {void}\n     */\n\n\n    function verifyListSpacing(properties, lineOptions) {\n      const length = properties.length;\n\n      for (let i = 0; i < length; i++) {\n        verifySpacing(properties[i], lineOptions);\n      }\n    }\n    /**\n     * Verifies vertical alignment, taking into account groups of properties.\n     * @param  {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {void}\n     */\n\n\n    function verifyAlignment(node) {\n      createGroups(node).forEach(group => {\n        const properties = group.filter(isKeyValueProperty);\n\n        if (properties.length > 0 && isSingleLineProperties(properties)) {\n          verifyListSpacing(properties, multiLineOptions);\n        } else {\n          verifyGroupAlignment(properties);\n        }\n      });\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    if (alignmentOptions) {\n      // Verify vertical alignment\n      return {\n        ObjectExpression(node) {\n          if (isSingleLine(node)) {\n            verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n          } else {\n            verifyAlignment(node);\n          }\n        }\n\n      };\n    } // Obey beforeColon and afterColon in each property as configured\n\n\n    return {\n      Property(node) {\n        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","containsLineTerminator","str","LINEBREAK_MATCHER","test","last","arr","length","isSingleLine","node","loc","end","line","start","isSingleLineProperties","properties","firstProp","lastProp","initOptionProperty","toOptions","fromOptions","mode","beforeColon","afterColon","align","on","initOptions","multiLine","singleLine","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","anyOf","enum","additionalProperties","messages","extraKey","extraValue","missingKey","missingValue","create","context","options","ruleOptions","multiLineOptions","singleLineOptions","alignmentOptions","sourceCode","getSourceCode","continuesPropertyGroup","lastMember","candidate","groupEndLine","candidateStartLine","leadingComments","getCommentsBefore","i","isKeyValueProperty","property","method","shorthand","kind","getLastTokenBeforeColon","colonToken","getTokenAfter","isColonToken","getTokenBefore","getNextColon","getKey","key","computed","getText","slice","range","getStaticPropertyName","report","side","whitespace","expected","diff","nextColon","tokenBeforeColon","includeComments","tokenAfterColon","isKeySide","isExtra","diffAbs","Math","abs","spaces","Array","join","locStart","locEnd","missingLoc","fix","fixer","removeRange","insertTextAfter","insertTextBefore","messageId","data","getKeyWidth","startToken","getFirstToken","endToken","getPropertyWhitespace","exec","value","createGroups","reduce","groups","currentGroup","prev","push","verifyGroupAlignment","widths","map","targetWidth","max","width","verifySpacing","lineOptions","actual","verifyListSpacing","verifyAlignment","forEach","group","filter","ObjectExpression","Property","parent"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/key-spacing.js"],"sourcesContent":["/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n/**\n * Checks whether the properties on a single line.\n * @param {ASTNode[]} properties List of Property AST nodes.\n * @returns {boolean} True if all properties is on a single line.\n */\nfunction isSingleLineProperties(properties) {\n    const [firstProp] = properties,\n        lastProp = last(properties);\n\n    return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n    toOptions.mode = fromOptions.mode || \"strict\";\n\n    // Set value of beforeColon\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\n        toOptions.beforeColon = +fromOptions.beforeColon;\n    } else {\n        toOptions.beforeColon = 0;\n    }\n\n    // Set value of afterColon\n    if (typeof fromOptions.afterColon !== \"undefined\") {\n        toOptions.afterColon = +fromOptions.afterColon;\n    } else {\n        toOptions.afterColon = 1;\n    }\n\n    // Set align if exists\n    if (typeof fromOptions.align !== \"undefined\") {\n        if (typeof fromOptions.align === \"object\") {\n            toOptions.align = fromOptions.align;\n        } else { // \"string\"\n            toOptions.align = {\n                on: fromOptions.align,\n                mode: toOptions.mode,\n                beforeColon: toOptions.beforeColon,\n                afterColon: toOptions.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n    if (typeof fromOptions.align === \"object\") {\n\n        // Initialize the alignment configuration\n        toOptions.align = initOptionProperty({}, fromOptions.align);\n        toOptions.align.on = fromOptions.align.on || \"colon\";\n        toOptions.align.mode = fromOptions.align.mode || \"strict\";\n\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n    } else { // string or undefined\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\n        if (toOptions.multiLine.align) {\n            toOptions.align = {\n                on: toOptions.multiLine.align.on,\n                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n                beforeColon: toOptions.multiLine.align.beforeColon,\n                afterColon: toOptions.multiLine.align.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing between keys and values in object literal properties\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/key-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        align: {\n                            anyOf: [\n                                {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                {\n                                    type: \"object\",\n                                    properties: {\n                                        mode: {\n                                            enum: [\"strict\", \"minimum\"]\n                                        },\n                                        on: {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        beforeColon: {\n                                            type: \"boolean\"\n                                        },\n                                        afterColon: {\n                                            type: \"boolean\"\n                                        }\n                                    },\n                                    additionalProperties: false\n                                }\n                            ]\n                        },\n                        mode: {\n                            enum: [\"strict\", \"minimum\"]\n                        },\n                        beforeColon: {\n                            type: \"boolean\"\n                        },\n                        afterColon: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                align: {\n                                    anyOf: [\n                                        {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        {\n                                            type: \"object\",\n                                            properties: {\n                                                mode: {\n                                                    enum: [\"strict\", \"minimum\"]\n                                                },\n                                                on: {\n                                                    enum: [\"colon\", \"value\"]\n                                                },\n                                                beforeColon: {\n                                                    type: \"boolean\"\n                                                },\n                                                afterColon: {\n                                                    type: \"boolean\"\n                                                }\n                                            },\n                                            additionalProperties: false\n                                        }\n                                    ]\n                                },\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        align: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                on: {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }],\n        messages: {\n            extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n            extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n            missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n            missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n        const options = context.options[0] || {},\n            ruleOptions = initOptions({}, options),\n            multiLineOptions = ruleOptions.multiLine,\n            singleLineOptions = ruleOptions.singleLine,\n            alignmentOptions = ruleOptions.align || null;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether a property is a member of the property group it follows.\n         * @param {ASTNode} lastMember The last Property known to be in the group.\n         * @param {ASTNode} candidate The next Property that might be in the group.\n         * @returns {boolean} True if the candidate property is part of the group.\n         */\n        function continuesPropertyGroup(lastMember, candidate) {\n            const groupEndLine = lastMember.loc.start.line,\n                candidateStartLine = candidate.loc.start.line;\n\n            if (candidateStartLine - groupEndLine <= 1) {\n                return true;\n            }\n\n            /*\n             * Check that the first comment is adjacent to the end of the group, the\n             * last comment is adjacent to the candidate property, and that successive\n             * comments are adjacent to each other.\n             */\n            const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n            if (\n                leadingComments.length &&\n                leadingComments[0].loc.start.line - groupEndLine <= 1 &&\n                candidateStartLine - last(leadingComments).loc.end.line <= 1\n            ) {\n                for (let i = 1; i < leadingComments.length; i++) {\n                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {boolean} Whether the property is a key-value property.\n         */\n        function isKeyValueProperty(property) {\n            return !(\n                (property.method ||\n                property.shorthand ||\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n            );\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n        function getLastTokenBeforeColon(node) {\n            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n\n            return sourceCode.getTokenBefore(colonToken);\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n        function getNextColon(node) {\n            return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n        }\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n        function getKey(property) {\n            const key = property.key;\n\n            if (property.computed) {\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\n            }\n            return astUtils.getStaticPropertyName(property);\n        }\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n        function report(property, side, whitespace, expected, mode) {\n            const diff = whitespace.length - expected,\n                nextColon = getNextColon(property.key),\n                tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),\n                tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),\n                isKeySide = side === \"key\",\n                isExtra = diff > 0,\n                diffAbs = Math.abs(diff),\n                spaces = Array(diffAbs + 1).join(\" \");\n\n            const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\n            const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\n            const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\n            const loc = isExtra ? { start: locStart, end: locEnd } : missingLoc;\n\n            if ((\n                diff && mode === \"strict\" ||\n                diff < 0 && mode === \"minimum\" ||\n                diff > 0 && !expected && mode === \"minimum\") &&\n                !(expected && containsLineTerminator(whitespace))\n            ) {\n                let fix;\n\n                if (isExtra) {\n                    let range;\n\n                    // Remove whitespace\n                    if (isKeySide) {\n                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n                    } else {\n                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n                    }\n                    fix = function(fixer) {\n                        return fixer.removeRange(range);\n                    };\n                } else {\n\n                    // Add whitespace\n                    if (isKeySide) {\n                        fix = function(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\n                        };\n                    } else {\n                        fix = function(fixer) {\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\n                        };\n                    }\n                }\n\n                let messageId = \"\";\n\n                if (isExtra) {\n                    messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n                } else {\n                    messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n                }\n\n                context.report({\n                    node: property[side],\n                    loc,\n                    messageId,\n                    data: {\n                        computed: property.computed ? \"computed \" : \"\",\n                        key: getKey(property)\n                    },\n                    fix\n                });\n            }\n        }\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n        function getKeyWidth(property) {\n            const startToken = sourceCode.getFirstToken(property);\n            const endToken = getLastTokenBeforeColon(property.key);\n\n            return endToken.range[1] - startToken.range[0];\n        }\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n        function getPropertyWhitespace(property) {\n            const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(\n                property.key.range[1], property.value.range[0]\n            ));\n\n            if (whitespace) {\n                return {\n                    beforeColon: whitespace[1],\n                    afterColon: whitespace[2]\n                };\n            }\n            return null;\n        }\n\n        /**\n         * Creates groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n         */\n        function createGroups(node) {\n            if (node.properties.length === 1) {\n                return [node.properties];\n            }\n\n            return node.properties.reduce((groups, property) => {\n                const currentGroup = last(groups),\n                    prev = last(currentGroup);\n\n                if (!prev || continuesPropertyGroup(prev, property)) {\n                    currentGroup.push(property);\n                } else {\n                    groups.push([property]);\n                }\n\n                return groups;\n            }, [\n                []\n            ]);\n        }\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyGroupAlignment(properties) {\n            const length = properties.length,\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\n                align = alignmentOptions.on; // \"value\" or \"colon\"\n            let targetWidth = Math.max(...widths),\n                beforeColon, afterColon, mode;\n\n            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.\n                beforeColon = alignmentOptions.beforeColon;\n                afterColon = alignmentOptions.afterColon;\n                mode = alignmentOptions.mode;\n            } else {\n                beforeColon = multiLineOptions.beforeColon;\n                afterColon = multiLineOptions.afterColon;\n                mode = alignmentOptions.mode;\n            }\n\n            // Conditionally include one space before or after colon\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n            for (let i = 0; i < length; i++) {\n                const property = properties[i];\n                const whitespace = getPropertyWhitespace(property);\n\n                if (whitespace) { // Object literal getters/setters lack a colon\n                    const width = widths[i];\n\n                    if (align === \"value\") {\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n                    } else { // align = \"colon\"\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param  {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifySpacing(node, lineOptions) {\n            const actual = getPropertyWhitespace(node);\n\n            if (actual) { // Object literal getters/setters lack colons\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n            }\n        }\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifyListSpacing(properties, lineOptions) {\n            const length = properties.length;\n\n            for (let i = 0; i < length; i++) {\n                verifySpacing(properties[i], lineOptions);\n            }\n        }\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n        function verifyAlignment(node) {\n            createGroups(node).forEach(group => {\n                const properties = group.filter(isKeyValueProperty);\n\n                if (properties.length > 0 && isSingleLineProperties(properties)) {\n                    verifyListSpacing(properties, multiLineOptions);\n                } else {\n                    verifyGroupAlignment(properties);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        if (alignmentOptions) { // Verify vertical alignment\n\n            return {\n                ObjectExpression(node) {\n                    if (isSingleLine(node)) {\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n                    } else {\n                        verifyAlignment(node);\n                    }\n                }\n            };\n\n        }\n\n        // Obey beforeColon and afterColon in each property as configured\n        return {\n            Property(node) {\n                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n            }\n        };\n\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}