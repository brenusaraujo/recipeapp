{"ast":null,"code":"/**\n * @fileoverview Utility for caching lint results.\n * @author Kevin Partington\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst fs = require(\"fs\");\n\nconst fileEntryCache = require(\"file-entry-cache\");\n\nconst stringify = require(\"json-stable-stringify-without-jsonify\");\n\nconst pkg = require(\"../../package.json\");\n\nconst hash = require(\"./hash\");\n\nconst debug = require(\"debug\")(\"eslint:lint-result-cache\"); //-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n\nconst configHashCache = new WeakMap();\nconst nodeVersion = process && process.version;\nconst validCacheStrategies = [\"metadata\", \"content\"];\nconst invalidCacheStrategyErrorMessage = `Cache strategy must be one of: ${validCacheStrategies.map(strategy => `\"${strategy}\"`).join(\", \")}`;\n/**\n * Tests whether a provided cacheStrategy is valid\n * @param {string} cacheStrategy The cache strategy to use\n * @returns {boolean} true if `cacheStrategy` is one of `validCacheStrategies`; false otherwise\n */\n\nfunction isValidCacheStrategy(cacheStrategy) {\n  return validCacheStrategies.indexOf(cacheStrategy) !== -1;\n}\n/**\n * Calculates the hash of the config\n * @param {ConfigArray} config The config.\n * @returns {string} The hash of the config\n */\n\n\nfunction hashOfConfigFor(config) {\n  if (!configHashCache.has(config)) {\n    configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));\n  }\n\n  return configHashCache.get(config);\n} //-----------------------------------------------------------------------------\n// Public Interface\n//-----------------------------------------------------------------------------\n\n/**\n * Lint result cache. This wraps around the file-entry-cache module,\n * transparently removing properties that are difficult or expensive to\n * serialize and adding them back in on retrieval.\n */\n\n\nclass LintResultCache {\n  /**\n   * Creates a new LintResultCache instance.\n   * @param {string} cacheFileLocation The cache file location.\n   * @param {\"metadata\" | \"content\"} cacheStrategy The cache strategy to use.\n   */\n  constructor(cacheFileLocation, cacheStrategy) {\n    assert(cacheFileLocation, \"Cache file location is required\");\n    assert(cacheStrategy, \"Cache strategy is required\");\n    assert(isValidCacheStrategy(cacheStrategy), invalidCacheStrategyErrorMessage);\n    debug(`Caching results to ${cacheFileLocation}`);\n    const useChecksum = cacheStrategy === \"content\";\n    debug(`Using \"${cacheStrategy}\" strategy to detect changes`);\n    this.fileEntryCache = fileEntryCache.create(cacheFileLocation, void 0, useChecksum);\n    this.cacheFileLocation = cacheFileLocation;\n  }\n  /**\n   * Retrieve cached lint results for a given file path, if present in the\n   * cache. If the file is present and has not been changed, rebuild any\n   * missing result information.\n   * @param {string} filePath The file for which to retrieve lint results.\n   * @param {ConfigArray} config The config of the file.\n   * @returns {Object|null} The rebuilt lint results, or null if the file is\n   *   changed or not in the filesystem.\n   */\n\n\n  getCachedLintResults(filePath, config) {\n    /*\n     * Cached lint results are valid if and only if:\n     * 1. The file is present in the filesystem\n     * 2. The file has not changed since the time it was previously linted\n     * 3. The ESLint configuration has not changed since the time the file\n     *    was previously linted\n     * If any of these are not true, we will not reuse the lint results.\n     */\n    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n    const hashOfConfig = hashOfConfigFor(config);\n    const changed = fileDescriptor.changed || fileDescriptor.meta.hashOfConfig !== hashOfConfig;\n\n    if (fileDescriptor.notFound) {\n      debug(`File not found on the file system: ${filePath}`);\n      return null;\n    }\n\n    if (changed) {\n      debug(`Cache entry not found or no longer valid: ${filePath}`);\n      return null;\n    } // If source is present but null, need to reread the file from the filesystem.\n\n\n    if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) {\n      debug(`Rereading cached result source from filesystem: ${filePath}`);\n      fileDescriptor.meta.results.source = fs.readFileSync(filePath, \"utf-8\");\n    }\n\n    return fileDescriptor.meta.results;\n  }\n  /**\n   * Set the cached lint results for a given file path, after removing any\n   * information that will be both unnecessary and difficult to serialize.\n   * Avoids caching results with an \"output\" property (meaning fixes were\n   * applied), to prevent potentially incorrect results if fixes are not\n   * written to disk.\n   * @param {string} filePath The file for which to set lint results.\n   * @param {ConfigArray} config The config of the file.\n   * @param {Object} result The lint result to be set for the file.\n   * @returns {void}\n   */\n\n\n  setCachedLintResults(filePath, config, result) {\n    if (result && Object.prototype.hasOwnProperty.call(result, \"output\")) {\n      return;\n    }\n\n    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n\n    if (fileDescriptor && !fileDescriptor.notFound) {\n      debug(`Updating cached result: ${filePath}`); // Serialize the result, except that we want to remove the file source if present.\n\n      const resultToSerialize = Object.assign({}, result);\n      /*\n       * Set result.source to null.\n       * In `getCachedLintResults`, if source is explicitly null, we will\n       * read the file from the filesystem to set the value again.\n       */\n\n      if (Object.prototype.hasOwnProperty.call(resultToSerialize, \"source\")) {\n        resultToSerialize.source = null;\n      }\n\n      fileDescriptor.meta.results = resultToSerialize;\n      fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);\n    }\n  }\n  /**\n   * Persists the in-memory cache to disk.\n   * @returns {void}\n   */\n\n\n  reconcile() {\n    debug(`Persisting cached results: ${this.cacheFileLocation}`);\n    this.fileEntryCache.reconcile();\n  }\n\n}\n\nmodule.exports = LintResultCache;","map":{"version":3,"names":["assert","require","fs","fileEntryCache","stringify","pkg","hash","debug","configHashCache","WeakMap","nodeVersion","process","version","validCacheStrategies","invalidCacheStrategyErrorMessage","map","strategy","join","isValidCacheStrategy","cacheStrategy","indexOf","hashOfConfigFor","config","has","set","get","LintResultCache","constructor","cacheFileLocation","useChecksum","create","getCachedLintResults","filePath","fileDescriptor","getFileDescriptor","hashOfConfig","changed","meta","notFound","results","source","readFileSync","setCachedLintResults","result","Object","prototype","hasOwnProperty","call","resultToSerialize","assign","reconcile","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/cli-engine/lint-result-cache.js"],"sourcesContent":["/**\n * @fileoverview Utility for caching lint results.\n * @author Kevin Partington\n */\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst fs = require(\"fs\");\nconst fileEntryCache = require(\"file-entry-cache\");\nconst stringify = require(\"json-stable-stringify-without-jsonify\");\nconst pkg = require(\"../../package.json\");\nconst hash = require(\"./hash\");\n\nconst debug = require(\"debug\")(\"eslint:lint-result-cache\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst configHashCache = new WeakMap();\nconst nodeVersion = process && process.version;\n\nconst validCacheStrategies = [\"metadata\", \"content\"];\nconst invalidCacheStrategyErrorMessage = `Cache strategy must be one of: ${validCacheStrategies\n    .map(strategy => `\"${strategy}\"`)\n    .join(\", \")}`;\n\n/**\n * Tests whether a provided cacheStrategy is valid\n * @param {string} cacheStrategy The cache strategy to use\n * @returns {boolean} true if `cacheStrategy` is one of `validCacheStrategies`; false otherwise\n */\nfunction isValidCacheStrategy(cacheStrategy) {\n    return (\n        validCacheStrategies.indexOf(cacheStrategy) !== -1\n    );\n}\n\n/**\n * Calculates the hash of the config\n * @param {ConfigArray} config The config.\n * @returns {string} The hash of the config\n */\nfunction hashOfConfigFor(config) {\n    if (!configHashCache.has(config)) {\n        configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));\n    }\n\n    return configHashCache.get(config);\n}\n\n//-----------------------------------------------------------------------------\n// Public Interface\n//-----------------------------------------------------------------------------\n\n/**\n * Lint result cache. This wraps around the file-entry-cache module,\n * transparently removing properties that are difficult or expensive to\n * serialize and adding them back in on retrieval.\n */\nclass LintResultCache {\n\n    /**\n     * Creates a new LintResultCache instance.\n     * @param {string} cacheFileLocation The cache file location.\n     * @param {\"metadata\" | \"content\"} cacheStrategy The cache strategy to use.\n     */\n    constructor(cacheFileLocation, cacheStrategy) {\n        assert(cacheFileLocation, \"Cache file location is required\");\n        assert(cacheStrategy, \"Cache strategy is required\");\n        assert(\n            isValidCacheStrategy(cacheStrategy),\n            invalidCacheStrategyErrorMessage\n        );\n\n        debug(`Caching results to ${cacheFileLocation}`);\n\n        const useChecksum = cacheStrategy === \"content\";\n\n        debug(\n            `Using \"${cacheStrategy}\" strategy to detect changes`\n        );\n\n        this.fileEntryCache = fileEntryCache.create(\n            cacheFileLocation,\n            void 0,\n            useChecksum\n        );\n        this.cacheFileLocation = cacheFileLocation;\n    }\n\n    /**\n     * Retrieve cached lint results for a given file path, if present in the\n     * cache. If the file is present and has not been changed, rebuild any\n     * missing result information.\n     * @param {string} filePath The file for which to retrieve lint results.\n     * @param {ConfigArray} config The config of the file.\n     * @returns {Object|null} The rebuilt lint results, or null if the file is\n     *   changed or not in the filesystem.\n     */\n    getCachedLintResults(filePath, config) {\n\n        /*\n         * Cached lint results are valid if and only if:\n         * 1. The file is present in the filesystem\n         * 2. The file has not changed since the time it was previously linted\n         * 3. The ESLint configuration has not changed since the time the file\n         *    was previously linted\n         * If any of these are not true, we will not reuse the lint results.\n         */\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n        const hashOfConfig = hashOfConfigFor(config);\n        const changed =\n            fileDescriptor.changed ||\n            fileDescriptor.meta.hashOfConfig !== hashOfConfig;\n\n        if (fileDescriptor.notFound) {\n            debug(`File not found on the file system: ${filePath}`);\n            return null;\n        }\n\n        if (changed) {\n            debug(`Cache entry not found or no longer valid: ${filePath}`);\n            return null;\n        }\n\n        // If source is present but null, need to reread the file from the filesystem.\n        if (\n            fileDescriptor.meta.results &&\n            fileDescriptor.meta.results.source === null\n        ) {\n            debug(`Rereading cached result source from filesystem: ${filePath}`);\n            fileDescriptor.meta.results.source = fs.readFileSync(filePath, \"utf-8\");\n        }\n\n        return fileDescriptor.meta.results;\n    }\n\n    /**\n     * Set the cached lint results for a given file path, after removing any\n     * information that will be both unnecessary and difficult to serialize.\n     * Avoids caching results with an \"output\" property (meaning fixes were\n     * applied), to prevent potentially incorrect results if fixes are not\n     * written to disk.\n     * @param {string} filePath The file for which to set lint results.\n     * @param {ConfigArray} config The config of the file.\n     * @param {Object} result The lint result to be set for the file.\n     * @returns {void}\n     */\n    setCachedLintResults(filePath, config, result) {\n        if (result && Object.prototype.hasOwnProperty.call(result, \"output\")) {\n            return;\n        }\n\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n\n        if (fileDescriptor && !fileDescriptor.notFound) {\n            debug(`Updating cached result: ${filePath}`);\n\n            // Serialize the result, except that we want to remove the file source if present.\n            const resultToSerialize = Object.assign({}, result);\n\n            /*\n             * Set result.source to null.\n             * In `getCachedLintResults`, if source is explicitly null, we will\n             * read the file from the filesystem to set the value again.\n             */\n            if (Object.prototype.hasOwnProperty.call(resultToSerialize, \"source\")) {\n                resultToSerialize.source = null;\n            }\n\n            fileDescriptor.meta.results = resultToSerialize;\n            fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);\n        }\n    }\n\n    /**\n     * Persists the in-memory cache to disk.\n     * @returns {void}\n     */\n    reconcile() {\n        debug(`Persisting cached results: ${this.cacheFileLocation}`);\n        this.fileEntryCache.reconcile();\n    }\n}\n\nmodule.exports = LintResultCache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}