{"ast":null,"code":"/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst OPTIONS = {\n  always: \"always\",\n  never: \"never\",\n  methods: \"methods\",\n  properties: \"properties\",\n  consistent: \"consistent\",\n  consistentAsNeeded: \"consistent-as-needed\"\n}; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow method and property shorthand syntax for object literals\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-shorthand\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\"]\n        }, {\n          type: \"object\",\n          properties: {\n            avoidQuotes: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\"]\n        }, {\n          type: \"object\",\n          properties: {\n            ignoreConstructors: {\n              type: \"boolean\"\n            },\n            avoidQuotes: {\n              type: \"boolean\"\n            },\n            avoidExplicitReturnArrows: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      expectedAllPropertiesShorthanded: \"Expected shorthand for all properties.\",\n      expectedLiteralMethodLongform: \"Expected longform method syntax for string literal keys.\",\n      expectedPropertyShorthand: \"Expected property shorthand.\",\n      expectedPropertyLongform: \"Expected longform property syntax.\",\n      expectedMethodShorthand: \"Expected method shorthand.\",\n      expectedMethodLongform: \"Expected longform method syntax.\",\n      unexpectedMix: \"Unexpected mix of shorthand and non-shorthand properties.\"\n    }\n  },\n\n  create(context) {\n    const APPLY = context.options[0] || OPTIONS.always;\n    const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n    const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n    const APPLY_NEVER = APPLY === OPTIONS.never;\n    const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n    const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n    const PARAMS = context.options[1] || {};\n    const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n    const AVOID_QUOTES = PARAMS.avoidQuotes;\n    const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const CTOR_PREFIX_REGEX = /[^_$0-9]/u;\n    /**\n     * Determines if the first character of the name is a capital letter.\n     * @param {string} name The name of the node to evaluate.\n     * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n     * @private\n     */\n\n    function isConstructor(name) {\n      const match = CTOR_PREFIX_REGEX.exec(name); // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'\n\n      if (!match) {\n        return false;\n      }\n\n      const firstChar = name.charAt(match.index);\n      return firstChar === firstChar.toUpperCase();\n    }\n    /**\n     * Determines if the property can have a shorthand form.\n     * @param {ASTNode} property Property AST node\n     * @returns {boolean} True if the property can have a shorthand form\n     * @private\n     *\n     */\n\n\n    function canHaveShorthand(property) {\n      return property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\";\n    }\n    /**\n     * Checks whether a node is a string literal.\n     * @param   {ASTNode} node Any AST node.\n     * @returns {boolean} `true` if it is a string literal.\n     */\n\n\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n    /**\n     * Determines if the property is a shorthand or not.\n     * @param {ASTNode} property Property AST node\n     * @returns {boolean} True if the property is considered shorthand, false if not.\n     * @private\n     *\n     */\n\n\n    function isShorthand(property) {\n      // property.method is true when `{a(){}}`.\n      return property.shorthand || property.method;\n    }\n    /**\n     * Determines if the property's key and method or value are named equally.\n     * @param {ASTNode} property Property AST node\n     * @returns {boolean} True if the key and value are named equally, false if not.\n     * @private\n     *\n     */\n\n\n    function isRedundant(property) {\n      const value = property.value;\n\n      if (value.type === \"FunctionExpression\") {\n        return !value.id; // Only anonymous should be shorthand method.\n      }\n\n      if (value.type === \"Identifier\") {\n        return astUtils.getStaticPropertyName(property) === value.name;\n      }\n\n      return false;\n    }\n    /**\n     * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n     * @param   {ASTNode} node Property AST node\n     * @param   {boolean} checkRedundancy Whether to check longform redundancy\n     * @returns {void}\n     *\n     */\n\n\n    function checkConsistency(node, checkRedundancy) {\n      // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n      const properties = node.properties.filter(canHaveShorthand); // Do we still have properties left after filtering the getters and setters?\n\n      if (properties.length > 0) {\n        const shorthandProperties = properties.filter(isShorthand);\n        /*\n         * If we do not have an equal number of longform properties as\n         * shorthand properties, we are using the annotations inconsistently\n         */\n\n        if (shorthandProperties.length !== properties.length) {\n          // We have at least 1 shorthand property\n          if (shorthandProperties.length > 0) {\n            context.report({\n              node,\n              messageId: \"unexpectedMix\"\n            });\n          } else if (checkRedundancy) {\n            /*\n             * If all properties of the object contain a method or value with a name matching it's key,\n             * all the keys are redundant.\n             */\n            const canAlwaysUseShorthand = properties.every(isRedundant);\n\n            if (canAlwaysUseShorthand) {\n              context.report({\n                node,\n                messageId: \"expectedAllPropertiesShorthanded\"\n              });\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Fixes a FunctionExpression node by making it into a shorthand property.\n     * @param {SourceCodeFixer} fixer The fixer object\n     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n     * @returns {Object} A fix for this node\n     */\n\n\n    function makeFunctionShorthand(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let keyPrefix = \"\"; // key: /* */ () => {}\n\n      if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n        return null;\n      }\n\n      if (node.value.async) {\n        keyPrefix += \"async \";\n      }\n\n      if (node.value.generator) {\n        keyPrefix += \"*\";\n      }\n\n      const fixRange = [firstKeyToken.range[0], node.range[1]];\n      const methodPrefix = keyPrefix + keyText;\n\n      if (node.value.type === \"FunctionExpression\") {\n        const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n        const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n        return fixer.replaceTextRange(fixRange, methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1]));\n      }\n\n      const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\n      const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\n      let shouldAddParensAroundParameters = false;\n      let tokenBeforeParams;\n\n      if (node.value.params.length === 0) {\n        tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\n      } else {\n        tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\n      }\n\n      if (node.value.params.length === 1) {\n        const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\n        const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\n        shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\n      }\n\n      const sliceStart = shouldAddParensAroundParameters ? node.value.params[0].range[0] : tokenBeforeParams.range[0];\n      const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\n      const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\n      const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\n      return fixer.replaceTextRange(fixRange, methodPrefix + newParamText + fnBody);\n    }\n    /**\n     * Fixes a FunctionExpression node by making it into a longform property.\n     * @param {SourceCodeFixer} fixer The fixer object\n     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n     * @returns {Object} A fix for this node\n     */\n\n\n    function makeFunctionLongform(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let functionHeader = \"function\";\n\n      if (node.value.async) {\n        functionHeader = `async ${functionHeader}`;\n      }\n\n      if (node.value.generator) {\n        functionHeader = `${functionHeader}*`;\n      }\n\n      return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n    }\n    /*\n     * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n     * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n     * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n     * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n     * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n     * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n     * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n     * because converting it into a method would change the value of one of the lexical identifiers.\n     */\n\n\n    const lexicalScopeStack = [];\n    const arrowsWithLexicalIdentifiers = new WeakSet();\n    const argumentsIdentifiers = new WeakSet();\n    /**\n     * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n     * Also, this marks all `arguments` identifiers so that they can be detected later.\n     * @returns {void}\n     */\n\n    function enterFunction() {\n      lexicalScopeStack.unshift(new Set());\n      context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n        variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n      });\n    }\n    /**\n     * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n     * @returns {void}\n     */\n\n\n    function exitFunction() {\n      lexicalScopeStack.shift();\n    }\n    /**\n     * Marks the current function as having a lexical keyword. This implies that all arrow functions\n     * in the current lexical scope contain a reference to this lexical keyword.\n     * @returns {void}\n     */\n\n\n    function reportLexicalIdentifier() {\n      lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: enterFunction,\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      \"Program:exit\": exitFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      \"FunctionExpression:exit\": exitFunction,\n\n      ArrowFunctionExpression(node) {\n        lexicalScopeStack[0].add(node);\n      },\n\n      \"ArrowFunctionExpression:exit\"(node) {\n        lexicalScopeStack[0].delete(node);\n      },\n\n      ThisExpression: reportLexicalIdentifier,\n      Super: reportLexicalIdentifier,\n\n      MetaProperty(node) {\n        if (node.meta.name === \"new\" && node.property.name === \"target\") {\n          reportLexicalIdentifier();\n        }\n      },\n\n      Identifier(node) {\n        if (argumentsIdentifiers.has(node)) {\n          reportLexicalIdentifier();\n        }\n      },\n\n      ObjectExpression(node) {\n        if (APPLY_CONSISTENT) {\n          checkConsistency(node, false);\n        } else if (APPLY_CONSISTENT_AS_NEEDED) {\n          checkConsistency(node, true);\n        }\n      },\n\n      \"Property:exit\"(node) {\n        const isConciseProperty = node.method || node.shorthand; // Ignore destructuring assignment\n\n        if (node.parent.type === \"ObjectPattern\") {\n          return;\n        } // getters and setters are ignored\n\n\n        if (node.kind === \"get\" || node.kind === \"set\") {\n          return;\n        } // only computed methods can fail the following checks\n\n\n        if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n          return;\n        } //--------------------------------------------------------------\n        // Checks for property/method shorthand.\n\n\n        if (isConciseProperty) {\n          if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n            const messageId = APPLY_NEVER ? \"expectedMethodLongform\" : \"expectedLiteralMethodLongform\"; // { x() {} } should be written as { x: function() {} }\n\n            context.report({\n              node,\n              messageId,\n              fix: fixer => makeFunctionLongform(fixer, node)\n            });\n          } else if (APPLY_NEVER) {\n            // { x } should be written as { x: x }\n            context.report({\n              node,\n              messageId: \"expectedPropertyLongform\",\n              fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n            });\n          }\n        } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n          if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n            return;\n          }\n\n          if (AVOID_QUOTES && isStringLiteral(node.key)) {\n            return;\n          } // {[x]: function(){}} should be written as {[x]() {}}\n\n\n          if (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\" && node.value.body.type === \"BlockStatement\" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {\n            context.report({\n              node,\n              messageId: \"expectedMethodShorthand\",\n              fix: fixer => makeFunctionShorthand(fixer, node)\n            });\n          }\n        } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n          // {x: x} should be written as {x}\n          context.report({\n            node,\n            messageId: \"expectedPropertyShorthand\",\n\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n\n          });\n        } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n          if (AVOID_QUOTES) {\n            return;\n          } // {\"x\": x} should be written as {x}\n\n\n          context.report({\n            node,\n            messageId: \"expectedPropertyShorthand\",\n\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["OPTIONS","always","never","methods","properties","consistent","consistentAsNeeded","astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","anyOf","items","enum","minItems","maxItems","avoidQuotes","additionalProperties","ignoreConstructors","avoidExplicitReturnArrows","messages","expectedAllPropertiesShorthanded","expectedLiteralMethodLongform","expectedPropertyShorthand","expectedPropertyLongform","expectedMethodShorthand","expectedMethodLongform","unexpectedMix","create","context","APPLY","options","APPLY_TO_METHODS","APPLY_TO_PROPS","APPLY_NEVER","APPLY_CONSISTENT","APPLY_CONSISTENT_AS_NEEDED","PARAMS","IGNORE_CONSTRUCTORS","AVOID_QUOTES","AVOID_EXPLICIT_RETURN_ARROWS","sourceCode","getSourceCode","CTOR_PREFIX_REGEX","isConstructor","name","match","exec","firstChar","charAt","index","toUpperCase","canHaveShorthand","property","kind","isStringLiteral","node","value","isShorthand","shorthand","method","isRedundant","id","getStaticPropertyName","checkConsistency","checkRedundancy","filter","length","shorthandProperties","report","messageId","canAlwaysUseShorthand","every","makeFunctionShorthand","fixer","firstKeyToken","computed","getFirstToken","isOpeningBracketToken","key","lastKeyToken","getFirstTokenBetween","isClosingBracketToken","getLastToken","keyText","text","slice","range","keyPrefix","commentsExistBetween","async","generator","fixRange","methodPrefix","functionToken","getTokens","find","token","tokenBeforeParams","getTokenAfter","replaceTextRange","arrowToken","getTokenBefore","body","isArrowToken","fnBody","shouldAddParensAroundParameters","params","isOpeningParenToken","hasParen","isTokenOutsideNode","sliceStart","sliceEnd","oldParamText","newParamText","makeFunctionLongform","getTokensBetween","functionHeader","lexicalScopeStack","arrowsWithLexicalIdentifiers","WeakSet","argumentsIdentifiers","enterFunction","unshift","Set","getScope","variables","variable","forEach","references","map","ref","identifier","add","exitFunction","shift","reportLexicalIdentifier","arrowFunction","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","delete","ThisExpression","Super","MetaProperty","Identifier","has","ObjectExpression","isConciseProperty","parent","fix","insertTextAfter","replaceText"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/object-shorthand.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst OPTIONS = {\n    always: \"always\",\n    never: \"never\",\n    methods: \"methods\",\n    properties: \"properties\",\n    consistent: \"consistent\",\n    consistentAsNeeded: \"consistent-as-needed\"\n};\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow method and property shorthand syntax for object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-shorthand\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreConstructors: {\n                                    type: \"boolean\"\n                                },\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                },\n                                avoidExplicitReturnArrows: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            expectedAllPropertiesShorthanded: \"Expected shorthand for all properties.\",\n            expectedLiteralMethodLongform: \"Expected longform method syntax for string literal keys.\",\n            expectedPropertyShorthand: \"Expected property shorthand.\",\n            expectedPropertyLongform: \"Expected longform property syntax.\",\n            expectedMethodShorthand: \"Expected method shorthand.\",\n            expectedMethodLongform: \"Expected longform method syntax.\",\n            unexpectedMix: \"Unexpected mix of shorthand and non-shorthand properties.\"\n        }\n    },\n\n    create(context) {\n        const APPLY = context.options[0] || OPTIONS.always;\n        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n        const APPLY_NEVER = APPLY === OPTIONS.never;\n        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n\n        const PARAMS = context.options[1] || {};\n        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n        const AVOID_QUOTES = PARAMS.avoidQuotes;\n        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const CTOR_PREFIX_REGEX = /[^_$0-9]/u;\n\n        /**\n         * Determines if the first character of the name is a capital letter.\n         * @param {string} name The name of the node to evaluate.\n         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n         * @private\n         */\n        function isConstructor(name) {\n            const match = CTOR_PREFIX_REGEX.exec(name);\n\n            // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'\n            if (!match) {\n                return false;\n            }\n\n            const firstChar = name.charAt(match.index);\n\n            return firstChar === firstChar.toUpperCase();\n        }\n\n        /**\n         * Determines if the property can have a shorthand form.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property can have a shorthand form\n         * @private\n         *\n         */\n        function canHaveShorthand(property) {\n            return (property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\");\n        }\n\n        /**\n         * Checks whether a node is a string literal.\n         * @param   {ASTNode} node Any AST node.\n         * @returns {boolean} `true` if it is a string literal.\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Determines if the property is a shorthand or not.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property is considered shorthand, false if not.\n         * @private\n         *\n         */\n        function isShorthand(property) {\n\n            // property.method is true when `{a(){}}`.\n            return (property.shorthand || property.method);\n        }\n\n        /**\n         * Determines if the property's key and method or value are named equally.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the key and value are named equally, false if not.\n         * @private\n         *\n         */\n        function isRedundant(property) {\n            const value = property.value;\n\n            if (value.type === \"FunctionExpression\") {\n                return !value.id; // Only anonymous should be shorthand method.\n            }\n            if (value.type === \"Identifier\") {\n                return astUtils.getStaticPropertyName(property) === value.name;\n            }\n\n            return false;\n        }\n\n        /**\n         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkRedundancy Whether to check longform redundancy\n         * @returns {void}\n         *\n         */\n        function checkConsistency(node, checkRedundancy) {\n\n            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n            const properties = node.properties.filter(canHaveShorthand);\n\n            // Do we still have properties left after filtering the getters and setters?\n            if (properties.length > 0) {\n                const shorthandProperties = properties.filter(isShorthand);\n\n                /*\n                 * If we do not have an equal number of longform properties as\n                 * shorthand properties, we are using the annotations inconsistently\n                 */\n                if (shorthandProperties.length !== properties.length) {\n\n                    // We have at least 1 shorthand property\n                    if (shorthandProperties.length > 0) {\n                        context.report({ node, messageId: \"unexpectedMix\" });\n                    } else if (checkRedundancy) {\n\n                        /*\n                         * If all properties of the object contain a method or value with a name matching it's key,\n                         * all the keys are redundant.\n                         */\n                        const canAlwaysUseShorthand = properties.every(isRedundant);\n\n                        if (canAlwaysUseShorthand) {\n                            context.report({ node, messageId: \"expectedAllPropertiesShorthanded\" });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a shorthand property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionShorthand(fixer, node) {\n            const firstKeyToken = node.computed\n                ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken)\n                : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed\n                ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken)\n                : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let keyPrefix = \"\";\n\n            // key: /* */ () => {}\n            if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n                return null;\n            }\n\n            if (node.value.async) {\n                keyPrefix += \"async \";\n            }\n            if (node.value.generator) {\n                keyPrefix += \"*\";\n            }\n\n            const fixRange = [firstKeyToken.range[0], node.range[1]];\n            const methodPrefix = keyPrefix + keyText;\n\n            if (node.value.type === \"FunctionExpression\") {\n                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n\n                return fixer.replaceTextRange(\n                    fixRange,\n                    methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])\n                );\n            }\n\n            const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\n            const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\n\n            let shouldAddParensAroundParameters = false;\n            let tokenBeforeParams;\n\n            if (node.value.params.length === 0) {\n                tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\n            } else {\n                tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\n            }\n\n            if (node.value.params.length === 1) {\n                const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\n                const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\n\n                shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\n            }\n\n            const sliceStart = shouldAddParensAroundParameters\n                ? node.value.params[0].range[0]\n                : tokenBeforeParams.range[0];\n            const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\n\n            const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\n            const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\n\n            return fixer.replaceTextRange(\n                fixRange,\n                methodPrefix + newParamText + fnBody\n            );\n\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a longform property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionLongform(fixer, node) {\n            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let functionHeader = \"function\";\n\n            if (node.value.async) {\n                functionHeader = `async ${functionHeader}`;\n            }\n            if (node.value.generator) {\n                functionHeader = `${functionHeader}*`;\n            }\n\n            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n        }\n\n        /*\n         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n         * because converting it into a method would change the value of one of the lexical identifiers.\n         */\n        const lexicalScopeStack = [];\n        const arrowsWithLexicalIdentifiers = new WeakSet();\n        const argumentsIdentifiers = new WeakSet();\n\n        /**\n         * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n         * Also, this marks all `arguments` identifiers so that they can be detected later.\n         * @returns {void}\n         */\n        function enterFunction() {\n            lexicalScopeStack.unshift(new Set());\n            context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n            });\n        }\n\n        /**\n         * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            lexicalScopeStack.shift();\n        }\n\n        /**\n         * Marks the current function as having a lexical keyword. This implies that all arrow functions\n         * in the current lexical scope contain a reference to this lexical keyword.\n         * @returns {void}\n         */\n        function reportLexicalIdentifier() {\n            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: enterFunction,\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            \"Program:exit\": exitFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            ArrowFunctionExpression(node) {\n                lexicalScopeStack[0].add(node);\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                lexicalScopeStack[0].delete(node);\n            },\n\n            ThisExpression: reportLexicalIdentifier,\n            Super: reportLexicalIdentifier,\n            MetaProperty(node) {\n                if (node.meta.name === \"new\" && node.property.name === \"target\") {\n                    reportLexicalIdentifier();\n                }\n            },\n            Identifier(node) {\n                if (argumentsIdentifiers.has(node)) {\n                    reportLexicalIdentifier();\n                }\n            },\n\n            ObjectExpression(node) {\n                if (APPLY_CONSISTENT) {\n                    checkConsistency(node, false);\n                } else if (APPLY_CONSISTENT_AS_NEEDED) {\n                    checkConsistency(node, true);\n                }\n            },\n\n            \"Property:exit\"(node) {\n                const isConciseProperty = node.method || node.shorthand;\n\n                // Ignore destructuring assignment\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                // getters and setters are ignored\n                if (node.kind === \"get\" || node.kind === \"set\") {\n                    return;\n                }\n\n                // only computed methods can fail the following checks\n                if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                //--------------------------------------------------------------\n                // Checks for property/method shorthand.\n                if (isConciseProperty) {\n                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n                        const messageId = APPLY_NEVER ? \"expectedMethodLongform\" : \"expectedLiteralMethodLongform\";\n\n                        // { x() {} } should be written as { x: function() {} }\n                        context.report({\n                            node,\n                            messageId,\n                            fix: fixer => makeFunctionLongform(fixer, node)\n                        });\n                    } else if (APPLY_NEVER) {\n\n                        // { x } should be written as { x: x }\n                        context.report({\n                            node,\n                            messageId: \"expectedPropertyLongform\",\n                            fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n                        });\n                    }\n                } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n                    if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n                        return;\n                    }\n                    if (AVOID_QUOTES && isStringLiteral(node.key)) {\n                        return;\n                    }\n\n                    // {[x]: function(){}} should be written as {[x]() {}}\n                    if (node.value.type === \"FunctionExpression\" ||\n                        node.value.type === \"ArrowFunctionExpression\" &&\n                        node.value.body.type === \"BlockStatement\" &&\n                        AVOID_EXPLICIT_RETURN_ARROWS &&\n                        !arrowsWithLexicalIdentifiers.has(node.value)\n                    ) {\n                        context.report({\n                            node,\n                            messageId: \"expectedMethodShorthand\",\n                            fix: fixer => makeFunctionShorthand(fixer, node)\n                        });\n                    }\n                } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n\n                    // {x: x} should be written as {x}\n                    context.report({\n                        node,\n                        messageId: \"expectedPropertyShorthand\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n                    if (AVOID_QUOTES) {\n                        return;\n                    }\n\n                    // {\"x\": x} should be written as {x}\n                    context.report({\n                        node,\n                        messageId: \"expectedPropertyShorthand\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}