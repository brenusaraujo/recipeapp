{"ast":null,"code":"/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n      FixTracker = require(\"./utils/fix-tracker\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\n\n\nfunction remove(array, element) {\n  const index = array.indexOf(element);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removable.\n */\n\n\nfunction isRemovable(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\n\n\nfunction isInFinally(node) {\n  for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {\n    if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n      return true;\n    }\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow redundant return statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-return\"\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      unnecessaryReturn: \"Unnecessary return statement.\"\n    }\n  },\n\n  create(context) {\n    const segmentInfoMap = new WeakMap();\n    const usedUnreachableSegments = new WeakSet();\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n    /**\n     * Checks whether the given segment is terminated by a return statement or not.\n     * @param {CodePathSegment} segment The segment to check.\n     * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n     */\n\n    function isReturned(segment) {\n      const info = segmentInfoMap.get(segment);\n      return !info || info.returned;\n    }\n    /**\n     * Collects useless return statements from the given previous segments.\n     *\n     * A previous segment may be an unreachable segment.\n     * In that case, the information object of the unreachable segment is not\n     * initialized because `onCodePathSegmentStart` event is not notified for\n     * unreachable segments.\n     * This goes to the previous segments of the unreachable segment recursively\n     * if the unreachable segment was generated by a return statement. Otherwise,\n     * this ignores the unreachable segment.\n     *\n     * This behavior would simulate code paths for the case that the return\n     * statement does not exist.\n     * @param {ASTNode[]} uselessReturns The collected return statements.\n     * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n     * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n     * @returns {ASTNode[]} `uselessReturns`.\n     */\n\n\n    function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n      const traversedSegments = providedTraversedSegments || new WeakSet();\n\n      for (const segment of prevSegments) {\n        if (!segment.reachable) {\n          if (!traversedSegments.has(segment)) {\n            traversedSegments.add(segment);\n            getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);\n          }\n\n          continue;\n        }\n\n        uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n      }\n\n      return uselessReturns;\n    }\n    /**\n     * Removes the return statements on the given segment from the useless return\n     * statement list.\n     *\n     * This segment may be an unreachable segment.\n     * In that case, the information object of the unreachable segment is not\n     * initialized because `onCodePathSegmentStart` event is not notified for\n     * unreachable segments.\n     * This goes to the previous segments of the unreachable segment recursively\n     * if the unreachable segment was generated by a return statement. Otherwise,\n     * this ignores the unreachable segment.\n     *\n     * This behavior would simulate code paths for the case that the return\n     * statement does not exist.\n     * @param {CodePathSegment} segment The segment to get return statements.\n     * @returns {void}\n     */\n\n\n    function markReturnStatementsOnSegmentAsUsed(segment) {\n      if (!segment.reachable) {\n        usedUnreachableSegments.add(segment);\n        segment.allPrevSegments.filter(isReturned).filter(prevSegment => !usedUnreachableSegments.has(prevSegment)).forEach(markReturnStatementsOnSegmentAsUsed);\n        return;\n      }\n\n      const info = segmentInfoMap.get(segment);\n\n      for (const node of info.uselessReturns) {\n        remove(scopeInfo.uselessReturns, node);\n      }\n\n      info.uselessReturns = [];\n    }\n    /**\n     * Removes the return statements on the current segments from the useless\n     * return statement list.\n     *\n     * This function will be called at every statement except FunctionDeclaration,\n     * BlockStatement, and BreakStatement.\n     *\n     * - FunctionDeclarations are always executed whether it's returned or not.\n     * - BlockStatements do nothing.\n     * - BreakStatements go the next merely.\n     * @returns {void}\n     */\n\n\n    function markReturnStatementsOnCurrentSegmentsAsUsed() {\n      scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      // Makes and pushs a new scope information.\n      onCodePathStart(codePath) {\n        scopeInfo = {\n          upper: scopeInfo,\n          uselessReturns: [],\n          codePath\n        };\n      },\n\n      // Reports useless return statements if exist.\n      onCodePathEnd() {\n        for (const node of scopeInfo.uselessReturns) {\n          context.report({\n            node,\n            loc: node.loc,\n            messageId: \"unnecessaryReturn\",\n\n            fix(fixer) {\n              if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n                /*\n                 * Extend the replacement range to include the\n                 * entire function to avoid conflicting with\n                 * no-else-return.\n                 * https://github.com/eslint/eslint/issues/8026\n                 */\n                return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);\n              }\n\n              return null;\n            }\n\n          });\n        }\n\n        scopeInfo = scopeInfo.upper;\n      },\n\n      /*\n       * Initializes segments.\n       * NOTE: This event is notified for only reachable segments.\n       */\n      onCodePathSegmentStart(segment) {\n        const info = {\n          uselessReturns: getUselessReturns([], segment.allPrevSegments),\n          returned: false\n        }; // Stores the info.\n\n        segmentInfoMap.set(segment, info);\n      },\n\n      // Adds ReturnStatement node to check whether it's useless or not.\n      ReturnStatement(node) {\n        if (node.argument) {\n          markReturnStatementsOnCurrentSegmentsAsUsed();\n        }\n\n        if (node.argument || astUtils.isInLoop(node) || isInFinally(node) || // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n        !scopeInfo.codePath.currentSegments.some(s => s.reachable)) {\n          return;\n        }\n\n        for (const segment of scopeInfo.codePath.currentSegments) {\n          const info = segmentInfoMap.get(segment);\n\n          if (info) {\n            info.uselessReturns.push(node);\n            info.returned = true;\n          }\n        }\n\n        scopeInfo.uselessReturns.push(node);\n      },\n\n      /*\n       * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n       * Removes return statements of the current segments from the useless return statement list.\n       */\n      ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","FixTracker","remove","array","element","index","indexOf","splice","isRemovable","node","STATEMENT_LIST_PARENTS","has","parent","type","isInFinally","currentNode","isFunction","finalizer","module","exports","meta","docs","description","category","recommended","url","fixable","schema","messages","unnecessaryReturn","create","context","segmentInfoMap","WeakMap","usedUnreachableSegments","WeakSet","sourceCode","getSourceCode","scopeInfo","isReturned","segment","info","get","returned","getUselessReturns","uselessReturns","prevSegments","providedTraversedSegments","traversedSegments","reachable","add","allPrevSegments","filter","push","markReturnStatementsOnSegmentAsUsed","prevSegment","forEach","markReturnStatementsOnCurrentSegmentsAsUsed","codePath","currentSegments","onCodePathStart","upper","onCodePathEnd","report","loc","messageId","fix","fixer","getCommentsInside","length","retainEnclosingFunction","onCodePathSegmentStart","set","ReturnStatement","argument","isInLoop","some","s","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","EmptyStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/eslint/lib/rules/no-useless-return.js"],"sourcesContent":["/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n\n    if (index !== -1) {\n        array.splice(index, 1);\n    }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removable.\n */\nfunction isRemovable(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n    for (\n        let currentNode = node;\n        currentNode && currentNode.parent && !astUtils.isFunction(currentNode);\n        currentNode = currentNode.parent\n    ) {\n        if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow redundant return statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-return\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n\n        messages: {\n            unnecessaryReturn: \"Unnecessary return statement.\"\n        }\n    },\n\n    create(context) {\n        const segmentInfoMap = new WeakMap();\n        const usedUnreachableSegments = new WeakSet();\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Checks whether the given segment is terminated by a return statement or not.\n         * @param {CodePathSegment} segment The segment to check.\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n         */\n        function isReturned(segment) {\n            const info = segmentInfoMap.get(segment);\n\n            return !info || info.returned;\n        }\n\n        /**\n         * Collects useless return statements from the given previous segments.\n         *\n         * A previous segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {ASTNode[]} uselessReturns The collected return statements.\n         * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n         * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n         * @returns {ASTNode[]} `uselessReturns`.\n         */\n        function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n            const traversedSegments = providedTraversedSegments || new WeakSet();\n\n            for (const segment of prevSegments) {\n                if (!segment.reachable) {\n                    if (!traversedSegments.has(segment)) {\n                        traversedSegments.add(segment);\n                        getUselessReturns(\n                            uselessReturns,\n                            segment.allPrevSegments.filter(isReturned),\n                            traversedSegments\n                        );\n                    }\n                    continue;\n                }\n\n                uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n            }\n\n            return uselessReturns;\n        }\n\n        /**\n         * Removes the return statements on the given segment from the useless return\n         * statement list.\n         *\n         * This segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {CodePathSegment} segment The segment to get return statements.\n         * @returns {void}\n         */\n        function markReturnStatementsOnSegmentAsUsed(segment) {\n            if (!segment.reachable) {\n                usedUnreachableSegments.add(segment);\n                segment.allPrevSegments\n                    .filter(isReturned)\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\n                    .forEach(markReturnStatementsOnSegmentAsUsed);\n                return;\n            }\n\n            const info = segmentInfoMap.get(segment);\n\n            for (const node of info.uselessReturns) {\n                remove(scopeInfo.uselessReturns, node);\n            }\n            info.uselessReturns = [];\n        }\n\n        /**\n         * Removes the return statements on the current segments from the useless\n         * return statement list.\n         *\n         * This function will be called at every statement except FunctionDeclaration,\n         * BlockStatement, and BreakStatement.\n         *\n         * - FunctionDeclarations are always executed whether it's returned or not.\n         * - BlockStatements do nothing.\n         * - BreakStatements go the next merely.\n         * @returns {void}\n         */\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\n            scopeInfo\n                .codePath\n                .currentSegments\n                .forEach(markReturnStatementsOnSegmentAsUsed);\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Makes and pushs a new scope information.\n            onCodePathStart(codePath) {\n                scopeInfo = {\n                    upper: scopeInfo,\n                    uselessReturns: [],\n                    codePath\n                };\n            },\n\n            // Reports useless return statements if exist.\n            onCodePathEnd() {\n                for (const node of scopeInfo.uselessReturns) {\n                    context.report({\n                        node,\n                        loc: node.loc,\n                        messageId: \"unnecessaryReturn\",\n                        fix(fixer) {\n                            if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n\n                                /*\n                                 * Extend the replacement range to include the\n                                 * entire function to avoid conflicting with\n                                 * no-else-return.\n                                 * https://github.com/eslint/eslint/issues/8026\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainEnclosingFunction(node)\n                                    .remove(node);\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            /*\n             * Initializes segments.\n             * NOTE: This event is notified for only reachable segments.\n             */\n            onCodePathSegmentStart(segment) {\n                const info = {\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\n                    returned: false\n                };\n\n                // Stores the info.\n                segmentInfoMap.set(segment, info);\n            },\n\n            // Adds ReturnStatement node to check whether it's useless or not.\n            ReturnStatement(node) {\n                if (node.argument) {\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\n                }\n                if (\n                    node.argument ||\n                    astUtils.isInLoop(node) ||\n                    isInFinally(node) ||\n\n                    // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n                    !scopeInfo.codePath.currentSegments.some(s => s.reachable)\n                ) {\n                    return;\n                }\n\n                for (const segment of scopeInfo.codePath.currentSegments) {\n                    const info = segmentInfoMap.get(segment);\n\n                    if (info) {\n                        info.uselessReturns.push(node);\n                        info.returned = true;\n                    }\n                }\n                scopeInfo.uselessReturns.push(node);\n            },\n\n            /*\n             * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n             * Removes return statements of the current segments from the useless return statement list.\n             */\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}