{"ast":null,"code":"/**\n * @fileoverview `ConfigArray` class.\n *\n * `ConfigArray` class expresses the full of a configuration. It has the entry\n * config file, base config files that were extended, loaded parsers, and loaded\n * plugins.\n *\n * `ConfigArray` class provides three properties and two methods.\n *\n * - `pluginEnvironments`\n * - `pluginProcessors`\n * - `pluginRules`\n *      The `Map` objects that contain the members of all plugins that this\n *      config array contains. Those map objects don't have mutation methods.\n *      Those keys are the member ID such as `pluginId/memberName`.\n * - `isRoot()`\n *      If `true` then this configuration has `root:true` property.\n * - `extractConfig(filePath)`\n *      Extract the final configuration for a given file. This means merging\n *      every config array element which that `criteria` property matched. The\n *      `filePath` argument must be an absolute path.\n *\n * `ConfigArrayFactory` provides the loading logic of config files.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n  ExtractedConfig\n} = require(\"./extracted-config\");\n\nconst {\n  IgnorePattern\n} = require(\"./ignore-pattern\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n// Define types for VSCode IntelliSense.\n\n/** @typedef {import(\"../../shared/types\").Environment} Environment */\n\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n\n/** @typedef {import(\"../../shared/types\").RuleConf} RuleConf */\n\n/** @typedef {import(\"../../shared/types\").Rule} Rule */\n\n/** @typedef {import(\"../../shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"../../shared/types\").Processor} Processor */\n\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n\n/** @typedef {import(\"./override-tester\")[\"OverrideTester\"]} OverrideTester */\n\n/**\n * @typedef {Object} ConfigArrayElement\n * @property {string} name The name of this config element.\n * @property {string} filePath The path to the source file of this config element.\n * @property {InstanceType<OverrideTester>|null} criteria The tester for the `files` and `excludedFiles` of this config element.\n * @property {Record<string, boolean>|undefined} env The environment settings.\n * @property {Record<string, GlobalConf>|undefined} globals The global variable settings.\n * @property {IgnorePattern|undefined} ignorePattern The ignore patterns.\n * @property {boolean|undefined} noInlineConfig The flag that disables directive comments.\n * @property {DependentParser|undefined} parser The parser loader.\n * @property {Object|undefined} parserOptions The parser options.\n * @property {Record<string, DependentPlugin>|undefined} plugins The plugin loaders.\n * @property {string|undefined} processor The processor name to refer plugin's processor.\n * @property {boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.\n * @property {boolean|undefined} root The flag to express root.\n * @property {Record<string, RuleConf>|undefined} rules The rule settings\n * @property {Object|undefined} settings The shared settings.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The element type.\n */\n\n/**\n * @typedef {Object} ConfigArrayInternalSlots\n * @property {Map<string, ExtractedConfig>} cache The cache to extract configs.\n * @property {ReadonlyMap<string, Environment>|null} envMap The map from environment ID to environment definition.\n * @property {ReadonlyMap<string, Processor>|null} processorMap The map from processor ID to environment definition.\n * @property {ReadonlyMap<string, Rule>|null} ruleMap The map from rule ID to rule definition.\n */\n\n/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>} */\n\n\nconst internalSlotsMap = new class extends WeakMap {\n  get(key) {\n    let value = super.get(key);\n\n    if (!value) {\n      value = {\n        cache: new Map(),\n        envMap: null,\n        processorMap: null,\n        ruleMap: null\n      };\n      super.set(key, value);\n    }\n\n    return value;\n  }\n\n}();\n/**\n * Get the indices which are matched to a given file.\n * @param {ConfigArrayElement[]} elements The elements.\n * @param {string} filePath The path to a target file.\n * @returns {number[]} The indices.\n */\n\nfunction getMatchedIndices(elements, filePath) {\n  const indices = [];\n\n  for (let i = elements.length - 1; i >= 0; --i) {\n    const element = elements[i];\n\n    if (!element.criteria || filePath && element.criteria.test(filePath)) {\n      indices.push(i);\n    }\n  }\n\n  return indices;\n}\n/**\n * Check if a value is a non-null object.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\n\n\nfunction isNonNullObject(x) {\n  return typeof x === \"object\" && x !== null;\n}\n/**\n * Merge two objects.\n *\n * Assign every property values of `y` to `x` if `x` doesn't have the property.\n * If `x`'s property value is an object, it does recursive.\n * @param {Object} target The destination to merge\n * @param {Object|undefined} source The source to merge.\n * @returns {void}\n */\n\n\nfunction mergeWithoutOverwrite(target, source) {\n  if (!isNonNullObject(source)) {\n    return;\n  }\n\n  for (const key of Object.keys(source)) {\n    if (key === \"__proto__\") {\n      continue;\n    }\n\n    if (isNonNullObject(target[key])) {\n      mergeWithoutOverwrite(target[key], source[key]);\n    } else if (target[key] === void 0) {\n      if (isNonNullObject(source[key])) {\n        target[key] = Array.isArray(source[key]) ? [] : {};\n        mergeWithoutOverwrite(target[key], source[key]);\n      } else if (source[key] !== void 0) {\n        target[key] = source[key];\n      }\n    }\n  }\n}\n/**\n * The error for plugin conflicts.\n */\n\n\nclass PluginConflictError extends Error {\n  /**\n   * Initialize this error object.\n   * @param {string} pluginId The plugin ID.\n   * @param {{filePath:string, importerName:string}[]} plugins The resolved plugins.\n   */\n  constructor(pluginId, plugins) {\n    super(`Plugin \"${pluginId}\" was conflicted between ${plugins.map(p => `\"${p.importerName}\"`).join(\" and \")}.`);\n    this.messageTemplate = \"plugin-conflict\";\n    this.messageData = {\n      pluginId,\n      plugins\n    };\n  }\n\n}\n/**\n * Merge plugins.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, DependentPlugin>} target The destination to merge\n * @param {Record<string, DependentPlugin>|undefined} source The source to merge.\n * @returns {void}\n */\n\n\nfunction mergePlugins(target, source) {\n  if (!isNonNullObject(source)) {\n    return;\n  }\n\n  for (const key of Object.keys(source)) {\n    if (key === \"__proto__\") {\n      continue;\n    }\n\n    const targetValue = target[key];\n    const sourceValue = source[key]; // Adopt the plugin which was found at first.\n\n    if (targetValue === void 0) {\n      if (sourceValue.error) {\n        throw sourceValue.error;\n      }\n\n      target[key] = sourceValue;\n    } else if (sourceValue.filePath !== targetValue.filePath) {\n      throw new PluginConflictError(key, [{\n        filePath: targetValue.filePath,\n        importerName: targetValue.importerName\n      }, {\n        filePath: sourceValue.filePath,\n        importerName: sourceValue.importerName\n      }]);\n    }\n  }\n}\n/**\n * Merge rule configs.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, Array>} target The destination to merge\n * @param {Record<string, RuleConf>|undefined} source The source to merge.\n * @returns {void}\n */\n\n\nfunction mergeRuleConfigs(target, source) {\n  if (!isNonNullObject(source)) {\n    return;\n  }\n\n  for (const key of Object.keys(source)) {\n    if (key === \"__proto__\") {\n      continue;\n    }\n\n    const targetDef = target[key];\n    const sourceDef = source[key]; // Adopt the rule config which was found at first.\n\n    if (targetDef === void 0) {\n      if (Array.isArray(sourceDef)) {\n        target[key] = [...sourceDef];\n      } else {\n        target[key] = [sourceDef];\n      }\n      /*\n       * If the first found rule config is severity only and the current rule\n       * config has options, merge the severity and the options.\n       */\n\n    } else if (targetDef.length === 1 && Array.isArray(sourceDef) && sourceDef.length >= 2) {\n      targetDef.push(...sourceDef.slice(1));\n    }\n  }\n}\n/**\n * Create the extracted config.\n * @param {ConfigArray} instance The config elements.\n * @param {number[]} indices The indices to use.\n * @returns {ExtractedConfig} The extracted config.\n */\n\n\nfunction createConfig(instance, indices) {\n  const config = new ExtractedConfig();\n  const ignorePatterns = []; // Merge elements.\n\n  for (const index of indices) {\n    const element = instance[index]; // Adopt the parser which was found at first.\n\n    if (!config.parser && element.parser) {\n      if (element.parser.error) {\n        throw element.parser.error;\n      }\n\n      config.parser = element.parser;\n    } // Adopt the processor which was found at first.\n\n\n    if (!config.processor && element.processor) {\n      config.processor = element.processor;\n    } // Adopt the noInlineConfig which was found at first.\n\n\n    if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {\n      config.noInlineConfig = element.noInlineConfig;\n      config.configNameOfNoInlineConfig = element.name;\n    } // Adopt the reportUnusedDisableDirectives which was found at first.\n\n\n    if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {\n      config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;\n    } // Collect ignorePatterns\n\n\n    if (element.ignorePattern) {\n      ignorePatterns.push(element.ignorePattern);\n    } // Merge others.\n\n\n    mergeWithoutOverwrite(config.env, element.env);\n    mergeWithoutOverwrite(config.globals, element.globals);\n    mergeWithoutOverwrite(config.parserOptions, element.parserOptions);\n    mergeWithoutOverwrite(config.settings, element.settings);\n    mergePlugins(config.plugins, element.plugins);\n    mergeRuleConfigs(config.rules, element.rules);\n  } // Create the predicate function for ignore patterns.\n\n\n  if (ignorePatterns.length > 0) {\n    config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());\n  }\n\n  return config;\n}\n/**\n * Collect definitions.\n * @template T, U\n * @param {string} pluginId The plugin ID for prefix.\n * @param {Record<string,T>} defs The definitions to collect.\n * @param {Map<string, U>} map The map to output.\n * @param {function(T): U} [normalize] The normalize function for each value.\n * @returns {void}\n */\n\n\nfunction collect(pluginId, defs, map, normalize) {\n  if (defs) {\n    const prefix = pluginId && `${pluginId}/`;\n\n    for (const [key, value] of Object.entries(defs)) {\n      map.set(`${prefix}${key}`, normalize ? normalize(value) : value);\n    }\n  }\n}\n/**\n * Normalize a rule definition.\n * @param {Function|Rule} rule The rule definition to normalize.\n * @returns {Rule} The normalized rule definition.\n */\n\n\nfunction normalizePluginRule(rule) {\n  return typeof rule === \"function\" ? {\n    create: rule\n  } : rule;\n}\n/**\n * Delete the mutation methods from a given map.\n * @param {Map<any, any>} map The map object to delete.\n * @returns {void}\n */\n\n\nfunction deleteMutationMethods(map) {\n  Object.defineProperties(map, {\n    clear: {\n      configurable: true,\n      value: void 0\n    },\n    delete: {\n      configurable: true,\n      value: void 0\n    },\n    set: {\n      configurable: true,\n      value: void 0\n    }\n  });\n}\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArrayElement[]} elements The config elements.\n * @param {ConfigArrayInternalSlots} slots The internal slots.\n * @returns {void}\n */\n\n\nfunction initPluginMemberMaps(elements, slots) {\n  const processed = new Set();\n  slots.envMap = new Map();\n  slots.processorMap = new Map();\n  slots.ruleMap = new Map();\n\n  for (const element of elements) {\n    if (!element.plugins) {\n      continue;\n    }\n\n    for (const [pluginId, value] of Object.entries(element.plugins)) {\n      const plugin = value.definition;\n\n      if (!plugin || processed.has(pluginId)) {\n        continue;\n      }\n\n      processed.add(pluginId);\n      collect(pluginId, plugin.environments, slots.envMap);\n      collect(pluginId, plugin.processors, slots.processorMap);\n      collect(pluginId, plugin.rules, slots.ruleMap, normalizePluginRule);\n    }\n  }\n\n  deleteMutationMethods(slots.envMap);\n  deleteMutationMethods(slots.processorMap);\n  deleteMutationMethods(slots.ruleMap);\n}\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArray} instance The config elements.\n * @returns {ConfigArrayInternalSlots} The extracted config.\n */\n\n\nfunction ensurePluginMemberMaps(instance) {\n  const slots = internalSlotsMap.get(instance);\n\n  if (!slots.ruleMap) {\n    initPluginMemberMaps(instance, slots);\n  }\n\n  return slots;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The Config Array.\n *\n * `ConfigArray` instance contains all settings, parsers, and plugins.\n * You need to call `ConfigArray#extractConfig(filePath)` method in order to\n * extract, merge and get only the config data which is related to an arbitrary\n * file.\n * @extends {Array<ConfigArrayElement>}\n */\n\n\nclass ConfigArray extends Array {\n  /**\n   * Get the plugin environments.\n   * The returned map cannot be mutated.\n   * @type {ReadonlyMap<string, Environment>} The plugin environments.\n   */\n  get pluginEnvironments() {\n    return ensurePluginMemberMaps(this).envMap;\n  }\n  /**\n   * Get the plugin processors.\n   * The returned map cannot be mutated.\n   * @type {ReadonlyMap<string, Processor>} The plugin processors.\n   */\n\n\n  get pluginProcessors() {\n    return ensurePluginMemberMaps(this).processorMap;\n  }\n  /**\n   * Get the plugin rules.\n   * The returned map cannot be mutated.\n   * @returns {ReadonlyMap<string, Rule>} The plugin rules.\n   */\n\n\n  get pluginRules() {\n    return ensurePluginMemberMaps(this).ruleMap;\n  }\n  /**\n   * Check if this config has `root` flag.\n   * @returns {boolean} `true` if this config array is root.\n   */\n\n\n  isRoot() {\n    for (let i = this.length - 1; i >= 0; --i) {\n      const root = this[i].root;\n\n      if (typeof root === \"boolean\") {\n        return root;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Extract the config data which is related to a given file.\n   * @param {string} filePath The absolute path to the target file.\n   * @returns {ExtractedConfig} The extracted config data.\n   */\n\n\n  extractConfig(filePath) {\n    const {\n      cache\n    } = internalSlotsMap.get(this);\n    const indices = getMatchedIndices(this, filePath);\n    const cacheKey = indices.join(\",\");\n\n    if (!cache.has(cacheKey)) {\n      cache.set(cacheKey, createConfig(this, indices));\n    }\n\n    return cache.get(cacheKey);\n  }\n  /**\n   * Check if a given path is an additional lint target.\n   * @param {string} filePath The absolute path to the target file.\n   * @returns {boolean} `true` if the file is an additional lint target.\n   */\n\n\n  isAdditionalTargetPath(filePath) {\n    for (const {\n      criteria,\n      type\n    } of this) {\n      if (type === \"config\" && criteria && !criteria.endsWithWildcard && criteria.test(filePath)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nconst exportObject = {\n  ConfigArray,\n\n  /**\n   * Get the used extracted configs.\n   * CLIEngine will use this method to collect used deprecated rules.\n   * @param {ConfigArray} instance The config array object to get.\n   * @returns {ExtractedConfig[]} The used extracted configs.\n   * @private\n   */\n  getUsedExtractedConfigs(instance) {\n    const {\n      cache\n    } = internalSlotsMap.get(instance);\n    return Array.from(cache.values());\n  }\n\n};\nmodule.exports = exportObject;","map":{"version":3,"names":["ExtractedConfig","require","IgnorePattern","internalSlotsMap","WeakMap","get","key","value","cache","Map","envMap","processorMap","ruleMap","set","getMatchedIndices","elements","filePath","indices","i","length","element","criteria","test","push","isNonNullObject","x","mergeWithoutOverwrite","target","source","Object","keys","Array","isArray","PluginConflictError","Error","constructor","pluginId","plugins","map","p","importerName","join","messageTemplate","messageData","mergePlugins","targetValue","sourceValue","error","mergeRuleConfigs","targetDef","sourceDef","slice","createConfig","instance","config","ignorePatterns","index","parser","processor","noInlineConfig","configNameOfNoInlineConfig","name","reportUnusedDisableDirectives","ignorePattern","env","globals","parserOptions","settings","rules","ignores","createIgnore","reverse","collect","defs","normalize","prefix","entries","normalizePluginRule","rule","create","deleteMutationMethods","defineProperties","clear","configurable","delete","initPluginMemberMaps","slots","processed","Set","plugin","definition","has","add","environments","processors","ensurePluginMemberMaps","ConfigArray","pluginEnvironments","pluginProcessors","pluginRules","isRoot","root","extractConfig","cacheKey","isAdditionalTargetPath","type","endsWithWildcard","exportObject","getUsedExtractedConfigs","from","values","module","exports"],"sources":["/Users/brenoaraujo/Projetos Trybe/sd-022-b-project-recipes-app/node_modules/@eslint/eslintrc/lib/config-array/config-array.js"],"sourcesContent":["/**\n * @fileoverview `ConfigArray` class.\n *\n * `ConfigArray` class expresses the full of a configuration. It has the entry\n * config file, base config files that were extended, loaded parsers, and loaded\n * plugins.\n *\n * `ConfigArray` class provides three properties and two methods.\n *\n * - `pluginEnvironments`\n * - `pluginProcessors`\n * - `pluginRules`\n *      The `Map` objects that contain the members of all plugins that this\n *      config array contains. Those map objects don't have mutation methods.\n *      Those keys are the member ID such as `pluginId/memberName`.\n * - `isRoot()`\n *      If `true` then this configuration has `root:true` property.\n * - `extractConfig(filePath)`\n *      Extract the final configuration for a given file. This means merging\n *      every config array element which that `criteria` property matched. The\n *      `filePath` argument must be an absolute path.\n *\n * `ConfigArrayFactory` provides the loading logic of config files.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { ExtractedConfig } = require(\"./extracted-config\");\nconst { IgnorePattern } = require(\"./ignore-pattern\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"../../shared/types\").Environment} Environment */\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../../shared/types\").Rule} Rule */\n/** @typedef {import(\"../../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../../shared/types\").Processor} Processor */\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {import(\"./override-tester\")[\"OverrideTester\"]} OverrideTester */\n\n/**\n * @typedef {Object} ConfigArrayElement\n * @property {string} name The name of this config element.\n * @property {string} filePath The path to the source file of this config element.\n * @property {InstanceType<OverrideTester>|null} criteria The tester for the `files` and `excludedFiles` of this config element.\n * @property {Record<string, boolean>|undefined} env The environment settings.\n * @property {Record<string, GlobalConf>|undefined} globals The global variable settings.\n * @property {IgnorePattern|undefined} ignorePattern The ignore patterns.\n * @property {boolean|undefined} noInlineConfig The flag that disables directive comments.\n * @property {DependentParser|undefined} parser The parser loader.\n * @property {Object|undefined} parserOptions The parser options.\n * @property {Record<string, DependentPlugin>|undefined} plugins The plugin loaders.\n * @property {string|undefined} processor The processor name to refer plugin's processor.\n * @property {boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.\n * @property {boolean|undefined} root The flag to express root.\n * @property {Record<string, RuleConf>|undefined} rules The rule settings\n * @property {Object|undefined} settings The shared settings.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The element type.\n */\n\n/**\n * @typedef {Object} ConfigArrayInternalSlots\n * @property {Map<string, ExtractedConfig>} cache The cache to extract configs.\n * @property {ReadonlyMap<string, Environment>|null} envMap The map from environment ID to environment definition.\n * @property {ReadonlyMap<string, Processor>|null} processorMap The map from processor ID to environment definition.\n * @property {ReadonlyMap<string, Rule>|null} ruleMap The map from rule ID to rule definition.\n */\n\n/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>} */\nconst internalSlotsMap = new class extends WeakMap {\n    get(key) {\n        let value = super.get(key);\n\n        if (!value) {\n            value = {\n                cache: new Map(),\n                envMap: null,\n                processorMap: null,\n                ruleMap: null\n            };\n            super.set(key, value);\n        }\n\n        return value;\n    }\n}();\n\n/**\n * Get the indices which are matched to a given file.\n * @param {ConfigArrayElement[]} elements The elements.\n * @param {string} filePath The path to a target file.\n * @returns {number[]} The indices.\n */\nfunction getMatchedIndices(elements, filePath) {\n    const indices = [];\n\n    for (let i = elements.length - 1; i >= 0; --i) {\n        const element = elements[i];\n\n        if (!element.criteria || (filePath && element.criteria.test(filePath))) {\n            indices.push(i);\n        }\n    }\n\n    return indices;\n}\n\n/**\n * Check if a value is a non-null object.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(x) {\n    return typeof x === \"object\" && x !== null;\n}\n\n/**\n * Merge two objects.\n *\n * Assign every property values of `y` to `x` if `x` doesn't have the property.\n * If `x`'s property value is an object, it does recursive.\n * @param {Object} target The destination to merge\n * @param {Object|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeWithoutOverwrite(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n\n        if (isNonNullObject(target[key])) {\n            mergeWithoutOverwrite(target[key], source[key]);\n        } else if (target[key] === void 0) {\n            if (isNonNullObject(source[key])) {\n                target[key] = Array.isArray(source[key]) ? [] : {};\n                mergeWithoutOverwrite(target[key], source[key]);\n            } else if (source[key] !== void 0) {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n\n/**\n * The error for plugin conflicts.\n */\nclass PluginConflictError extends Error {\n\n    /**\n     * Initialize this error object.\n     * @param {string} pluginId The plugin ID.\n     * @param {{filePath:string, importerName:string}[]} plugins The resolved plugins.\n     */\n    constructor(pluginId, plugins) {\n        super(`Plugin \"${pluginId}\" was conflicted between ${plugins.map(p => `\"${p.importerName}\"`).join(\" and \")}.`);\n        this.messageTemplate = \"plugin-conflict\";\n        this.messageData = { pluginId, plugins };\n    }\n}\n\n/**\n * Merge plugins.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, DependentPlugin>} target The destination to merge\n * @param {Record<string, DependentPlugin>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergePlugins(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetValue = target[key];\n        const sourceValue = source[key];\n\n        // Adopt the plugin which was found at first.\n        if (targetValue === void 0) {\n            if (sourceValue.error) {\n                throw sourceValue.error;\n            }\n            target[key] = sourceValue;\n        } else if (sourceValue.filePath !== targetValue.filePath) {\n            throw new PluginConflictError(key, [\n                {\n                    filePath: targetValue.filePath,\n                    importerName: targetValue.importerName\n                },\n                {\n                    filePath: sourceValue.filePath,\n                    importerName: sourceValue.importerName\n                }\n            ]);\n        }\n    }\n}\n\n/**\n * Merge rule configs.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, Array>} target The destination to merge\n * @param {Record<string, RuleConf>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeRuleConfigs(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetDef = target[key];\n        const sourceDef = source[key];\n\n        // Adopt the rule config which was found at first.\n        if (targetDef === void 0) {\n            if (Array.isArray(sourceDef)) {\n                target[key] = [...sourceDef];\n            } else {\n                target[key] = [sourceDef];\n            }\n\n        /*\n         * If the first found rule config is severity only and the current rule\n         * config has options, merge the severity and the options.\n         */\n        } else if (\n            targetDef.length === 1 &&\n            Array.isArray(sourceDef) &&\n            sourceDef.length >= 2\n        ) {\n            targetDef.push(...sourceDef.slice(1));\n        }\n    }\n}\n\n/**\n * Create the extracted config.\n * @param {ConfigArray} instance The config elements.\n * @param {number[]} indices The indices to use.\n * @returns {ExtractedConfig} The extracted config.\n */\nfunction createConfig(instance, indices) {\n    const config = new ExtractedConfig();\n    const ignorePatterns = [];\n\n    // Merge elements.\n    for (const index of indices) {\n        const element = instance[index];\n\n        // Adopt the parser which was found at first.\n        if (!config.parser && element.parser) {\n            if (element.parser.error) {\n                throw element.parser.error;\n            }\n            config.parser = element.parser;\n        }\n\n        // Adopt the processor which was found at first.\n        if (!config.processor && element.processor) {\n            config.processor = element.processor;\n        }\n\n        // Adopt the noInlineConfig which was found at first.\n        if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {\n            config.noInlineConfig = element.noInlineConfig;\n            config.configNameOfNoInlineConfig = element.name;\n        }\n\n        // Adopt the reportUnusedDisableDirectives which was found at first.\n        if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {\n            config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;\n        }\n\n        // Collect ignorePatterns\n        if (element.ignorePattern) {\n            ignorePatterns.push(element.ignorePattern);\n        }\n\n        // Merge others.\n        mergeWithoutOverwrite(config.env, element.env);\n        mergeWithoutOverwrite(config.globals, element.globals);\n        mergeWithoutOverwrite(config.parserOptions, element.parserOptions);\n        mergeWithoutOverwrite(config.settings, element.settings);\n        mergePlugins(config.plugins, element.plugins);\n        mergeRuleConfigs(config.rules, element.rules);\n    }\n\n    // Create the predicate function for ignore patterns.\n    if (ignorePatterns.length > 0) {\n        config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());\n    }\n\n    return config;\n}\n\n/**\n * Collect definitions.\n * @template T, U\n * @param {string} pluginId The plugin ID for prefix.\n * @param {Record<string,T>} defs The definitions to collect.\n * @param {Map<string, U>} map The map to output.\n * @param {function(T): U} [normalize] The normalize function for each value.\n * @returns {void}\n */\nfunction collect(pluginId, defs, map, normalize) {\n    if (defs) {\n        const prefix = pluginId && `${pluginId}/`;\n\n        for (const [key, value] of Object.entries(defs)) {\n            map.set(\n                `${prefix}${key}`,\n                normalize ? normalize(value) : value\n            );\n        }\n    }\n}\n\n/**\n * Normalize a rule definition.\n * @param {Function|Rule} rule The rule definition to normalize.\n * @returns {Rule} The normalized rule definition.\n */\nfunction normalizePluginRule(rule) {\n    return typeof rule === \"function\" ? { create: rule } : rule;\n}\n\n/**\n * Delete the mutation methods from a given map.\n * @param {Map<any, any>} map The map object to delete.\n * @returns {void}\n */\nfunction deleteMutationMethods(map) {\n    Object.defineProperties(map, {\n        clear: { configurable: true, value: void 0 },\n        delete: { configurable: true, value: void 0 },\n        set: { configurable: true, value: void 0 }\n    });\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArrayElement[]} elements The config elements.\n * @param {ConfigArrayInternalSlots} slots The internal slots.\n * @returns {void}\n */\nfunction initPluginMemberMaps(elements, slots) {\n    const processed = new Set();\n\n    slots.envMap = new Map();\n    slots.processorMap = new Map();\n    slots.ruleMap = new Map();\n\n    for (const element of elements) {\n        if (!element.plugins) {\n            continue;\n        }\n\n        for (const [pluginId, value] of Object.entries(element.plugins)) {\n            const plugin = value.definition;\n\n            if (!plugin || processed.has(pluginId)) {\n                continue;\n            }\n            processed.add(pluginId);\n\n            collect(pluginId, plugin.environments, slots.envMap);\n            collect(pluginId, plugin.processors, slots.processorMap);\n            collect(pluginId, plugin.rules, slots.ruleMap, normalizePluginRule);\n        }\n    }\n\n    deleteMutationMethods(slots.envMap);\n    deleteMutationMethods(slots.processorMap);\n    deleteMutationMethods(slots.ruleMap);\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArray} instance The config elements.\n * @returns {ConfigArrayInternalSlots} The extracted config.\n */\nfunction ensurePluginMemberMaps(instance) {\n    const slots = internalSlotsMap.get(instance);\n\n    if (!slots.ruleMap) {\n        initPluginMemberMaps(instance, slots);\n    }\n\n    return slots;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The Config Array.\n *\n * `ConfigArray` instance contains all settings, parsers, and plugins.\n * You need to call `ConfigArray#extractConfig(filePath)` method in order to\n * extract, merge and get only the config data which is related to an arbitrary\n * file.\n * @extends {Array<ConfigArrayElement>}\n */\nclass ConfigArray extends Array {\n\n    /**\n     * Get the plugin environments.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Environment>} The plugin environments.\n     */\n    get pluginEnvironments() {\n        return ensurePluginMemberMaps(this).envMap;\n    }\n\n    /**\n     * Get the plugin processors.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Processor>} The plugin processors.\n     */\n    get pluginProcessors() {\n        return ensurePluginMemberMaps(this).processorMap;\n    }\n\n    /**\n     * Get the plugin rules.\n     * The returned map cannot be mutated.\n     * @returns {ReadonlyMap<string, Rule>} The plugin rules.\n     */\n    get pluginRules() {\n        return ensurePluginMemberMaps(this).ruleMap;\n    }\n\n    /**\n     * Check if this config has `root` flag.\n     * @returns {boolean} `true` if this config array is root.\n     */\n    isRoot() {\n        for (let i = this.length - 1; i >= 0; --i) {\n            const root = this[i].root;\n\n            if (typeof root === \"boolean\") {\n                return root;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Extract the config data which is related to a given file.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {ExtractedConfig} The extracted config data.\n     */\n    extractConfig(filePath) {\n        const { cache } = internalSlotsMap.get(this);\n        const indices = getMatchedIndices(this, filePath);\n        const cacheKey = indices.join(\",\");\n\n        if (!cache.has(cacheKey)) {\n            cache.set(cacheKey, createConfig(this, indices));\n        }\n\n        return cache.get(cacheKey);\n    }\n\n    /**\n     * Check if a given path is an additional lint target.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {boolean} `true` if the file is an additional lint target.\n     */\n    isAdditionalTargetPath(filePath) {\n        for (const { criteria, type } of this) {\n            if (\n                type === \"config\" &&\n                criteria &&\n                !criteria.endsWithWildcard &&\n                criteria.test(filePath)\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nconst exportObject = {\n    ConfigArray,\n\n    /**\n     * Get the used extracted configs.\n     * CLIEngine will use this method to collect used deprecated rules.\n     * @param {ConfigArray} instance The config array object to get.\n     * @returns {ExtractedConfig[]} The used extracted configs.\n     * @private\n     */\n    getUsedExtractedConfigs(instance) {\n        const { cache } = internalSlotsMap.get(instance);\n\n        return Array.from(cache.values());\n    }\n};\n\nmodule.exports = exportObject;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}