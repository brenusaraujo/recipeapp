"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("@testing-library/react");
const carousel_1 = __importDefault(require("./carousel"));
// Fake timers using Jest
beforeEach(() => {
    jest.useFakeTimers();
});
// Running all pending timers and switching to real timers using Jest
afterEach(() => {
    jest.runOnlyPendingTimers();
    jest.useRealTimers();
});
describe('Carousel', () => {
    const renderCarousel = (_a = {}) => {
        var { slideCount = 5 } = _a, props = __rest(_a, ["slideCount"]);
        return (0, react_1.render)((0, jsx_runtime_1.jsx)(carousel_1.default, Object.assign({}, props, { children: [...Array(slideCount)].map((_, index) => ((0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide ${index}` }, index))) })));
    };
    it('autoplays at the right rate', () => {
        const beforeSlide = jest.fn();
        const afterSlide = jest.fn();
        const speed = 500;
        const autoplayInterval = 1000;
        const slideCount = 2;
        renderCarousel({
            slideCount,
            autoplay: true,
            autoplayInterval,
            speed,
            wrapAround: true,
            beforeSlide,
            afterSlide,
        });
        expect(beforeSlide).toHaveBeenCalledTimes(0);
        expect(afterSlide).toHaveBeenCalledTimes(0);
        // autoplay initiated, waiting for first interval
        (0, react_1.act)(() => {
            jest.advanceTimersByTime(autoplayInterval);
        });
        expect(beforeSlide).toHaveBeenCalledTimes(1);
        expect(afterSlide).toHaveBeenCalledTimes(0);
        const checkTimingCycle = (timesMoved) => {
            // Animation begins, and next autoplay timeout set up
            (0, react_1.act)(() => {
                jest.advanceTimersByTime(speed);
            });
            // Animation completes
            expect(beforeSlide).toHaveBeenCalledTimes(timesMoved);
            expect(afterSlide).toHaveBeenCalledTimes(timesMoved);
            expect(afterSlide).toHaveBeenLastCalledWith(timesMoved % slideCount);
            (0, react_1.act)(() => {
                jest.advanceTimersByTime(autoplayInterval - speed);
            });
            // autoplay timeout triggers
            expect(beforeSlide).toHaveBeenCalledTimes(timesMoved + 1);
            expect(afterSlide).toHaveBeenCalledTimes(timesMoved);
        };
        checkTimingCycle(1);
        checkTimingCycle(2);
        checkTimingCycle(3);
    });
    it('omits slides whose children are falsy', () => {
        const { container } = (0, react_1.render)((0, jsx_runtime_1.jsxs)(carousel_1.default, { children: [(0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide 1` }), (0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide 2` }), false && (0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide 3` }), null, (0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide 5` })] }));
        expect(container.getElementsByClassName('slide').length).toBe(3);
    });
    it('can be controlled with the keyboard', () => {
        const beforeSlide = jest.fn();
        const keyCodeConfig = {
            nextSlide: [39],
            previousSlide: [37],
            firstSlide: [81],
            lastSlide: [69],
            pause: [32],
        };
        renderCarousel({
            enableKeyboardControls: true,
            keyCodeConfig,
            slideCount: 8,
            beforeSlide,
        });
        const carouselFrame = react_1.screen.getByRole('region');
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.nextSlide[0] });
        expect(beforeSlide).toHaveBeenLastCalledWith(0, 1);
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.nextSlide[0] });
        expect(beforeSlide).toHaveBeenLastCalledWith(1, 2);
        react_1.fireEvent.keyDown(carouselFrame, {
            keyCode: keyCodeConfig.previousSlide[0],
        });
        expect(beforeSlide).toHaveBeenLastCalledWith(2, 1);
        react_1.fireEvent.keyDown(carouselFrame, {
            keyCode: keyCodeConfig.previousSlide[0],
        });
        expect(beforeSlide).toHaveBeenLastCalledWith(1, 0);
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.lastSlide[0] });
        expect(beforeSlide).toHaveBeenLastCalledWith(0, 7);
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.firstSlide[0] });
        expect(beforeSlide).toHaveBeenLastCalledWith(7, 0);
    });
});
//# sourceMappingURL=carousel.test.js.map