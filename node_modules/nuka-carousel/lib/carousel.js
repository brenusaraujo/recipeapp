"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Carousel = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = __importStar(require("react"));
const slide_1 = __importDefault(require("./slide"));
const announce_slide_1 = __importDefault(require("./announce-slide"));
const slider_list_1 = require("./slider-list");
const controls_1 = __importDefault(require("./controls"));
const default_carousel_props_1 = __importDefault(require("./default-carousel-props"));
const utils_1 = require("./utils");
const use_frame_height_1 = require("./hooks/use-frame-height");
const default_controls_1 = require("./default-controls");
const Carousel = (rawProps) => {
    /**
     * We need this cast because we want the component's properties to seem
     * optional to external users, but always-present for the internal
     * implementation.
     *
     * This cast is safe due to the `Carousel.defaultProps = defaultProps;`
     * statement below. That guarantees all the properties are present, since
     * `defaultProps` has type `InternalCarouselProps`.
     */
    const props = rawProps;
    const { adaptiveHeight, adaptiveHeightAnimation, afterSlide, animation, autoplay, autoplayInterval, autoplayReverse, beforeSlide, cellAlign, cellSpacing, children, className, disableAnimation, disableEdgeSwiping, dragging: desktopDraggingEnabled, dragThreshold: propsDragThreshold, enableKeyboardControls, frameAriaLabel, innerRef, keyCodeConfig, onDrag, onDragEnd, onDragStart, pauseOnHover, renderAnnounceSlideMessage, scrollMode, slideIndex, slidesToScroll: propsSlidesToScroll, slidesToShow, speed: propsSpeed, style, swiping: mobileDraggingEnabled, wrapAround, zoomScale, } = props;
    const filteredSlides = react_1.default.Children.toArray(children).filter(Boolean);
    const slideCount = filteredSlides.length;
    const slidesToScroll = animation === 'fade' ? slidesToShow : propsSlidesToScroll;
    const [currentSlide, setCurrentSlide] = (0, react_1.useState)(() => (0, utils_1.getDefaultSlideIndex)(slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode));
    const [isAnimating, setIsAnimating] = (0, react_1.useState)(false);
    const [pause, setPause] = (0, react_1.useState)(false);
    const [isDragging, setIsDragging] = (0, react_1.useState)(false);
    const [dragDistance, setDragDistance] = (0, react_1.useState)(0);
    const prevXPosition = (0, react_1.useRef)(null);
    const preDragOffset = (0, react_1.useRef)(0);
    const sliderListRef = (0, react_1.useRef)(null);
    const defaultCarouselRef = (0, react_1.useRef)(null);
    const autoplayTimeout = (0, react_1.useRef)();
    const autoplayLastTriggeredRef = (0, react_1.useRef)(null);
    const animationEndTimeout = (0, react_1.useRef)();
    const isMounted = (0, react_1.useRef)(true);
    const [slide] = (0, utils_1.getIndexes)(currentSlide, currentSlide - slidesToScroll, slideCount);
    (0, react_1.useEffect)(() => {
        isMounted.current = true;
        return () => {
            isMounted.current = false;
        };
    }, []);
    (0, react_1.useEffect)(() => {
        // disable img draggable attribute by default, this will improve the dragging
        document
            .querySelectorAll('.slider-list img')
            .forEach((el) => el.setAttribute('draggable', 'false'));
    }, []);
    const carouselRef = innerRef || defaultCarouselRef;
    const goToSlide = (0, react_1.useCallback)((targetSlideIndex) => {
        // Boil down the target index (-Infinity < targetSlideIndex < Infinity) to
        // a user-friendly index (0 â‰¤ targetSlideIndex < slideCount)
        const userFacingIndex = ((targetSlideIndex % slideCount) + slideCount) % slideCount;
        const slideChanged = targetSlideIndex !== currentSlide;
        slideChanged && beforeSlide(slide, userFacingIndex);
        // if animation is disabled decrease the speed to 40
        const msToEndOfAnimation = !disableAnimation ? propsSpeed || 500 : 40;
        if (!disableAnimation) {
            setIsAnimating(true);
            clearTimeout(animationEndTimeout.current);
            animationEndTimeout.current = setTimeout(() => {
                if (!isMounted.current)
                    return;
                setIsAnimating(false);
            }, msToEndOfAnimation);
        }
        if (slideChanged) {
            setCurrentSlide(targetSlideIndex);
            setTimeout(() => {
                if (!isMounted.current)
                    return;
                afterSlide(userFacingIndex);
            }, msToEndOfAnimation);
        }
    }, [
        slide,
        afterSlide,
        beforeSlide,
        slideCount,
        currentSlide,
        disableAnimation,
        propsSpeed,
    ]);
    const nextSlide = (0, react_1.useCallback)(() => {
        const nextSlideIndex = (0, utils_1.getNextMoveIndex)(scrollMode, wrapAround, currentSlide, slideCount, propsSlidesToScroll, slidesToShow, cellAlign);
        if (currentSlide !== nextSlideIndex) {
            goToSlide(nextSlideIndex);
        }
    }, [
        cellAlign,
        currentSlide,
        goToSlide,
        propsSlidesToScroll,
        scrollMode,
        slideCount,
        slidesToShow,
        wrapAround,
    ]);
    const prevSlide = (0, react_1.useCallback)(() => {
        const prevSlideIndex = (0, utils_1.getPrevMoveIndex)(scrollMode, wrapAround, currentSlide, propsSlidesToScroll, slidesToShow, cellAlign);
        if (currentSlide !== prevSlideIndex) {
            goToSlide(prevSlideIndex);
        }
    }, [
        cellAlign,
        currentSlide,
        goToSlide,
        propsSlidesToScroll,
        scrollMode,
        slidesToShow,
        wrapAround,
    ]);
    // When user changed the slideIndex property from outside.
    const prevMovedToSlideIndex = (0, react_1.useRef)(slideIndex);
    (0, react_1.useEffect)(() => {
        if (slideIndex !== undefined &&
            slideIndex !== prevMovedToSlideIndex.current &&
            !autoplayReverse) {
            goToSlide(slideIndex);
            prevMovedToSlideIndex.current = slideIndex;
        }
    }, [slideIndex, autoplayReverse, goToSlide]);
    (0, react_1.useEffect)(() => {
        let pauseStarted = null;
        // Keep track of when autoplay was paused so we can resume it with the same
        // remaining time to the next slide transition
        if (pause) {
            pauseStarted = Date.now();
        }
        return () => {
            if (pauseStarted !== null && autoplayLastTriggeredRef.current !== null) {
                autoplayLastTriggeredRef.current += Date.now() - pauseStarted;
            }
        };
    }, [pause]);
    (0, react_1.useEffect)(() => {
        if (autoplay && !pause) {
            // Adjust the timeout duration to account for changes that triggered the
            // re-creation of this timeout, such as the currentSlide being changed
            // periodically to make wrapAround loop forever
            const adjustedTimeoutMs = autoplayLastTriggeredRef.current !== null
                ? autoplayInterval - (Date.now() - autoplayLastTriggeredRef.current)
                : autoplayInterval;
            autoplayTimeout.current = setTimeout(() => {
                autoplayLastTriggeredRef.current = Date.now();
                if (autoplayReverse) {
                    prevSlide();
                }
                else {
                    nextSlide();
                }
            }, adjustedTimeoutMs);
        }
        // Clear the timeout if user hover on carousel
        if (autoplay && pause) {
            clearTimeout(autoplayTimeout.current);
        }
        return () => {
            clearTimeout(autoplayTimeout.current);
        };
    }, [
        pause,
        autoplay,
        autoplayInterval,
        autoplayReverse,
        prevSlide,
        nextSlide,
    ]);
    // Makes the carousel infinity when wrapAround is enabled
    (0, react_1.useEffect)(() => {
        if (wrapAround && !isAnimating && !isDragging) {
            if (currentSlide <= -slidesToShow) {
                setCurrentSlide(slideCount - -currentSlide);
            }
            else if (currentSlide >= slideCount) {
                setCurrentSlide(currentSlide - slideCount);
            }
        }
    }, [
        currentSlide,
        isAnimating,
        isDragging,
        slideCount,
        slidesToShow,
        wrapAround,
    ]);
    const onKeyDown = (event) => {
        let keyCommand = null;
        Object.keys(keyCodeConfig).forEach((command) => {
            var _a;
            if ((_a = keyCodeConfig[command]) === null || _a === void 0 ? void 0 : _a.includes(event.keyCode)) {
                keyCommand = command;
            }
        });
        if (keyCommand === null)
            return;
        // At this point we know some action is going to be triggered, so we
        // preventDefault to avoid the browser interpreting the key event and
        // stopPropagation to avoid any higher-up handlers from interpreting it.
        event.preventDefault();
        event.stopPropagation();
        switch (keyCommand) {
            case 'nextSlide':
                nextSlide();
                break;
            case 'previousSlide':
                prevSlide();
                break;
            case 'firstSlide':
            case 'lastSlide': {
                const dotIndices = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);
                if (keyCommand === 'firstSlide') {
                    goToSlide(dotIndices[0]);
                }
                else {
                    goToSlide(dotIndices[dotIndices.length - 1]);
                }
                break;
            }
            case 'pause':
                setPause((p) => !p);
                break;
        }
    };
    const dragPositions = (0, react_1.useRef)([]);
    const handleDragEnd = (e) => {
        if (!isDragging || !carouselRef.current)
            return;
        setIsDragging(false);
        // Inertia calculation is used to allow quick flicks to scroll the carousel
        // where they might not based on the start and end points of the gesture
        // alone. In certain conditions, the inertia may also scroll the carousel
        // several times.
        let distanceFromInertia = 0;
        if (dragPositions.current.length > 1) {
            const startMove = dragPositions.current[0];
            const endMove = dragPositions.current[dragPositions.current.length - 1];
            const timeOffset = endMove.time - startMove.time;
            const goodInertiaFeelConstant = 9;
            const goodFrictionFeelConstant = 0.92;
            const initialVelocity = goodInertiaFeelConstant *
                Math.abs((endMove.pos - startMove.pos) / timeOffset);
            let velocity = initialVelocity;
            while (Math.abs(velocity) > 1) {
                distanceFromInertia += velocity;
                velocity *= goodFrictionFeelConstant;
            }
        }
        dragPositions.current = [];
        const adjustedDragDistance = Math.abs(dragDistance) + Math.abs(distanceFromInertia);
        onDragEnd(e);
        prevXPosition.current = null;
        setDragDistance(0);
        const oneScrollWidth = carouselRef.current.offsetWidth *
            Math.min(1, slidesToScroll / slidesToShow);
        const dragThreshold = oneScrollWidth * propsDragThreshold;
        if (adjustedDragDistance < dragThreshold) {
            goToSlide(currentSlide);
            return;
        }
        // If skipping over multiple slides at a time is still roughly trackable by
        // your eyes, we allow for skipping multiple slides with a single gesture.
        // This formula is just based off an observation that it is confusing to
        // skip from slides 1 to 3 when only one slide is shown at a time, but
        // skipping from 1 to 4 or so with two slides shown at a time is pulled-back
        // enough that you can still roughly keep track of your place in the
        // carousel.
        const canMaintainVisualContinuity = slidesToShow >= 2 * slidesToScroll;
        const timesToMove = canMaintainVisualContinuity
            ? 1 + Math.floor((adjustedDragDistance - dragThreshold) / oneScrollWidth)
            : 1;
        let nextSlideIndex = currentSlide;
        for (let index = 0; index < timesToMove; index += 1) {
            if (dragDistance > 0) {
                nextSlideIndex = (0, utils_1.getNextMoveIndex)(scrollMode, wrapAround, nextSlideIndex, slideCount, propsSlidesToScroll, slidesToShow, cellAlign);
            }
            else {
                nextSlideIndex = (0, utils_1.getPrevMoveIndex)(scrollMode, wrapAround, nextSlideIndex, propsSlidesToScroll, slidesToShow, cellAlign);
            }
        }
        goToSlide(nextSlideIndex);
    };
    const onTouchStart = (0, react_1.useCallback)((e) => {
        if (!mobileDraggingEnabled ||
            !sliderListRef.current ||
            !carouselRef.current) {
            return;
        }
        setIsDragging(true);
        preDragOffset.current =
            sliderListRef.current.getBoundingClientRect().left -
                carouselRef.current.getBoundingClientRect().left;
        onDragStart(e);
    }, [carouselRef, onDragStart, mobileDraggingEnabled]);
    const handlePointerMove = (0, react_1.useCallback)((xPosition) => {
        if (!isDragging)
            return;
        const isFirstMove = prevXPosition.current === null;
        const delta = prevXPosition.current !== null ? xPosition - prevXPosition.current : 0;
        const nextDragDistance = dragDistance + delta;
        const now = Date.now();
        // Maintain a buffer of drag positions from the last 100ms
        while (dragPositions.current.length > 0) {
            if (now - dragPositions.current[0].time <= 100) {
                break;
            }
            dragPositions.current.shift();
        }
        dragPositions.current.push({ pos: nextDragDistance, time: now });
        if (!isFirstMove) {
            // nextDragDistance will always be `0` on the first move event, so we
            // skip it because the value is already set to 0 at this point
            setDragDistance(nextDragDistance);
        }
        prevXPosition.current = xPosition;
    }, [isDragging, dragDistance]);
    const onTouchMove = (0, react_1.useCallback)((e) => {
        if (!isDragging || !carouselRef.current)
            return;
        onDragStart(e);
        const moveValue = carouselRef.current.offsetWidth - e.touches[0].pageX;
        handlePointerMove(moveValue);
    }, [isDragging, carouselRef, handlePointerMove, onDragStart]);
    const onMouseDown = (0, react_1.useCallback)((e) => {
        if (!desktopDraggingEnabled ||
            !sliderListRef.current ||
            !carouselRef.current)
            return;
        setIsDragging(true);
        preDragOffset.current =
            sliderListRef.current.getBoundingClientRect().left -
                carouselRef.current.getBoundingClientRect().left;
        onDragStart(e);
    }, [carouselRef, desktopDraggingEnabled, onDragStart]);
    const onMouseMove = (0, react_1.useCallback)((e) => {
        if (!isDragging || !carouselRef.current)
            return;
        onDrag(e);
        const offsetX = e.clientX - carouselRef.current.getBoundingClientRect().left;
        const moveValue = carouselRef.current.offsetWidth - offsetX;
        handlePointerMove(moveValue);
    }, [carouselRef, isDragging, handlePointerMove, onDrag]);
    const onMouseUp = (e) => {
        e.preventDefault();
        handleDragEnd(e);
    };
    const onMouseEnter = (0, react_1.useCallback)(() => {
        if (pauseOnHover) {
            setPause(true);
        }
    }, [pauseOnHover]);
    const onMouseLeave = (0, react_1.useCallback)(() => {
        if (pauseOnHover) {
            setPause(false);
        }
    }, [pauseOnHover]);
    const { frameHeight, handleVisibleSlideHeightChange, initializedAdaptiveHeight, } = (0, use_frame_height_1.useFrameHeight)(adaptiveHeight, slidesToShow, slideCount);
    const renderSlides = (typeOfSlide) => {
        const slides = filteredSlides.map((child, index) => {
            const isCurrentSlide = wrapAround
                ? currentSlide === index ||
                    currentSlide === index + slideCount ||
                    currentSlide === index - slideCount
                : currentSlide === index;
            return ((0, jsx_runtime_1.jsx)(slide_1.default, Object.assign({ count: slideCount, currentSlide: currentSlide, index: index, isCurrentSlide: isCurrentSlide, typeOfSlide: typeOfSlide, wrapAround: wrapAround, cellSpacing: cellSpacing, animation: animation, slidesToShow: slidesToShow, speed: propsSpeed, zoomScale: zoomScale, cellAlign: cellAlign, onVisibleSlideHeightChange: handleVisibleSlideHeightChange, adaptiveHeight: adaptiveHeight, initializedAdaptiveHeight: initializedAdaptiveHeight }, { children: child }), `${typeOfSlide}-${index}`));
        });
        return slides;
    };
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: 'slider-container', style: {
            position: 'relative',
        }, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave }, { children: [(0, jsx_runtime_1.jsx)(announce_slide_1.default, { ariaLive: autoplay && !pause ? 'off' : 'polite', message: renderAnnounceSlideMessage({
                    currentSlide: slide,
                    count: slideCount,
                }) }), (0, controls_1.default)(props, slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll), (0, jsx_runtime_1.jsx)("div", Object.assign({ className: ['slider-frame', className || ''].join(' ').trim(), style: Object.assign({ overflow: 'hidden', width: '100%', position: 'relative', outline: 'none', height: frameHeight, transition: adaptiveHeightAnimation
                        ? 'height 300ms ease-in-out'
                        : undefined, willChange: 'height', userSelect: 'none' }, style), "aria-label": frameAriaLabel, role: "region", tabIndex: 0, onKeyDown: enableKeyboardControls ? onKeyDown : undefined, ref: carouselRef, onMouseUp: onMouseUp, onMouseDown: onMouseDown, onMouseMove: onMouseMove, onMouseLeave: onMouseUp, onTouchStart: onTouchStart, onTouchEnd: handleDragEnd, onTouchMove: onTouchMove }, { children: (0, jsx_runtime_1.jsxs)("div", Object.assign({ className: "slider-list", style: (0, slider_list_1.getSliderListStyles)(slideCount, currentSlide, isAnimating, slidesToShow, cellAlign, wrapAround, propsSpeed, isDragging ? preDragOffset.current - dragDistance : 0, slidesToScroll, scrollMode, disableEdgeSwiping, animation), ref: sliderListRef }, { children: [wrapAround ? renderSlides('prev-cloned') : null, renderSlides(), wrapAround ? renderSlides('next-cloned') : null] })) }))] })));
};
exports.Carousel = Carousel;
exports.Carousel.defaultProps = default_carousel_props_1.default;
exports.default = exports.Carousel;
//# sourceMappingURL=carousel.js.map